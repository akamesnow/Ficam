[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V21.00 P3 E1 W21.00 T1505932409 M21.00 I0 O0
scncpost_revision     := "21.80" # Internal revision number for use by CNC Software only.  Please do not change this number.
scustpost_revision    := "0"  # Revision number for use by Resellers or customers.
# Post Name           : MPWFANUC.pst
# Product             : Wire
# Machine Name        : Generic
# Control Name        : Fanuc
# Description         : Generic 4 Axis Wire Post
# 4-axis              : Yes
# Executable          : mp.dll
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# Associated File List$
#
# default.mcam-control
# WIRE DEFAULT.mcam-wmd
# WIRE DEFAULT MM.mcam-wmd
#
# Associated File List$
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# CNC 10/27/05  -  Initial post setup for Mastercam X
# CNC 10/14/05  -  Modified parc, changed do_full_arc$ to full_arc_flg$
# CNC 06/23/06  -  Initial post update for Mastercam X2
# CNC 02/14/07  -  Modified pcantxt$ to remove forced M60 when sof
# CNC 04/08/08  -  X3 release - no changes made
# CNC 01/26/09  -  Initial post update for Mastercam X4
# CNC 02/03/10  -  Initial post update for Mastercam X5
# CNC 08/17/10  -  Removed CD_VAR variables
# CNC 02/17/11  -  Added arctype$ initialization to correct full arc output when using R or signed R
# CNC 05/20/11  -  Initial post update for Mastercam X6
# CNC 10/16/12  -  Initial post update for Mastercam X7
# CNC 02/06/14  -  Initial post update for Mastercam X8
# CNC 12/23/14  -  Initial post update for Mastercam X9
# CNC 11/09/15  -  Initial post update for Mastercam 2017
# CNC 10/14/16  -  Initial post update for Mastercam 2018
# CNC 03/31/17  -  Beginning with Mastercam 2018, all post text edits MUST be made with the Control Definition Manager.
#                  Do NOT edit the post text manually.
#               -  For Mastercam 2018, only ANSI text is supported. The UTF-8 tag is still required in 2018 and should not be changed.
# CNC 04/24/17  -  (20.80) Initial revision number assigned.
# CNC 09/13/17  -  (21.80) Initial post update for Mastercam 2019
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
# This post supports Generic Fanuc code for 2 and 4 axis wire edm.
# It is designed to support the features of Mastercam X Wire.
#
# NEW FEATURES FOR X:
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
# - Additional date, time and data path output options (see pheader)
# - Support for 10 additional canned text options for X.  X coolant is supported through Canned Text logic.
#
# --------------------------------------------------------------------------
# Misc. Values:
# --------------------------------------------------------------------------
# Integers:
#
# mi1 - Work coordinate system
#        0 and 1 = G92 output.
#        2 = WCS of G54, G55.... based on Mastercam settings (use STCW).
#
# mi2 - Main program absolute or incremental positioning
#        0 = absolute
#        1 = incremental
#
# mi3 - Sub program absolute or incremental positioning
#        0 = absolute
#        1 = incremental
#
# mi4 - Substitute G62/G63 for G61 conical corner
#        0 = G61 (min)
#        1 = G62 (mean)
#        2 = G63 (max)
#
# mi5 - mi9 (NOT USED)
#
# mi10 - Convert 2D wirepath to 4 axis
#        0 = off
#        1 = 4 axis direct
#        2 = 4 axis taper
#
# Reals:
#
# mr1 - mr10 (NOT USED)
#
# --------------------------------------------------------------------------
#Additional Notes:
# 1)Metric is applied from the first NCI met_tool variable.  This is set
#   from the configuration file selected in Screen/Configure.
# 2)Subprograms only write the first wirepath, only the misc. functions
#   in that path are written.
# 3)If 'g60_mod_on' is active and legal line-arc-line motion is found,
#   the arc conic is applied for the replaced arc move (reverts to line-line
#   intersection).  An immediate taper or a gradual taper to or from the end
#   of the converted arc with 'g60_mode' is not allowed.  A warning is
#   generated.
# 4)Arc conics (other than conical) not converted with 'g60_mode' do not
#   have the conic applied.  The default of the machine is applied.
# 5)Wirepaths that generate the warning-
#   "THE WIREPATH DOES NOT REFLECT THE BACKPLOT, ENABLE 2D CONVERSION"
#   should be converted to 4 axis by editing and setting mi10 in the NCI.
# 6)Do not use work shifts in Mastercam with G92 output in post.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and Factory Set Program Switches
# --------------------------------------------------------------------------
#Define Constants
m_one        := -1
zero         := 0
one          := 1
two          := 2
three        := 3
four         := 4
five         := 5
c9k          := 9999

bug4$        : 1     #Debug output with the tilde '~'.
                     #A value greater the zero applies the variable formatting with
                     #debug output (default is typically FS 1 but not a guarantee).
                     #A value of zero gets the value directly with NO formatting.

linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 1     #Associate X plane specific variables to V9- variable?

# The following initialization is used for full arc output when the CD is set to output R or signed R for arcs
arctype$     : 2     #Arc center type XY plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.

get_1004$    : 0     #Find gcode 1004 with getnextop?
skp_lead_flgs$ : 0   #Do not use v9 style contour flags
rpd_typ_v7$  : 0     #Use Version 7 style contour flags?
strtool_v7$  : 2     #Use Version 7 toolname, 1= path components, 2=string
tlchng_aft$  : 2     #Delay call to toolchange until move line, 2 calls null
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
#Mi2 and mi3 control the XY output for absolute or incremental
#Altering the arcoutput may produce a conflict with g60_mode (R address)
uvtyp_lin    : 2     #UV - linear XY move,
                     #0=Signed incremental, u-prv_u calculation
                     #1=Signed incr. delta, (u-x)-(prv_u-prv_x) calculation
                     #2=Signed delta, u-x calculation
                     #3=Absolute, u calculation
uvtyp_arc    : 2     #UV - arc XY move,
                     #0=Signed incremental, u-prv_u calculation
                     #1=Signed incr. delta, (u-x)-(prv_u-prv_x) calculation
                     #2=Signed delta, u-x calculation
                     #3=Absolute, u calculation
kltyp_lin    : 3     #KL - linear XY move,
                     #0=Signed start-center inc., wxc-prv_u calculation
                     #1=Signed center-start inc., prv_u-wxc calculation
                     #2=Unsigned incremental, abs(wxc-prv_u) calculation
                     #3=Signed XY-center inc., wxc-x calculation
                     #4=Absolute, wxc calculation
kltyp_arc    : 3     #KL - arc XY move,
                     #0=Signed start-center inc., wxc-prv_u calculation
                     #1=Signed center-start inc., prv_u-wxc calculation
                     #2=Unsigned incremental, abs(wxc-prv_u) calculation
                     #3=Signed IJ-center inc., wxc-i calculation
                     #4=Absolute, wxc calculation
g92_in_sub   : 1     #G92/G54 is written to start of sub if not incremental
g92_frc_sb   : 1     #G92/G54 is written in each sub if g92_in_sub
                     #G54 is written at each new wirepath
g60_mod_on   : 0     #Activate G60_mode if wire taper is detected
set_plot     : 1     #Never set to zero (0)
                     #1 = Draw to screen 2d backplot on conversion
                     #2 = Draw and keep as geometry 2d backplot
                     #3 = Do not draw to screen

man_wire     : no$   #Machine is manual wire feed?
nosubs       : no$   #Do not support sub programs?
rapid_off    : no$   #Force lead-off moves to be 'G0' rapid motions (yes/no)
flast_UV     : no$   #Force output of BOTH 'U' & 'V' on final position (yes/no)
re_G92       : no$   #Output a 'G92X?Y?' after each re-position to new cutout?
use_G61      : no$   #Output 'G61' conical corner codes with 'T'aper output?

sweep$       : 179   #Max. angle for G60_mode conversion, set during post read
progname$    : 1     #Use uppercase for program name
subprg$      : 1     #Open subprogram file?

#Variables required to build wire radius and taper lists, reference
listrad$     : 0     #Enable radius list output, see pradlist
listtpr$     : 0     #Enable taper list output, see ptprlist

#MP variables used to set up the post, normally not changed
g60_mode$    : 0     #G60 radius conversion, controlled by g60_mod_on above
immediate$   : 1     #Immediate flag for immediate tapers, always on
use_2d_uv$   : 1     #The 2D conversion routine to 4 axis, always on
plot_2d_uv$  : 1     #Post generated backplot of converted 2D path, always on
tooltable$   : 3     #Read for tool table and pwrtt
qrtyp$       : 2     #System 4 axis, 0=Delta to XY, 1=0 and wq,wr, 2=abs.

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
#Common variables and strings
bld          : 0     #Block delete active
result       : 0     #Return value for functions
sav_spc      : 0     #Save spaces
wtgcode      : 1     #Wire taper gcode selector from wt
max_atol$    : sweep$#Saved value for tanflag
sof          : 1     #Indicate that the sof code is needed
postlchng    : 1     #Indicate that the machine needs to position in toolchange
wtmax        : 0     #largest 2d wire taper from NCI
cant_pos     : 0     #Read from current canned text (cant_pos1 - cant_pos20)
feed_out     : 0     #Output feedrate with motion? This holds the Control Def setting "Use feedrate in NC output"
serror2_used : 0     #Flag to indicate that serror2 has already been displayed during this posting session

#Saved variables
sav_n        : 0     #Sequence number saved from main
sav_x        : 0     #Absolute saved value for X
sav_y        : 0     #Absolute saved value for Y
sav_z        : 0     #Absolute saved value for Z
sav_u        : 0     #Absolute saved value for U
sav_v        : 0     #Absolute saved value for V
sav_w        : 0     #Absolute saved value for W
sav_g92x_m   : 0     #Saved X origin output, main
sav_g92y_m   : 0     #Saved Y origin output, main
sav_g92z_m   : 0     #Saved Z origin output, main
sav_wt       : 0     #Saved and signed value for last taper
sav_linarc   : 0     #Saved linarc
sav_bld      : 0     #Saved block delete flag

#Motion control flags
cuttype      : 0     #Cut type flag, 0=2D, 1=direct, 2=taper
leadintype   : 0     #Lead type flag, 0=None, 1=move
strtflag     : 0     #Start pos. flag, 0 = thrd/strt eq., 1 = not equal
thdcutflag   : 0     #Thread/cut flag, 0 = thrd/cut eq., 1 = not equal
cntrflag     : 0     #Contour flag, 0 = before, 1 = contour, 2 = after
                     #3 = single move case.
tanflag      : 0     #Tangent elements
l_lflag      : 0     #Define type elements, 0=fail, 1=ll, 2=la, 3=al, 4=aa
wc_outflag   : 0     #Wire conic output
                     #0=no corner output, arcs are conic by default
                     #1=G60 constant corner
                     #2=G61 conic corner
                     #3=RK for independent upper radius
                     #4=R-0 for fish tail
                     #5=output of the explicit UV position
wt_outflag   : 0     #Wire taper output
                     #-1=g60_mode apply g60_last_wt to current move
                     #0=no taper output
                     #1=wt with current move
                     #2=1 then wt_immd after current move
                     #3=2 but update for wt_immd after move
                     #4=wt after current move (forced)
subsflag     : 0     #Sub program flag, 0 = off, 1 = before, 2 = start,
                     #3 = contour, 4 = end, 5 = after, 6 = single line case.
                     #neg. defines a subprogram call

#Variables used in the incremental calculation
xia          : 0     #Formated absolute value for X
yia          : 0     #Formated absolute value for Y
zia          : 0     #Formated absolute value for Z
uia          : 0     #Formated absolute value for U
via          : 0     #Formated absolute value for V
wia          : 0     #Formated absolute value for W

# --------------------------------------------------------------------------
# STRINGS
# --------------------------------------------------------------------------
serror1      : "THE WIREPATH DOES NOT REFLECT THE BACKPLOT, ENABLE 2D CONVERSION"
serror2      : "WARNING - THE CONTROL DEF OPTION 'CONVERT RAPID TO MAXIMUM FEEDRATE' IS ENABLED IN YOUR CONTROL DEFINITION.  THIS POST MAY NEED CUTOMIZATION TO SUPPORT THIS OPTION."

#Default paren strings
sopen_prn    : "("
sclose_prn   : ")"

#Address string definitions
strm         : "M"
strn         : "N"
stro         : "O"
strp         : "P"
srad         : "R"
srminus      : "R-"
sblank       : ""

#Cantext string definitions (spaces must be padded here)
sm00         : "M00"
sm01         : "M01"
strtextno    : ""
strcantext   : ""

# --------------------------------------------------------------------------
#Motion G code selection, post uses g20code for output of string
sg00    : "G0"       #Rapid
sg01    : "G1"       #Linear feed
sg02    : "G2"       #Circular interpolation CW
sg03    : "G3"       #Circular interpolation CCW
sg04    : "G4"       #Dwell
sg20code : ""        #Target string
sg30code : ""        #Target string

fstrsel sg00 g20code$ sg20code 5 -1
fstrsel sg00 g30code$ sg30code 6 -1
# --------------------------------------------------------------------------
#Select english/metric code
sg20    : "G20"      #Inch code
sg21    : "G21"      #Metric code
smetric : ""         #Target string

fstrsel sg20 met_tool$ smetric 2 -1
# --------------------------------------------------------------------------
#Select reference return code
sg28    : "G28"      #First reference point return
sg30    : "G30"      #Second reference point return
sg28ref : ""         #Target string

fstrsel sg28 mi3$ sg28ref 2 -1
# --------------------------------------------------------------------------
#Cutter compensation G code selection
scc0    : "G40"      #Cancel cutter compensation
scc1    : "G41"      #Cutter compensation left
scc2    : "G42"      #Cutter compensation right
sccomp  : ""         #Target string

fstrsel scc0 cc_pos$ sccomp 3 -1
# --------------------------------------------------------------------------
#Wire taper direction selector
sg50t   : "G51"      #Taper < 0
sg51t   : "G50"      #Taper = 0
sg52t   : "G52"      #Taper > 0
swtcode : ""         #Target string

fstrsel sg50t wtgcode swtcode 3 -1
# --------------------------------------------------------------------------
#Wire corner type selector
#These selectors are from Mastercam
#WC=0, Conical corner type
#WC=1, Sharp corner type
#WC=2, Constant corner type
#WC=3, Other corner type
#WC=4, Fixed corner type
#WC=5, Fish Tail corner type
#These corner types can be output by post but are not reflected in backplot
sg61    : "G61"      #Conical corner type, min
sg62    : "G62"      #Conical corner type, mean
sg63    : "G63"      #Conical corner type, max

#These selectors are post specific
sct0    : ""         #Default corner type
sct1    : "G60"      #Constant corner type
sct2    : "G61"      #Conical corner type, min
sct3    : ""         #RK independent corner type
sct4    : ""         #Fish tail corner type
sct5    : ""         #UV corner type
sctype  : ""         #Target string

fstrsel sct0 wc_outflag sctype 6 -1
# --------------------------------------------------------------------------
#Select incremental or absolute G code
sg90    : "G90"      #Absolute code
sg91    : "G91"      #Incremental code
sgabsinc : ""        #Target string

fstrsel sg90 absinc$ sgabsinc 2 -1
# --------------------------------------------------------------------------
#Tank M code selection
sm34    : "M34"      #Tank fill
sm35    : "M35"      #Tank empty
stank   : ""         #Target string

fstrsel sm34 tank$ stank 2 -1
# --------------------------------------------------------------------------
#Power M code selection
sm41    : "M41"      #Power off
sm81    : "M81"      #Power on
spower  : ""         #Target string

fstrsel sm41 power$ spower 2 -1
# --------------------------------------------------------------------------
#Wire M code selection
sm42    : "M42"      #Wire off
sm82    : "M82"      #Wire on
swire   : ""         #Target string

fstrsel sm42 wire$ swire 2 -1
# --------------------------------------------------------------------------
#Water M code selection
sm43    : "M43"      #Water off
sm83    : "M83"      #Water on
swater  : ""         #Target string

fstrsel sm43 water$ swater 2 -1
# --------------------------------------------------------------------------
#Automatic thread/cut M code selection
sm50z   : ""         #Dummy for zero
sm60    : "M60"      #Thread wire
sm50    : "M50"      #Cut wire
sautowire : ""       #Target string

fstrsel sm50z thrd_cut$ sautowire 3 -1
# --------------------------------------------------------------------------
# Month selector
smon0   : ""
smon1   : "JAN."
smon2   : "FEB."
smon3   : "MAR."
smon4   : "APR."
smon5   : "MAY."
smon6   : "JUN."
smon7   : "JUL."
smon8   : "AUG."
smon9   : "SEP."
smon10  : "OCT."
smon11  : "NOV."
smon12  : "DEC."
smonth  : ""

fstrsel smon0 month$ smonth 13 -1
# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
#Format statements
fs2 1   0.7 0.6      #Decimal, absolute, 7 place, default for initialize (:)
fs2 2   0.5 0.4      #Decimal, absolute, 5/4 place
fs2 3   0.5 0.4d     #Decimal, delta, 5/4 place
#Common format statements
fs2 4   1 0 1 0      #Integer, not leading
fs2 5   2 0 2 0l     #Integer, force two leading
fs2 6   3 0 3 0l     #Integer, force three leading
fs2 7   4 0 4 0l     #Integer, force four leading
fs2 9   0.1 0.1      #Decimal, absolute, 1 place
fs2 10  0.2 0.2      #Decimal, absolute, 2 place
fs2 11  0.3 0.3      #Decimal, absolute, 3 place
fs2 12  0.4 0.4      #Decimal, absolute, 4 place
fs2 13  0.5 0.5      #Decimal, absolute, 5 place
fs2 14  0.3 0.3d     #Decimal, delta, 3 place
fs2 15  0.2 0.1      #Decimal, absolute, 2/1 place
fs2 16  1 0 1 0n     #Integer, forced output
# These formats used for 'Date' & 'Time'
fs2 18  2.2 2.2lt    #Decimal, force two leading & two trailing (time2)
fs2 19  2 0 2 0t     #Integer, force trailing                   (hour)
fs2 20  0 2 0 2lt    #Integer, force leading & trailing         (min)

# --------------------------------------------------------------------------
fmt  "O" 7  progno$     #Program number
fmt  "O" 7  subprogno   #Subroutine number head of file
fmt  "P" 7  subno$      #Subroutine call number
fmt  "G" 4  g_wcs       #WCS G address
fmt  "P" 4  p_wcs       #WCS P address
fmt  "S" 4  ccode$      #Condition code
fmt  "D" 4  offset$     #Wire diameter offset
fmt     2   tlrad$      #Wire radius
fmt  "H" 4  tofs$       #Wire index to taper list
fmt     2   wt$         #Wire taper
# --------------------------------------------------------------------------
#The variables for absolute output are xabs, yabs, zabs, uabs, vabs, wabs.
#The variables for incremental output are xinc, yinc, zinc, uinc, vinc, winc.
fmt  "N" 4  n$          #Sequence number
fmt  "X" 2  xabs        #X position output
fmt  "Y" 2  yabs        #Y position output
fmt  "Z" 2  zabs        #Z position output
fmt  "X" 3  xinc        #X position output
fmt  "Y" 3  yinc        #Y position output
fmt  "Z" 3  zinc        #Z position output
fmt  "U" 2  uabs        #U position output
fmt  "V" 2  vabs        #V position output
fmt  "W" 2  wabs        #W position output
fmt  "U" 3  uinc        #U position output
fmt  "V" 3  vinc        #V position output
fmt  "W" 3  winc        #W position output
fmt  "U" 2  uout        #U position output
fmt  "V" 2  vout        #V position output
fmt  "W" 2  wout        #W position output
fmt  "I" 3  iout        #Arc center description in X
fmt  "J" 3  jout        #Arc center description in Y
fmt  "K" 3  kout        #Arc center description in U
fmt  "L" 3  lout        #Arc center description in V
fmt     3   mout        #Arc center description in W, needed for vec math
fmt  "R" 2  arcrad$     #Arc radius
fmt  "R" 2  xy_rad      #Wire radius XY plane
fmt  "K" 2  uv_rad      #Wire radius UV plane
fmt  "T" 2  wtout       #Wire angle
fmt  "X" 2  g92x_m      #X origin output, main
fmt  "Y" 2  g92y_m      #Y origin output, main
fmt  "Z" 2  g92z_m      #Z origin output, main
fmt  "J" 2  xyheight$   #Base height
fmt  "I" 2  uvheight$   #Part height
fmt  "F" 15 fr$         #Feedrate
fmt  "P" 11 dwell$      #Dwell
fmt  "M" 5  cantext$    #Canned text
# --------------------------------------------------------------------------
fmt     4   year2       #Calculated year value
fmt     18  time2       #Capture 24-hour time value into 'time2' variable
fmt     19  hour        #Hour
fmt     20  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
pradlist$        #List of wire radii, only offset and tlrad are read
      *offset$, " = ", *tlrad$, e$

ptprlist$        #List of taper angles, only tofs (index) and wt are read
                #List is checked in linear/circular (0,1,2,3) and "tofs" set
      *tofs$, " = ", *wt$, e$

pcomment$       #Comment from manual entry (must call pcomment2)
      pcomment2 #Required if doing boolean 'if' logic testing!

pcomment2       #Comment from manual entry
      scomm$ = ucase (scomm$)
      if gcode$ = 1005, sopen_prn, scomm$, sclose_prn, e$  #Manual entry - as comment
      if gcode$ = 1006, scomm$, e$                         #Manual entry - as code
      if gcode$ = 1007, sopen_prn, scomm$, sclose_prn      #Manual entry - as comment with move NO e$
      if gcode$ = 1026, scomm$                             #Manual entry - as code with move NO e$
      if gcode$ = 1008, sopen_prn, scomm$, sclose_prn, e$  #Operation comment
      if gcode$ = 1051, sopen_prn, scomm$, sclose_prn, e$  #Machine name
      if gcode$ = 1052, sopen_prn, scomm$, sclose_prn, e$  #Group comment
      if gcode$ = 1053, sopen_prn, scomm$, sclose_prn, e$  #Group name
      if gcode$ = 1054, sopen_prn, scomm$, sclose_prn, e$  #File Descriptor

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
pprep$           #Pre NCI read postblock
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE) BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      chord_tol$ = 0.00005 #System tolerance for 2D conversion
      if scalex$ | scaley$ | scalez$, fastmode$ = zero
      omitcrlf$ = 0  #End NC block with CR/LF, 0=CR/LF, 1=use eob
      eob$ = 0       #Assign first eob character
      prv_eob$ = 0   #Assign second eob character
      rd_cd$         #Read CD Parameters

pq$              #Setup post based on switch settings
      if arctype$ = one | arctype$ = four,
        [
        result = newfs(two, iout)
        result = newfs(two, jout)
        ]
      else,
        [
        result = newfs(three, iout)
        result = newfs(three, jout)
        ]

ptime           #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader$         #Call before start of file
      "%", e$
      sav_spc = spaces$
      spaces$ = 0
      *progno$, sopen_prn, sprogname$, sclose_prn, e$
      #sopen_prn, "PROGRAM NAME - ", sprogname$, sclose_prn, e$
      sopen_prn, "DATE=DD-MM-YY - ", date$, " TIME=HH:MM - ", time$, sclose_prn, e$ #Date and time output Ex. 12-02-05 15:52
      #sopen_prn, "DATE - ", month$, "-", day$, "-", year$, sclose_prn, e$  #Date output as month,day,year - Ex. 02-12-05
      #sopen_prn, "DATE - ", *smonth, " ", day$, " ", *year2, sclose_prn, e$ #Date output as month,day,year - Ex. Feb. 12 2005
      #sopen_prn, "TIME - ", time$, sclose_prn, e$  #24 hour time output - Ex. 15:52
      #sopen_prn, "TIME - ", ptime sclose_prn, e$  #12 hour time output 3:52 PM
      spathnc$ = ucase(spathnc$)
      smcname$ = ucase(smcname$)
      snamenc$ = ucase(snamenc$)
      sopen_prn, "MCAM FILE - ", *smcpath$, *smcname$, *smcext$, sclose_prn, e$
      sopen_prn, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, sclose_prn, e$
      spaces$ = sav_spc

psof0$           #Start of file for tool zero
      psof$

psof$            #Start of file for non-zero tool number
      pcuttype
      g20code$ = zero
      cc_pos$ = zero
      prv_xia = vequ(startx$)
      prv_uia = vequ(startx$)
      comment$
      pbld, n$, *sg20code, *smetric, *sgabsinc, [if feed_out, "G94"], e$
      if strtflag = one, ptlch_strt
      else,
        [
        prv_g20code$ = -1
        prv_xabs = c9k
        prv_yabs = c9k
        ptlch_nstrt
        ]
      pbld, n$, pconchg$, e$
      motst$ = one
      sof = zero

ptlchg0$         #Call from NCI null tool change (tool number repeats)
      ptlchg$

ptlchg$          #Tool change
      pcuttype
      g20code$ = zero
      comment$
      #if there was no motion, stop gcode, else force motion
      if (motst$ < one | motst$ > 7) & not(strtflag), !g20code$
      else,
        [
        prv_g20code$ = -1
        prv_xabs = c9k
        prv_yabs = c9k
        ]
      if strtflag, ptlch_strt
      else, ptlch_nstrt
      pbld, n$, pconchg$, e$

ptlch_strt      #Tool change, use start position
      pstart_pos
      pcom_moveb
      pcantxt
      pcantxt1, pbld, n$, pwcs, pfxout, pfyout, pzout, pstrtij, strcantext, e$
      pcom_movea
      prstore_pos
      ptlch_nstrt

ptlch_nstrt     #Tool change, do not use start position
      pcom_moveb

      if sof, #Program start
        [
          if strtflag = zero, # Start Pt. = Thread Pt.
           [
            # Initial 'G92' at program start
            pcantxt1, pbld, n$, pwcs, `sg20code, sgabsinc, pfxout, pfyout,
              pzout, pstrtij, strcantext, e$
            # Rapid to this G92 position (same X,Y position as G92)
            pbld, n$, *sg20code, pfxout, pfyout, e$
           ]
          else,  # Start Pt. <> Thread Pt.
           [
            #Rapid from Start Pt. -> Thread Pt. (at start of file)
            pcantxt1, pbld, n$, *sg20code, pfxout, pfyout, strcantext, e$
            if re_G92,  # Re-G92XY at after positioning to Thread Pt.?
              pbld, n$, pwcs, pfxout, pfyout, pzout, e$
           ]
        ]
      else, # After initial program start
        [
         if xinc | yinc,  # Reposition motion?
           [
            # Rapid to new cut (Cut Pt. -> new Thread Pt.)
            pcantxt1, pbld, n$, pwcs, `sg20code, sgabsinc, pxout, pyout, pzout,
              pstrtij, strcantext, e$
            if re_G92,  # Re-G92XY at each thread point (after SOF)?
              [
               sof = one # Needed to force 'G92' output in all to 'pwcs'
               pbld, n$, pwcs, pfxout, pfyout, pzout, e$
               sof = zero
              ]
           ]
        ]

      postlchng = zero
      pcantxt
      pbld, n$, stank, e$
      sof = zero
      pcom_movea

pmiscint$        #Check misc. integer setting to set flag
      brk_cc_pos$ = -1 #Set to see if a move is being broken at start
      linarc$ = zero
      absinc$ = mi2$
      if mi4$,
        [
        if mi4$ = one, sct2 = sg62
        else, sct2 = sg63
        ]
      else, sct2 = sg61
      if mi10$,
        [
        immediate$ = zero
        plot_2d_uv$ = -set_plot
        if mi10$ = two, linarc$ = one
        ]
      else,
        [
        immediate$ = one
        plot_2d_uv$ = set_plot #screen drawn backplot, control setting
        ]
      sav_linarc = linarc$

ptlchg1002$      #Call at actual toolchange, examine start position
      pthdstrttype
      cntrflag = zero
      if nosubs = yes$ | subtyp$ = zero, subsflag = zero
      else,
        [
        subsflag = one
        prv_cend$ = zero
        prv_cstart$ = zero
        ]
      if g60_mod_on = one & wtmax, g60_mode$ = one
      else, g60_mode$ = zero
      sav_wt = inittaper$
      postlchng = one

ptoolend$        #End of tool path
      pcntr
      if nosubs = no$ & subtyp$, psubs
      if subsflag = four, pendsub
      prv_wc_outflag = -1

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool
      ptoolend$
      comment$
      pbld, n$, "M30", e$
      if nchsub$ > one,
        [
        " ", e$
        " ", e$
        mergesub$
        clearsub$
        ]
      "%", e$

pwcs            #Coordinate setting
      if sof | mi1$ > one,
        [
        if mi1$ > one, pwcs_g54
        else, "G92"
        !g20code$
        !absinc$
        prv_g92x_m = vequ (xabs)
        ]

pwcs_g54        #G54 coordinate setting
      if workofs$ < 6, g_wcs = workofs$ + 54
      else, p_wcs = workofs$ - 5
      if workofs$ < 6 & (prv_g_wcs <> g_wcs | g92_frc_sb = yes$), *g_wcs
      if workofs$ > 5 & (prv_p_wcs <> p_wcs | g92_frc_sb = yes$), "G54.1", *p_wcs
      !workofs$, !g_wcs, !p_wcs

pstrtij         #Base/height setting for Fanuc
      if sof, *uvheight$, *xyheight$

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapidout       #Output to NC of linear movement - 2D rapid
      pcantxt1, pbld, n$, sgabsinc, pccomp, sg20code, pwtcode,
        pxout, pyout, pzout, pwtout, strcantext, e$
      pwtoutaft

plinout         #Output to NC of linear movement - 2D feed
      pcantxt1, pbld, n$, sgabsinc, pccomp, sg20code, pwtcode,
        pxout, pyout, pzout, pctype, pwtout, pfrout, strcantext, e$
      pwtoutaft

pcirout         #Output to NC of circular interpolation - 2D
      pcantxt1, pbld, n$, sgabsinc, pccomp, sg20code, pwtcode,
        pxout, pyout, pzout, parc, pctype, pwtout, pfrout, strcantext, e$
      pwtoutaft

pnc_out_4       #Build 4 axis motion blocks
      if (g20code$ = two & g30code$ = 3) | (g20code$ = three & g30code$ = two),
        result = mprint (serror1)
      if xinc | yinc | uinc | vinc,
        [
        pbld, n$, sgabsinc, pccomp
        if g20code$ < two & (xinc | yinc), plinxy4
        if g20code$ > one & (xinc | yinc), pcirxy4
        if g30code$ > one & (uinc | vinc), pciruv4
        else, plinuv4
        if not(xinc) & not(yinc), prv_g20code$ = g30code$
        else, prv_g30code$ = g20code$
        ]

plinxy4         #Linear XY component - 4 axis direct and taper
      # if RAPID_OFF = YES, Force linear lead-off moves to be 'G0' motions
      if (rapid_off = yes$ & prv_cend$ = three) & (g20code$ < two & g30code$ < two),
        g20code$ = zero
      sg20code, pxout, pyout, pzout
      !g30code$

pcirxy4         #Circular XY component - 4 axis direct
      sg20code, pxout, pyout, pzout, parc
      !g30code$

plinuv4         #Linear UV component - 4 axis direct and taper
      pcantxt1, sg30code, puvout, pwout, pfrout, strcantext

pciruv4         #Circular UV component - 4 axis direct
      pcantxt1, sg30code, puvout, pwout, parckl, pfrout, strcantext

pconchg$         #Control setting change
      if gcode$ = 1010, pbld, n$, ccode$, offset$, e$
      else, ccode$, offset$, e$

pnc_out         #Calls to motion postblocks
      if convert_rpd$ & gcode$ = 0,
        [
        gcode$ = one
        g20code$ = one
        g30code$ = one
        fr$ = pst_rpd_fr$
        if serror2_used = 0, result = mprint(serror2)
        serror2_used = 1
        ]
      if cuttype = zero, pnc_out_2  # 2-axis path
      else, pnc_out_4               # 4-axis path

pnc_out_2       #Calls to motion postblocks, 2D
      if g20code$ = zero, prapidout
      if g20code$ = one, plinout
      if g20code$ > one & g20code$ < four, pcirout
      !g20code$, !g30code$

pdwl_spd$        #Call from NCI gcode 4
      comment$
      pcantxt
      if fmtrnd(dwell$), pcantxt1, pbld, n$, *sg20code, *dwell$, strcantext, e$
      pcantxt2

prapid$          #Output to NC on subsflag
      pcom_moveb
      pcantxt
      pstrtsub
      pnc_out, e$
      pendsub
      pcom_movea

pzrapid$         #Output to NC of linear movement - rapid Z only
      prapid$

plin$            #Output to NC of linear movement - feed
      prapid$

pz$              #Output to NC of linear movement - feed Z only
      prapid$

pcir$            #Output to NC of circular interpolation
      prapid$

pedm$            #4 Axis Taper
      pcntr     #Set control flags
      if cntrflag = one | cntrflag = two, g20code$ = one
      else, g20code$ = zero
      g30code$ = g20code$
      prapid$

pdir_tapr$       #2D conversion routine postblock to switch direct to taper
                #linarc controls switch
      if (g20code$ = two & g30code$ = three) | (g20code$ = three & g30code$ = two),
        linarc$ = one

pcom_moveb      #Common motion preparation routines, before
      pcntr
      if nosubs = no$ & subtyp$, psubs
      if cuttype = zero & gcode$ < five, # 2-axis path & axis motion
        [
        # if RAPID_OFF = YES, Force linear lead-off moves to be 'G0' motions
        if (rapid_off = yes$ & prv_cntrflag = two), g20code$ = zero
        else, g20code$ = gcode$
        ]
      pget_wt  #Assign 'wt' (wire taper) to post variable 'wtout'
      xabs = vequ(x$)
      if cuttype < two, u$ = vequ(wx$)
      uabs = vequ(u$)
      xia = fmtrnd(xabs)
      yia = fmtrnd(yabs)
      zia = fmtrnd(zabs)
      xinc = vsub(xia, prv_xia)
      uia = fmtrnd(uabs)
      via = fmtrnd(vabs)
      wia = fmtrnd(wabs)
      uinc = vsub(uia, prv_uia)

pcom_movea      #Common motion preparation routines, after
      if (cend$ = two | cend$ = three) & nextop$ = 1011 & subsflag <> zero,
        [
        !cend$
        psubs
        pendsub
        ]
      if not(sof), pcantxt2
      if mi2$ = zero & mi3$ = zero & nosubs = no$ & subtyp$ & subsflag = four
        & (skimpass$ = -2 | thdcutflag = one),
        [
        if mi1$ <= one,
          [
          g92x_m = vequ (xabs)
          n$, pbld, 'G92', g92x_m, g92y_m, e$
          ]
        !g92x_m, !g92y_m
        ]
      !xia, !yia, !zia, !uia, !via, !wia
      !uabs, !vabs, !wabs, !uinc, !vinc, !winc
      !gcode$, !x$, !y$, !z$, !u$, !v$, !w$, !wx$, !wy$, !wt$
      !cstart$, !cend$, !g60_mode$
      !cc_pos$, !cutpos2$
      linarc$ = sav_linarc

plin_end$        #End of linear
      brk_cc_pos$ = -1

pcir_end$        #End of circular
      brk_cc_pos$ = -1

# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
pbld            #Canned text - block delete
      if bld = one, '/'

pfbld           #Force - block delete
      "/"

pccomp          #Cutter Compensation
      sccomp

pwtcode         #Wire taper gcode
      swtcode

pxout           #X output
      if absinc$ = zero, xabs, !xinc
      else, xinc, !xabs

pfxout          #Force X axis output
      if absinc$ = zero, *xabs, !xinc
      else, *xinc, !xabs

pyout           #Y output
      if absinc$ = zero, yabs, !yinc
      else, yinc, !yabs

pfyout          #Force Y axis output
      if absinc$ = zero, *yabs, !yinc
      else, *yinc, !yabs

pzout           #Z output
      if absinc$ = zero, zabs, !zinc
      else, zinc, !zabs

pfzout          #Force Z axis output
      if absinc$ = zero, *zabs, !zinc
      else, *zinc, !zabs

puvout          #UV output
      if g20code$ < two,
        [
        if uvtyp_lin >= two, #make absolute formats highest
          [
          result = newfs(two, uout)
          result = newfs(two, vout)
          ]
        else,
          [
          result = newfs(three, uout)
          result = newfs(three, vout)
          ]
        if uvtyp_lin = zero, uout = vequ(uinc)
        if uvtyp_lin = one,
          [
          uout = (fmtrnd(uabs) - fmtrnd(xabs)) - (prv_uabs - prv_xabs)
          vout = (fmtrnd(vabs) - fmtrnd(yabs)) - (prv_vabs - prv_yabs)
          ]
        if uvtyp_lin = two, uout = vsub(uabs, xabs)
        if uvtyp_lin = three, uout = vequ(uabs)
        ]
      else,
        [
        if uvtyp_arc >= two, #make absolute formats highest
          [
          result = newfs(two, uout)
          result = newfs(two, vout)
          ]
        else,
          [
          result = newfs(three, uout)
          result = newfs(three, vout)
          ]
        if uvtyp_arc = zero, uout = vequ(uinc)
        if uvtyp_arc = one,
          [
          uout = (fmtrnd(uabs) - fmtrnd(xabs)) - (prv_uabs - prv_xabs)
          vout = (fmtrnd(vabs) - fmtrnd(yabs)) - (prv_vabs - prv_yabs)
          ]
        if uvtyp_arc = two, uout = vsub(uabs, xabs)
        if uvtyp_arc = three, uout = vequ(uabs)
        ]
      if (flast_UV & prv_cend$ = three), *uout, *vout # Force both U & V to output on final position
      else, uout, vout   # Standard output based on FMT setting

pwout           #W output
      if absinc$ = zero, wabs, !winc
      else, winc, !wabs

pfwout          #Force W output
      if absinc$ = zero, *wabs, !winc
      else, *winc, !wabs

parc            #Arc center output - IJ, arctype controls form
      if arctype$ < five | full_arc_flg$,
        [
        iout = i$
        jout = j$
        iout, jout
        ]
      else,
        [
        if abs(sweep$) <= 180 | arctype$ = five,
        result = nwadrs(srad, arcrad$)
        else, result = nwadrs(srminus, arcrad$)
        *arcrad$
        ]

parckl          #Arc center output - KL
      if g20code$ < two,
        [
        if kltyp_lin >= three, #make absolute formats highest
          [
          result = newfs(two, kout)
          result = newfs(two, lout)
          ]
        else,
          [
          result = newfs(three, kout)
          result = newfs(three, lout)
          ]
        if kltyp_lin = zero, kout = vsub(wxc$, prv_uabs)
        if kltyp_lin = one, kout = vsub(prv_uabs, wxc$)
        if kltyp_lin = two,
          [
          kout = abs(wxc$ - prv_uabs)
          lout = abs(wyc$ - prv_vabs)
          ]
        if kltyp_lin = three, kout = vsub(wxc$, xabs)
        if kltyp_lin = four, kout = vequ(wxc$)
        ]
      else,
        [
        if kltyp_arc >= three, #make absolute formats highest
          [
          result = newfs(two, kout)
          result = newfs(two, lout)
          ]
        else,
          [
          result = newfs(three, kout)
          result = newfs(three, lout)
          ]
        if kltyp_lin = zero, kout = vsub(wxc$, prv_uabs)
        if kltyp_lin = one, kout = vsub(prv_uabs, wxc$)
        if kltyp_lin = two,
          [
          kout = abs(wxc$ - prv_uabs)
          lout = abs(wyc$ - prv_vabs)
          ]
        if kltyp_lin = three, kout = vsub(wxc$, xc$)
        if kltyp_lin = four, kout = vequ(wxc$)
        ]
      kout, lout
      if kltyp_lin <> four,
        [
        prv_kout = zero
        prv_lout = zero
        ]

pctype          #Intersection and implied corner conics
      #wc_outflag (wire conic output) ->
      #0=no corner output, arcs are conic by default
      #1=G60 constant corner
      #2=G61 conic corner
      #3=RK for independent upper radius
      #4=R-0 for fish tail
      #5=output of the explicit UV position
      if wc_outflag = one, sctype, *xy_rad #G60R
      if wc_outflag = two, sctype, *xy_rad #G61R
      if wc_outflag = three, *xy_rad, *uv_rad #RK
      if wc_outflag = four, #R-0
        [
        result = nwadrs(srminus, xy_rad)
        *xy_rad
        result = nwadrs(srad, xy_rad)
        ]
      if wc_outflag = five, puvout, pwout #UV

pwtout          #Wire taper output with block
      if listtpr$ & bldnxtool$, tofs$
      else,
        [
        if wt_outflag = -1, pget_wt_last
        if wt_outflag & wt_outflag <> four, wtout
        ]

pfrout          #Wire feed output
      if feed_out & fr$ > zero, fr$

pwtoutaft       #Wire taper output after block
      if wt_outflag >= two,
        [
        if wt_outflag = two, pget_wt_immd
        if prv_wtgcode <> wtgcode | wt_outflag = four, prv_wtout = c9k
        pbld, n$, swtcode, wtout, e$
        ]
      #this is always the last taper, saved for comparison
      sav_wt = wt_immd$

pget_wt         #Assign wt to wtout
      if prv_cntrflag = two, wt$ = zero
      wtgcode = fsg3(wt$)
      wtout = abs(wt$)
      sav_wt = wt$

pget_wt_immd    #Assign wt_immd to wtout
      if prv_cntrflag = two, pget_wt
      wtgcode = fsg3(wt_immd$)
      wtout = abs(wt_immd$)

pget_wt_last    #Assign last_g60_wt to wtout
      if prv_cntrflag = two, pget_wt
      wtgcode = fsg3(last_g60_wt$)
      wtout = abs(last_g60_wt$)

# --------------------------------------------------------------------------
# Canned cycle calls
# pcan1 thru pcan8 and pcan1_2 thru pcan8_2 are available
# only pcan1 and pcan1_2 are shown as examples
# --------------------------------------------------------------------------
pcan1$           #Canned cycle 1
      pbld, n$, x$, y$, e$

pcan1_2$         #Canned cycle 1, repeat position
      pbld, n$, x$, y$, e$

# --------------------------------------------------------------------------
#Subprogram postblocks
# --------------------------------------------------------------------------
pstrtsub        #Start of subroutine
      if subsflag = two | subsflag = 6,
        [
        if subtyp$ = one,
          [
          if absinc$ = zero,
            [
            g92x_m = vequ (prv_xabs)
            sav_g92x_m = vequ (g92x_m)
            ]
          if (g92_in_sub = zero & mi1$ <= one) & absinc$ = zero,
            [
            n$, pbld, "G92", *g92x_m, *g92y_m, e$
            !g92x_m, !g92y_m
            ]
          subprogno = subno$
          pbld, n$, "M98", *subno$, e$
          subout$ = one
          sav_n = n$
          subprogno, e$
          n$ = seqno$
          if g92_in_sub = one & (absinc$ = zero | g92_frc_sb = one),
            [
            absinc$ = zero
            pbld, n$, sgabsinc, e$
            if mi1$ > one, n$, pbld, pwcs_g54, e$
            else, n$, pbld, "G92", *g92x_m, *g92y_m, e$ #G192 restart here
            absinc$ = mi3$
            pbld, n$, *sgabsinc, e$
            ]
          else,
            [
            absinc$ = mi3$
            pbld, n$, *sgabsinc, e$
            ]
          ]
        else,
          [
          subprogno = subno$
          pbld, n$, "M98", *subno$, e$
          no_nc_out$ = one #shut output off
          ]
        if absinc$ = zero, prv_g92x_m = vequ (sav_g92x_m)
        ]

pendsub         #End of subroutine
      if subsflag = four | subsflag = 6,
        [
        absinc$ = mi2$
        pbld, n$, *sgabsinc, e$
        pbld, n$, "M99", e$
        " ", e$
        " ", e$
        subout$ = zero
        n$ = sav_n
        no_nc_out$ = zero
        ]

psubs           #Set the subprogram flag
      if subsflag = two & subout$, subsflag = three
      if (cstart$ = two | cstart$ = three) & leadintype = one, subsflag = two
      if (prv_cstart$ = two | prv_cstart$ = three) & leadintype = zero, subsflag = two
      if subsflag = four, subsflag = five
      if (prv_cend$ = two | prv_cend$ = three) & subsflag <= three, subsflag = four
      if (cstart$ = two | cstart$ = three) & (cend$ = two | cend$ = three), subsflag = 6

# --------------------------------------------------------------------------
# Canned Text
# --------------------------------------------------------------------------
pcantxt            #Canned text - before output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]
      if thrd_cut$ = one & not(postlchng),
        [
        if man_wire = yes$,
          [
          pbld, n$, swire, e$
          pbld, n$, spower, e$
          pbld, n$, swater, e$
          ]
        else, pbld, n$, sautowire, e$
        ]

pcantxt1           #Canned text - with move
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = one | cant_pos1$ = four, pcant_1
        if cant_pos2$ = one | cant_pos2$ = four, pcant_2
        if cant_pos3$ = one | cant_pos3$ = four, pcant_3
        if cant_pos4$ = one | cant_pos4$ = four, pcant_4
        if cant_pos5$ = one | cant_pos5$ = four, pcant_5
        if cant_pos6$ = one | cant_pos6$ = four, pcant_6
        if cant_pos7$ = one | cant_pos7$ = four, pcant_7
        if cant_pos8$ = one | cant_pos8$ = four, pcant_8
        if cant_pos9$ = one | cant_pos9$ = four, pcant_9
        if cant_pos10$ = one | cant_pos10$ = four, pcant_10
        if cant_pos11$ = one | cant_pos11$ = four, pcant_11
        if cant_pos12$ = one | cant_pos12$ = four, pcant_12
        if cant_pos13$ = one | cant_pos13$ = four, pcant_13
        if cant_pos14$ = one | cant_pos14$ = four, pcant_14
        if cant_pos15$ = one | cant_pos15$ = four, pcant_15
        if cant_pos16$ = one | cant_pos16$ = four, pcant_16
        if cant_pos17$ = one | cant_pos17$ = four, pcant_17
        if cant_pos18$ = one | cant_pos18$ = four, pcant_18
        if cant_pos19$ = one | cant_pos19$ = four, pcant_19
        if cant_pos20$ = one | cant_pos20$ = four, pcant_20
        ]
      #Output of strcantext occurs at the end of the output line

pcantxt2           #Canned text - after output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]
      if thrd_cut$ = two,
        [
        if man_wire = yes$,
          [
          wire$ = zero
          power$ = zero
          water$ = zero
          pbld, n$, swire, e$
          pbld, n$, spower, e$
          pbld, n$, swater, e$
          ]
        else, pbld, n$, sautowire, e$
        ]

      sav_bld = bld
      if subsflag = two | subsflag = three, bld = one
      pbld, n$, swater, e$
      pbld, n$, spower, e$
      pbld, n$, stank, e$
      if cstop$, pbld, n$, *sm00, e$
      if cgstop$, pbld, n$, *sm01, e$
      bld = sav_bld

pcant_1         #Canned text - output call
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Canned text - output call
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Canned text - output call
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Canned text - output call
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Canned text - output call
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Canned text - output call
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Canned text - output call
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Canned text - output call
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Canned text - output call
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Canned text - output call
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Canned text - output call
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Canned text - output call
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Canned text - output call
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Canned text - output call
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Canned text - output call
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Canned text - output call
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Canned text - output call
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Canned text - output call
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Canned text - output call
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Canned text - output call
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
      #Assign string select type outputs
      if cant_pos < three, #cant_pos indicates canned text output
        [
        if cantext$ = three, bld = one
        if cantext$ = four, bld = zero
        #Build the cantext string
        if cantext$ = one, strcantext = strcantext + sm00
        if cantext$ = two, strcantext = strcantext + sm01
        if cantext$ > four,
          [
          strtextno = no2str(cantext$)
          strcantext = strcantext + strm + strtextno
          ]
        ]
      else, #cant_pos indicates coolant output
        [
        strtextno = no2str(cantext$)
        strcantext = strcantext + strm + strtextno
        ]

# --------------------------------------------------------------------------
# Position calculations, generally these do not need to be modified
# --------------------------------------------------------------------------
pcuttype        #Determine the cut type, 0=2D, 1=direct, 2=taper
      pleadintype
      cuttype = zero
      if uvflag$, cuttype = one
      if gcode$ = 11 | nextop$ = 11, cuttype = two

pleadintype     #Determine the lead in type
      leadintype = not(cstart$ = two | cstart$ = three)

pthdstrttype    #Determine the start/thread position type
      if fmtrnd(threadx$) <> fmtrnd(startx$) | fmtrnd(thready$) <> fmtrnd(starty$), strtflag = one
      else, strtflag = zero
      if fmtrnd(threadx$) <> fmtrnd(cutx$) | fmtrnd(thready$) <> fmtrnd(cuty$), thdcutflag = one
      else, thdcutflag = zero

pcntr           #Set control flags
      if not(prv_cntrflag) & cntrflag &  brk_cc_pos$ <> -1, cc_pos$ = brk_cc_pos$
      #Set the contour flags
      !cntrflag
      if cstart$ = two | cstart$ = three, cntrflag = one # flag start of contour
      if cend$ = two | cend$ = three, # prior move was last of contour
        [
        cntrflag = two  # flag that this the leadoff move
        if leadintype = zero & nextop$ > four, !cntrflag
        ]
      if (cstart$ = two | cstart$ = three) & (cend$ = two | cend$ = three), cntrflag = 3 #single move
      #set line_line flag - 0=fail, 1=ll, 2=la, 3=al, 4=aa
      if gcode$ = zero | gcode$ = one,
        [
        if nextop$ = zero | nextop$ = one, l_lflag = one # line-line
        else,
          [
          if nextop$ > one & nextop$ < four, l_lflag = two # line-arc
          else, l_lflag = zero # fail
          ]
        ]
      else,
        [
        if gcode$ > one & gcode$ < four,
          [
          if nextop$ = zero | nextop$ = one, l_lflag = three  # arc-line
          else,
            [
            if nextop$ > one & nextop$ < four, l_lflag = four # arc-arc
            else, l_lflag = zero  # fail
            ]
          ]
        else, l_lflag = zero  # fail
        ]
      #set tangent flag
      if abs(move_ang$) > atol$ & abs(move_ang$) < max_atol$, tanflag = zero
      else, tanflag = one
      #Now set the 'wc_outflag' & 'wt_outflag' flags...

      # 'wc_outflag' (Wire conic output) ->
       #0=no corner output, arcs are conic by default
       #1=G60 constant corner
       #2=G61 conic corner
       #3=RK for independent upper radius
       #4=R-0 for fish tail
       #5=output of the explicit UV position

      # 'wt_outflag' (Wire taper output) ->
       #-1=g60_mode apply g60_last_wt to current move
       #0=no taper output
       #1=wt with current move
       #2=1 then wt_immd after current move
       #3=2 but update for wt_immd after move
       #4=wt after current move (forced)

      # 'wtmax'   = largest 2d wire taper read from NCI
      # 'cuttype' = 0=2D, 1=direct, 2=taper
      if wtmax = zero | cuttype,
        [
        wt_outflag = zero
        wc_outflag = zero
        if wc$ = 5 & tanflag = zero & cntrflag = one & prv_cntrflag = one,
          [
          wc_outflag = four #R-0, fish
          xy_rad = zero
          ]
        if prv_cntrflag = zero, !wabs
        ]
      else,
        [
        #Set the wt_outflag -
        #sav_wt is last taper, wt is current taper and wt_immd
        #is same unless immediate taper, if immediate taper
        #wt_immd is second point on current and nextwt is
        #taper at end of next move.
        #Four tapers for replaced arcs with g60_mode are saved
        #prv_last_g60_wt and last_g60_wt are the tapers in order
        #for the start of the arc.
        #wt and wt_immd are the tapers in order for the end of the
        #arc.  If they are not immediate the values are set equal.
        #Tapers are tested for the current and next move to
        #determine if the change.  Based on the change, type of
        #intersection and control flags, the wt_outflag is set.
        #Set the wc_outflag -
        #Corner types are set based on the corner or arc corner
        #(g60_mode) setting in the NCI.
        #Arcs are defined with IJ, lower radius, xy_rad (R) and
        #upper radius, uv_rad (K).
        if wtmax,
          [
          if ((g60_mode$ = two & fmtrnd(sav_wt) <> fmtrnd(last_g60_wt$))
            | (prv_g60_mode$ = two & g60_mode$ = one & fmtrnd(sav_wt) <> fmtrnd(wt$))
            | immediate$ > two), result = mprint(serror1)
          if tanflag = one | prv_cntrflag = zero,
            [
            if immediate$ = two | immediate$ >= four, wt_outflag = two
            else, wt_outflag = one
            wc_outflag = zero
            !wabs
            ]
          else, #intersection, test for taper changes
            [
            if g60_mode$ & g60_mode$ <> two,
              [
              if (fmtrnd(sav_wt) <> fmtrnd(wt$) | fmtrnd(wt_immd$) <> fmtrnd(nextwt$)),
                [
                wc_outflag = zero
                if l_lflag > one | (use_2d_uv$ > one & wc$) | (use_2d_uv$ > two & wc$ = zero),
                  result = mprint(serror1)
                else, #line-line with gradual taper
                  [
                  wc_outflag = five #UV
                  wt_outflag = zero
                  #display must be sharp
                  #if wc = zero | wc > two, result = mprint(serror1)
                  ]
                ]
              else, #taper angle has not changed
                [
                if wc$ = three & cntrflag = one, #'other' corner type
                  [
                  if immediate$ = one, wt_outflag = four
                  else, wt_outflag = two
                  wc_outflag = zero
                  ]
                else, #normal intersection with constant taper
                  [
                  if immediate$ = one, wt_outflag = one
                  else, wt_outflag = three
                  # Wire corner type selector
                  # wc=0, Conical corner type
                  # wc=1, Sharp corner type
                  # wc=2, Constant corner type
                  # wc=3, Other corner type
                  # wc=4, Fixed corner type
                  # wc=5, Fish Tail corner type
                  if cntrflag = one & prv_cntrflag = one,
                    [
                    if wc$ = zero,
                      [
                      if use_G61 = yes$,
                        wc_outflag = two #G61R
                      else,
                        wc_outflag = zero #G61R
                      xy_rad = zero
                      ]
                    #wc=1,wc=2,wc=3 are sharp, no wc_outflag
                    if wc$ = one | wc$ = two | wc$ = three,
                      [
                      wc_outflag = zero
                      xy_rad = zero
                      ]
                    if wc$ = four,  # wc=4, Fixed corner type
                      [
                      wc_outflag = three #RK
                      xy_rad = zero
                      uv_rad = wc_rad$
                      ]
                    if wc$ = five,  # wc=5, Fish Tail corner type
                      [
                      wc_outflag = four #R-0, fish
                      xy_rad = zero
                      ]
                    ]
                  else, wc_outflag = zero #start and end, no corners
                  ]
                ]
              ]
            else, #g60_mode active, apply starting taper
              [
              if g60_mode$,
                [
                wt_outflag = -1
                wc_outflag = zero
                uv_rad = zero
                # Wire arc type (taper)
                # wc=0, Conical corner type
                # wc=1, Sharp corner type
                # wc=2, Constant corner type
                # wc=3, Other corner type
                # wc=4, Fixed corner type
                # wc=5, Fish Tail corner type
                if warc_ctyp$ = zero,
                  [
                  wc_outflag = two #G61R
                  xy_rad = arcrad$
                  ]
                if warc_ctyp$ = one | warc_ctyp$ >= three,
                  [
                  wc_outflag = three #RK
                  xy_rad = arcrad$
                  if warc_ctyp$ = four, uv_rad = warc_rad$
                  ]
                if warc_ctyp$ = two,
                  [
                  wc_outflag = one #G60R
                  xy_rad = arcrad$
                  ]
                ]
              ]
            ]
          ]
        ]

pstart_pos      #Copy start to current position
      sav_x = vequ(x$)
      sav_u = vequ(u$)
      x$ = vequ(startx$)
      u$ = vequ(startx$)

prstore_pos     #Restore current position
      x$ = vequ(sav_x)
      u$ = vequ(sav_u)

# --------------------------------------------------------------------------
# Tooltable calls
# --------------------------------------------------------------------------
pwrtt$           #Write tool table, scans entire file
      if abs(wt_max$) > abs(wtmax), wtmax = wt_max$

# --------------------------------------------------------------------------
# Parameter lookup tables - You must adjust the size value if you add any parameters to these tables!
# --------------------------------------------------------------------------
# Machine Definition Parameters
fprmtbl 17000   0    #Table Number, Size
#       Param   Variable to load value into

# Control Definition Parameters
fprmtbl 18000   1    #Table Number, Size
#       Param   Variable to load value into
        18803   feed_out   #Capture the Control Def setting for "Use feedrate in NC output"

# Toolpath Group Parameters
fprmtbl 19000   0    #Table Number, Size
#       Param   Variable to load value into

# --------------------------------------------------------------------------
# Machine definition and control definition parameter capture:
# --------------------------------------------------------------------------
pmachineinfo$   #Machine information parameters postblock
      #rd_md is used to call pmachineinfo postblock and read the parameters of the selected axis
      #combination machine entity set in rd_mch_ent_no
      #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
      #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters
      #"-->pmachineinfo", ~prmcode$, "  ", ~sparameter$, e$  #Do not uncomment if being called from pprep$ - see pprep comment

      #Read parameter lookup tables -
      #Leave lines below commented until you enter values in related lookup tables
      #if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000) #Run the parameter table for Machine Definition Parameters
      if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Run the parameter table for Control Definition Parameters
      #if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000) #Run the parameter table for Toolpath Group Parameters

# --------------------------------------------------------------------------
# POST TEXT
# --------------------------------------------------------------------------
[CTRL_TEXT_XML_BEGIN]  # Post text edits MUST be made with Control Definition Manager.
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text>
	<control>
		<control_label>CTRL_WIRE|DEFAULT</control_label>
		<language>en-US</language>
		<misc_integers>
			<misc_1>
				<text>WCS, 0-1=G92,2=AUTO-G54,G55...</text>
			</misc_1>
			<misc_2>
				<text>Main program,0=Abs. 1=Inc.</text>
			</misc_2>
			<misc_3>
				<text>Subprogram,0=Abs. 1=Inc.</text>
				<value>1</value>
			</misc_3>
			<misc_4>
				<text>Sub G61 w/G62/G63, 0=Off,1=G62,2=G63</text>
			</misc_4>
			<misc_10>
				<text>Convert 2D,1=4D direct,2=4D taper</text>
			</misc_10>
		</misc_integers>
		<wire_canned_text>
			<canned_text_1>
				<text>M00 - Stop</text>
			</canned_text_1>
			<canned_text_2>
				<text>M01 - Optional Stop</text>
			</canned_text_2>
			<canned_text_3>
				<text>Block Delete ON</text>
			</canned_text_3>
			<canned_text_4>
				<text>Block Delete OFF</text>
			</canned_text_4>
			<canned_text_5>
				<text>Text 5</text>
			</canned_text_5>
			<canned_text_6>
				<text>Text 6</text>
			</canned_text_6>
			<canned_text_7>
				<text>Text 7</text>
			</canned_text_7>
			<canned_text_8>
				<text>Text 8</text>
			</canned_text_8>
			<canned_text_9>
				<text>Text 9</text>
			</canned_text_9>
			<canned_text_10>
				<text>Text 10</text>
			</canned_text_10>
		</wire_canned_text>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]