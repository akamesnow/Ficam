[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V21.00 P4 E1 W21.00 T1505932411 M21.00 I0 O10
scncpost_revision     := "21.80" # Internal revision number for use by CNC Software only.  Please do not change this number.
scustpost_revision    := "0"  # Revision number for use by Resellers or customers.
# Post Name           : Lathe.set
# Product             : Lathe
# Machine Name        : Generic
# Control Name        : Generic
# Description         : Generic setup sheet for Lathe X
# Mill/Turn           : Yes
# 4-axis/Axis subs.   : Yes
# 5-axis              : No
# Executable          : mp.dll
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# CNC 04/28/05  -  Initial Setup for Version X.
# CNC 11/15/05  -  Modified header section and layout, added new functionality
# CNC 01/20/06  -  Fixed buffer logic to correctly handle null toolchanges
# CNC 02/17/06  -  Added opcomment string reset in pcomment2
# CNC 03/14/06  -  Modified pdrillcyc to use nextdc$ rather than drillcyc$
# CNC 06/26/06  -  Initial post setup for Mastercam X2
# CNC 07/18/06  -  Added !op_id$ to psof$, ptlchg$ and ptlchg0$, removed tlchng_aft$
# CNC 10/31/07  -  Added sub_level$ override to pprep$
# CNC 12/18/07  -  Modified EOB (End of Block) in pprep$ postblock
# CNC 04/08/08  -  X3 release - no changes made
# CNC 01/22/09  -  Initial post update for Mastercam X4
# CNC 02/03/10  -  Initial post update for Mastercam X5
# CNC 08/17/10  -  Removed CD_VAR variables
# CNC 05/20/11  -  Initial post update for Mastercam X6
# CNC 09/16/11  -  Added plunge turn operation to String selector table.
# CNC 10/16/12  -  Initial post update for Mastercam X7
# CNC 11/12/13  -  Added limited support for mill/turn operations
# CNC 02/06/14  -  Initial post update for Mastercam X8
# CNC 12/23/14  -  Initial post update for Mastercam X9
# CNC 11/09/15  -  Initial post update for Mastercam 2017
# CNC 10/14/16  -  Initial post update for Mastercam 2018
# CNC 04/24/17  -  (20.80) Initial revision number assigned.
#               -  Removed [CTRL_TEXT_END] - Not needed for Mastercam 2018
# CNC 09/13/17  -  (21.80) Initial post update for Mastercam 2019
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
# This post supports output for 2 axis turning and basic support for Mill/Turn.
# It is designed to support the features of Mastercam X Lathe.
#
# NEW FEATURES FOR X:
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
#     Output of these comments is controlled by setting outputxcom in the Optional Output Settings area.
# - Enhanced output control via post switches (see Optional Output Settings area)
#
# --------------------------------------------------------------------------
# Misc. Values:
# --------------------------------------------------------------------------
# Integers:
#
# mi1 - mi10 (NOT USED)
#
# Reals:
#
# mr1 - mr10 (NOT USED)
#
# --------------------------------------------------------------------------
# Additional Notes:
# --------------------------------------------------------------------------
# File extension (.doc) is set internally in MP.  Use pprep$ postblock to override this setting.
#
# Rapid traverse times are determined by maximum rapid feedrates set in the selected Machine Definition
# Time estimates will be wrong if these settings are incorrect.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and Factory Set Program Switches
# --------------------------------------------------------------------------
# Define constants
m_one        := -1
zero         := 0
one          := 1
two          := 2
three        := 3
four         := 4
five         := 5
c9k          := 9999
m_c9k        := -99999

bug1$        : 2     #0=No display, 1=Generic list box, 2=Editor
bug4$        : 1     #Debug output with the tilde '~'.
                     #A value greater the zero applies the variable formatting with
                     #debug output (default is typically FS 1 but not a guarantee).
                     #A value of zero gets the value directly with NO formatting.

linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 1     #Associate X plane specific variables to V9- variable?
linklvar$    : 1     #Associate X lathe specific variables to V9- variable?

skp_lead_flgs$ : 0   #Do NOT use v9+ style contour flags
get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
tooltable$   : 3     #Pre-read, call the pwrtt postblock (DO NOT CHANGE!)

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
linarc$      : yes$  #Linearize arcs? (DO NOT CHANGE!)
progname$    : 1     #Use uppercase for program name (sprogname)
rotaxtyp$    : 3     #Rotary axis type for toolplane

# --------------------------------------------------------------------------
# Optional Output Settings
# --------------------------------------------------------------------------
output_op_number : yes$  #Output operation number at start of operation?
output_comments  : yes$  #Output Operation Comments in tool list?

outputxcom   : yes$  #Output new X comments? (Machine name, Group comment, Group name)

xz_limits    : 3     #Output Max/Min X,Y,Z information?
                     #0 = Do NOT output ANY Max/Min X,Y,Z information.
                     #1 = Output Max/Min X,Y,Z info. ONLY for EACH tool (not Program)
                     #2 = Output Max/Min X,Y,Z info. ONLY for entire Program
                     #3 = Output Max/Min X,Y,Z info. for EACH tool AND Program (if > 1 tool)

# Individual axis output (if xz_limits > 0)
X_limits     : yes$  #Output Max/Min values for the X axis?
Z_limits     : yes$  #Output Max/Min values for the Z axis?

# Specific setting to allow tuning the cycle time calculations
# Set the time it takes for machine to do a toolchange
tlchgtime    : 0.1   #Tool Change Time (* in Minutes *)

time_est     : 3     #Output operation and/or cycle times?
                     #0 = Do NOT output time estimates (including det_time estimates below)
                     #1 = Output operation time ONLY for EACH tool (not Program)
                     #2 = Output comeplete cycle time ONLY for entire Program
                     #3 = Output operation time for EACH tool AND cycle time for Program (if > 1 tool)

# The 'det_time' switch allows selecting the output of "Detailed Times".
# In addition to the usual 'Cycle Time' you can get the time spent at
# RAPID and at FEEDRATE during the program.
# *IMPORTANT* -
# Note that the Program TOTAL TIME includes the Toolchange time(s),
# so it will be longer than the Total RAPID time + Total FEED time!
det_time     : 3     #Output Rapid/Feedrate times? (Requires time_est > 0)
                     #0 = Do NOT output ANY Rapid/Feedrate time breakdown.
                     #1 = Output Rapid/Feedrate times ONLY for EACH tool (not Program)
                     #2 = Output Rapid/Feedrate times ONLY at end for entire program
                     #3 = Output Rapid/Feedrate times for EACH tool AND Program (if > 1 tool)


show_lengths : 3     #Output Feed/Rapid path length information?
                     #0 = Do NOT output ANY Feed/Rapid path length information.
                     #1 = Output Feed/Rapid path length info. ONLY for EACH tool (not Program)
                     #2 = Output Feed/Rapid path length info. ONLY at end for entire program
                     #3 = Output Feed/Rapid path length info. for EACH tool AND Program (if > 1 tool)

show_tool_mfg : yes$ #Output the tool definition - 'manufacturer' data?

stock_info   : yes$  #Display stock material and size?

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
dia_mult     : 2     #Multiplier for output on X axis
drlgsel      : -1    #Selector variable for drill cycle string
tol          : 0.0001 #Tolerence for feed rates set to zero
max_speed    : 10000 #Maximum spindle speed (used if maxss out of range)
min_speed    : 0     #Minimum spindle speed
strt_spd     : 0     #Test spindle speed
testx        : 0     #Test X position
ttltime      : 0     #Total operation time
tltime       : 0     #Feed time
trtime       : 0     #Rapid time
total        : 0     #Total machine time
tot_ltime    : 0     #Total FEED time
tot_rtime    : 0     #Total RAPID time
dx           : 0     #Delta X
dz           : 0     #Delta Z
cssflag      : 0     #Indicate if CSS calculations are required
cssarea      : 0     #CSS calculations
absfr        : 0     #CSS calculations (Feedrate as a POSITIVE value)
thdxr        : 0     #Thread rapid point X
xsav         : 0     #Thread saved point X
zsav         : 0     #Thread saved point Z
thdrapfr     : 0     #Rapid traverse rate when Threading (saved from 'fr')
maxss_x      : 0     #Clamp RPM occurs at the X axis position
len          : 0     #Length for calculation
len1         : 0     #Broken length
len2         : 0     #Broken length
percent      : 0     #Percent of length
tool_op1     : 0     #Operation comment selector variable (post calculated)
is_miscops   : 0     #Misc. Op. flag
tool_end     : no$   #End flag when scanning for CDC settings at Null tlchgs
sof          : 1     #Start of file flag

# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Seperator lines
sepline      : "-------------------------------------"
sepline2     : "=========================================="
sepline3     : "================================================="

#Comment strings
snull        : ""    #Null string
smachname    : ""    #Machine name
sgrpcomm     : ""    #Group comment
sgrpname     : ""    #Group name
sopcomment   : ""    #Operation comment

#String variables to hold 'sparameter' string data
stl_mfg_com  : ""    #'tool mfg comment' from tool

#Misc. Ops. strings
sindent      : "      "
sblank       : ""    #'Blank' empty string
smiscops   : ""    #String varaible to hold message
stck_spindle0_0 : "XFER PART FROM LEFT SPINDLE"
stck_spindle1_0 : "XFER PART FROM RIGHT SPINDLE"
stck_op0     : "PUSH STOCK"
stck_op1     : "PUSH STOCK WITH 'USE TOOL STOP' OPTION"
stck_op2     : "PULL STOCK"
stck_spindle0_1 : " - FROM LEFT SPINDLE"
stck_spindle1_1 : " - FROM RIGHT SPINDLE"
sclmp_op0    : "CLAMP"
sclmp_op1    : "UN-CLAMP"
sclmp_op2    : "RE-POSITION"
sclmp_op3    : "UN-CLAMP AND EJECT STOCK"
sclmp_spindle0 : " - LEFT SPINDLE"
sclmp_spindle1 : " - RIGHT SPINDLE"
stlstck_on0  : "RETRACT TAILSTOCK"
stlstck_on1  : "ADVANCE TAILSTOCK"

# --------------------------------------------------------------------------
# General String select tables
# --------------------------------------------------------------------------
#Select operation note
sopid0  : ""
sopid1  : "Contour"
sopid2  : "Drill - "
sopid3  : "Pocket"
sopid4  : "Transform"
sopid5  : "Multisurface Rough Parallel"
sopid6  : "Multisurface Rough Radial"
sopid7  : "Multisurface Rough Project"
sopid8  : "Multisurface Rough Flowline"
sopid9  : "Multisurface Rough Contour"
sopid10 : "Multisurface Rough Pocket"
sopid11 : "Multisurface Finish Parallel"
sopid12 : "Multisurface Finish Radial"
sopid13 : "Multisurface Finish Project"
sopid14 : "Multisurface Finish Flowline"
sopid15 : "Multisurface Finish Contour"
sopid16 : "C-Hook Created Operation"
sopid17 : "Manual Entry"
sopid18 : "Circle Mill"
sopid19 : "Point"
sopid20 : "Trimmed"
sopid21 : "Ruled"
sopid22 : "Revolved"
sopid23 : "Letters"
sopid24 : "Swept 2D"
sopid25 : "Swept 3D"
sopid26 : "Coons"
sopid27 : "Lofted"
sopid28 : "5-axis Drilling"
sopid29 : "5-axis Curve"
sopid30 : "Project toolpath onto plane"
sopid31 : "Project toolpath onto cylinder"
sopid32 : "Project toolpath onto sphere"
sopid33 : "Project toolpath onto cone"
sopid34 : "Project toolpath onto cross section"
sopid35 : "Project toolpath onto surface"
sopid36 : "Non-associative contour"
sopid37 : "Non-associative drilling"
sopid38 : "Non-associative pocketing"
sopid39 : "Multisurface finish pencil trace"
sopid40 : "Multisurface finish leftover stock"
sopid41 : "Multisurface finish steep"
sopid42 : "Multisurface finish shallow"
sopid43 : "Multisurface finish constant scallop"
sopid44 : "Multisurface rough plunge"
sopid45 : "Multisurface finish 5-axis flowline"
sopid46 : "Multisurface finish 4-axis"
sopid47 : "Merged in ASCII NCI"
sopid48 : "5-axis swarf"
sopid49 : "5-axis roll die"
sopid50 : ""
sopid51 : "C-axis Face Contour"
sopid52 : "C-axis Cross Contour"
sopid53 : "C-axis Contour"
sopid54 : ""
sopid55 : "C-axis Face Drill - "
sopid56 : "C-axis Cross Drill - "
sopid57 : "C-axis Drill - "
sopid58 : ""
sopid59 : ""
sopid60 : "ROUGH"
sopid61 : "FINISH"
sopid62 : "GROOVING"
sopid63 : "THREADING"
sopid64 : "DRILL CYCLE - "
sopid65 : "POINT"
sopid66 : "FACING"
sopid67 : "CUTOFF"
sopid68 : "PLUNGE ROUGH / CHAINED GROOVE"
sopid69 : "MANUAL ENTRY"
sopid70 : "MERGED ASCII"
sopid_1 : ""         #Target string

fstrsel sopid0 tool_op1 sopid_1 71 -1
# --------------------------------------------------------------------------
#Select operation note
sopid201 : "CANNED FINISH"
sopid202 : "CANNED ROUGH"
sopid203 : "CANNED ROUGH AND FINISH"
sopid204 : "CANNED ROUGH FACE"
sopid205 : "CANNED ROUGH AND FINISH FACE"
sopid206 : "CANNED PATTERN REPEAT ROUGH"
sopid207 : "CANNED PATTERN REPEAT ROUGH AND FINISH"
sopid208 : "CANNED GROOVE ROUGH"
sopid209 : "CANNED GROOVE FINISH"
sopid210 : "QUICK ROUGH"
sopid211 : "QUICK FINISH"
sopid212 : "QUICK GROOVE"
sopid213 : "C-HOOK GENERATED"
sopid214 : "STOCK TRANSFER"
sopid215 : "STOCK FLIP"
sopid216 : "STOCK ADVANCE"  #(BAR FEED)
sopid217 : "CHUCK CLAMP/UN-CLAMP"
sopid218 : "TAILSTOCK POSITION"
sopid219 : "STEADYREST POSITION"
sopid220 : ""
sopid221 : ""
sopid222 : ""
sopid223 : ""
sopid224 : "PLUNGE TURN"
sopid_2  : ""        #Target string

fstrsel sopid201 tool_op1 sopid_2 24 -1
# --------------------------------------------------------------------------
#Select drill operation note
sdr00   : "SIMPLE"       #drill - no dwell
sdr01   : "PECK"         #peck drill - no dwell
sdr02   : "CHIP BREAK"   #chip break - no dwell
sdr03   : "TAP"          #tap - right hand
sdr04   : "BORE_1"      #bore #1 - no dwell
sdr05   : "BORE_2"      #bore #2 - no dwell
sdr06   : "MISC_1"       #misc #1 - no dwell
sdr07   : "MISC_2"       #misc #2 - right hand
sdrillcyc : ""           #Target string

fstrsel sdr00 drlgsel sdrillcyc 8 -1
# --------------------------------------------------------------------------
# Month selector
smon0   : ""
smon1   : "JAN."
smon2   : "FEB."
smon3   : "MAR."
smon4   : "APR."
smon5   : "MAY."
smon6   : "JUN."
smon7   : "JUL."
smon8   : "AUG."
smon9   : "SEP."
smon10  : "OCT."
smon11  : "NOV."
smon12  : "DEC."
smonth  : ""         #Target string

fstrsel smon0 month$ smonth 13 -1
# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
fs2  1  0.4 0.3      #Decimal, absolute, 4/3 place, default for initialize (:)
fs2  2  0.4 0.3n     #Decimal, absolute, 4/3 place, non-modal
fs2  3  1 0 1 0n     #Integer, not leading, non-modal
fs2  4  0.2 0.2n     #Decimal, absolute, 2 place, non-modal
fs2  5  1.4 1.3ltn   #Decimal, absolute, 4/3 place, leading&trailing, non-modal
fs2  6 +1.4 1.3ltn   #Decimal, absolute, 4/3 place, leading&trailing with SIGN
fs2  7  0.4 0.3ltn   #Decimal, 4/3 place, trailing, non-modal
fs2  8  0^2 0^2n     #Decimal, 2 place, omit decimal if whole number, non-modal
fs2  9  4 0 4 0l     #Integer, force four leading

# These formats used for 'Date' & 'Time'
fs2 17  1 0 1 0      #Integer, not leading
fs2 18  2.2 2.2lt    #Decimal, force two leading & two trailing (time2)
fs2 19  2 0 2 0t     #Integer, force trailing                   (hour)
fs2 20  0 2 0 2lt    #Integer, force leading & trailing         (min)

# --------------------------------------------------------------------------
# Format assignments
# --------------------------------------------------------------------------
fmt     9   progno$     #Program number
fmt     3   t$          #Tool number
fmt     7   tcr$        #Tool corner radius
fmt     3   tloffno$    #Diameter offset number
fmt     3   speed       #Spindle speed
fmt     3   maxss$      #Max Spindle speed
fmt     4   absfr       #Feedrate
fmt     2   llen        #Feed cut length
fmt     2   rlen        #Rapid traverse cut length
fmt     2   llen_total  #Feed cut length (program total)
fmt     2   rlen_total  #Rapid traverse cut length (program total)
fmt     3   thrs        #Time in hours
fmt     3   tmin        #Time in minutes
fmt     8   tsec        #Time in seconds
fmt     3   tcnt        #Tool Counter
fmt     3   custcycle   #Custom Cycle number
fmt     2   stck_ht$    #Stock Length
fmt     2   stck_wdth$  #Maximum Stock Diameter
fmt     3   op_number   #The operation number displayed in the Operations Manager
# --------------------------------------------------------------------------
#Format the variables used to output the X,Z Max/Min values
fmt     6   max_Xpos
fmt     6   min_Xpos
fmt     6   max_Zpos
fmt     6   min_Zpos
# --------------------------------------------------------------------------
fmt     17  year2       #Calculated year value
fmt     18  time2       #Capture 24-hour time value into 'time2' variable
fmt     19  hour        #Hour
fmt     20  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
pcomment$        #Comment from manual entry (must call pcomment2)
      pcomment2  #Required if doing boolean 'if' logic testing!

pcomment2        #Output Comment from manual entry
      sopcomment = snull
      scomm$ = ucase(scomm$)
      if gcode$ = 1051, smachname = scomm$   #Machine name
      if gcode$ = 1052, sgrpcomm = scomm$    #Group comment
      if gcode$ = 1053, sgrpname = scomm$    #Group name
      if gcode$ = 1008, sopcomment = scomm$  #Operation comment

pdrillcyc        #Output drillcycle type note if canned cycle was programmed
      if opcode$ = 105 | opcode$ = three, #Lathe drill / Mill drill
        [
        drlgsel = nextdc$
        if drlgsel > 7,  #Custom canned cycle was programmed
          [
          custcycle = drlgsel + one  #Shift it to match cycle number displayed in drill cycle drop down
          "CUSTOM CYCLE ", 35, *custcycle
          ]
        else, *sdrillcyc
        ]

#----------------------------------------------------------------------------
# Lathe 'Misc. Ops.' toolpath functions - comment output only!
# --------------------------------------------------------------------------
pmiscops         #Ouptut operation info for Misc Ops.
      if is_miscops > 0 & smiscops <> sblank,
        [
        " ", *e$  #Output a blank line
        if not (gcode$ = 902 & stck_op$ > 0), pop_desc #Don't output redundant op description for miscops that include a tool change
        if smiscops <> sblank, sindent, "(", smiscops, ")", e$
        " ", *e$  # Output a blank line
        ]
      is_miscops = 0  #Reset the flag
      smiscops = sblank

pstck_trans$     #Misc Ops. - Stock Xfer (NCI code = 900)
      #Available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_chuk_st_dz, stck_chuk_st_dx,
      #stck_chuk_end_dz, stck_chuk_end_dx
      is_miscops = gcode$
      if stck_spindle$ = 0, smiscops = stck_spindle0_0
      if stck_spindle$ = 1, smiscops = stck_spindle1_0
      pmiscops

pstck_flip$      #Misc Ops. - Stock Flip (NCI code = 901)
      #Available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x
      is_miscops = gcode$
      smiscops = "Flip Stock"
      pmiscops

pstck_bar_fd$    #Misc Ops. - Stock Advance (NCI code = 902)
      #Available variables:
      #stck_spindle, stck_op, stck_clear,
      #stck_grip, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_adv_fr, stck_appr_fr
      is_miscops = gcode$
      if stck_op$ = 0, smiscops = stck_op0
      if stck_op$ = 1, smiscops = stck_op1
      if stck_op$ = 2, smiscops = stck_op2
      #Build up the message string
      if stck_spindle$ = 0, smiscops = smiscops  + stck_spindle0_1
      if stck_spindle$ = 1, smiscops = smiscops  + stck_spindle1_1
      pmiscops

pchuck$          #Misc Ops. - Chuck (NCI code = 903)
      #Available variables:
      #clmp_spindle, clmp_op,  stck_chuk_st_z,
      #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
      is_miscops = gcode$
      if clmp_op$ = 0, smiscops = sclmp_op0
      if clmp_op$ = 1, smiscops = sclmp_op1
      if clmp_op$ = 2, smiscops = sclmp_op2
      if clmp_op$ = 3, smiscops = sclmp_op3
      #Build up the message string
      if clmp_spindle$ = 0, smiscops = smiscops + sclmp_spindle0
      if clmp_spindle$ = 1, smiscops = smiscops + sclmp_spindle1
      pmiscops

ptailstock$      #Misc Ops. - TailStock (NCI code = 904)
      #Available variables:
      #tlstck_on, stck_init_z, stck_final_z
      is_miscops = gcode$
      if tlstck_on$ = 0, smiscops = stlstck_on0
      if tlstck_on$ = 1, smiscops = stlstck_on1
      pmiscops

psteadyrest$     #Misc Ops. - SteadyRest (NCI code = 905)
      #Available variables:
      #stck_init_z, stck_final_z
      is_miscops = gcode$
      smiscops = "Position Steadyrest"
      pmiscops

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
ptimecalc        #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader$         #Call before start of file
      if pst_rpd_fr$ <= 0, pst_rpd_fr$ = 300  #Make it greater than ZERO !
      "CUSTOMIZABLE LATHE SETUP SHEET - LATHE.SET", e$
      sepline2, e$
      " ", e$  #Blank line
      "PROGRAM NAME   = ", *sprogname$, e$
      if progno$ > zero, "PROGRAM NUMBER = ", *progno$, e$
      #Date/Time output
      #"DATE PROCESSED = ", month$, "-", day$, "-", year$, e$   #Date output as month,day,year - Ex. 02-12-05
      "DATE PROCESSED = ", *smonth, " ", day$, " ", *year2, e$  #Date output as month,day,year - Ex. Feb. 12 2005
      #"DATE PROCESSED (DD-MM-YY) = ", date$, " TIME(HH:MM) = ", time$, e$  #Date and time output Ex. 12-02-05 15:52
      #"TIME           = ", time$, e$                           #24 hour time output - Ex. 15:52
      "TIME           = ", ptimecalc, e$                        #12 hour time output 3:52 PM
      pstock_info  #Stock information output

psof0$           #Start of file for tool zero
      psof$

psof$            #Start of file for non-zero tool number
      psetup   #Call for toolchange info output
      sof = 0  #Reset start of file flag
      !op_id$

ptlchg0$         #Call from NCI null tool change (tool number repeats)
      !gcode$
      if op_id$ <> prv_op_id$, ptlchg$
      !op_id$

ptlchg$          #Tool change - Output of time calculations for the last tool run
      #Calculate for the 'return to home' move at toolchange
      gcode$ = zero
      x$ = xh$, z$ = zh$
      prapid$
      ptooldata  #Total ending data for tool (Path Length and Times)
      psetup     #Call for toolchange info output
      !op_id$

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool - Output of time calculations for the last tool and total time
      #Calculate for the 'return to home' move at end of program
      gcode$ = zero
      x$ = xh$, z$ = zh$
      prapid$
      ptooldata  #Total ending data for tool (Path Length and Times)
      #Supress Program totals if only one tool or no output selected
      if tcnt > one & (xz_limits | show_lengths | time_est),
        [
        " ", e$  #Blank line
        sepline3, e$
        "PROGRAM TOTALS (", *tcnt, " TOOLS):", e$
        " ", e$ # Blank line

        #Output Max/Min X,Y,Z information
        if xz_limits = two | xz_limits = three,
          [
          preadbuf1e   #Read Buffer 1 (get X,Z extents of entire program)
          pMaxMin      #Output Max/Min X,Z coords for entire program
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Feed/Rapid path lengths
        if show_lengths = two | show_lengths = three,
          [
          "TOTAL FEED CUT LENGTH = ", *llen_total, e$
          "TOTAL RAPID TRAVERSE LENGTH = ", *rlen_total, e$
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Rapid/Feedrate times
        if time_est > 0 & (det_time = two | det_time = three),
          [
          ttltime = tot_rtime
          "TOTAL RAPID TIME = ", ptimeout, e$
          ttltime = tot_ltime
          "TOTAL FEED TIME = ", ptimeout, e$
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Cycle Time information
        if time_est = two | time_est = three,
          [
          ttltime = total                #Transfer TOTAL program time
          "CYCLE TIME:  ", ptimeout, e$  #Program Total time output
          ]
        ]

psetup           #Output of toolchange information
      !gcode$
      tcnt = tcnt + one  #Tool Counter
      absfr = abs(fr$)
      pspindle
      cssflag = zero
      if ss$ < zero, cssflag = one
      #" ", e$  #Blank line
      comment$
      if sof & outputxcom,  #If start of file and outputxcom = yes$
        [
        if smachname <> snull, "MACHINE NAME   = ", smachname, e$  #Machine name
        if sgrpcomm <> snull, "GROUP COMMENT  = ", sgrpcomm, e$    #Group comment
        if sgrpname <> snull, "GROUP NAME     = ", sgrpname, e$    #Group name
        " ", e$  #Blank Line
        ]
      sepline, e$  #Output the separator '----' line
      pop_desc  #Output operation description - op number (if output_op_number is enabled), operation type, and operation comment (if output_comments is enabled)
      "TOOL NAME = ", *strtool$, e$
      if show_tool_mfg & strlen(stl_mfg_com) > zero & stl_mfg_com <> " ",
        "TOOL DEF. (MANUFACTURER) = ", stl_mfg_com, e$
      "TOOL NUM. = ", *t$, e$
      "TOOL OFFSET = ", *tloffno$, e$
      "TOOL RADIUS = ", *tcr$, e$
      if ss$ = zero, "SPINDLE OFF", e$
      if ss$ < zero,
        [
        "SPINDLE = ", *speed, pspindleim, e$
        "MAX RPM = ", *maxss$, e$
        ]
      if ss$ > zero, "SPINDLE = ", *speed, " RPM", e$
      if fr$ = zero, "*ERROR* - THE FEEDRATE WAS SET TO ZERO", e$
      if fr$ > zero, "FEEDRATE = ", *absfr, pfrminim, e$
      if fr$ < zero, "FEEDRATE = ", *absfr, pfrrevim, e$
      if opcode$ <> 105,  #If NOT a canned cycle, output CDC setting
        [
        if ccomp$ = zero,  "CUTTER COMP. = OFF", e$
        if ccomp$ = two,   "CUTTER COMP. = LEFT", e$
        if ccomp$ = three, "CUTTER COMP. = RIGHT", e$
        ]
      llen = zero     #Reset counter for next tool
      rlen = zero     #Reset counter for next tool
      tltime = zero   #Reset counter for next tool
      trtime = zero   #Reset counter for next tool
      ttltime = zero  #Reset counter for next tool
      x$ = xh$, z$ = zh$
      !x$, !z$  #Update previous [prv_?] variables

pop_desc         #Operation description
      if tool_op$ < 200,
        [
        tool_op1 = tool_op$
        if tool_op1 >= zero & tool_op1 <= 70, [if is_miscops, sindent], "OPERATION ", [if output_op_number, "# ", *op_number, " "], "= ", *sopid_1, pdrillcyc, e$
        else, [if is_miscops, sindent], "OPERATION ", [if output_op_number, "# ", *op_number, " "], "= ", "Operation type is not listed in string selector", e$
        ]
      else,
        [
        tool_op1 = tool_op$ - 201
        if tool_op1 >= zero & tool_op1 <= 23, [if is_miscops, sindent], "OPERATION ", [if output_op_number, "# ", *op_number, " "], "= ", *sopid_2, e$
        else, [if is_miscops, sindent], "OPERATION ", [if output_op_number, "# ", *op_number, " "], "= ", "Operation type is not listed in string selector", e$
        ]
      if output_comments & sopcomment <> snull, [if is_miscops, sindent], "OPERATION COMMENT = " sopcomment, e$  #Operation comment
      sopcomment = snull

ptooldata        #Total ending data for tool (Path Length and Times)
      #Output Max/Min X,Y,Z information
      if xz_limits = one | xz_limits = three,
        [
        preadbuf1t   #Read the data from the Buffer 1
        pMaxMin      #Output Max/Min X,Z coords during this tool operation
        #sepline, e$  #Output the separator '----' line
        ]

      #Output Feed/Rapid path lengths
      if show_lengths = one | show_lengths = three,
        [
        "TOOL FEED CUT LENGTH = ", *llen, e$
        "TOOL RAPID TRAVERSE LENGTH = ", *rlen, e$
        #sepline, e$  #Output the separator '----' line
        ]
      llen_total = llen_total + llen  #Keep running total for Program
      rlen_total = rlen_total + rlen  #Keep running total for Program

      #Output Rapid/Feedrate times
      if time_est > 0 & (det_time = one | det_time = three),
        [
        ttltime = trtime
        "RAPID TIME = ", ptimeout, e$  #Time at RAPID RATE (for last tool)
        ttltime = tltime
        "FEED TIME  = ", ptimeout, e$  #Time at FEEDRATE (for last tool)
        #sepline, e$  #Output the separator '----' line
        ]

      pttltime  #Total tool times
      #Output Cycle Time information
      if time_est = one | time_est = three,
        [
        "OPERATION TIME = ", ptimeout, e$  #This operations time output
        #sepline, e$  #Output the separator '----' line
        ]

pthrminsec       #Convert minutes to hr/min/sec format
      thrs = int(ttltime / 60)
      tmin = int(ttltime - thrs * 60)
      tsec = (ttltime - thrs * 60 - tmin) * 60

pttltime         #Total tool times and total program time
      tot_ltime = tot_ltime + tltime      #Total FEED time
      tot_rtime = tot_rtime + trtime      #Total RAPID time
      ttltime = tltime + trtime           #Calc. current Tool Time
      total = ttltime + total + tlchgtime #Calc. total Program Time

ptimeout         #Output "times"
      pthrminsec  #Convert minutes to hr/min/sec format
      #Output 'HOURS'
      if thrs = one, *thrs, " HOUR, "
      if thrs > one, *thrs, " HOURS, "
      #Output 'MINUTES'
      if tmin = one, *tmin, " MINUTE, "
      if tmin > one, *tmin, " MINUTES, "
      #Output 'SECONDS'
      if tsec > zero, *tsec, " SECONDS"

ptimer           #Rapid time and length calc
      rlen = rlen + len            #Running total RAPID length
      trtime = rlen / pst_rpd_fr$  #Running total RAPID time

ptimel           #Feed time and length calc, RPM and IPM
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$              #Was already in IPM
      if absfr < tol, absfr = tol    #Make sure it is valid
      tltime = tltime + len / absfr  #Calc. total Feed time

ptimecs2_1a      #Feed time and length calc, CSS
      speed = abs(ss$)
      absfr = abs(fr$)
      if absfr < tol, absfr = tol         #Make sure it is valid
      if speed = zero, speed = min_speed  #Make sure it is valid
      if met_tool$ = zero, tltime = tltime + (cssarea * (one / (absfr * 12 * speed)))
      else, tltime = tltime + (cssarea * (one / (absfr * 1000 * speed)))

ptimecs2_1       #Feed time and length calc, CSS
      cssarea = pi$ * len * (abs(prv_x$) + abs(x$))
      ptimecs2_1a

ptimecs2_2a      #Feed time and length calc, CSS
      percent = abs(prv_x$ - maxss_x) / abs(dx)
      len1 = len * percent
      len2 = len * (one - percent)
      cssarea = pi$ * len1 * (abs(prv_x$) + abs(maxss_x))
      ptimecs2_1a
      speed = maxss$
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$               #Was already in IPM
      if absfr < tol, absfr = tol     #Make sure it is valid
      tltime = tltime + len2 / absfr  #Running total FEED time

ptimecs2_2       #Feed time and length calc, CSS
      if abs(prv_x$) = maxss_x, ptimecs1
      else, ptimecs2_2a

ptimecs2_3a      #Feed time and length calc, CSS
      percent = abs(prv_x$ - maxss_x) / abs(dx)
      len1 = len * percent
      len2 = len * (one - percent)
      speed = maxss$
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$               #Was already in IPM
      if absfr < tol, absfr = tol     #Make sure it is valid
      tltime = tltime + len1 / absfr  #Running total FEED time
      cssarea = pi$ * len2 * (abs(x$) + abs(maxss_x))
      ptimecs2_1a

ptimecs2_3       #Feed time and length calc, CSS
      if abs(prv_x$) = maxss_x, ptimecs2_1
      else, ptimecs2_3a

ptimecs2         #Feed time and length calc, CSS and dx
      if abs(x$) >  maxss_x & abs(prv_x$) >  maxss_x, ptimecs2_1
      if abs(x$) <  maxss_x & abs(prv_x$) >= maxss_x, ptimecs2_2
      if abs(x$) >  maxss_x & abs(prv_x$) <= maxss_x, ptimecs2_3
      if abs(x$) <= maxss_x & abs(prv_x$) <= maxss_x, ptimecs1

ptimecs1         #Feed time and length calc, CSS and no dx
      speed = abs(ss$)
      testx = abs(x$)
      pspindle2         #Spindle speed calculations for CSS
      pspindle3         #MAX/MIN spindle checking for CSS
      speed = strt_spd
      ptimel            #FEED time and length calc.

ptimecss         #Feed time and length calc, CSS
      if abs(dx) <= mtol$, ptimecs1  #No X axis motion
      else, ptimecs2                 #Yes, there was X axis motion

ptimelsw         #Feed time and length calc
      if cssflag = one, ptimecss     #Need to calc. for CSS
      else, ptimel                   #No, direct RPM is active

ptime            #Distance calculations
      tlrad$ = zero
      dx = x$ - prv_x$
      dz = z$ - prv_z$
      len = sqrt(dx^2 + dz^2)
      if gcode$ = zero, ptimer            #RAPID time and length calc
      if gcode$ = one, ptimelsw           #FEED  time and length calc
      if gcode$ = one, llen = llen + len  #Keep running total
      !x$, !z$  #Update previous [prv_?] variables

pMaxMin          #Output Max/Min X,Z coordinates
      max_Xpos = max_Xpos * dia_mult
      min_Xpos = min_Xpos * dia_mult
      if X_limits = yes$, "MAX_X = ", *max_Xpos, "  MIN_X = ", *min_Xpos, e$
      if Z_limits = yes$, "MAX_Z = ", *max_Zpos, "  MIN_Z = ", *min_Zpos, e$

pspindle3        #MAX/MIN spindle speed checking for CSS
      if strt_spd > maxss$, strt_spd = maxss$
      if strt_spd < min_speed, strt_spd = min_speed

pspindle2        #Spindle speed calculations for CSS
      if testx < 0.001, testx = 0.001
      if met_tool$ = zero, strt_spd = (12 * speed) / (pi$ * testx * two)  #Inch
      else, strt_spd = (1000 * speed) / (pi$ * testx * two)  #Metric

pspindle1        #Spindle speed calculations for CSS
      testx = abs(xr$)
      if opcode$ = 104, testx = abs(xr$)   #Threading
      if opcode$ = 105, testx = abs(tcr$)  #Drilling
      pspindle2  #Spindle speed calculations for CSS

pspindle         #Spindle speed calculations for RPM
      if maxss$ = zero, maxss$ = max_speed  #Use RPM limit from this post
      speed = abs(ss$)
      if ss$ < zero, pspindle1           #CSS is active
      if ss$ > zero, strt_spd = speed    #RPM is active
      pspindle3                          #MAX/MIN spindle checking for CSS
      if opcode$ = 104, ss$ = strt_spd  #Convert thread to RPM
      if opcode$ = 105, ss$ = strt_spd  #Convert drill to RPM
      speed = abs(ss$)
      if met_tool$ = zero, maxss_x = (12 * speed) / (pi$ * maxss$ * two)  #Inch
      else, maxss_x = (1000 * speed) / (pi$ * maxss$ * two)  #Metric

pspindleim       #Spindle speed inch / metric
      if met_tool$ = zero, " SFPM"
      else, " SMPM"

pfrminim         #Feed per MIN inch / metric
      if met_tool$ = zero, " IN/MIN"
      else, " MM/MIN"

pfrrevim         #Feed per REV inch / metric
      if met_tool$ = zero, " IN/REV"
      else, " MM/REV"

pstock_info      #Output stock information if requested
      if stock_info,
        [
        "MATERIAL TYPE  = "
        if stck_matl$ = "NONE" | stck_matl$ = "", "*NOT DEFINED*", e$  #No material type was selected
        else, stck_matl$, e$
        ]
      if stock_info & tlplnno$ = five, #ONLY if in SIDE plane (Top for Lathe)
        [
        #If any stock values are empty, disable don't output
        if stck_ht$ > 0 & stck_wdth$ > 0,
          [
          "STOCK LENGTH   = ", stck_ht$, e$
          "STOCK MAX DIA. = ", stck_wdth$, e$
          ]
        ]

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapid$          #Output to NC of linear movement - rapid
      ptime

plin$            #Output to NC of linear movement - feed
      ptime

pthread0$        #Threading override
      thdtype$ = zero     #Long cycle
      thdrapfr = fr$  #Capture rapid traverse rate
      fr$ = thdlead$  #This is the Feedrate (from 'thdlead')

pthrg32_1$       #1st threading first position (at clearance)
      gcode$ = zero
      fr$ = thdrapfr
      ptime

pthrg32_2$       #2nd threading position (at thread position)
      gcode$ = zero
      fr$ = thdrapfr
      ptime

pthrg32_3$       #3rd threading position (thread cut pass)
      gcode$ = one
      fr$ = thdlead$ * speed  #Need to pass IPM feedrate
      ptime

pthrg32_4$       #4th threading position (pull-off clearance move)
      gcode$ = zero
      fr$ = thdrapfr

# --------------------------------------------------------------------------
# Parameter read postblocks:
# --------------------------------------------------------------------------
pprep$           #Pre-process postblock
#Allows post instructions after the post is parsed but before the NC and NCI file are opened.
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE)
#BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      sub_level$ = 0     #Force subs off
      subout$ = 0        #Force output stream to NC file
      comm_filter$ = 0   #Allow output of all comments
      #sextnc$ = ".doc"  #Uncomment and change extension here to override
      #Force longhand drilling cycles for proper time estimate
      usecandrill$  = no$   #Use canned cycle for drill
      usecanpeck$   = no$   #Use canned cycle for Peck
      usecanchip$   = no$   #Use canned cycle for Chip Break
      usecantap$    = no$   #Use canned cycle for Tap
      usecanbore1$  = no$   #Use canned cycle for Bore1
      usecanbore2$  = no$   #Use canned cycle for Bore2
      usecanmisc1$  = no$   #Use canned cycle for Misc1
      usecanmisc2$  = no$   #Use canned cycle for Misc2
      lusecandrill$ = no$   #Use canned cycle for drill
      lusecanpeck$  = no$   #Use canned cycle for Peck
      lusecanchip$  = no$   #Use canned cycle for Chip Break
      lusecantap$   = no$   #Use canned cycle for Tap
      lusecanbore1$ = no$   #Use canned cycle for Bore1
      lusecanbore2$ = no$   #Use canned cycle for Bore2
      lusecanmisc1$ = no$   #Use canned cycle for Misc1
      lusecanmisc2$ = no$   #Use canned cycle for Misc2
      spaces$ = 0
      use_alt_eob$ = no$

pwrtt$           #Pre-read NCI file
      pwritbuf1  #Write MAX/MIN X,Z values to Buffer 1
      !op_id$

pparameter$      #Read operation parameters
      #rd_params is used to call pparameter postblock and read the parameters of the operation specified in rd_param_op_no
      #"pparameter", ~prmcode$, ~sparameter$, e$
      #Read tool definition data
      if prmcode$ = 20002, stl_mfg_com = sparameter$  #'manufacturer' data
      if prmcode$ = 15240, op_number = rparsngl(sparameter$, 1)

# --------------------------------------------------------------------------
# Buffer 1 definition (for Max/Min X,Z storage)
# --------------------------------------------------------------------------
rc1          : 2     #Buffer1 READ pointer (YES, '2' is correct for this case!)
wc1          : 1     #Buffer1 WRITE pointer
size1        : 0     #To hold 'size' of Buffer 1

b1_gcode     : 0     #Stored in Buffer #1
b1_tcode     : 0     #        "
b1_xmax      : 0     #        "
b1_xmin      : 0     #        "
b1_zmax      : 0     #        "
b1_zmin      : 0     #        "

fbuf 1 0 6 0 0       #Declare Buffer1 to hold Min/Max X,Z axis info.

# --------------------------------------------------------------------------
# Buffer 1  Read / Write Routines
# --------------------------------------------------------------------------
pinit            #Initialize the limit checking variables
      max_Xpos = m_c9k  #Initialize
      min_Xpos = c9k    #     "
      max_Zpos = m_c9k  #     "
      min_Zpos = c9k    #     "

plimits          #Check for NEW X,Z limits
      if b1_xmax > max_Xpos, max_Xpos = b1_xmax
      if b1_xmin < min_Xpos, min_Xpos = b1_xmin
      if b1_zmax > max_Zpos, max_Zpos = b1_zmax
      if b1_zmin < min_Zpos, min_Zpos = b1_zmin

pwritbuf1        #Write Buffer 1
      b1_gcode = gcode$
      if gcode$ = 1002 & op_id$ = prv_op_id$, b1_gcode = 1000
      if gcode$ = 1000 & op_id$ <> prv_op_id$, b1_gcode = 1002
      b1_tcode = t$
      b1_xmax  = x_max$
      b1_xmin  = x_min$
      b1_zmax  = z_max$
      b1_zmin  = z_min$
      b1_gcode = wbuf(one, wc1)  #Write the record

preadbuf1t       #Read Buffer 1 (at the toolchanges for X,Z limits)
      pinit                      #Initialize the limit checking variables
      b1_gcode = rbuf(one, rc1)  #Read a record from the Buffer
      plimits                    #Check for NEW limits

      #Loop thru possible NULL toolchanges
      while b1_gcode = 1000,  #Find the next NON-NULL toolchange
        [
        b1_gcode = rbuf(one, rc1)  #Read the next record from the Buffer
        plimits                    #Check for NEW limits
        ]

preadbuf1e       #Read Buffer 1 (at the END of Program for X,Z limits)
      pinit                    #Initialize the limit checking variables
      size1 = rbuf(one, zero)  #Get the size of the Buffer 1
      rc1 = two                #Reset read pointer (SKIP 1st record!)
      while rc1 <= size1,      #Loop thru entire program
        [
        b1_gcode = rbuf(one, rc1)  #Read a record from the Buffer
        plimits                    #Check for NEW limits
        ]

# --------------------------------------------------------------------------

