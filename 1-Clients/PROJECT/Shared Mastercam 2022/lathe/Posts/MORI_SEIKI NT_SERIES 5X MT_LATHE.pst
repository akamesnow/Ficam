[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V24.00 P4 E1 W24.00 T1648225312 M24.00 I0 O0
# Post Name           : Mori_Seiki NT_Series 5X MT_Lathe.pst
# Product             : Lathe
# Machine Name        : Mori Seiki NT Series Mill/Turn Lathe
# Control Name        : Mapps III
# Description         : Mori Seiki NT 5-Axis Lathe Post
# Mill/Turn           : Yes
# 4-axis/Axis subs.   : Yes
# 5-axis              : Yes
# Subprograms         : Yes
# Canned Cycles       : Yes
# Executable          : MP 16.0
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# Associated File List$
#
# MORI_SEIKI NT_SERIES 5X MT_LATHE.control-7
# MORI_SEIKI NT_SERIES 5X DUAL_TURRET MT_LATHE.LMD-7
# MORI_SEIKI NT_SERIES 5X DUAL_TURRET MT_LATHE MM.LMD-7
#
# Associated File List$
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# Programmers Note:
# CNC 06/01/06  -  Initial post update for X
# CNC 02/26/07  -  Modified pwcs
# CNC 08/05/08  -  X3 release - Removed check for write_ops
# CNC 03/03/09  -  Initial post update for Mastercam X4
# CNC 02/03/10  -  Initial post update for Mastercam X5
# CNC 10/13/10  -  Added fix for MP line break pattern
#               -  Added Flag for Misc Operation when its the first operation to Post
#               -  Added fix for P & Q  when using Sequence number in lathe canned cycles
# CNC 12/02/10  -  Added fix for acceleration clearance distance when threading on Sub-Spindle
# CNC 02/17/11  -  Added arctype$ initialization to correct helix and full arc output when using R or signed R
# CNC 05/20/11  -  Initial post update for Mastercam X6
# CNC 09/13/11  -  Force G19 tool plane with a vertical nool not using G68.1
# CNC 08/21/12  -  Added fix for pattern repeat output (G73)
# CNC 10/16/12  -  Initial post update for Mastercam X7
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
#######          MILL/TURN FUNCTIONS SUPPORTED BY THIS POST          #######
#
# This post supports Generic Fanuc code output for mill/turn lathes.
# It is designed to support the features of Mastercam X.
#
# The Following Misc. Integers are used:
#
# mi1 - Work coordinate system: (home_type)
#       -1 = Reference return / Tool offset positioning.
#       0 = G50 with the X and Z home positions.
#       1 = X and Z home positions.
#       2 = WCS of G54, G55.... based on Mastercam settings.
#
# mi2 - Absolute or Incremental positioning at top level
#       0 = absolute
#       1 = incremental
#
# mi3 = Select G28 or G30 reference point return:
#       0 = G28, 1 = G30, 2 = G30P2, 3 = G30P3 etc.
#
# mi4 = Canned conversion cycle type selection:
#       Mill-
#       Activates milling axis conversation canned cycles (G107 or G112).
#       1 or -1 activates the cycle, the path continues until next entry is
#       zero, sign switches (1 to -1) forces g113 at null toolchnge, the
#       cycle changes or the tool changes.
#
# mi5   Spindle (C-Axis) Clamp (Active for Milling and Mill/Drill)
#       0=Off,1=Clamp,2=Brake,3=Both
#       Clamp selector on/off based on modality, brake on/off for entire path
#
# mi6   Turret (B-Axis) Clamp (Active for Milling and Mill/Drill)
#       0=Off,1=Clamp,2=Brake,3=Both
#       Clamp selector on/off based on modality, brake on/off for entire path
#
# Misc. Reals:
#
# The Following Misc. Reals are used:
#
# Mr1 = synchronous drilling option:
#       Misc. Real one is the percentage of the spindle speed to apply to the
#       live tooling for Synchronous drilling.  To use this feature enter the
#       TOTAL speed required to obtain the proper cutting speed within the tool
#       parameters page, then enter what percentage of that speed should be
#       applied to the tool spindle.  i.e. Enter speed of 50 RPM in the parameter
#       page and 60.0 (or .60) in the Misc. Real #1 and you will get S20 for the
#       chuck and S30 for the live tool.
#
# Mr2 = G74 / G75 Backoff Value
#
#Canned text:
#  Entering cantext within Mastercam allows the following functions to
#  enable/disable.
#  cantext value:
#  1 = Stop =  output the "M00" stop code
#  2 = Ostop = output the "M01" optional stop code
#  3 = Bld on = turn on block delete codes in NC lines
#  4 = bLd off = turn off block delete codes in NC lines
#  5 = Ret. tlstk =  output the code to retract the tail stock
#  6 = Adv. tlstk =  output the code to advance the tail stock
#  7 = Ret. chute =  output the code to retract the chute
#  8 = Adv. chute =  output the code to advance the chute
#  9 = Exstp = turn on the exact stop code in the NC line
#  10 = Exstp = turn off the exact stop code in the NC line
#  11 to 99 output the value selected
#
#TURN TOOLPATHS:
#Lathe canned cycles:
# V8 supports lathe canned turning cycles through Mastercam.  This post
# is configured to process them.
#
#MILL TOOLPATHS:
#Mill Layout:
# The term "Reference View" refers to the coordinate system associated
# with the Mill Top view (Alt-F9, the upper gnomon of the three displayed).
# Create the part drawing with the the axis of rotation along the X axis
# of the "Mill Reference View" with the face of the part toward the side
# view (Mill Reference View X plus direction).  The Y plus axis of the
# Mill Reference View indicates the position on the part of C zero
# (View number 3).  The right or left side view are the only legal views
# for face milling.  The view number 3 rotated about the X axis as a
# "single axis rotation" are the only legal views for cross milling
# except for axis substitution where the top view is required.
# Rotation around the part is positive in the CCW direction when viewed
# from the side view.
# (The Chook 'CVIEW' should be used for creating milling tool plane and
# construction plane selections, C axis toolpaths in lathe perform
# this function automatically).
#NOTICE: View number 3 always indicates the location for C zero.  Milling
#        with a turret below the centerline indicates C at 180 degrees.
#
#Mill canned cycles:
#Cylindrical interpolation, G107 canned cycle:
# Cylindrical interpolation is created with axis substitution only.
# Use the Caxis/C_axis Contour toolpath.  Create the geometry from
# view number 4 if the rotation of C axis is CCW.  This prevents producing
# a mirror image.  Wrapped and unwrapped geometry are broken and arcs are
# lost so it is better to create flattened geometry.  Set the parameters
# in Rotary Axis not to 'unroll' and set the correct diameter.
# Use View number 3 as the C0 location.  Set mi4 to activate!
#
#Polar interpolation, G112 canned cycle:
# Polar interpolation is active only for face cutting (Right or Left).
# Use the Caxis/Face Contour toolpath.  Create geometry for the lead in
# and lead out with the start and end position on the View number 3 tool
# axis.  All paths must start and end at the 'C0'location for output to
# be correct.  Chain the entire geometry without using Mastercam leads.
# Set mi4 to activate!
#
#Axis substitution:
# View number 3 is the C zero location on the part and corresponds to the
# Y zero position of the "Mill Reference View".  Positions are wrapped
# from and to the diameter of the part as CCW for the Y positive direction.
# If geometry is drawn from View number 4 (Bottom), it is correct for the
# wrap/unwrap on the diameter.  The radius of the specified diameter is
# added to the Z position in the post.  The Y axis is the only axis to
# be converted with mill/turn.
#
#Simultaneous 4 and 5 Axis (11 gcode):
# Full 4 and 5 axis toolpaths can be generated from various toolpaths under
# the 'multi-axis' selection (i.e. Rotary 4 axis). All 5 axis paths are
# converted to 4 axis paths where only the angle about the rotation axis
# is resolved. Use View number 3 for the toolplane with all 'multi-axis'.
# 4 and 5 axis toolpaths are converted assuming cross machining only!
#
#Y axis output and machining over part center:
# Output Y axis motion by setting 'Rotary axis/Y axis' in the NC
# parameter page.  This requires a valid Axis Combination in your machine defintion.
# y_axis_mch is set from the axis combination.
# Set 'Rotary axis/Y axis' in a machine with no Y axis (y_axis_mch = 0)
# to force linear/circular position moves in the XZ plane (g18).
# This allows machining over the part center.
#Caution: The machining must stay in the XZ plane at a Y fixed value
# when y_axis_mch = zero because no C (other than the Tplane) or
# Y positions are output!!!  This occurs when selecting C_axis/Cross
# Contour without 'y_axis_mch'.  Use Mill toolpaths for cross profiling.
#
#NOTICE: Milling through the part center with a linear move requires the
#        geometry be broken at the centerline.  Milling through the part
#        center with an arc move in the G18 plane, no Y axis and on the
#        negative side of X, reverses only the arc direction and I sign.
#
#5-Axis positioning:
# View number 3 rotated about the X axis as a "single axis rotation" is the
# primary angle for C.  This view can also be rotated about the Y axis to
# create a 5-Axis toolplane for milling on B-Axis machines (see b_axis_mch).
# It is important to select valid toolplanes.  It's probably worth reiterating
# that TOP is only a valid toolplane with Y-Axis substitution where it is
# required. Rotation around the part in C is positive in the CCW direction
# when viewed from the side view.  The B-Axis direction and zero position can
# be configured via the following two switches: 'ccw_b_pos' and 'bzer_vert'.
#
# It is extremely important to follow these guidelines when selecting toolplanes
# Especially when using IJK arc output or pivot point calculations when the
# 'use_g68' option has been turned off!
#
#Additional Notes:
# 1) G54 calls are generated where the work offset entry of 0 = G54,
#    1 = G55, etc.
# 2) Metric is applied from the NCI met_tool variable.
# 3) The Tplane angle is added to polar conversion and rotary paths.
# 4) The variable 'absinc' is now pre-defined, set mi2 (Misc. Integer) for
#    the 'top level' absolute/incremental program output.  Subprograms are
#    updated through the Mastercam dialog settings for sub-programs.
# 5) Lathe disables coordinate mirror and rotate subprograms.
# 6) When creating tools the diameter/radius should end as even numbers
#    relative to the machine precision. EX. Enter 1.0002 dia. and not
#    1.0001 dia. with a machine accuracy of .0001.
# 7) Transform subprograms are intended for use with G54... workshifts.
# 8) Incremental motion at a toolchange is calculated from the values
#    entered for home position.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and program switches
# --------------------------------------------------------------------------
m_one        := -1   #Define constant
zero         := 0    #Define constant
one          := 1    #Define constant
two          := 2    #Define constant
three        := 3    #Define constant
four         := 4    #Define constant
five         := 5    #Define constant
six          := 6    #Define constant
seven        := 7    #Define constant
eight        := 8    #Define constant
nine         := 9    #Define constant
ten          := 10   #Define constant

arc45        := 45   #Define constant
arc90        := 90   #Define constant
arc180       := 180  #Define constant
arc360       := 360  #Define constant

c9k          := 9999 #Define constant

bug4$        : 1     #Debug output with the tilde '~'.
                     #A value greater the zero applies the variable formatting with
                     #debug output (default is typically FS 1 but not a guarantee).
                     #A value of zero gets the value directly with NO formatting.

linktolvar$  : 1     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 1     #Associate X plane specific variables to V9- variable?
linklvar$    : 1     #Associate X lathe specific variables to V9- variable?

get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
tlchng_aft$  : 2     #Delay call to toolchange until move line
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
cc_1013$     : 1     #Read cc_pos on the 1013 line, lathe
miscopsflag  : 0     #Flag for Misc Operation when its the first operation to Post

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
# The following initialization is used for full arc and helix arc output when the CD
#   is set to output R or signed R for arcs
arctype$     : 2     #Arc center type XY plane 1=abs, 2=St-Ctr, 3=Ctr-St, 4=unsigned inc.

sub_level$   : 1     #Enable automatic subprogram support
breakarcs$   : 1     #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arcoutput$   : 3     #0 = IJK, 1 = R no sign, 2 = R signed neg. over 180, 3 = IJK over 180
iout_dia     : no$   #Output I value using Diameter Multiplier (yes,no)
do_full_arc$ : 0     #Allow full circle output? 0=no, 1=yes
helix_arc$   : 1     #Support helix arc output, 0=no, 1=all planes, 2=XY plane only
arccheck$    : 1     #Convert small arcs to linear, 1=ltol, 2=atol,ltol
atol$        : 0.01  #Angularity tolerance for arccheck = 2
ltol$        : 0.002 #Length tolerance for arccheck = 1
vtol$        : 0.0001#System tolerance
maxfeedpm    : 1500  #Limit for feed in inch/min
maxfrinv     : 999.99#Min for feed inverse time
minfrinv     : 0.99  #Limit for feed inverse time
lcc_move     : 0.05  #Enter the move in X, Z for lathe canned cycle comp.
ltol_m       : 0.05  #Length tolerance for arccheck = 1, metric
vtol_m       : 0.0005#System tolerance, metric
maxfeedpm_m  : 10000 #Limit for feed in mm/min
lcc_move_m   : 1.25  #Enter the move in X, Z for lathe canned cycle comp.,mm

spaces$      : 1     #No. of spaces to add between fields
omitseq$     : yes$  #Omit sequence no. (use -1 to enable sequence for LCC)
seq_at_tc    : yes$  #Force sequence no. at toolchange (forces omitseq : 1)
start_at_ref : yes$  #Force move to ref return prior to initial position
end_w_g53    : no$   #Yes = G53X0Z0, No = G28U0W0 (based in mi3)
seqmax$      : 9999  #Max. sequence no.
nobrk$       : no$   #Omit breakup of x, y & z rapid moves
progname$    : 1     #Use uppercase for program name
rotaxtyp$    : 3     #Rotary axis type for toolplane
tooltable$   : 3     #Read for tool table and pwrtt (3 recalls pwrtt at sof)
list_tools   : 0     #0=Output tool comment at each tool change
                     #1=Output tool list at top of program
                     #2=Output both top of program AND at each toolchange
ref_ret      : 0     #G29 / G30 return variable from Mi3
css_start_rpm : no$  #Do direct RPM spindle start prior to CSS ?
force_wcs    : yes$  #Force WCS output at every toolchange?
use_frst_wcs : no$   #Use only the first WCS read and ignore all others in NCI
max_axe_B : 180
min_axe_B : -180


sextsub$ : "P2"

# --------------------------------------------------------------------------
# Machine Specific Settings
# --------------------------------------------------------------------------
#Machine axis switches, initial
y_axis_mch   : no$   #SET_BY_MD - Machine has a Y axis, 0=no, 1=yes - Set based on Axis Combination in MD
b_axis_mch   : yes$  #Machine has B axis, 0=no, 1=yes
sub_sp_mch   : yes$  #Machine has sub spindle, 0=no, 1=yes
dual_turret  : yes$  #SET_BY_MD - Single turret machine = 0, Dual turret machine = 1 - Set by number of turrets in MD

old_new_sw   : 1     #Switch old (6T), new (0T+) cycle formats, 0=old, 1=new
wcs_origin   : 0     #Always use the WCS origin for coordinates
dia_mult     : 2     #Multiplier for output on X axis (Neg. switches sign of X)
g68_dia_mult : 2     #Multiplier for output on X axis WHILE IN G68.1 MODE (Neg. switches sign of X)
y_mult       : 1     #Multiplier for output on Y axis (Neg. switches sign of Y)
z_mult       : 1     #Multiplier for output on Z axis (Neg. switches sign of Z)
dia_shift    : 0     #Shift for output on X axis, radial entry
y_shift      : 0     #Shift for output on Y axis
z_shift      : 0     #Shift for output on Z axis
map_home     : yes$  #Use home positions as entered or map to machine axis
tlchg_crlf   : no$   #Insert blank line between toolchanges

#Feed control settings
convert_rpd$ : 0     #Convert rapid to rapid feed

#Feedrate Options
use_fr       : 4     #Output feedrate
                     #0 - programmed feedrate
                     #1 - inverse feedrate
                     #2 - inverse feedrate on 5 axis continuous
                     #3 - inverse feedrate on motion with rotary
                     #4 - fr/deg on motion with rotary

#Tool length compensation for milling
use_g68      : 1     #Use G68 option for B-Axis operations (see 'b_axis_mch')
                     #0=Pivot Point, 1= All except B0 B90 & B-90, 2=All Milling
use_tcmacro  : 1     #Use Tool Change Macro to simplify toolchange (see stcmacro string definition)
use_tlength  : 0     #Use tool length, read from tool overall length or...
                     #0=Use 'toollength' var, 1=Mastercam OAL, 2=Prompt (not used with G68 option)
use_g43      : 2     #0=None,1=Mill Only,2=Both Milling and Turning operations
str_g43      : "G43" #String definition for G43 (use "G343" for tool life management function)
g43_b_out    : no$   #Output B Value with G43 i.e. G43Hn.Bn.
g41_d_out    : no$   #Output D word for with G41 offset
add_gage     : 0     #Add Gage length to toollength for pivot point calculations
toollength   : 0     #Tool length if not read from overall length
use_rigid_tap : 1    #Enable Rigid Tapping 0=No, 1=Mill Only, 2=Lathe Only, 3=Both M/L
gagelength   : 7.123 #Machine Constant for pivot point calculations (see 'add_gage_len')
chuck_appr_dist : 1  #Offset distance from final to approach for part xfer operation
chuck_feed_dist : 0.1#Offset distance from final to feed distance for part xfer operation
chuck_appr_feed : 2  #Feedrate for approach and workpiece detect pushing
chuck_appr_dist_inch : 1.5 #Offset distance from final to approach for part xfer operation (inch)
chuck_feed_dist_inch : 0.2 #Offset distance from final to feed distance for part xfer operation (inch)
chuck_appr_feed_inch : 2.  #Feedrate for approach and workpiece detect pushing (inch)
rap_to_refht : no$   #Add Rapid Move to R-Plane prior to first hole in Mill Canned drilling

# --------------------------------------------------------------------------
# Enable Canned Drill Cycle Postblocks, set for mill and lathe
# --------------------------------------------------------------------------
pcuttypldrl   #Change cut parameters for lathe drill
      usecandrill$ = 0
      usecanpeck$  = 0
      usecanchip$  = 0
      usecantap$   = 1
      usecanbore1$ = 0
      usecanbore2$ = 0
      usecanmisc1$ = 0
      usecanmisc2$ = 0

pcuttypmdrl   #Change cut parameters for mill drill
      usecandrill$ = 1
      usecanpeck$  = 1
      usecanchip$  = 1
      usecantap$   = 1
      usecanbore1$ = 1
      usecanbore2$ = 1
      usecanmisc1$ = 1
      usecanmisc2$ = 1

#C axis and Index switches
str_cax_abs  : "C"   #String address for absolute primary rotary axis
str_cax_inc  : "H"   #String address for incremental primary rotary axis
str_cindex   : "C"   #String address for C-Axis indexer
str_bax_abs  : "B"   #String address for absolute secondary rotary axis
str_bax_inc  : "B"   #String address for incremental secondary rotary axis
str_bindex   : "B"   #String address for B-Axis indexer

frc_cinit    : 1     #Force C axis reset at toolchange (0=No,1=Yes)
frc_binit    : 2     #Force B axis reset at toolchange (0=No,1=Zero,2=b_tc_posn)
b_tc_posn    : -90   #B-Axis toolchange Position
c_shift      : 0     #Shift for output on bottom turrets with C axis
b_shift      : 0     #Shift for output on bottom turrets with B axis
ctol         : 270   #Tolerance in deg. of inc. move before 'rev' flag changes
btol         : 270   #Tolerance in deg. of inc. move before 'rev' flag changes
ctable       : 5     #Degrees for each index step with indexing spindle
btable       : 5     #Degrees for each index step with indexing spindle
cixtol       : 0.01  #Tolerance in deg. for index error
bixtol       : 0.01  #Tolerance in deg. for index error
maxfrdeg     : 2000  #Limit for feed in deg/min
frdegstp     : 10    #Step limit for rotary feed in deg/min
bzero_vert   : 1     #0=B90 Vert, 1=B0 Vert
ccw_b_pos    : 1     #B-Axis CCW positive 1=Yes,-1=No (DO NOT USE ZERO)
ccw_c_pos    : 1     #C-Axis CCW positive 1=Yes,-1=No (DO NOT USE ZERO)
ccw_c_pos_sub : 1    #Sub Spindle C-Axis CCW positive 1=Yes,-1=No (DO NOT USE ZERO)
sync         : 100   #Forced Sync Code for dual turret serial processing (M100 - M199)

#Spindle switches and values
use_gear     : 0     #Output gear selection code, 0=no, 1=yes
cool_w_spd   : 0     #Output coolant with spindle code,
                     #0=Use Coolant Selector, 1=Use Spindle Selector, 2= Use Both
max_speedl0  : 3600  #Maximum spindle speed (lathe), Bottom turret/Left spindle
min_speedl0  : 20    #Minimum spindle speed
max_speedm0  : 2500  #Maximum spindle speed (mill)
min_speedm0  : 50    #Minimum spindle speed
max_speedl1  : 3600  #Maximum spindle speed (lathe), Top turret/Left spindle
min_speedl1  : 20    #Minimum spindle speed
max_speedm1  : 2500  #Maximum spindle speed (mill)
min_speedm1  : 50    #Minimum spindle speed
max_speedl2  : 3600  #Maximum spindle speed (lathe), Bottom turret/Right spindle
min_speedl2  : 20    #Minimum spindle speed
max_speedm2  : 2500  #Maximum spindle speed (mill)
min_speedm2  : 50    #Minimum spindle speed
max_speedl3  : 3600  #Maximum spindle speed (lathe), Top turret/Right spindle
min_speedl3  : 20    #Minimum spindle speed
max_speedm3 : 12000  #Maximum spindle speed (mill)
min_speedm3  : 50    #Minimum switchesspindle speed

#Machining position turret/spindle settings
# Switch strings based on turret position top/bottom-left/right and cut type.
# Turret position is based on the Mastercam settings (see lathtype).
# Strings are re-assigned for output in the routine psw_str_mult.
# The string variable sw_string holds the place position value to determine
# how to assign the strings.  Planes are relative to the view from Mastercam.
# Assign the 17 digit string following the alpha columns below:
# A - C axis, 1 = axis winds, 2 = axis signed, 3 = indexer
# B - B axis, 1 = axis winds, 2 = axis signed, 3 = indexer
# C - Spindle direction, 0 = normal, 1 = reverse
# D - Plane 0 arc/comp, 0 = normal, 1 = switch
# E - Plane 1 arc/comp, 0 = normal, 1 = switch
# F - Plane 2 arc/comp, 0 = normal, 1 = switch
# G - Plane 0, 0 = G17, 1 = G19, 2 = G18
# H - Plane 1, 0 = G17, 1 = G19, 2 = G18
# I - Plane 2, 0 = G17, 1 = G19, 2 = G18
# Decimal (required)
# J - Plane 0, X axis, 0 = normal, 1 = switch sign from basic
# K - Plane 0, Y axis, 0 = normal, 1 = switch sign from basic
# L - Plane 0, Z axis, 0 = normal, 1 = switch sign from basic
# M - Plane 1, X axis, 0 = normal, 1 = switch sign from basic
# N - Plane 1, Y axis, 0 = normal, 1 = switch sign from basic
# O - Plane 1, Z axis, 0 = normal, 1 = switch sign from basic
# P - Plane 2, X axis, 0 = normal, 1 = switch sign from basic
# Q - Plane 2, Y axis, 0 = normal, 1 = switch sign from basic
# R - Plane 2, Z axis, 0 = normal, 1 = switch sign from basic
use_only_tl  : 0     #Use only Top turret/Left spindle settings (below) for
                    #all Mastercam turret/spindle selections
                    #When configuring for multi-spindle/turret set to 0

#Columns-       ABCDEFGHI.JKLMNOPQR   #Top turret/Left spindle
scase_tl_c1  : "110000222.000000000"  #Turning cut
scase_tl_c2  : "110000012.000000000"  #Right Face cut
scase_tl_c_2 : "110110012.000000000"  #Left Face cut
scase_tl_c3  : "110010102.000000000"  #Cross cut w/g68
scase_tl_c3p : "110010102.000000000"  #Cross cut pivot point
scase_tl_c4c : "110110111.000000000"  #Y axis subs. Cycle
scase_tl_c4  : "110110222.000000000"  #Y axis subs.
scase_tl_c5  : "110000012.000000000"  #Multisurf Rotary w/g68
scase_tl_c5p : "110000222.000000000"  #Multisurf Rotary pivot point
scase_tl_c6  : "110000012.000000000"  #B-Axis Positioning w/g68
scase_tl_c6p : "110000222.000000000"  #B-Axis Positioning pivot point

#Columns-    ABCDEFGHI.JKLMNOPQR      #Bottom turret/Left spindle
scase_bl_c1  : "110001222.100100100"  #Turning cut
scase_bl_c2  : "110000012.000000000"  #Right Face cut
scase_bl_c_2 : "110110012.000000000"  #Left Face cut
scase_bl_c3  : "110010102.000000000"  #Cross cut w/g68
scase_bl_c3p : "110010102.000000000"  #Cross cut pivot point
scase_bl_c4c : "110110111.000000000"  #Y axis subs. Cycle
scase_bl_c4  : "110110222.000000000"  #Y axis subs.
scase_bl_c5  : "110000012.000000000"  #Multisurf Rotary w/g68
scase_bl_c5p : "110000222.000000000"  #Multisurf Rotary pivot point
scase_bl_c6  : "110000012.000000000"  #B-Axis Positioning w/g68
scase_bl_c6p : "110000222.000000000"  #B-Axis Positioning pivot point

#Columns-    ABCDEFGHI.JKLMNOPQR      #Top turret/Right spindle
scase_tr_c1  : "110000222.000000000"  #Turning cut
scase_tr_c2  : "110000012.000000000"  #Right Face cut
scase_tr_c_2 : "110110012.000000000"  #Left Face cut
scase_tr_c3  : "110010102.100100100"  #Cross cut w/g68
scase_tr_c3p : "110010102.000000000"  #Cross cut pivot point
scase_tr_c4c : "110110112.000000000"  #Y axis subs. Cycle
scase_tr_c4  : "110110112.000000000"  #Y axis subs.
scase_tr_c5  : "110000012.000000000"  #Multisurf Rotary w/g68
scase_tr_c5p : "110000222.000000000"  #Multisurf Rotary pivot point
scase_tr_c6  : "110000012.000000000"  #B-Axis Positioning w/g68
scase_tr_c6p : "110000222.000000000"  #B-Axis Positioning pivot point

#Columns-    ABCDEFGHI.JKLMNOPQR      #Bottom turret/Right spindle
scase_br_c1  : "110001222.100100100"  #Turning cut
scase_br_c2  : "110000012.000000000"  #Right Face cut
scase_br_c_2 : "110110012.000000000"  #Left Face cut
scase_br_c3  : "110010102.000000000"  #Cross cut w/g68
scase_br_c3p : "110010102.000000000"  #Cross cut pivot point
scase_br_c4c : "110110112.000000000"  #Y axis subs. Cycle
scase_br_c4  : "110110112.000000000"  #Y axis subs.
scase_br_c5  : "110000012.000000000"  #Multisurf Rotary w/g68
scase_br_c5p : "110000222.000000000"  #Multisurf Rotary pivot point
scase_br_c6  : "110000012.000000000"  #B-Axis Positioning w/g68
scase_br_c6p : "110000222.000000000"  #B-Axis Positioning pivot point

# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
stra         : "A"   #String for address A
strb         : "B"   #String for address B
strc         : "C"   #String for address C
strd         : "D"   #String for address D
stre         : "E"   #String for address E
strf         : "F"   #String for address F
stri         : "I"   #String for address I
strj         : "J"   #String for address J
strk         : "K"   #String for address K
strm         : "M"   #String for address M
stro         : "O"   #String for address O
strp         : "P"   #String for address P
strq         : "Q"   #String for address Q
strr         : "R"   #String for address R
stru         : "U"   #String for address U
strv         : "V"   #String for address V
strw         : "W"   #String for address W
stry         : "Y"   #String for address Y
srad         : "R"   #String for address R (radius)

sb_minus     : "B-"  #Manipulated string for signed rotary minus
sc_minus     : "C-"  #Manipulated string for signed rotary minus
srminus      : "R-"  #String for address R- (minus radius)

#Tool note
stoper       : ""    #String for tool notes
stinsert     : " INSERT - "#String for tool notes
stinsert2    : ""    #String for tool notes

#String to capture rapid feedrate
sq38         : ""

#String definitions
sg50         : "G50"   #String for spindle clamp and work coordinate
sg68on       : "G68.1" #String for 3D Coordinate Conversion
sg68off      : "G69.1" #String for 3D Coordinate Conversion Cancel
sm_rigid     : "M329"  #String for rigid tap

#Cantext string definitions (spaces must be padded here)
sm00         : "M00" #String for stop
sm01         : "M01" #String for optional stop
strtextno    : ""    #String for cantext
strcantext   : ""    #String for cantext

sblank       : ""    #Empty string
sw_string    : ""    #String for lathe turret type settings

# --------------------------------------------------------------------------
# User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
axis_label    : 0   #Axis label - 1=X,2=Y,3=Z
turret_id_no  : 0   #Each turret has a unique id number
mch_comp_idno : 0   #Machine Component Unique ID number
mch_comp_type : 0   #Machine Component type

# --------------------------------------------------------------------------
# Error message strings
# --------------------------------------------------------------------------
saxiserror   : "ERROR-WRONG AXIS OF ROTATION, ROTATE ON X AXIS OF WCS"
sc_idxerror  : "WARNING-INDEX ANGLE DOES NOT MATCH POST SETTING ('ctable')"
sb_idxerror  : "WARNING-INDEX ANGLE DOES NOT MATCH POST SETTING ('btable')"
ssignerror   : "WARNING-SIGNED AXIS POSITIONING MOVE OVER 360 DEGREES"
swrkserror   : "WARNING-WORK OFFSET IS CHANGED IN A SUBPROGRAM"
stoperror    : "ERROR-AXIS SUBSTITUTION MUST USE THE TOP TOOLPLANE"
scutterror   : "ERROR-A VALID CUT TYPE WAS NOT FOUND, CHECK ROTARY SETTINGS"
sfccerror    : "ERROR-MATCHING G70 FINISH PROFILE WAS NOT FOUND"
s5drlerror   : "ERROR-5 AXIS DRILLING REQUIRES LONG CYCLE ('usecan..')"
slthrmerror  : "ERROR-ROTATE/MIRROR SUBPROGRAM NOT ALLOWED WITH LATHE PATH"
smilrmerror  : "ERROR-ROTATE/MIRROR PROGRAM ROUTINE NOT ALLOWED"
smny50error  : "ERROR-G50 AND HOME ('mi1') DOES NOT SUPPORT MULTIPLE TOOL SUBPROGRAM"
shomeserror  : "ERROR-HOME ('mi1') DOES NOT SUPPORT TRANSFORM SUBPROGRAM"
symoterror   : "WARNING-Y AXIS MOTION AND ('y_axis_mch') NOT SET"
sbmoterror   : "WARNING-B AXIS MOTION AND ('b_axis_mch') NOT SET"

# --------------------------------------------------------------------------
# General G and M Code String select tables
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg02   : "G2"       #Circular interpolation CW
sxg03   : "G3"       #Circular interpolation CCW
# --------------------------------------------------------------------------
# Motion G code selection, plane 0
sg00    : "G0"       #Rapid
sg01    : "G1"       #Linear feed
sg02    : "G2"       #Circular interpolation CW
sg03    : "G3"       #Circular interpolation CCW
sg04    : "G4"       #Dwell
sgcode  : ""         #Target string

fstrsel sg00 gcode$ sgcode 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 1
sg00_1  : "G0"       #Rapid
sg01_1  : "G1"       #Linear feed
sg02_1  : "G2"       #Circular interpolation CW
sg03_1  : "G3"       #Circular interpolation CCW
sg04_1  : "G4"       #Dwell
sgcode1 : ""         #Target string

fstrsel sg00_1 gcode$ sgcode1 5 -1
# --------------------------------------------------------------------------
# Motion G code selection, plane 2
sg00_2  : "G0"       #Rapid
sg01_2  : "G1"       #Linear feed
sg02_2  : "G2"       #Circular interpolation CW
sg03_2  : "G3"       #Circular interpolation CCW
sg04_2  : "G4"       #Dwell
sgcode2 : ""         #Target string

fstrsel sg00_2 gcode$ sgcode2 5 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg17   : "G17"      #XY plane code
sxg19   : "G19"      #YZ plane code
sxg18   : "G18"      #XZ plane code
swstr   : ""         #Target string

#fstrsel sxg17 plane2 swstr
fstrsel sxg17 rslt_plc swstr 3 -1
# --------------------------------------------------------------------------
# Select work plane G code
sg17    : "G17"      #XY plane code
sg19    : "G19"      #YZ plane code
sg18    : "G18"      #XZ plane code
sgplane : ""         #Target string

fstrsel sg17 plane$ sgplane 3 -1
# --------------------------------------------------------------------------
#Select english/metric code
sg20    : "G20"      #Inch code
sg21    : "G21"      #Metric code
smetric : ""         #Target string

fstrsel sg20 met_tool$ smetric 2 -1
# --------------------------------------------------------------------------
#Select reference return code
sg28    : "G28"      #First reference point return
sg30    : "G30"      #Second reference point return
sg28ref : ""         #Target string

fstrsel sg28 ref_ret sg28ref 2 -1
# --------------------------------------------------------------------------
# Strings for switch based on planes, see psw_str_mult
sxg41   : "G41"      #Cutter compensation left
sxg42   : "G42"      #Cutter compensation right
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 0
sg40    : "G40"      #Cancel cutter compensation
sg41    : "G41"      #Cutter compensation left
sg42    : "G42"      #Cutter compensation right
sccomp  : ""         #Target string

fstrsel sg40 cc_pos$ sccomp 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 1
sg40_1  : "G40"      #Cancel cutter compensation
sg41_1  : "G41"      #Cutter compensation left
sg42_1  : "G42"      #Cutter compensation right
sccomp1 : ""         #Target string

fstrsel sg40_1 cc_pos$ sccomp1 3 -1
# --------------------------------------------------------------------------
# Cutter compensation G code selection, plane 2
sg40_2  : "G40"      #Cancel cutter compensation
sg41_2  : "G41"      #Cutter compensation left
sg42_2  : "G42"      #Cutter compensation right
sccomp2 : ""         #Target string

fstrsel sg40_2 cc_pos$ sccomp2 3 -1
# --------------------------------------------------------------------------
# Select canned cycle type, profile is direction of finish profile vector
sthdg32 : "G32"      #Cycle type G32
sthdg76 : "G76"      #Cycle type G76
sthdg92 : "G92"      #Cycle type G92
sthdg33 : "G32"      #Cycle type G32 with alternating position
sthdgcode : ""       #Target string

fstrsel sthdg32 thdtype$ sthdgcode 4 -1
# --------------------------------------------------------------------------
# Select canned cycle type
sg70    : "G70"      #Cycle type G70
sg71    : "G71"      #Cycle type G71
sg72    : "G72"      #Cycle type G72
sg73    : "G73"      #Cycle type G73
sg74    : "G74"      #Cycle type G74
sg75    : "G75"      #Cycle type G75
scclgcode : ""       #Target string

fstrsel sg70 gcodecc scclgcode 6 -1
# --------------------------------------------------------------------------
# Canned drill cycle string select
sg80_f  : "G83"      #drill face
sg80_fd : "G83"      #drill face w/dwell
sg81_f  : "G83.6"    #peck face
sg81_fd : "G83.6"    #peck face w/dwell
sg82_f  : "G83"      #chpbrk face
sg82_fd : "G83"      #chpbrk face w/dwell
sg83_f  : "G84"      #Rigid tap right face
sg83_fd : "G84"      #Rigid tap left face
sg84_f  : "G85"      #bore1 face
sg84_fd : "G85"      #bore1 face w/dwell
sg85_f  : "G85"      #bore2 face
sg85_fd : "G85"      #bore2 face w/dwell
sg86_f  : "G84"      #Tap face
sg86_fd : "G84"      #Tap face w/dwell
sg87_f  : "G85"      #misc2 face
sg87_fd : "G85"      #misc2 face w/dwell
sgdrillf : ""        #Target string

fstrsel sg80_f drlgsel sgdrillf 16 -1
# --------------------------------------------------------------------------
sg80_c  : "G87"      #drill cross
sg80_cd : "G87"      #drill cross w/dwell
sg81_c  : "G87.5"    #HIGH SPEED PECK cross
sg81_cd : "G87.5"    #HIGH SPEED PECK cross w/dwell
sg82_c  : "G87.6"      #chpbrk cross
sg82_cd : "G87.6"      #chpbrk cross w/dwell
sg83_c  : "G88"      #tap right cross
sg83_cd : "G88"      #tap left cross
sg84_c  : "G89"      #bore1 cross
sg84_cd : "G89"      #bore1 cross w/dwell
sg85_c  : "G89"      #bore2 cross
sg85_cd : "G89"      #bore2 cross w/dwell
sg86_c  : "G461"      #side c-axis drill
sg86_cd : "G461"      #side c-axis drill w/dwell
sg87_c  : "G87.6"    #PECK cross
sg87_cd : "G87.6"    #PECK cross w/dwell
sgdrillc : ""        #Target string

fstrsel sg80_c drlgsel sgdrillc 16 -1
# --------------------------------------------------------------------------
# Select incremental or absolute G code
sg90    : "G90"      #Absolute code
sg91    : "G91"      #Incremental code
sgabsinc : ""        #Target string

fstrsel sg90 absinc$ sgabsinc 2 -1
# --------------------------------------------------------------------------
# RPM/CSS code selection
sg97    : "G97"      #RPM
sg96    : "G96"      #CSS
sg9697  : ""         #Target string

fstrsel sg97 css_actv$ sg9697 2 -1
# --------------------------------------------------------------------------
# Feed mode G code selection
sgupm_l : "G98"      #UPM (Turning)
sgupr_l : "G99"      #UPR (Turning)
sgupm_m : "G98"      #UPM (Milling)
sgdpm_m : "G98"      #DPM (Milling)
sgivt_m : "G93"      #1/T (Milling)
sgfeed  : ""         #Target string

fstrsel sgupm_l fr_sel sgfeed 5 -1
# --------------------------------------------------------------------------
# C axis cycles
sg107   : "G07.1(G107)"     #C axis cylindrical interpolation enable
sg108   : "G07.1(G107)"     #C axis cylindrical interpolation disable
sg112   : "G12.1(G112)"     #C axis face polar interpolation enable
sg113   : "G13.1(G113)"     #C axis face polar interpolation disable
# --------------------------------------------------------------------------
#Canned drill cycle reference height
sg198   : ""         #G198   #Reference at initht
sg199   : ""         #G199  #Reference at refht
sgdrlref : ""        #Target string

fstrsel sg198 drillref sgdrlref 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe (main spindle)
sm04m   : "M04"      #Spindle reverse - no coolant
sm05m   : "M05"      #Spindle off     - no coolant
sm03m   : "M03"      #Spindle forward - no coolant
sm14m   : "M04"      #Spindle reverse - coolant
sm05cm  : "M05"      #Spindle off     - coolant
sm13m   : "M03"      #Spindle forward - coolant
spindle_lm : ""      #Target string

fstrsel sm04m g_spdir spindle_lm 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, lathe (sub-spindle)
sm04s   : "M204"     #Spindle reverse - no coolant
sm05s   : "M05"      #Spindle off     - no coolant
sm03s   : "M203"     #Spindle forward - no coolant
sm14s   : "M204"     #Spindle reverse - coolant
sm05cs  : "M05"      #Spindle off     - coolant
sm13s   : "M203"     #Spindle forward - coolant
spindle_ls : ""      #Target string

fstrsel sm04s g_spdir spindle_ls 6 -1
# --------------------------------------------------------------------------
# Coolant M code selection
               #OFF
sbtlsm_none_0 : ""   #"Bottom turret/Left spindle Mill off  0"
sbtlsm_none_1 : ""   #"Bottom turret/Left spindle Mill on   1"
sbtlst_none_0 : ""   #"Bottom turret/Left spindle Turn off  2"
sbtlst_none_1 : ""   #"Bottom turret/Left spindle Turn  on  3"
sttlsm_none_0 : ""   #"Top turret/Left spindle Mill off     4"
sttlsm_none_1 : ""   #"Top turret/Left spindle Mill  on     5"
sttlst_none_0 : ""   #"Top turret/Left spindle Turn off     6"
sttlst_none_1 : ""   #"Top turret/Left spindle Turn  on     7"
sbtrsm_none_0 : ""   #"Bottom turret/Right spindle Mill off 8"
sbtrsm_none_1 : ""   #"Bottom turret/Right spindle Mill on  9"
sbtrst_none_0 : ""   #"Bottom turret/Right spindle Turn off 10"
sbtrst_none_1 : ""   #"Bottom turret/Right spindle Turn  on 11"
sttrsm_none_0 : ""   #"Top turret/Right spindle Mill off    12"
sttrsm_none_1 : ""   #"Top turret/Right spindle Mill on     13"
sttrst_none_0 : ""   #"Top turret/Right spindle Turn off    14"
sttrst_none_1 : ""   #"Top turret/Right spindle Turn on     15"
               #FLOOD
sbtlsm_flood_0 : "M9" #"Bottom turret/Left spindle Mill off  16"
sbtlsm_flood_1 : "M8" #"Bottom turret/Left spindle Mill on   17"
sbtlst_flood_0 : "M9" #"Bottom turret/Left spindle Turn off  18"
sbtlst_flood_1 : "M8" #"Bottom turret/Left spindle Turn  on  19"
sttlsm_flood_0 : "M9" #"Top turret/Left spindle Mill off     20"
sttlsm_flood_1 : "M8" #"Top turret/Left spindle Mill  on     21"
sttlst_flood_0 : "M9" #"Top turret/Left spindle Turn off     22"
sttlst_flood_1 : "M8" #"Top turret/Left spindle Turn  on     23"
sbtrsm_flood_0 : "M9" #"Bottom turret/Right spindle Mill off 24"
sbtrsm_flood_1 : "M8" #"Bottom turret/Right spindle Mill on  25"
sbtrst_flood_0 : "M9" #"Bottom turret/Right spindle Turn off 26"
sbtrst_flood_1 : "M8" #"Bottom turret/Right spindle Turn  on 27"
sttrsm_flood_0 : "M9" #"Top turret/Right spindle Mill off    28"
sttrsm_flood_1 : "M8" #"Top turret/Right spindle Mill on     29"
sttrst_flood_0 : "M9" #"Top turret/Right spindle Turn off    30"
sttrst_flood_1 : "M8" #"Top turret/Right spindle Turn on     31"
               #MIST / SHOWER
sbtlsm_mist_0 : "M459" #"Bottom turret/Left spindle Mill off  32"
sbtlsm_mist_1 : "M458" #"Bottom turret/Left spindle Mill on   33"
sbtlst_mist_0 : "M459" #"Bottom turret/Left spindle Turn off  34"
sbtlst_mist_1 : "M458" #"Bottom turret/Left spindle Turn  on  35"
sttlsm_mist_0 : "M459" #"Top turret/Left spindle Mill off     36"
sttlsm_mist_1 : "M458" #"Top turret/Left spindle Mill  on     37"
sttlst_mist_0 : "M459" #"Top turret/Left spindle Turn off     38"
sttlst_mist_1 : "M458" #"Top turret/Left spindle Turn  on     39"
sbtrsm_mist_0 : "M459" #"Bottom turret/Right spindle Mill off 40"
sbtrsm_mist_1 : "M458" #"Bottom turret/Right spindle Mill on  41"
sbtrst_mist_0 : "M459" #"Bottom turret/Right spindle Turn off 42"
sbtrst_mist_1 : "M458" #"Bottom turret/Right spindle Turn  on 43"
sttrsm_mist_0 : "M459" #"Top turret/Right spindle Mill off    44"
sttrsm_mist_1 : "M458" #"Top turret/Right spindle Mill on     45"
sttrst_mist_0 : "M459" #"Top turret/Right spindle Turn off    46"
sttrst_mist_1 : "M458" #"Top turret/Right spindle Turn on     47"
               #THRU TOOL
sbtlsm_tool_0 : "M485" #"Bottom turret/Left spindle Mill off  48"
sbtlsm_tool_1 : "M484" #"Bottom turret/Left spindle Mill on   49"
sbtlst_tool_0 : "M485" #"Bottom turret/Left spindle Turn off  50"
sbtlst_tool_1 : "M484" #"Bottom turret/Left spindle Turn  on  51"
sttlsm_tool_0 : "M485" #"Top turret/Left spindle Mill off     52"
sttlsm_tool_1 : "M484" #"Top turret/Left spindle Mill  on     53"
sttlst_tool_0 : "M485" #"Top turret/Left spindle Turn off     54"
sttlst_tool_1 : "M484" #"Top turret/Left spindle Turn  on     55"
sbtrsm_tool_0 : "M485" #"Bottom turret/Right spindle Mill off 56"
sbtrsm_tool_1 : "M484" #"Bottom turret/Right spindle Mill on  57"
sbtrst_tool_0 : "M485" #"Bottom turret/Right spindle Turn off 58"
sbtrst_tool_1 : "M484" #"Bottom turret/Right spindle Turn  on 59"
sttrsm_tool_0 : "M485" #"Top turret/Right spindle Mill off    60"
sttrsm_tool_1 : "M484" #"Top turret/Right spindle Mill on     61"
sttrst_tool_0 : "M485" #"Top turret/Right spindle Turn off    62"
sttrst_tool_1 : "M484" #"Top turret/Right spindle Turn on     63"

scool2       : ""
cool_sel = coolant$ * 16 + (lathtype * 4) + (abs(posttype$ - 1) * 2) + fsg2(cool_on)
cool_on      : 1     #flag to turn coolant on/off

fstrsel sbtlsm_none_0 cool_sel scool2 64 -1

sm09    : "M9 M485 M595"       #Coolant Off             (NO LONGER USED --See Above)
sm08    : "M8"       #Coolant Flood           (NO LONGER USED --See Above)
sm08_1  : "M484"       #Coolant Mist (shower)   (NO LONGER USED --See Above)
sm08_2  : "M458"       #Coolant Tool            (NO LONGER USED --See Above)
scoolant : ""        #Target string       (NO LONGER USED --See Above)

fstrsel sm09 coolant$ scoolant 4 -1

# --------------------------------------------------------------------------
# Table rotation direction, index
scindx_cw  : "M22"   #Rotate CW code
scindx_ccw : "M21"   #Rotate CCW code
scindx_mc : ""       #Target string

fstrsel scindx_cw cindx_mc scindx_mc 2 -1
# --------------------------------------------------------------------------
# Table rotation direction, index
sbindx_cw  : "M22"   #Rotate CW code
sbindx_ccw : "M21"   #Rotate CCW code
sbindx_mc : ""       #Target string

fstrsel sbindx_cw bindx_mc sbindx_mc 2 -1
# --------------------------------------------------------------------------
# C axis mode
sc_on0  : "M45"      #Main Spindle C-Axis Enable
sc_on1  : "M245"     #Sub-Spindle C-Axis Enable
sc_axis_on : ""      #Target string

fstrsel sc_on0 spindle_no$ sc_axis_on 2 -1
# --------------------------------------------------------------------------
sc_off0 : "M46"      #Main Spindle C axis Disable
sc_off1 : "M246"     #Main Spindle C axis Disable
sc_axis_off : ""     #Target string

fstrsel sc_off0 spindle_no$ sc_axis_off 2 -1
# --------------------------------------------------------------------------
smain_spdl : "M303"
ssub_spdl  : "M304"
sspdl_sel  : ""      #Target string

fstrsel smain_spdl spindle_no$ sspdl_sel 2 -1
# --------------------------------------------------------------------------
strtlor0a : ""
strtlor0b : ""
strtlor0c : ""
strtlor1  : ""       #Rotary Tool
strtlor2  : ""       #Rotary Tool
strtlor3  : ""       #Rotary Tool
strtlor5  : "M437"   #Turning Tool M437
strtlor6  : ""       #Turning Tool
strtlor7  : "M436"   #Turning Tool M436
smlcut_dir : ""      #Target string

fstrsel strtlor0a d_sel smlcut_dir 9 -1
# --------------------------------------------------------------------------
#Tool Change Macro D-Word
strdw0   : "D0."     #Milling / Rotary tool
strdw1   : "D2."     #Turning tool
strdw2   : "D1."     #Turning tool
strdw3   : "D1."     #Turning tool
strdw4   : "D2."     #Turning tool
strdw5   : "D2."     #Turning tool
strdw6   : "D1."     #Turning tool
sel_dword : ""

fstrsel strdw0 d_sel sel_dword 7 -1
# --------------------------------------------------------------------------
# Tailstock M code selection
sm26    : "M26"      #Tailstock retracted
sm25    : "M25"      #Tailstock engaged
stlstk  : ""         #Target string

fstrsel sm26 tlstk stlstk 2 -1
# --------------------------------------------------------------------------
# Generate string for spindle, mill (upper turret)
sm52u   : "M14"      #Spindle reverse - no coolant
sm55u   : "M5"       #Spindle off     - no coolant
sm51u   : "M13"      #Spindle forward - no coolant
sm54u   : "M14"      #Spindle reverse - coolant
sm55cu  : "M5"       #Spindle off     - coolant
sm53u   : "M13"      #Spindle forward - coolant
spindle_mu : ""      #Target string

fstrsel sm52u g_spdir spindle_mu 6 -1
# --------------------------------------------------------------------------
# Generate string for spindle, mill (lower turret)
sm52l   : "M14"      #Spindle reverse - no coolant
sm55l   : "M5"       #Spindle off     - no coolant
sm51l   : "M13"      #Spindle forward - no coolant
sm54l   : "M14"      #Spindle reverse - coolant
sm55cl  : "M5"       #Spindle off     - coolant
sm53l   : "M13"      #Spindle forward - coolant
spindle_ml : ""      #Target string

fstrsel sm52l g_spdir spindle_ml 6 -1
# --------------------------------------------------------------------------
sm_sdrl_offm : "M91"  #Syncronous drilling off (main spindle)
sm_sdrl_onm  : "M90"  #Syncronous drilling on (main spindle)
sm_sdrl_offs : "M291" #Syncronous drilling off (sub spindle)
sm_sdrl_ons  : "M290" #Syncronous drilling on (sub spindle)
sm_sync_drill : ""    #Target string

fstrsel sm_sdrl_offm sync_drill_on sm_sync_drill 4 -1

sync_drill_on = spindle_no$ * 2 + sync_drill

# --------------------------------------------------------------------------
# Chute M code selection
sm73    : "M73"      #Chute retracted
sm74    : "M74"      #Chute engaged
schute  : ""         #Target string

fstrsel sm73 chute schute 2 -1
# --------------------------------------------------------------------------
#Spindle (C-Axis) Clamp
sc_clamp_on_m  : "M68"  #Clamp On for Milling
sc_clamp_off_m : "M69"  #Clamp Off to position C
sc_clamp_on_s  : "M268" #Clamp On for Milling
sc_clamp_off_s : "M269" #Clamp Off to position C
sc_clamp : ""           #Target String

c_clamp_off = spindle_no$ * 2 + fsg2(cinc)
fstrsel sc_clamp_on_m c_clamp_off sc_clamp 4 -1
# --------------------------------------------------------------------------
#Turret (B-Axis) Clamp
sb_clamp_on  : "M368" #Clamp On for Milling
sb_clamp_off : "M369" #Clamp Off to position B
sb_clamp : ""         #Target String

b_clamp_off = fsg2(binc)
fstrsel sb_clamp_on b_clamp_off sb_clamp 2 -1
# --------------------------------------------------------------------------
#Spindle (C-Axis) Brake
sc_brake_on_m  : "M68"  #Brake On for Milling
sc_brake_off_m : "M69"  #Brake Off to position C
sc_brake_on_s  : "M268" #Brake On for Milling
sc_brake_off_s : "M269" #Brake Off to position C
sc_brake       : ""     #Target String

c_brake_off = spindle_no$ * 2 + one

fstrsel sc_brake_on_m c_brake_off sc_brake 4 -1
# --------------------------------------------------------------------------
#Turret (B-Axis) brake
sb_brake_on  : "M305" #brake On for Milling
sb_brake_off : ""     #brake Off to position B
sb_brake     : ""     #Target String

fstrsel sb_brake_on b_brake_actv sb_brake 2 -1
# --------------------------------------------------------------------------
# G362 returns to G30P4 ref point
stcmacro1 : "G361"   #String for Toolchange Macro Call
stcmacro2 : "G362"   #String for Toolchange Macro Call
stcmacro  : ""       #Target string

fstrsel stcmacro1 tcmacro stcmacro 2 -1

#tcmacro = int(mi3$/4)  #Use G361 unless mi3 set for G30P4
tcmacro      : 0

d_sel        : 0
# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
#Default english/metric position format statements
fs2 1   0.7 0.6     #Decimal, absolute, 7 place, default for initialize (:)
fs2 2   0.4 0.3     #Decimal, absolute, 4/3 place
fs2 3   0.4 0.3d    #Decimal, delta, 4/3 place
#Common format statements
fs2 4   1 0 1 0     #Integer, not leading
fs2 5   2 0 2 0l    #Integer, force two leading
fs2 6   3 0 3 0l    #Integer, force three leading
fs2 7   4 0 4 0l    #Integer, force four leading
fs2 9   0.1 0.1     #Decimal, absolute, 1 place
fs2 10  0.2 0.2     #Decimal, absolute, 2 place
fs2 11  0.3 0.3     #Decimal, absolute, 3 place
fs2 12  0.4 0.4     #Decimal, absolute, 4 place
fs2 13  0.5 0.5     #Decimal, absolute, 5 place
fs2 14  0.3 0.3d    #Decimal, delta, 3 place
fs2 15  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 16  0 4 0 4t    #No decimal, absolute, 4 trailing
#Default english/metric feed format statements
fs2 17  0.2 0.1     #Decimal, absolute, 2/1 place
fs2 18  0.4 0.3     #Decimal, absolute, 4/3 place
fs2 19  0.5 0.4     #Decimal, absolute, 5/4 place
fs2 20  1 0 1 0n    #Integer, forced output
fs2 21  1 2 1 2t    #No Decimal 2 trailing
fs2 22  1 3 1 3t    #No Decimal 3 trailing
fs2 23  0 4 0 3t    #No decimal, absolute, 4/3 trailing
fs2 24  1.3 1.3l    #Decimal 3 trailing
fs2 25  1 1 1 1lt   #Integer, force 1 leading & 1 trailing
fs2 26  0 4 0 3     #No Decimal, absolute, 4/3 place

# --------------------------------------------------------------------------
# Toolchange / NC output Variable Formats
# --------------------------------------------------------------------------
fmt  "Tool "  7   t$    #Tool number prompt
fmt  "T" 7  toolno      #Tool number
fmt  "T" 7  next_toolno #Tool number
fmt  "H" 9  tlngno$     #Tool length offset (4=integer, 9=decimal format)
fmt  "D" 4  tloffno$    #Tool diameter offset
fmt  "G" 4  g_wcs       #WCS G address
fmt  "P" 4  p_wcs       #WCS P address
fmt  "P" 4  ref_ret     #G30 P address
fmt  "S" 4  speed       #Spindle Speed
fmt  "S" 4  m_speed     #Spindle Speed for synchronous drilling
fmt  "M" 4  gear        #Gear range
fmt  "S" 4  maxss$      #RPM spindle speed
fmt  "M" 4  sync        #Sync Code for dual turret (M100 - M199)
# --------------------------------------------------------------------------
fmt  "N" 4  n$          #Sequence number
fmt  "X" 2  xabs        #X position output
fmt  "Y" 2  yabs        #Y position output
fmt  "Z" 2  zabs        #Z position output
fmt  "U" 3  xinc        #X position output
fmt  "V" 3  yinc        #Y position output
fmt  "W" 3  zinc        #Z position output
fmt  "X" 2  g68tox      #Tool Origin X position output (mapped)
fmt  "Y" 2  g68toy      #Tool Origin Y position output (mapped)
fmt  "Z" 2  g68toz      #Tool Origin Z position output (mapped)
fmt  "C" 11 cabs        #C axis position
fmt  "H" 14 cinc        #C axis position
fmt  "C" 4  cindx_out   #Index position
fmt  "B" 11 babs        #B axis position
fmt  "B" 14 binc        #B axis position
fmt  "B" 4  bindx_out   #Index position
fmt  "R" 11 braw        #B axis position formatted for G68 line
fmt  "I" 3  iout        #Arc center description in X
fmt  "J" 3  jout        #Arc center description in Y
fmt  "K" 3  kout        #Arc center description in Z
fmt  "R" 2  arcrad$     #Arc Radius
fmt  "F" 18 feed        #Feedrate
fmt  "P" 22 dwell$      #Dwell  11=1.xxx 22=1xxx
fmt  "D" 22 dwell_2      #Dwell  11=1.xxx 22=1xxx
fmt  "U" 24 dwell2      #lathe denter tapping dwell
fmt  "M" 5  cantext$    #Default cantext
fmt  "C" 2  crad        #C axis start radius, G107
fmt  "H" 2  tlrad$      #C axis cancel, G112, currently using C position
# --------------------------------------------------------------------------
#Move comment (pound) to output colon with program numbers
fmt  "O" 7  progno$      #Program number
#fmt ":" 7   progno$      #Program number
fmt  "O" 7  main_prg_no$ #Program number
#fmt ":" 7   main_prg_no$ #Program number
#fmt  O  7   sub_prg_no$  #Program number
fmt ":" 7   sub_prg_no$  #Program number
fmt  "U" 2  sub_trnsx$   #Rotation point
fmt  "V" 2  sub_trnsy$   #Rotation point
fmt  "W" 2  sub_trnsz$   #Rotation point
# --------------------------------------------------------------------------
# Drill output
# --------------------------------------------------------------------------
fmt  "R" 2  refht_a     #Reference height
fmt  "R" 2  refht_i     #Reference height
fmt  "X" 2  initht_x    #Initial height, mapped X
fmt     2   initht_y    #Initial height, mapped Y
fmt  "Z" 2  initht_z    #Initial height, mapped Z
fmt  "X" 2  refht_x     #Reference height, mapped X
fmt     2   refht_y     #Reference height, mapped Y
fmt  "Z" 2  refht_z     #Reference height, mapped Z
fmt  "X" 2  depth_x     #Depth, mapped X
fmt     2   depth_y     #Depth, mapped Y
fmt  "Z" 2  depth_z     #Depth, mapped Z
fmt  "Q" 22 peck1$      #First peck increment (positive)
fmt  "Q" 22 peck2$      #Second or last peck (positive)
fmt  "R" 2  peckclr$    #Safety distance
fmt     2   retr$       #Retract height
fmt  "Q" 2  shftdrl$    #Fine bore tool shift
# --------------------------------------------------------------------------
# Thread output
# --------------------------------------------------------------------------
fmt  "P" 2  thddepth$   #Thread height absolute
fmt  "Q" 2  thdfirst$   #First depth cut in thread
fmt  "Q" 2  thdlast$    #Last depth cut in thread
fmt  "R" 2  thdfinish$  #G76 thread finish allowance
fmt  "R" 3  thdrdlt     #Thread R delta G92 and G76
fmt  "U" 3  thd_dirx    #Incremental X move for G76 mult starts
fmt  "W" 3  thd_dirz    #Incremental Z move for G76 mult starts
fmt  "P" 5  nspring$    #Number of spring cuts
fmt     5   thdpull     #G76 thread pull off
fmt     5   thdang      #G76 threading angle
fmt  "Q" 4  thd_shft_ang #G76 thread shift angle for multiple starts
# --------------------------------------------------------------------------
# Canned cycle output format (do not change order, used by buffer 2)
# --------------------------------------------------------------------------
fmt  "U" 2  depthcc
fmt  "R" 2  clearcc
fmt  "U" 2  xstckcc
fmt  "W" 2  zstckcc
fmt  "R" 4  ncutscc
fmt     2   stepcc
fmt  "P" 4  ng70s       #P line number in canned cycle
fmt  "Q" 4  ng70e       #Q line number in canned cycle
fmt  "U" 2  g73x        #Stored offset of canned cycle rough cut G73
fmt  "V" 2  g73y        #Stored offset of canned cycle rough cut G73
fmt  "W" 2  g73z        #Stored offset of canned cycle rough cut G73
fmt  "P" 26 grvspcc
fmt  "Q" 26 grvdpcc

fmt  "R" 12 backoff     #G74/G75 backoff value from Mr2
# --------------------------------------------------------------------------
fmt "TOOL - "              4   tnote     #Note format
fmt " LENGTH OFFSET - "    4   toffnote  #Note format
fmt " RADIAL OFFSET - "    4   toffnote2 #Note format

# --------------------------------------------------------------------------
# Define the gear selection code
flktbl  1       3       #Lookup table definition - table no. - no. entries
        40      0       #Low gear range
        41      400     #Med gear range
        42      2250    #Hi gear range

# --------------------------------------------------------------------------
# User prompt definitions
fq 1 toollength "Enter the pivot distance for //t$//"

# --------------------------------------------------------------------------
# Parameter information lookup tables, see pparameter
# --------------------------------------------------------------------------
fprmtbl 1 5 #Rough cut parameters
        13343 depthcc
        10407 clearcc
        10202 xstckcc
        10203 zstckcc
        10214 directcc

fprmtbl 2 6 #Finish cut parameters
        13341 ncutscc
        10101 depthcc
        10102 xstckcc
        10103 zstckcc
        13149 anglelcc
        13341 ncutslcc

fprmtbl 3 5 #Groove cut parameters
        13358 stepcc
        13138 directcc
        13352 dopeckcc
        10316 depthcc
        13364 clearcc

fprmtbl 104 4 #Thread cut parameters
        10811 xmaj_thd
        10813 zstrt_thd
        10814 zend_thd
        10819 face_thd

############################################################################
############################################################################
fprmtbl 17000   1   #Table Number, Size - Machine Definition parameter table
#       Param   Variable to load value into
        17391   axis_label   #Axis label - 1=X,2=Y,3=Z

# Control Definition Parameters
fprmtbl 18000   0    #Table Number, Size
#       Param   Variable to load value into

# Machine Group Parameters
fprmtbl 19000   0    #Table Number, Size
#       Param   Variable to load value into

pprep$          #Pre-process postblock - Allows post instructions after the post is parsed but before the NC and NCI file are opened.
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE) BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      rd_cd$       #Read CD Parameters
      rd_mch_ent_no$ = -1  #Read the entire machine def file's parameters
      rd_md$       #Read machine definition parameters
      if not(b_axis_mch), use_g68 = zero
      use_g68_sav = use_g68
      if seq_at_tc, omitseq$ = one
      #Feedrate from question 38.
      rapid_fr = rpar(sq38, one)


# --------------------------------------------------------------------------
pset_mach       #Set post switches by reading machine def parameters
      #Reset variables prior to MD read
      y_axis_mch = no$    #Reset to zero - Set from Axis Combination

      rd_mch_ent_no$ = syncaxis$  #Retrieve machine parameters based on current axis combination - read from .nci G950 line
      rd_md$       #Read machine definition parameters - calls pmachineinfo$

      #We only need these set at toolchange (and start of file).  No need to set them each time a user may call rd_md

# --------------------------------------------------------------------------
# Machine definition and control definition parameter capture:
# --------------------------------------------------------------------------
pmachineinfo$   #Machine information parameters postblock
      #rd_mach is used to call pmachineinfo postblock and read the parameters of the selected axis
      #combination machine entity set in rd_mch_ent_no.
      #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
      #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters
      #"-->pmachineinfo", ~prmcode$, "  ", ~sparameter$, e$  #Do not uncomment if being called from pprep$ - see pprep comment

      #Read parameter lookup tables -
      if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000) #Run the parameter table for Machine Definition Parameters
      #Leave lines below commented until you enter values in related lookup tables
      #if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Run the parameter table for Control Definition Parameters
      #if prmcode$ >= 19000 & prmcode$ < 20000, result = fprm(19000) #Run the parameter table for Machine Group Parameters

      if axis_label = 2, y_axis_mch = yes$    #Y axis in axis combination found


      #Check for single or multiple turret machine def
      if prmcode$ = 19959, mch_comp_idno = rpar(sparameter$, 1)
      if prmcode$ = 19958,
        [
        mch_comp_type = rpar(sparameter$, 1)  #Component type
        if mch_comp_type = 303,
          [
          turret_id_no = mch_comp_idno
          if prv_turret_id_no & (turret_id_no <> prv_turret_id_no), dual_turret = one
          !turret_id_no
          ]
        ]

############################################################################
############################################################################
# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
ptoolcomment    #Comment for tool
      tnote = abs(t$)
      toffnote = tlngno$
      toffnote2 = tloffno$
      strtool$ = ucase(strtool$)
      stoper = ucase(stoper)
      stinsert2 = ucase(stinsert2)
      "(", *tnote, *toffnote, *toffnote2, ")", e$
      if posttype$ = two,
        "(", *stoper, " ", *strtool$, " ", *stinsert, *stinsert2, ")", e$
      else,
        "(", *stoper, " ", *strtool$, ")", e$

pcomment$        #Comment from manual entry (must call pcomment2 if booleans)
      if miscopsflag = zero, pheader$
      pcomment2

pcomment2       #Comment from manual entry
      scomm$ = ucase(scomm$)
      if gcode$ = 1007, "(", scomm$, ")"
      else, "(", scomm$, ")", e$

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------


double_prog : 0
fmt "Double prog" 4 double_prog




psortie_iso_debut   # c'est la que l'on decide si on ecrit en P1 ou P2 au debut de programme
                #"voir tourel dans debut et cut type", *lturret$, *cuttype, e$
                !lturret$
                #newsub$
                if lturret$ = 1 | cuttype > 1, subout$ = 0
                if lturret$ = 0 & cuttype < 2,
                    [
                    subout$ = 1
                    double_prog = 1
                    ]


psortie_iso_fin   # c'est la que fini date$'ecrire les fichier en fin de programme
                #"voir tourel dans fin", *lturret$,cuttype, e$
                !lturret$
                #newsub$
                if double_prog = 2, # ON a ECRIT 2 PROGRAMMES
                    [
                        subout$ = 1
                        ptoolend$
                        comment$
                        if dual_turret, n$, "M197", e$
                        #paxeW_origine
                        n$, "M30", e$
                        "%", e$
                        subout$ = 0
                    ]

psortie_iso_milieu   # c'est la que l'on decide si on ecrit en P1 ou P2 dans le programme
                #"voir tourel dans milieu", *lturret$,*cuttype, e$
                !lturret$
                #newsub$
                if lturret$ = 1 | cuttype > 1 ,
                    [
                    subout$ = 0  # ecrire dans P1
                    if double_prog = 1, # on as deja ecrit un sous prog
                        [

                        pheader_debut
                        double_prog = 2
                        ]
                    ]

                if lturret$ = 0 & cuttype < 2 ,
                    [

                    subout$ = 1   # ecrire dans P2
                    if double_prog = 0, # on as deja ecrit un sous prog
                        [

                        pheader_debut
                        double_prog = 2
                        ]
                    ]


pheader_debut   # debut d'ecriture

        "%", e$
        if progno$ = zero | progno$ > 8000, progno$ = one
        *progno$, "(", *sprogname$,")", e$
        "(FAIT LE - ", date$, " A - ", time$, ")", e$
        pbld, n$, *smetric, e$
        if not(met_tool$), result = newfs(16,peck1$)
        miscopsflag = one



pheader$         #Start of file
        psortie_iso_debut
      if miscopsflag = zero, pheader_debut
      !sub_seq_typ$

ptlchg1002$      #Call at actual toolchange with tlchng_aft
      pset_mach   #Read machine def parameters
      if use_only_tl,
        [
        lturret$ = one
        spindle_no$ = zero
        lathtype = one
        ]
##      pvalidate_tlinfo

      if posttype$ = two,
        [
        if opcode$ = 105 & nextdc$ = three & use_rigid_tap >= two, rigid_actv = one
        else, rigid_actv = zero
        ]
      else,
        [
        if opcode$ = three & nextdc$ = three &
           (use_rigid_tap = one | use_rigid_tap = three), rigid_actv = one
        else, rigid_actv = zero
        ]
      if use_g43 >= posttype$ & lturret$, g49_mode = one
      else, g49_mode = zero
      if posttype$ = two, tlngno$ = tloffno$   #no height offset reg in lathe yet
      #if lturret$ & spindle_no$, tlngno$ = tlngno$ + 120 #Add 120 to tlngno$ for Upper Turret Sub Spindle
      whatline$ = four #Required for vector toolpaths
      toolend_flg = one
      pmatrix_su
      pmap_plane
      pset_turret
      pset_g_speed
      cool_on = one
      if rcc_flg$ = zero, sub_seq_typ$ = prv_sub_seq_typ$
      if gcode$ = 1000,
        [
        #Null toolchange
        if millcc & prv_mi4$ = mi4$, cutpos2$ = sav_cutpos2
        if use_frst_wcs, workofs$ = sav_wcs
        if cc_stop_fcc & rcc_flg$ = 6, no_nc_out$ = one
        ]
      else,
        [
        #Toolchange and Start of file
        if fastmode$ & not(use_g68) & cuttype >= 5 & use_tlength = two,q1
        pgetnexttool
        vshftx = vequ(vzerox)
        if add_gage, vshftz = toollength + gagelength
        else, vshftz = toollength
        if gcode$ = 1002,
          [
          #Actual toolchange
          if use_frst_wcs, workofs$ = sav_wcs
          sync = sync + one
          preset_mod
          ]
        else, #SOF
          [
          sav_wcs = workofs$
          ]
        prv_xia = vequ (c1_xh)
        prv_feed = c9k
        pnt_at_zero = zero
        ]
      #Mill canned cycle initialze at toolchange
      arcoutput$ = sav_arcout
      if millcc,
        [
        #R arc output
        arcoutput$ = one
        if cuttype = four,
          [
          crad = rotdia$/two
          ]
        else,
          [
          breakarcs$ = zero
          ]
        ]
      iout = zero
      jout = zero
      kout = zero
      !mi4$

lsof$            #Start of file for non-zero tool number, lathe
        #"voir B", *babs, e$
      if seq_at_tc, pbld, *n$, e$
      ltlchg$

msof$            #Start of file for non-zero tool number, mill
        #"voir B", *babs, e$
      if seq_at_tc, pbld, *n$, e$
      mtlchg$




garage : 0
fmt "GARAGE" 4 garage   # variable qui passe de 0 a 1 si on a deja garer l'axe BW
fmt "old opid" 4 old_operation


pnumoutil  # equivalence de toolno
                if lturret$ = 1, toolno = t$ + 2000
                else, toolno = t$ * 100 + tloffno$





pgarage_BW_on    # Ecriture pour garer la broche de gauche

                if babs <= -46 & garage = 0 & spindle_no$ = 0 & subout$ = 0,
                [
                gcode$ = 0
                pbld, n$, *sg28ref, "U0. W0.", e$
                pbld, n$, "G330 P4", e$
                pbld, n$, *sgcode,"B0", e$
                pbld, n$, *sgcode,"BW-90", e$
                pbld, n$, "G330", e$
                garage = 1
                ]

pgarage_BW_off    # Ecriture pour dégarer la broche de gauche
                if garage = 1 & spindle_no$ = 1 & subout$ = 0,
                [
                gcode$ = 0
                pbld, n$, *sg28ref, "U0. W0.", e$
                pbld, n$, "G330 P4", e$
                pbld, n$, *sgcode,"B0", e$
                pbld, n$, *sgcode,"BW0", e$
                garage = 0
                ]


rot_BW : 0
fmt "Rotation de 25degre de BW" 4 rot_BW
fmt "M" 4 ori_base
fmt "Max B" 2 max_axe_B
fmt "Min B" 2 min_axe_B
fmt "Old B" 2 old_babs

plimitB # test si on sort des limites de B
                old_babs = babs
                #"ici on ecrit avant B=", *babs, e$
                if babs > max_axe_B, babs =babs-360
                if babs < min_axe_B, babs = babs + 360
                #"ici on ecrit apret B=", *babs, e$


paxeW      # savoir si l'axes BW avec + 25 degre
            plimitB
            if babs = 90,
                [
                babs = babs - 25
                if rot_BW = 0, rot_BW = 1
                ]
            else, paxeW_origine


paxeW_tourne   # routine  pour ecrire la rotaion de BW

                if rot_BW = 1,
                [
                ori_base = g_wcs

                gcode$ = 0
                pbld, n$,"G330 P4", e$
                pbld, n$, *sgcode, "BW-25", e$
                pbld, n$, "G474", *ori_base, "Q59","B-25 A#5246", e$
                rot_BW = 2
                n$, pwcs, e$
                pbld, n$, "G68.1 X0 Y0 Z0 I0 J1 K0 R-25.", e$
                ]

paxeW_origine   # remise en etat de l'axe BW
                if rot_BW = 2,
                    [
                    gcode$ = 0
                    pbld, n$,"G330 P4", e$
                    pbld, n$, *sgcode, "BW0", e$
                    pbld, n$, "G69.1", e$
                    rot_BW = 0
                    n$, pwcs, e$
                    ]



ltlchg$          #Toolchange, lathe
        paxeW_origine  # remetre a 0 l'axe BW si il a ete utiliser

        pbld, n$, "M01", e$
        " ", e$
        pbld, *n$, e$

        pnumoutil
        if garage <> 1 & subout$ = 0, pbld, n$, "G330 P4", e$
        #"voir B", *babs, e$
        pcaxis_on_arret
         psortie_iso_milieu
      if vertical = zero & orient$ < five, orient$ = orient$ + four
      if use_only_tl = no$ & dual_turret, pbld, n$, *sync, e$
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      pcc_capture         #Capture LCC ends, stop output RLCC
      c_rcc_setup$        #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb          #Get machine position, set inc. from c1_xh
      c_mmlt$             #Position multi-tool sub, sets inc. current if G54...
      if list_tools <> one, ptoolcomment
      comment$
      if home_type < two, #Toolchange G50/home/reference position
        [

        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        pmap_home         #Get home position, xabs
        ps_inc_calc       #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position
          pbld, n$, pg28ref, "U0.", [if y_axis_mch, "V0."], "W0.", e$
          if not(g49_mode), pnumoutil
          else, pnumoutil
          if home_type = m_one, pbld, n$, *toolno, e$
         # else, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      #Safety block
      pbld, n$, "G0", "M5", e$
      if g49_mode, pbld, n$, "G49", e$
        else, "G99", *sgplane, [if (lturret$ & spindle_no$), "M246", else, "M46"], e$
      if start_at_ref,
        [
        pbld, n$, *sg28ref, "U0.", [if y_axis_mch & lturret$, "V0."], e$
        pbld, n$, *sg28ref, "W0.", e$
        ]
      pbld, n$, pwcs, e$
      pbld, n$, *sgcode, *toolno, e$
      pcaxis_off_l  #Postblock for lathe transition  (Moved ahead of tc macro 09/28/02)
      if lturret$,
        [
        if use_tcmacro,
          [
          pcom_moveb    #Reset machine position, set inc. from last position
          if mi7$ > zero, tcmacro = one
            else, tcmacro = zero
          if opcode$ = 105, d_sel = spindle_no$ + three
            else, d_sel = (posttype$ - one) * (spdir$ + (lh_tool * two) + spindle_no$ + two)
          pgarage_BW_on
          pgarage_BW_off
          paxeW  # routine pour la gestion de l'axes BW avec + 25 degre
          pbld, n$, *stcmacro, pfbout, *sel_dword, e$
          ]
        else,
          [
          pget_tool
          pbld, n$, *smlcut_dir, e$
          result = force(babs, bindx_out)
          pcom_moveb    #Reset machine position, set inc. from last position
          ]
        ]
      #skip stage tool in single tool program lower turret and forced null toolchng
     # if lturret$ & abs(toolno) <> abs(next_toolno),
     # pbld, n$, *next_toolno, e$

      if (use_g43 >= posttype$) & lturret$, pbld, n$, *str_g43, *tlngno$, [if g43_b_out, pfbout], e$
      paxeW_tourne
      if sub_sp_mch, pbld,n$, *sspdl_sel, e$
      if (tool_op$ = 64 & drillcyc$ = three), pbld, n$, *sg50, *maxss$, e$
      pcan
      pspindle
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      if css_actv$, pbld, n$, pcssg50, e$
      pbld, n$, pfsgplane, e$
      if css_actv$ & not(rigid_actv),
        [
        if css_start_rpm, pbld, n$, prpm, e$  # Direct RPM startup for programmed CSS
        else,
          [
          result = force(g_spdir, g_spdir)
          pbld, n$, pcss, e$ # NO RPM start - just output the CSS
          ]
        ]
      else, # Direct RPM was programmed
        [
        if not(rigid_actv), pbld, n$, prpm, e$ # Output programmed RPM
        ]
      if opcode$ = 105 & drillcyc$ = three, fr_sel = one
      if lturret$ = 1,
      [
      if spindle_no$ = 0 & subout$ = 0, n$, "G330", e$
      if spindle_no$ = 1, n$,  g_wcs, "A0", e$
      ]
      pcan1, pbld, n$, psccomp, *sgcode, *sgfeed, pfzout, pfscool, strcantext, e$

      if b_axis_mch & lturret$ = one,
        [
        if b_clamp_actv, pbld, n$, *sb_clamp_off, e$
        if b_brake_actv, pbld, n$, *sb_brake_off, e$
        pbld, n$, pbout, e$
        if b_clamp_actv, pbld, n$, *sb_clamp_on, e$
        if b_brake_actv, pbld, n$, *sb_brake_on, e$
        ]

      pbld, n$, sgcode, pfxout, pyout, [if css_actv$ & css_start_rpm, pcss], e$
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      absinc$ = sav_absinc
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
        old_operation = op_id$
         @old_operation


mtlchg$          #Toolchange, mill
        paxeW_origine  # remetre a 0 l'axe BW si il a ete utiliser
         pbld, n$, "M01", e$
        " ", e$
        pbld, *n$, e$
        pnumoutil
        if garage <> 1 & subout$ = 0, pbld, n$, "G330 P4", e$
        #"voir B", *babs, e$
        pcaxis_on_arret
         psortie_iso_milieu
      if use_only_tl = no$ & dual_turret, pbld, n$, *sync, e$
      toolchng = one
      gcode$ = zero
      copy_x = vequ(x$)
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      if list_tools <> one, ptoolcomment
      comment$
      pcom_moveb    #Get machine position, set inc. from c1_xh
      if home_type < two, #Toolchange G50/home/reference position
        [
        sav_xh = vequ(copy_x)
        sav_absinc = absinc$
        absinc$ = zero
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set start position, not incremental
        #Toolchange home position
        if home_type = one,
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, e$
        else,
          [
          #Toolchange g50 position/reference
          pbld, n$, pg28ref, "U0.", [if y_axis_mch, "V0."], "W0.", e$
          if not(g49_mode), pnumoutil
          else, pnumoutil
          if home_type = m_one, pbld, n$, *toolno, e$
          #else, pbld, n$, *sg50, pfxout, pfyout, pfzout, e$
          ]
        pe_inc_calc #Update previous
        absinc$ = sav_absinc
        copy_x = vequ(sav_xh)
        ]
      #Safety block
      pbld, n$, "G0", "M5", e$
      pbld, n$, "G49", e$
      if start_at_ref,
        [
        pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], e$
        pbld, n$, *sg28ref, "W0.", e$
        ]
      pbld, n$, pwcs, e$
      pbld, n$, *toolno, e$
      if lturret$,
        [
        if use_tcmacro,
          [
          pcom_moveb    #Reset machine position, set inc. from last position
          if b_clamp_actv, pbld, n$, *sb_clamp_off, e$
          if b_brake_actv, pbld, n$, *sb_brake_off, e$
          if mi7$ > zero, tcmacro = one
            else, tcmacro = zero
          if opcode$ = 105, d_sel = spindle_no$ + three
            else, d_sel = (posttype$ - one) * (spdir$ + (lh_tool * two) + spindle_no$ + two)
          pgarage_BW_on
          pgarage_BW_off
          paxeW  # routine pour la gestion de l'axes BW avec + 25 degre
          pbld, n$, *stcmacro, pfbout, *sel_dword, e$
          if b_clamp_actv, pbld, n$, *sb_clamp_on, e$
          if b_brake_actv, pbld, n$, *sb_brake_on, e$
          ]
        else,
          [
          pget_tool
          pbld, n$, *smlcut_dir, e$
          result = force(babs, bindx_out)
          pcom_moveb    #Reset machine position, set inc. from last position
          ]
        ]
      #skip stage tool in single tool program lower turret and forced null toolchng
      #if lturret$ & abs(toolno) <> abs(next_toolno),
      #pbld, n$, *next_toolno, e$
      !xnci$, !ynci$, !znci$
       if use_g43 >= posttype$ & lturret$, pbld, n$, *str_g43, *tlngno$, [if g43_b_out, pfbout], e$
      paxeW_tourne
      if sub_sp_mch, pbld,n$, *sspdl_sel, e$

      #pcaxis_on_m   # devalider par eric
       pcaxis_on_marche
      if cuttype = five & lturret$,
        [
        pbld, n$, "M594", e$
        ]

      if c_clamp_actv, pbld, n$, pfc_clamp_off, e$
      if c_brake_actv, pbld, n$, pfc_brake_off, e$
      pbld, n$, *sg28ref, "H0.", pcrotretinc, e$
      #pbld, n$, *sg28ref, "A0.", pcrotretinc, e$
      if lturret$ = 1,
      [
      if spindle_no$ = 0 & subout$ = 0, n$, "G330", e$
      if spindle_no$ = 1, n$,  g_wcs, "A0", e$
      ]
      if c_clamp_actv, pbld, n$, pfc_clamp_on, e$
      if c_brake_actv, pbld, n$, pfc_brake_on, e$

      pcom_moveb
      pcan
      sav_absinc = absinc$
      if home_type > one, absinc$ = zero
      pspindle
      if not((mi4$ = 1 & cuttype = 4)), pbld, pfsgplane, e$
      plimitB
      if not(((cuttype <> 5 & babs <> 0 & abs(babs) <> 90 & use_g68 = 1) | (cuttype = five & use_g68 = 1)) | (cuttype <> 4 & use_g68 = two)),
        [
        if not(rigid_actv), pbld, n$, prpm, e$
        ]
      if cuttype = five & lturret$,
        [
        pbld, n$, "G5", "P10000", e$
        pbld, n$, "G43.4", "D9", e$
        ]
      pcan1, pbld, n$, *sgcode, psccomp, *sgfeed, pfzout, pfscool, strcantext, e$

      if c_clamp_actv, pbld, n$, pfc_clamp_off, e$
      if c_brake_actv, pbld, n$, pfc_brake_off, e$
      pbld, n$, pfcout, e$
      pcindex
      if c_clamp_actv, pbld, n$, pfc_clamp_on, e$
      if c_brake_actv, pbld, n$, pfc_brake_on, e$

      if b_axis_mch & lturret$ = one,
        [
        if b_clamp_actv, pbld, n$, *sb_clamp_off, e$
        if b_brake_actv, pbld, n$, *sb_brake_off, e$
        pbld, n$, pbout, e$
        pbindex
        if b_clamp_actv, pbld, n$, *sb_clamp_on, e$
        if b_brake_actv, pbld, n$, *sb_brake_on, e$
        ]

      pbld, n$, sgcode, pfxout, pyout, e$
      pcom_movea    #Update previous, pcan2
      ps_inc_calc   #Reset current
      if lturret$ & ((cuttype <> 5 & babs <> 0 & abs(babs) <> 90 & use_g68 = 1) |
          (cuttype = five & use_g68 = 1) | (cuttype <> 4 & use_g68 = two)),
        [
        pg68_on
        if not(rigid_actv), pbld, n$, prpm, e$
        ]
      absinc$ = sav_absinc
      c_msng$        #Position single-tool sub, sets inc. current if G54...
      toolchng = zero
      if millcc,
        [
        pmillccb #Set mill conversion
        pmillcca #End mill conversion
        ]
      !c_clamp_off, !b_clamp_off
      !xnci$, !ynci$, !znci$
      old_operation = op_id$
      @old_operation

ltlchg0$         #Call from NCI null tool change, lathe

      copy_x = vequ(x$)
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      pcom_moveb     #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan
      if not(g49_mode),
        [
        pnumoutil
        if lturret$ = zero & spindle_no$ = one, toolno = toolno * 100 + tloffno$
        ]
      else, pnumoutil
     # pbld, n$, toolno, e$
      pbld, n$, psgplane, e$
      pcaxis_off_l  #Postblock for lathe transition
      pspindle
      pnullspindle
      pbld, n$, pscool,e$
      if home_type > one & workofs$ <> prv_workofs$,
        [
        sav_absinc = absinc$
        absinc$ = zero
        pbld, n$, psgcode, pwcs, pfxout, pfyout, pfzout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      if gcode$ = one, plinout
      else, prapidout
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea
      c_msng$ #Single tool subprogram call
      old_operation = op_id$
       @old_operation

mtlchg0$         #Call from NCI null tool change, mill
      if old_operation <> op_id$ & ((mill_on = 1 & spindle_no$ <> 0) | (mill_on = 2 & spindle_no$ = 0)) , mtlchg$, ex$
      copy_x = vequ(x$)
      pcom_moveb    #Get machine position, set inc. from last position
      c_mmlt$        #Position multi-tool sub, sets inc. current if G54...
      comment$
      pcan
      if not(g49_mode),
        [

        pnumoutil
        if lturret$ = zero & spindle_no$ = one, toolno = toolno + 30  # + tloffno$
        ]
      else, pnumoutil
     # pbld, n$, toolno, e$
      pbld, n$, psgplane, e$
      pspindle

      if home_type > one & workofs$ <> prv_workofs$ & old_babs <> babs,  # on remonte pour tourner
            [
            pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], e$
            pbld, n$, *sg28ref, "W0.", e$
            n$, pfbout, e$
            ]

      if (prv_cuttype <> cuttype | prv_tlngno$ <> tlngno$) & (use_g43 >= posttype$ & lturret$),
        pbld, n$, *str_g43, *tlngno$, [if g43_b_out, pfbout], e$
      if old_operation <> op_id$, pcaxis_on_marche   #Postblock for mill transition
      if (prv_cuttype <> cuttype) & (cuttype = five & lturret$),
        [
        pbld, n$, "M594", e$
        ]
      pnullspindle
      if (prv_cuttype <> cuttype) & (cuttype = five & lturret$),
        [
        pbld, n$, "G5", "P10000", e$
        pbld, n$, "G43.4", "D9", e$
        ]
      pbld, n$, pscool,e$

      if c_clamp_actv, pbld, n$, sc_clamp, e$
      if c_brake_actv, pbld, n$, sc_brake, e$
      if b_clamp_actv, pbld, n$, sb_clamp, e$
      if b_brake_actv, pbld, n$, sb_brake, e$

      if home_type > one & workofs$ <> prv_workofs$,
        [
        sav_absinc = absinc$
        absinc$ = zero
        if old_babs <> babs,  # on remonte pour tourner
            [
            pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], e$
            pbld, n$, *sg28ref, "W0.", e$
            n$, pfbout, e$
            ]
        pbld, n$, psgcode, pwcs, pfxout, pfyout, pfzout, pfcout, e$ #pfbout, e$
        pe_inc_calc #Update previous
        ps_inc_calc #Set current inc.
        absinc$ = sav_absinc
        ]
      pcindex
      pbindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if millcc, pmillccb #Set mill conversion
      if gcode$ = one, plinout
      else, prapidout
      if millcc, pmillcca #End mill conversion
      pcom_movea    #Update previous, pcan2
      c_msng$ #Single tool subprogram call
      !xnci$, !ynci$, !znci$
        old_operation = op_id$
         @old_operation


ptoolend$        #Read from buffer 1 for prv_, current and next tool info
                 #end tool here, current and next valid
      if toolend_flg,
        [
        sav_crev = crev #Axis Sub does not update to rev
        pcan
        if n1_gcode <> 1000,
          [
          if not(g49_mode),
              [
              pnumoutil
                if lturret$ = zero & spindle_no$ = one, toolno = toolno + 30
              ]
          else, pnumoutil
          sav_gcode = gcode$
          gcode$ = zero
          if posttype$ = two, pl_retract
          else, pm_retract
          cool_on = zero
          pbld, n$, pfscool, e$
          #if n1_gcode <> 1003,
          #  [
          #  if tlchg_crlf, " ", e$
          #  pbld, n$, "M01", e$
          #  " ", e$
          #  if seq_at_tc, pbld, *n$, e$
          #  ]
          gcode$ = sav_gcode
          ]
        else, #Null toolchange
          [
          if n1_posttype <> posttype$, pcan1, pbld, n$, pnullstop, strcantext, e$
          ]
        pcan2
        #Update current variables to prv_ needed in comparisons
        !posttype$, !cuttype
        if rc1 < size1, preadcur_nxt
        ]
      else,
        [
        if tlchg_crlf, " ", e$
        ]

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool

        psortie_iso_fin
      ptoolend$
      pcaxis_on_arret
      comment$
      if dual_turret, n$, "M197", e$
      paxeW_origine
      n$, "M30", e$
     # mergesub$
     # clearsub$
      mergeaux$
      clearaux$
      "%", e$

pl_retract      #Retract tool based on next tool gcode, lathe (see ptoolend)
      cc_pos$ = zero
      if g49_mode, pbld, n$, "G49", e$
      if home_type = one,
        [
        pmap_home   #Get home position, xabs
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, [if not(g49_mode), *toolno], e$
        pbld, n$, pnullstop, strcantext, e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one & not(g49_mode), pbld, n$, *toolno, e$
        if end_w_g53,
          [
          pcan1, pbld, n$, "G53", "X0.", [if y_axis_mch, "Y0."], e$
          pbld, n$, "G53", "Z0.", pnullstop, strcantext, e$
          ]
        else,
          [
          pcan1, pbld, n$, *sg28ref, "U0.", [if y_axis_mch & lturret$, "V0."], e$
          pbld, n$, *sg28ref, "W0.", pnullstop, strcantext, e$
          ]
        ]

pm_retract      #Retract tool based on next tool gcode, mill (see ptoolend)
      if c_clamp_actv, pbld, n$, pfc_clamp_off, e$
      if c_brake_actv, pbld, n$, pfc_brake_off, e$
      if b_clamp_actv, pbld, n$, *sb_clamp_off, e$
      if b_brake_actv, pbld, n$, *sb_brake_off, e$

      if g49_mode, pbld, n$, "G49", e$
      if g68_actv, pg68_off
      if nextop$ = 1003 & cuttype = five & lturret$, pbld, n$, "G5", "P0", e$
      if home_type = one,
        [
        pmap_home   #Get home position, xabs
        if frc_cinit, cabs = zero
        ps_inc_calc #Set inc.
        pbld, n$, psccomp, e$
        pcan1, pbld, n$, *sgcode, pfxout, pfyout, pfzout, pcrotretinc,
          [if not(g49_mode), *toolno], strcantext, e$
        if b_axis_mch, pbld, n$, pg28ref, pbrotretinc, e$
        pbld, n$, pnullstop, e$
        ]
      else,
        [
        #Retract to reference return
        pbld, n$, `sgcode, psccomp, e$
        if home_type = m_one & not(g49_mode), pbld, n$, *toolno, e$
        if end_w_g53,
          [
          pcan1, pbld, n$, "G53", "X0.", [if y_axis_mch, "Y0."], e$
          pbld, n$, "G53", "Z0.", pcrotretinc, pnullstop, strcantext, e$
          ]
        else,
          [
          pcan1, pbld, n$, *sg28ref, "U0.", [if y_axis_mch, "V0."], e$
          pbld, n$, *sg28ref, "W0.", pcrotretinc, pnullstop, strcantext, e$
          ]
        if first_tool$ <> t$,
          [
          #if home_type > m_one & not(g49_mode), pbld, n$, *toolno, e$
          ]
        ]

pget_tool  #Turret 1 on b Axis machine toolchange sequence
      pbld, n$, pg28ref, "U0.", [if y_axis_mch, "V0."], e$
      pbld, n$, pg28ref, "W0.", e$
      if sub_sp_mch, pbld, n$, pg28ref, "A0.", e$
      pbld, n$, *sg00, pb_tc_posn, pfbout, e$
      pbld, n$, "G30", "P3", [if y_axis_mch, "V0."], "W0.", e$
      pbld, n$, "G30", "P3", "U0.", e$
      pbld, n$, "M06", e$
      pbld, n$, pg28ref, "U0.", "W0.", e$
      pbld, n$, pg28ref, [if y_axis_mch, "V0."], e$
      pbld, n$, *sc_axis_off, e$

pb_tc_posn
      bsav = b_tc_posn
      pax_shift
      protary_mod

pg28ref         #Ouptut ref return
      if ref_ret < two, *sg28ref
      else, *sg30, *ref_ret

pwcs            #G54+ coordinate setting at toolchange

      if home_type > one,
        [
        sav_frc_wcs = force_wcs
        if sub_level$ > zero, force_wcs = zero
        if workofs$ <> prv_workofs$ | (force_wcs & toolchng),
          [
          if sub_level$, result = mprint(swrkserror)
          if workofs$ < 55,
            [
            if rot_BW = 2, g_wcs = 59
            else, g_wcs = 54
            *g_wcs
            ]
          else,
            [
            if rot_BW = 2, g_wcs = 59
            else, g_wcs = workofs$
            *g_wcs
            ]
          ]
        force_wcs = sav_frc_wcs
        !workofs$
        ]

#Rc1 is used to flag the SOF, rc1 = two at SOF
pcaxis_off_l    #Toolchange C axis disable, lathe, check prv_ to current
        if (rc1 = two | prv_posttype$ = one),
        [
        pbld, n$, *sc_axis_off, e$
        mill_on = 0
        ]



mill_on : 0
fmt "Fraisage" 4 mill_on


pcaxis_on_m     #Toolchange C axis enable, mill, check prv_ to current
      if (rc1 = two | prv_posttype$ = two),
        [
        if mill_on = 1, n$, "M46", e$
        if mill_on = 2, n$, "M246", e$
        pbld, n$, *sc_axis_on, e$
        if  spindle_no$ = 0,  mill_on = 1 # on a ecrit un M45
        else, mill_on = 2 # on a ecrit un M245
        if nextdc$ = three, pbld, n$, "M49", e$  #Disable tap
        ]

pcaxis_on_marche   # activation fraisage
        if  spindle_no$ = 0 & mill_on <> 1, n$, "M45",e$,    mill_on = 1 # on a ecrit un M45
        if  spindle_no$ <> 0 & mill_on <> 2, n$, "M245",e$,  mill_on = 2 # on a ecrit un M245

pcaxis_on_arret_chantoolnul   # arret fraisage

        if mill_on = 1 & spindle_no$ <> 0, n$, "M46", e$, mill_on = 0  # on a ecrit un M45
        if mill_on = 2 & spindle_no$ = 0, n$, "M246",e$, mill_on = 0 # on a ecrit un M245



pcaxis_on_arret   # arret fraisage
        if mill_on = 1, n$, "M46", e$  # on a ecrit un M45
        if mill_on = 2, n$, "M246",e$ # on a ecrit un M245
        mill_on = 0



pg68_on    #Turn On 3D Coordinate Conversion for B-Axis
      if braw | use_g68 = two,
        [
        pbld, n$, "G49", e$
        pbld, n$, *sg68on, *g68tox, *g68toy, *g68toz, "I0", "J1", "K0", *braw, e$
        if use_g43 >= posttype$, pbld, n$, *str_g43, *tlngno$, [if g43_b_out, pfbout], e$
        g68_actv = one
        ]


pg68_off   #Cancel 3D Coordinate Conversion
      pbld, n$, *sg68off, e$
      g68_actv = zero


# --------------------------------------------------------------------------
# Cutter Compensation / Spindle and Coolant output
# --------------------------------------------------------------------------
psccomp         #Output the cutter compensation based on the current plane
      if compok,
        [
        if plane$ = zero, sccomp
        if plane$ = one, sccomp1
        if plane$ = two, sccomp2
        if cc_pos$ & g41_d_out, tloffno$
        ]

plcc_cc_pos     #Position for lathe canned cycle cutter comp. enable
                #Position saved in prcc_setup
      pe_inc_calc   #Update previous
      copy_x = vequ(sav_xa)
      pcom_moveb    #Get machine position, set inc. from previous
      #Force comp from the finish profile
      compok = one
      cc_pos$ = n1_cc_pos
      if gcode$ = zero, prapidout
      else, plinout
      lcc_cc_pos = zero

pscool          #Coolant is seperate code
      if cool_w_spd = zero | cool_w_spd = two, scool2
      !coolant$, !cool_sel

pfscool         #Coolant is seperate code, force
      if cool_w_spd = zero | cool_w_spd = two, *scool2
      !coolant$, !cool_sel

pgear           #Use spindle gear range, find gear from RPM at X min.
      if use_gear = one,
        [
        if lathtype = zero | lathtype = two, x_min$ = c1_x_max
        else, x_min$ = c1_x_min
        x_min$ = x_min$ + c1_tox  #Correction for workshift
        if x_min$ = zero, x_min$ = 0.001
        if css_actv$ = zero, gear_spd = speedrpm
        else, gear_spd = (conversion * g_speed) / (pi$ * abs(x_min$) * two)
        gear = frange(one, gear_spd)
        *gear
        ]

plspindle       #Lathe spindle string select function branch on spindle
      if rigid_actv = one, *sm_rigid
      else,
        [
        if not(rigid_actv),
          [
          if spindle_no$ = zero, spindle_lm   #main
          else, spindle_ls                    #sub
          ]
        else, rigid_actv = zero
        ]

pmspindle       #Milling spindle string select function based on turret
      if rigid_actv = one, *sm_rigid
      else,
        [
        if not(rigid_actv),
          [
          if sync_drill, plspindle
          else,
            [
            if lturret$ = zero, spindle_ml    #lower
            else, spindle_mu                  #upper
            ]
          !css_actv$ #added for modality
          ]
        else, rigid_actv = zero
        ]

prpm            #Output for start spindle
      speed = speedrpm
      result = force(g_spdir, g_spdir)
      if sync_drill, pbld, n$, *sm_sync_drill, *m_speed, e$
      if posttype$ = two, *sg97, *speed, plspindle, pgear
      else,
        [
        if rigid_actv, *sg97, pmspindle, *speed
          else, *sg97, *speed, pmspindle
        ]

prpmnull       #Output for RPM at NULL tlchg (don't force spindle 'M' code)
      speed = speedrpm
      if posttype$ = two, *sg97, *speed, plspindle, pgear
      else, *sg97, *speed, pmspindle

pcssg50         #Output Constant surface speed clamp
      if css_actv$, *sg50, *maxss$

pcss            #Output Constant surface speed
      speed = g_speed
      if css_actv$, *sg9697, *speed, plspindle
      !speed

#Toolchange setup, spindle output, pspindle must be called first
pnullspindle  #Null toolchange and dwell spindle change, g_speed is input
      if prv_css_actv$<>css_actv$ | prv_g_spdir<>g_spdir
         | prv_speed<>g_speed,
        [
        #Switch G97/G96 or direction at null or dwell
        #Stop the spindle if direction changes
        if prv_g_spdir <> g_spdir,
          [
          pbld, n$, pnullstop, e$
          if posttype$ = two & c1_gcode = 1000, pbld, n$, *smlcut_dir, e$
          ]

        if css_actv$,
          [
          speed = g_speed
          pnullg50
          if prv_speed <> speed | prv_css_actv$<>css_actv$, pbld, n$, pcss, e$
          ]
        else,
          [
          if (prv_speed<>g_speed | prv_g_spdir<>g_spdir | prv_css_actv$<>css_actv$)
             & g_speed, pbld, n$, prpmnull, e$
          ]
        ]
      else, pnullg50

pnullg50      #Change G50 clamp speed at null or dwell
      if prv_maxss$ <> maxss$ & css_actv$, pbld, n$, pcssg50, e$

pnullstop     #Stop spindle at null, dwell or tool end
      sav_spdir = g_spdir
      if cool_w_spd = zero, g_spdir = one
      else, g_spdir = one + (fsg2(coolant$) * three)
      if rigid_actv, rigid_actv = m_one

      if posttype$ = two, plspindle
      else, pmspindle
      g_spdir = sav_spdir
      if sync_drill, #Turn off synchronous drilling
        [
        sync_drill = zero
        e$, pbld, n$, *sm_sync_drill, e$
        ]

pspindle        #Spindle speed calculations for RPM
      if abs(cuttype) = two & mr1$ & (opcode$ = three | opcode$ = 105) & fmtrnd(nextx$) = zero,
        [
        sync_drill = one
        css_actv$ = zero
        if mr1$ > one, mr1$ = mr1$ * 0.01
        else, mr1$ = abs(mr1$)
        m_speed = g_speed * mr1$
        g_speed = g_speed - m_speed
        ]
      else, sync_drill = zero
      if maxss$ = zero | maxss$ > max_speed, maxss$ = max_speed
      if css_actv$,
        [
        #Spindle speed calculations for strt_spd w/CSS
        speedx = abs(xa)
        if opcode$ = 104, speedx = abs(c1_x_min)
        if opcode$ = 105, speedx = abs(tcr$)
        if speedx < 0.001,speedx = 0.001
        speedrpm = (conversion * g_speed) / (pi$ * speedx * two)
        ]
      else, speedrpm = g_speed
      #zero indicates spindle off (not a mistake)
      if speedrpm,
        [
        if speedrpm > maxss$, speedrpm = maxss$
        if speedrpm < min_speed, speedrpm = min_speed
        ]
      #Spindle speed for RPM with lathe drill, thread
      if opcode$ = 104 | opcode$ = 105, css_actv$ = zero
      if css_actv$ = zero, g_speed = speedrpm

pset_g_speed    #Set the spindle control variables from the read variables
      g_speed = abs(ss$)
      if cool_w_spd, g_spdir = fsg3(spdir$) + (fsg2(coolant$) * 3)
      else, g_spdir = fsg3(spdir$)
      if spd_rev, pswtchspin

pswtchspin      #Reverse spindle direction
      if g_spdir > two, g_spdir = abs (g_spdir - five) + three
      else, g_spdir = abs (g_spdir - two)

preset_mod    #Reset the mode flags and map during motion blocks
      breakarcs$ = breakarcss
      cir_at_zero = zero
      linarc$ = zero
      brklinestype$ = zero
      if abs(cuttype) = two & c1_y_axis & fmtrnd(xa) = zero &
        fmtrnd(ya) = zero & millcc = zero,
        [
        #If milling over center set c1_y_axis = zero, brklinestype = 6,
        #linarc = one etc.
        rotary_type$ = two
        c1_y_axis = zero
        ]

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapidout       #Output to NC, linear movement - rapid
      pcan1, pbld, n$, psgplane, pexct, psgcode, psccomp, pxout, pyout,
        pzout, pcout, pbout, pscool, strcantext, e$
      prv_feed = -2  #Reinstate feedrate after rapid move

plinout         #Output to NC, linear movement - feed
      pcan1, pbld, n$, [if not(millcc = one & abs(cuttype) <> two & cutpos2$ < two), psgplane],
        sgfeed, pexct, psgcode, psccomp, pxout,
      pyout,  pzout, pcout, pbout, pfr, pscool, strcantext, e$

pcirout         #Output to NC, circular interpolation
      pcan1, pbld, n$, psgplane, sgfeed, pexct, psgcode, psccomp, pxout,
        pyout, pzout, pcout, pbout, parc, pfr, pscool, strcantext, e$

pl_ncoutput     #Movement output
      pcom_moveb    #Get machine position, set inc. from last position
      pcan
      c_rcc_setup$   #Save original in sav_xa and shift copy_x for LCC comp.
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      if lcc_cc_pos, plcc_cc_pos  #Use sav_xa to position with comp. LCC
      pcom_movea    #Update previous, pcan2

pm_ncoutput     #Movement output
      pcom_moveb    #Get machine position, set inc. from last position
      if c_clamp_actv, pbld, n$, sc_clamp, e$
      if b_clamp_actv, pbld, n$, sb_clamp, e$
      pcan
      pcindex
      pbindex
      ppos_cax_lin  #Position C axis, toolplane or CL
      if millcc, e$, pmillccb #Set mill conversion
      if gcode$ = zero, prapidout
      if gcode$ = one, plinout
      if gcode$ > one & gcode$ < four, pcirout
      if millcc & gcode$ <> zero, pmillcca #End mill conversion
      pcom_movea    #Update previous, pcan2
      ppos_pnt_zero #Update to detect point at zero


pdwl_spd$        #Output to NC, spindle, dwell changes
      pset_g_speed
      pspindle
      comment$
      pnullspindle
      pcan
      if fmtrnd(dwell$), pdwell1
      else, pcan1, pbld, n$, strcantext, e$
      pcan2

# --------------------------------------------------------------------------
# Drilling
# --------------------------------------------------------------------------
pdrill0$         #Pre-drill postblock call
      if cuttype = five, #Don't allow 5 axis, rests at toolchange
        [
        usecandrill$ = zero
        usecanpeck$  = zero
        usecanchip$  = zero
        usecantap$   = zero
        usecanbore1$ = zero
        usecanbore2$ = zero
        usecanmisc1$ = zero
        usecanmisc2$ = zero
        ]
      else,
        [
        if abs(c1_cuttype) < three, mdrl_dir = zero
        else,
          [
          if abs(c1_cuttype < five), mdrl_dir = one
          else, mdrl_dir = two
          ]

        #Update mdrl_dir to account for G68
        if g68_actv,
          [
          mdrl_dir = not(bzero_vert)
          ]

        x$ = xnci$
        y$ = ynci$
        z$ = refht$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        refht_x = vequ(xabs)
        z$ = depth$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        depth_x = vequ(xabs)
        z$ = zdrl$
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        zdrl_x = vequ(xabs)
        z$ = initht$  #Initial is last
        copy_x = vequ(x$)
        pshft_map_xa
        pxyzcout
        initht_x = vequ(xabs)
        znci$ = initht$
        ps_inc_calc
        ]

pdrlcommonb     #Canned Drill Cycle common call, before
      if gcode$ = 81,
        [
        if drillcyc$ = three, drlgsel = fsg1 (-g_speed) + drillcyc$ * two #Tap
        else, drlgsel = fsg2 (dwell$) + drillcyc$ * two
        if initht$ <> refht$, drillref = zero
        else, drillref = one
        prv_refht_a = c9k
        prv_refht_i = c9k
        prv_dwell$ = zero
        ]
      if mdrl_dir = zero, #Set Z to depth
        [
        zia = fmtrnd(depth_z)
        zinc = zia - prv_zia
        ]
      else,               #Set X to depth
        [
        xia = fmtrnd(depth_x)
        xinc = xia - prv_xia
        ]
      xabs = vequ (depth_x)
      comment$
      pcan
      if posttype$ <> two & gcode$ <> 81,  #(clamp is already on from toolchange)
        [
        if c_clamp_actv & cinc,
          [
          pbld, n$, pfc_clamp_off, e$
          pbld, n$, pfcout, e$
          pbld, n$, pfc_clamp_on, e$
          ]
        if c_brake_actv, pbld, n$, pfc_brake_on, e$
        if b_clamp_actv & binc,
          [
          pbld, n$, sb_clamp_off, e$
          pbld, n$, pfbout, e$
          pbld, n$, sb_clamp_on, e$
          ]
        if b_brake_actv, pbld, n$, sb_brake_on, e$
        ]
      if gcode$ = 81 & rigid_actv, prpm


pmdrlprep     #Mill Drill Preparatory move
      xabs = vequ(refht_x)
      if mdrl_dir = zero | (mdrl_dir = two & g68_actv = zero),
          [
          pbld, n$, *sg00, pfxout, pfyout, pcout, e$
          if rap_to_refht, pbld, n$, pfzout, e$
          ]
      if mdrl_dir = one | (mdrl_dir = two & g68_actv = one),
          [
          pbld, n$, *sg00, pfyout, pfzout, e$
          if rap_to_refht, pbld, n$, pfxout, e$
          ]

pmdrldepth
      if gcode$ = 81,
          [
          if mdrl_dir = zero | (mdrl_dir = two & use_g68 >= one & g68_actv),
              pxout, pyout, pfzout
          if mdrl_dir = one | (mdrl_dir = two & (use_g68 = zero | not(g68_actv))),
              pfxout, pyout, pzout
          ]
       else, pxout, pyout, pzout

pgdrlout        #Drill Gcode output (selector logic accounts for G68)
      if mdrl_dir = zero, *sgdrillf
      else, *sgdrillc

prdrlout        #R drill position
      #Refht is ALWAYS an incremental radial value
      refht_x = vsub(refht_x, initht_x)
      refht_x = refht_x / 2
      if mdrl_dir = zero, refht_a = refht_z
      else, refht_a = refht_x
      refht_i = refht$ - initht$
      refht_a, !refht_i

ldrill$          #Canned drill cycle, lathe
      #Use this postblock to customize lathe drilling cycles 0 - 7
      pdrlcommonb,e$
      "CUSTOMIZABLE DRILL CYCLE ", pfxout, pfyout, pfzout, e$
      pcom_movea

lpeck$           #Canned peck drill cycle, lathe
      ldrill$

lchpbrk$         #Canned chip break cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pcan1, pbld, n$, sgcode, pzout, strcantext,e$
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      if old_new_sw = one,
        [
        pbld, n$, *sg74, *peckclr$, e$
        result = nwadrs (strq, peck1$)
        ]
      else, result = nwadrs (strk, peck1$)
      pcan1, pbld, n$, *sg74, pfzout, *peck1$, pffr, strcantext, e$
      prv_gcode$ = m_one
      if refht$ <> initht$,
        [
        gcode$ = zero
        xabs = vequ(refht_x)
        ps_inc_calc
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        pbld, n$, sgcode, pfzout, e$
        ]
      pcom_movea

ltap$            #Canned tap cycle, lathe
      gcode$ = zero
      prv_dwell$ = zero
      @dwell$
      comment$
      pcan
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pcan1, pbld, n$, sgfeed, sgcode, pzout, strcantext, e$
      pe_inc_calc
      xabs = vequ(depth_x)
      ps_inc_calc
      opcode$ = 104 #thread address from feedrate
      pbld, n$, *sthdg32, pfzout, pffr, e$
      if dwell$, pdwell2
      pnullstop, e$
      pe_inc_calc
      xabs = vequ(refht_x)
      ps_inc_calc
      pswtchspin
      result = force(g_spdir, g_spdir)
      pbld, n$, pfzout, plspindle, e$
      prv_gcode$ = m_one
      pswtchspin
      if refht$ <> initht$,
        [
        gcode$ = zero
        pe_inc_calc
        xabs = vequ(initht_x)
        ps_inc_calc
        result = force(g_spdir, g_spdir)
        pbld, n$, pfzout, e$
        ]
      opcode$ = 81 #Restore opcode
      pcom_movea

lbore1$          #Canned bore #1 cycle, lathe
      ldrill$

lbore2$          #Canned bore #2 cycle, lathe
      ldrill$

lmisc1$          #Canned misc #1 cycle, lathe
      ldrill$

lmisc2$          #Canned misc #2 cycle, lathe
      ldrill$

mdrill$          #Canned drill cycle, mill
      #pmdrlprep          # mise en veille par ed suite prob avec ER
      pdrlcommonb,e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout, dwell$, pffr, strcantext, e$
      pcom_movea

mpeck$         #Canned peck drill cycle, mill
     # pmdrlprep
      pdrlcommonb,e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout, *peck1$, dwell$, pffr, strcantext, e$
      pcom_movea

mchpbrk$       #Canned chip break cycle, mill
      mpeck$

mtap$          #Canned rigid tap cycle, mill

      pdrlcommonb, e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout, dwell$, pffr, strcantext, e$
      pcom_movea

mbore1$        #Canned bore #1 cycle, mill
      #pmdrlprep
      pdrlcommonb,e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout, dwell$, pffr, strcantext, e$
      pcom_movea

mbore2$        #Canned bore #2 cycle, mill
      mdrill$

mmisc1$        #cycle alesage indexe
        dwell_2 = dwell$
      pdrlcommonb,e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout,shftdrl$, *dwell_2, pffr, strcantext, e$
      pcom_movea

mmisc2$        #Canned misc #2 cycle, mill
        pdrlcommonb,e$
      pcan1, pbld, n$, *sgdrlref, pgdrlout, pmdrldepth,
        pcout, pbout, prdrlout, *peck1$, dwell$, pffr, strcantext, e$
      pcom_movea

mdrill_2$      #Canned drill cycle repeat, mill
      pdrlcommonb,e$
      pcan1, pbld, n$, pmdrldepth, pcout, pbout, prdrlout,
      dwell$,
      pfr, strcantext, e$
      pcom_movea

mpeck_2$       #Canned peck drill cycle repeat, mill
      pdrlcommonb,e$
      pcan1, pbld, n$, pmdrldepth, pcout, pbout, prdrlout,
      dwell$, pfr, strcantext, e$
      pcom_movea

mchpbrk_2$     #Canned chip break cycle repeat, mill
      mdrill_2$

mtap_2$        #Canned tap cycle repeat, mill
      pdrlcommonb,e$
      pcan1, pbld, n$, pmdrldepth, pcout, pbout, prdrlout,
      dwell$,
      pfr, strcantext, e$
      pcom_movea

mbore1_2$      #Canned bore #1 cycle repeat, mill
      pdrlcommonb,e$
      pcan1, pbld, n$, pmdrldepth, pcout, pbout, prdrlout, dwell$,
      pfr, strcantext, e$
      pcom_movea

mbore2_2$      #Canned bore #2 cycle repeat, mill
      mdrill_2$

mmisc1_2$      #Canned misc #1 cycle repeat, mill
      pdrlcommonb,e$
      pcan1, pbld, n$, pmdrldepth, pcout, pbout, prdrlout,
      dwell$,
      pfr, strcantext, e$
      pcom_movea

mmisc2_2$      #Canned misc #2 cycle repeat, mill
      mpeck_2$

pdrlcst$         #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb,e$
      "CUSTOMIZABLE DRILL CYCLE ", pmdrldepth, pfcout, pfbout, e$
      pcom_movea

pdrlcst_2$       #Custom drill cycles 8 - 19 (user option)
      #Use this postblock to customize drilling cycles 8 - 19
      pdrlcommonb,e$
      "CUSTOMIZABLE DRILL CYCLE ", pmdrldepth, pfcout, pfbout, e$
      pcom_movea

pcanceldc$     #Cancel drill cycle
      xabs = vequ (initht_x) #Position to return
      ps_inc_calc
      pe_inc_calc #Update to current location
      gcode$ = zero
      pcan
      pcan1, pbld, n$, sgcode, "G80", strcantext, e$
      pbld, n$, *sg00, e$
      pcan2

# --------------------------------------------------------------------------
# Threading output
# --------------------------------------------------------------------------
pthread0$        #Pre-thread calculations
      # Calculate taper delta 'X' on Acceleration Clearance distance
      if spindle_no$, thdrdlt = (((thdx2$ - thdx3$) / abs(thdz2$ - thdz1$)) * thdzclr$)
        else, thdrdlt = (((thdx2$ - thdx3$) / abs(thdz1$ - thdz2$)) * thdzclr$)
      # Add to the original thread 'X' difference calculation
      thdrdlt = (thdrdlt + (thdx2$ - thdx3$)) * pl_ax_m0x
      thdang = rad2deg$ * thdangle$ * two
      thd_dirx = (thdx2$ - thdx3$) * pl_ax_m0x
      thd_dirz = (thdz1$ - thdz2$) * pl_ax_m0z
      thd_vlen = thdlead$/ nstarts$
      thd_dirx = vsa (thd_vlen, thd_dirx)
      if fr_pos$, pthreadpull
      else, thdpull = zero

pthreadpull     #Pre-thread calculations
      if thdpulloff$/(fr_pos$*10) > 0.99,thdpull = 99
      else, thdpull = (thdpulloff$/(fr_pos$*10))*100

pthdext$         #Calculation override for external thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthdint$         #Calculation override for internal thread
      #thddepth = thdlead * .54127         #Calc. thread depth
      #thdflat  = thdlead * .125           #Calc. thread flat

pthdface$        #Calculation override for face thread
      #thddepth = thdlead * .61343         #Calc. thread depth
      #thdflat  = thdlead * .1667          #Calc. thread flat

pthrg32_1$       #G32 threading first
      comment$
      gcode$ = zero
      lrapid$

pthrg32_2$       #G32 threading second
      gcode$ = zero
      lrapid$

pthrg32_3$       #G32 threading third
      copy_x = vequ(x$)
      pcom_moveb
      pcan1, pbld, n$, sgfeed, *sthdgcode, pxout, pyout, pzout, pcout, pbout, pffr,
      strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg32_4$       #G32 threading fourth
      gcode$ = zero
      lrapid$

pthrg92_1$       #G92 threading
      if thdpass$ = one, pthrg92_11

pthrg92_11      #G92 threading
      comment$
      gcode$ = zero
      lrapid$
      prv_feed = m_one
      prv_zabs = c9k
      prv_thdtype$ = m_one
      prv_thd_shft_ang = m_one

pthrg92_2$       #G92 threading


pthrg92_3$       #G92 threading
      copy_x = vequ (x$)
      pcom_moveb
      if nstarts$ = one, thd_shft_ang = zero
        else, thd_shft_ang = (360 / nstarts$) * 1000
      pcan1, pbld, n$, sgfeed, sthdgcode, pxout, pyout, pzout, pcout, pbout,
        [if thdrdlt & thdpass$ = one, *thdrdlt], pfr, [if thd_shft_ang & thdpass$ = one, *thd_shft_ang], strcantext, e$
      pcom_movea
      prv_gcode$ = m_one

pthrg92_4$       #G92 threading

pg32e$           #G32/G92 threading end
      gcode$ = zero
      lrapid$

pthrg76_1$       #G76 threading start point
      gcode$ = zero
      lrapid$

pg76$            #G76 threading
      comment$
      gcode$ = zero
      lrapid$
      sav_xa = vequ(copy_x)
      if thdface$ = zero, copy_x = thdx2$
      else, copy_z = thdx2$
      if thdface$ = zero, copy_z = thdz2$
      else, copy_x = thdz2$
      pcom_moveb
      nstart_cnt = zero
      while nstart_cnt < nstarts$, pg76nstart
      pcom_movea
      prv_gcode$ = m_one
      copy_x = vequ(sav_xa)
      copy_x = copy_x + (thd_dirx * (nstarts$ - one))
      copy_z = copy_z + (thd_dirz * (nstarts$ - one))
      pcom_moveb
      pe_inc_calc
      !gcode$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc

pg76nstart      #G76 threading, for multiple starts
      if old_new_sw = zero, pg76old
      else, pg76new
      nstart_cnt = nstart_cnt + one
      if nstarts$ <> one & nstart_cnt <> nstarts$,
      pbld, n$, *sgcode, thd_dirx, thd_dirz, e$

pg76old         #G76 threading old style
      pbld, n$, *sthdgcode, pfxout, pfzout, *thdrdlt, *thddepth$,
        *thdfirst$, *thdang, pffr, e$

pg76new         #G76 threading new style
      pbld, n$, *sthdgcode, *nspring$, *thdpull, *thdang, [if thdlast$, *thdlast$],
        [if thdfinish$, *thdfinish$], e$
      pbld, n$, *sthdgcode, pfxout, pfzout, [if thddepth$, *thddepth$], [if thdfirst$, *thdfirst$],
        [if thdrdlt, *thdrdlt], pffr, e$

# --------------------------------------------------------------------------
# Lathe canned cycle output
# --------------------------------------------------------------------------
pg71old         #Output G71-G72 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc,
        *depthcc, pffr, e$

pg71new         #Output G71-G72 canned cycle routines, new style, first
      if gcodecc = one, result = nwadrs (stru, depthcc)
      else, result = nwadrs (strw, depthcc)
      pbld, n$, *scclgcode, *depthcc, *clearcc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg73old         #Output G73 canned cycle routines, old style
      pbld, n$, *scclgcode, *ng70s, *ng70e, *g73x, *g73z,
        *xstckcc, *zstckcc, *ncutscc, pffr, e$

pg73new       #Output G73 canned cycle routines, new style, first
      pbld, n$, *scclgcode, *g73x, *g73z, *ncutscc, e$
      pbld, n$, *scclgcode, *ng70s, *ng70e, *xstckcc, *zstckcc, pffr, e$

pg74old         #Output G74-G75 canned cycle routines, old style
      pbld, n$, *scclgcode, pfxout, pfzout, *grvspcc, *grvdpcc,
        *clearcc, pffr, e$

pg74new         #Output G74-G75 canned cycle routines, new style, first
      backoff = mr2$
      pbld, n$, *scclgcode, *clearcc, e$
      pbld, n$, *sgfeed, *scclgcode, pfxout, pfzout, [if grvspcc, *grvspcc],
        [if grvdpcc, *grvdpcc], [if backoff, *backoff], pffr, e$

prcc_setup$      #Lathe canned cycle setup
                #Capture values from rough
      sav_iprcc = c1_ipr_actv
      sav_feedcc = c1_fr_pos
      if orient$ = one|orient$ = two|orient$ = five|orient$ = six, lccdirx = one
      else, lccdirx = m_one
      if orient$ = one|orient$ = four|orient$ = five|orient$ = eight, lccdirz = one
      else, lccdirz = m_one
      if lathecc > zero, cc_stop_fcc = one
      else, cc_stop_fcc = zero
      #G74/G75
      if lathecc = three,
        [
        lcc_xcst = vequ (copy_x)
        if dopeckcc = zero,
          [
          depthcc = zero
          clearcc = zero
          ]
        if directcc > one,
          [
          gcodecc = four
          grvspcc = stepcc * 1000
          grvdpcc = depthcc * 1000
          ]
        else,
          [
          gcodecc = five
          grvspcc = depthcc * 1000
          grvdpcc = stepcc * 1000
          ]
        ]
      else,
        [
        if n1_cc_pos,
          [
          sav_xa = vequ(copy_x)
          #Shift for cutter comp. start position
          copy_x = copy_x + (lcc_move * lccdirx)
          copy_z = copy_z + (lcc_move * lccdirz)
          pcom_moveb
          compok = zero
          lcc_cc_pos = one
          ]
        else, lcc_cc_pos = zero
        ]
      sub_seq_typ$ = zero

prcc_call_st$    #Rough canned cycle start
      if tool_op$ <> 208,
        [
        sav_subout = subout$
        sav_omitsq = omitseq$
        omitseq$ = one
        extprg$ = one
        subout$ = three
        prv_gcode$ = m_one #Added (06/25/01)
        ]

prcc_call_end$   #Rough canned cycle end
      if tool_op$ <> 208,
        [
        omitseq$ = sav_omitsq
        #Close the ext file
        result = fclose (sbufname3$)
        #Open the ext file as a buffer
        #Use the size to determine the start and end sequence
        subout$ = sav_subout
        size3 = rbuf(three, zero)
        if omitseq$ = one,
          [
          ng70s = n$
          ng70e = n$ + seqinc$
          ]
        else,
          [
          if old_new_sw = zero, ng70s = n$ + seqinc$
          else, ng70s = n$ + (seqinc$ * two)
          ng70e = ng70s + (seqinc$ * (size3 - one))
          ]
        pwrite_g70
        ]
      #Setup the stock and clearance directions
      g73x = sin(anglelcc * rad2deg$) * (ncutslcc-1) * depthcc + xstckcc
      g73z = cos(anglelcc * rad2deg$) * (ncutslcc-1) * depthcc + zstckcc

      if old_new_sw = zero, g73x = g73x * pl_ax_m0x
      #Uncomment next line for U in diameter on first G73 line
      #else, g73x = g73x * dia_mult
      g73z = g73z * pl_ax_m0z
      xstckcc =  xstckcc * dia_mult * lccdirx
      zstckcc =  zstckcc * lccdirz * pl_ax_m0z
      clearcc =  clearcc * pl_ax_m0z
      #Write the cycle definition
      sav_feed = feed
      sav_ipr = ipr_actv$
      feed = sav_feedcc
      ipr_actv$ = sav_iprcc
      if lathecc = three,
        [
        #Setup the previous position for inc. in G74/G75 cycle
        sav_xa = vequ(xabs) #Save the cycle end
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Recalculate incremental
        pe_inc_calc #Update previous at start
        xabs = vequ(sav_xa) #Restore the cycle end
        ps_inc_calc #Recalculate incremental
        ]
      if old_new_sw = zero,
        [
        if gcodecc < three, pg71old
        if gcodecc = three, pg73old
        if gcodecc > three, pg74old
        ]
      else,
        [
        if gcodecc < three, pg71new
        if gcodecc = three, pg73new
        if gcodecc > three, pg74new
        ]
      if lathecc = three,
        [
        #Set the cycle end position at the original start
        copy_x = vequ(lcc_xcst) #The cycle start raw
        pshft_map_xa
        pxyzcout  ##The cycle start in machine terms
        ps_inc_calc #Position at start
        pe_inc_calc #Update previous
        ps_inc_calc #Recalculate incremental
        ]
      feed = sav_feed
      ipr_actv$ = sav_ipr
      if tool_op$ <> 208,
        [
        #Bug2 is off to prevent execution crashes with long strings
        bug2$ = zero
        #Write the cycle profile, sequence are written now
        rc3 = one
        while rc3 <= size3,
          [
          #Write the lathe canned cycle profile
          string3 = rbuf (three, rc3)
          if rc3 = two,
            [
            #Add the finish spindle speed to the first move
            speed = n1_ss
            pbld, *n$, *string3, *speed, e$
            ]
          else,
            [
            if omitseq$ = one & rc3 = size3 + one, pbld, *n$, *string3, e$
            else, pbld, n$, *string3, e$
            ]
          ]
        #Close the buffer
        result = fclose (three)
        #Remove the ext file
        result = remove (sbufname3$)
        bug2$ = sav_bug2
        ]

pfcc_call$       #G70 recall output postblock
      if cc_stop_fcc = zero,
        [
        pread_g70
        if foundcc = zero, result = mprint(sfccerror)
        ]
      no_nc_out$ = zero
      cc_stop_fcc = zero

pread_g70       #Read G70 recall buffer
      foundcc = zero
      size2 = rbuf (two, zero)
      wc2 = one
      while wc2 <= size2 & foundcc = zero,
        [
        fcc_subid = rbuf (two, wc2)
        if fcc_subid = sub_op_id$,
          [
          gcodecc = zero
          ng70s = fcc_ng70s
          ng70e = fcc_ng70e
          pbld, n$, *scclgcode, *ng70s, *ng70e, e$
          foundcc = one
          ]
        ]

pwrite_g70      #Write G70 recall buffer
      fcc_subid = sub_op_id$
      fcc_ng70s = ng70s
      fcc_ng70e = ng70e
      fcc_subid = wbuf (two, rc2)

# --------------------------------------------------------------------------
#Subprogram output
#sub_trnstyp - 0=mirror, 1=rotate, 2=scale, 3=translate
#sub_trnmthd (mirror) - 0=X axis, 1=Y axis, 2=line
#sub_trnmthd (rotate) - 0=tplane, 1=tplane origin only, 2=coordinates
# --------------------------------------------------------------------------
pmiscint$        #Capture the top level absinc for subprograms
      mi3$ = 0
      if sub_level$ <= zero, absinc$ = mi2$
      ref_ret = mi3$
      if mi5$ = one | mi5$ = three, c_clamp_actv = one
      else, c_clamp_actv = zero
      if mi5$ = two | mi5$ = three, c_brake_actv = one
      else, c_brake_actv = zero
      if mi6$ = one | mi6$ = three, b_clamp_actv = one
      else, b_clamp_actv = zero
      if mi6$ = two | mi6$ = three, b_brake_actv = one
      else, b_brake_actv = zero

psub_call_m$     #Call to main level, single tool
      psub_call_trans

psub_call_mm$    #Call to main level, multiple tools
      psub_call_trans

psub_call_trans #Translate level calls from toolchange, user
      #Mirror and coordinate rotate subs not allowed with lathe
      if sub_trnstyp$ <> three & posttype$ = two, result = mprint(slthrmerror)
      if (sub_trnstyp$ = one & sub_trnmthd$ = two)
      | sub_trnstyp$ = zero, result = mprint(smilrmerror)
      sav_absinc = absinc$
      pcindex
      pbindex
      if home_type > one,
        [
        if sub_mny_t$,
          [
          absinc$ = zero
          pbld, n$, *sgcode, pwcs, pfxout, pfyout, pfzout, pfcout, pfbout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      else,
        [
        if home_type = one, result = mprint(shomeserror)
        else,
          [
          if sub_mny_t$, result = mprint(smny50error)
          ]
        #Apply G50 shift and correct incremental position
        if sub_sec_no$ & sub_trnstyp$ = three,
          [
          sub_trnsx$ = vmap(sub_trnsx$, hmtx1)
          sub_trnsx$ = vscl(m_one, sub_trnsx$)
          sub_trnsx$ = sub_trnsx$ * dia_mult
          sub_trnsy$ = sub_trnsy$ * y_mult
          sub_trnsz$ = sub_trnsz$ * z_mult
          pbld, n$, *sg50, *sub_trnsx$, [if y_axis_mch, *sub_trnsy$],
            *sub_trnsz$, e$
          prv_xia = vadd(prv_xia, sub_trnsx$)
          ps_inc_calc
          ]
        if toolchng = zero | home_type < two,
          [
          pbld, n$, *sgcode, pfxout, pfyout, pfzout, pfcout, pfbout, e$
          pe_inc_calc
          ps_inc_calc
          ]
        ]
      absinc$ = sav_absinc
      result = nwadrs(strp, main_prg_no$)
      pbld, n$, "M98", *main_prg_no$, e$
      prv_feed = c9k #Force feed in sub

psub_st_m$       #Header in main level
      result = nwadrs(stro, main_prg_no$)
      " ", e$
      *main_prg_no$, e$

psub_end_m$      #End in main level
      n$, "M99", e$

psub_call_s$     #Call to sub level
      if tool_op$ = 201,  pread_g70
      else, foundcc = zero

      if foundcc = zero,
        [
        result = nwadrs(strp, sub_prg_no$)
        sub_prg_no$ = sub_prg_no$ + 1000 #Add sub number offset
        pbld, n$, "M98", *sub_prg_no$, e$
        ]

psub_st_s$       #Header in sub leveln
      result = nwadrs(stro, sub_prg_no$)
      " ", e$
      *sub_prg_no$, e$

psub_end_s$      #End in sub level
      n$, "M99", e$

# --------------------------------------------------------------------------
# Canned Text
# --------------------------------------------------------------------------
pcan          #Canned text - before output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = zero, pcant_1
        if cant_pos2$ = zero, pcant_2
        if cant_pos3$ = zero, pcant_3
        if cant_pos4$ = zero, pcant_4
        if cant_pos5$ = zero, pcant_5
        if cant_pos6$ = zero, pcant_6
        if cant_pos7$ = zero, pcant_7
        if cant_pos8$ = zero, pcant_8
        if cant_pos9$ = zero, pcant_9
        if cant_pos10$ = zero, pcant_10
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1         #Canned text - with move
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = one, pcant_1
        if cant_pos2$ = one, pcant_2
        if cant_pos3$ = one, pcant_3
        if cant_pos4$ = one, pcant_4
        if cant_pos5$ = one, pcant_5
        if cant_pos6$ = one, pcant_6
        if cant_pos7$ = one, pcant_7
        if cant_pos8$ = one, pcant_8
        if cant_pos9$ = one, pcant_9
        if cant_pos10$ = one, pcant_10
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan2         #Canned text - after output call
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two, pcant_1
        if cant_pos2$ = two, pcant_2
        if cant_pos3$ = two, pcant_3
        if cant_pos4$ = two, pcant_4
        if cant_pos5$ = two, pcant_5
        if cant_pos6$ = two, pcant_6
        if cant_pos7$ = two, pcant_7
        if cant_pos8$ = two, pcant_8
        if cant_pos9$ = two, pcant_9
        if cant_pos10$ = two, pcant_10, e$
        pbld, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1       #Canned text - output call
      cantext$ = cant_val1$
      pcant_out

pcant_2       #Canned text - output call
      cantext$ = cant_val2$
      pcant_out

pcant_3       #Canned text - output call
      cantext$ = cant_val3$
      pcant_out

pcant_4       #Canned text - output call
      cantext$ = cant_val4$
      pcant_out

pcant_5       #Canned text - output call
      cantext$ = cant_val5$
      pcant_out

pcant_6       #Canned text - output call
      cantext$ = cant_val6$
      pcant_out

pcant_7       #Canned text - output call
      cantext$ = cant_val7$
      pcant_out

pcant_8       #Canned text - output call
      cantext$ = cant_val8$
      pcant_out

pcant_9       #Canned text - output call
      cantext$ = cant_val9$
      pcant_out

pcant_10      #Canned text - output call
      cantext$ = cant_val10$
      pcant_out

pcant_out     #Canned text - final output call
      #Assign string select global variables
      if cantext$ = three, bld = one
      if cantext$ = four, bld = zero
      if cantext$ = nine, exact = one
      if cantext$ = ten, exact = zero
      #Build the cantext string from strings
      if cantext$ = one, strcantext = strcantext + sm00
      if cantext$ = two, strcantext = strcantext + sm01
      #Build the cantext string from string selects
      if cantext$ = five | cantext$ = six,
        [
        if cantext$ = five, tlstk = zero
        else, tlstk = one
        rslt_upd = updstr (stlstk)
        strcantext = strcantext + stlstk
        ]
      if cantext$ = seven | cantext$ = eight,
        [
        if cantext$ = seven, chute = zero
        else, chute = one
        rslt_upd = updstr (schute)
        strcantext = strcantext + schute
        ]
      #Build the cantext string from cantext number
      if cantext$ > ten,
        [
        strtextno = no2str(cantext$)
        strcantext = strcantext + strm + strtextno
        ]

# --------------------------------------------------------------------------
# Version 9+ MiscOps Section
# --------------------------------------------------------------------------
#Miscellaneous Variables Common to all Miscops operations
#Format as needed

#Integers
#miscops_mi1, miscops_mi2, miscops_mi3,
#miscops_mi4,  miscops_mi5, miscops_mi6,
#miscops_mi7, miscops_mi8, miscops_mi9,
#miscops_mi10

#Reals
#miscops_mr1, miscops_mr2, miscops_mr3,
#miscops_mr4, miscops_mr5, miscops_mr6,
#miscops_mr7, miscops_mr8, miscops_mr9,
#miscops_mr10
#
# --------------------------------------------------------------------------
#Format Assignments and Initializations
# --------------------------------------------------------------------------
fmt "Z" 2 stck_init_z$           #Initial Z position of the stock (900-902,904,905)
fmt "V" 2 stck_final_z$          #Final Z position of the stock (900-902,904,905)
fmt "A" 2 stck_chuk_st_z$        #Initial Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_st_x$        #Initial X axis Chuck Position (900-903)
fmt "A" 2 stck_chuk_end_z$       #Final Z axis Chuck Position (900-903)
fmt "X" 2 stck_chuk_end_x$       #Final X axis Chuck Position (900-903)
fmt "W" 3 stck_chuk_st_dz$       #Destination chuck Z axis reference position before transfer (900)
fmt "U" 3 stck_chuk_st_dx$       #Destination chuck X axis reference position before transfer (900)
fmt "W" 3 stck_chuk_end_dz$      #Destination chuck Z axis reference position after transfer (900)
fmt "U" 3 stck_chuk_end_dx$      #Destination chuck X axis reference position after transfer (900)
fmt "Z" 2 stck_clear$            #Stock clearance value for stock pull operation (902)
fmt "X" 2 stck_tool_x$           #Tool X axis position for bar stop / puller (902)
fmt "Z" 2 stck_grip$             #Grip length value for stock pull operation(902)

fmt "F" 18 stk_adv_fr            #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902).
fmt "F" 18 stck_appr_fr$         #Used with Lathe Stock Advance (Bar-Feed/Pull) function (NCI 902)

#Flags
stck_op$         : 0             #Stock advance operation method (902)
                                 #(0=Push stock,1=Push stock with Use Tool Stop option,2=Pull stock)
stck_spindle$    : 0             #Active spindle with stock to transfer (900-902)
                                 #0=Left Spindle,1=Right Spindle
clmp_op$         : 0             #The selected Operation mode: 0=Clamp,1=Un-clamp,2=Re-position (903)
clmp_spindle$    : 0             #Active spindle for clamp/unclamp 0=Left Spindle,1=Right Spindle (903)
tlstck_on$       : 0             #Retract or engage the tailstock (0=Retract,1=Engage) (904)

toolend_flg      : 1             #Flag to execute ptoolend sequence or not

main_sub         : 0             #Transfer Direction

# --------------------------------------------------------------------------
#Postblock Section
# --------------------------------------------------------------------------
pstck_trans$    #NCI code = 900 available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_chuk_st_dz, stck_chuk_st_dx,
      #stck_chuk_end_dz, stck_chuk_end_dx
      if toolchng <> two, ptoolend$
      toolend_flg = zero  #Do not execute ptoolend again after xfer
      if stck_spindle$ = zero, [main_sub = one,  "(PART TRANSFER FROM MAIN SPINDLE)", e$]
      if stck_spindle$ = one,  [main_sub = m_one, "(PART TRANSFER FROM SUB SPINDLE)",  e$]
      pbld, n$, "G00", "M05", e$
      pbld, n$, "M09", e$
      if lturret$ = one,
        [
        pbld, n$, "G49", e$
        pbld, n$, "G98", "G18", "M46", e$
        pbld, n$, "M436", e$
        ]
      pbld, n$, "G59", e$                                                   #G59 outputs as a comment block
      if stck_spindle$ = zero, [pbld, n$, "M211", e$]                       #Chuck (Sub SP)  Open
      if stck_spindle$ = one, [pbld, n$, "M11",  e$]                        #Chuch (Main SP) Open
      pbld, n$, "G28", "U0.", [if lturret$, "V0."], e$                      #X Y Return to Home
      pbld, n$, "G28", "W0.", e$                                            #Z   Return to Home
      if lturret$ = one, [pbld, n$, "G00", pb_tc_posn, pfbout, e$]          #B   Index to -90.
      pbld, n$, "M51", e$                                                   #Air blow (main) ON
      pbld, n$, "M251", e$                                                  #Air blow (sub)  ON
      pbld, n$, "M35", e$                                                   #Speed Synchronized Operation Mode
      pbld, n$, "G97", "S100", "M03", e$                                    #Constant Spindle Speed Mode, S100, normal
      pbld, n$, "M79", e$                                                   #Unclamp A-axis
      if met_tool$ = zero, stck_chuk_st_z$ = main_sub * stck_chuk_end_z$ + chuck_appr_dist_inch
      if met_tool$ = one, stck_chuk_st_z$ = main_sub * stck_chuk_end_z$ + chuck_appr_dist
      pbld, n$, "G00", *stck_chuk_st_z$, e$                                 #Repid move
      if met_tool$ = zero,
        [
        stck_chuk_end_z$ = main_sub * stck_chuk_end_z$ + chuck_feed_dist_inch
        stck_appr_fr$ = chuck_appr_feed_inch
        ]
      if met_tool$ = one,
        [
        stck_chuk_end_z$ = main_sub * stck_chuk_end_z$ + chuck_feed_dist
        stck_appr_fr$ = chuck_appr_feed
        ]
      pbld, n$, "G98", "G01", *stck_chuk_end_z$, *stck_appr_fr$, e$         #Cutting Feed move
      pbld, n$, "M59", e$                                                   #Air blow (main) OFF
      pbld, n$, "M259", e$                                                  #Air blow (sub)  OFF
      if met_tool$ = zero, stck_chuk_end_z$ = stck_chuk_end_z$ - chuck_feed_dist_inch
      if met_tool$ = one, stck_chuk_end_z$ = stck_chuk_end_z$ - chuck_feed_dist
      pbld, n$, "G38", *stck_chuk_end_z$, "K0.", *stck_appr_fr$, "Q0.1", e$ #Puch Check
      pbld, n$, "G04 U1.0", e$                                              #Dwell
      if stck_spindle$ = zero, [pbld, n$, "M210", e$]                       #Chuck (Sub SP)  Close
      if stck_spindle$ = one, [pbld, n$, "M10",  e$]                        #Chuch (Main SP) Close
      pbld, n$, "G04 U1.0", e$                                              #Dwell
      if stck_spindle$ = zero, [pbld, n$, "M11",  e$]                       #Chuck (Main SP) Open
      if stck_spindle$ = one, [pbld, n$, "M211", e$]                        #Chuch (Sub SP)  Open
      pbld, n$, "G04 U1.0", e$                                              #Dwell
      pbld, n$, "G01", *stck_chuk_st_z$, *stck_appr_fr$, e$                 #Pull
      pbld, n$, "M36", e$                                                   #Cancel Speed/Phase Sync. Operation Mode
      pbld, n$, "G28 A0.", e$                                               #A axis - Return to Home
      pbld, n$, "M01", "(END OF TRANSFER OPERATION)", e$

pstck_flip$      #NCI code = 901 available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x
      if toolchng <> two, ptoolend$
      toolend_flg = zero  #Do not execute ptoolend again after xfer
      pbld, n$, "M00", "(FLIP STOCK)", e$


pstck_bar_fd$    #NCI code = 902 available variables:
      #stck_spindle, stck_op, stck_clear,
      #stck_grip, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x
      if toolchng <> two, ptoolend$
      toolend_flg = zero  #Do not execute ptoolend again after xfer
        [
        if stck_op$ = zero, "(PUSH STOCK -",e$
        if stck_op$ = one, "(PUSH STOCK WITH USE TOOL STOP OPTION -",e$
        if stck_op$ = two, "(PULL STOCK -",e$
        if stck_spindle$ = zero, "FROM LEFT SPINDLE)", e$
        if stck_spindle$ = one, "FROM RIGHT SPINDLE)", e$
        ]
      #pbld, n, "M70", e

pchuck$          #NCI code = 903 available variables:
      #clmp_spindle, clmp_op,  stck_chuk_st_z,
      #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
      if clmp_op$ = two,
        [
        if toolchng <> two, ptoolend$
        toolend_flg = zero  #Do not execute ptoolend again after xfer
        ]
      [ #Make user-defined to concatenate strings
      if clmp_op$ = zero, "(CLAMP - ",e$
      if clmp_op$ = one, "(UN-CLAMP - ",e$
      if clmp_op$ = two, "(RE-POSITION -",e$
      if clmp_spindle$ = zero, "LEFT SPINDLE)", e$
      if clmp_spindle$ = one, "RIGHT SPINDLE)", e$
      ]
      if clmp_op$ >= one, pchuck_unclamp
      if clmp_op$ = two, pbld, n$, *stck_chuk_end_z$, e$
      if clmp_op$ = zero | clmp_op$ = two, pchuck_clamp

pchuck_clamp    #user-defined postblock for chuck clamp
      if clmp_spindle$ = zero, "M10", e$
      if clmp_spindle$ = one, "M210", e$

pchuck_unclamp  #user-defined postblock for chuck unclamp
      if clmp_spindle$ = zero, "M11", e$
      if clmp_spindle$ = one, "M211", e$

ptailstock$      #NCI code = 904 available variables:
      #tlstck_on, stck_init_z, stck_final_z
      if toolchng <> two, ptoolend$
      toolend_flg = zero  #Do not execute ptoolend again after xfer
      if tlstck_on$ = zero,
        [
        pbld, n$, *sm26, "(RETRACT TAILSTOCK)", e$
        ]
      else,
        [
        dwell$ = 0.5
        pbld, n$, *sm26, "(RETRACT TAILSTOCK)", e$
        #pbld, n, "M79", "(UN-CLAMP TAILSTOCK)", e
        pbld, n$, "G479", "Q1", *stck_final_z$, "(REPOSITION)", e$
        #pbld, n, "M78", "(CLAMP TAILSTOCK)", e
        pbld, n$, *sm25, "(ENGAGE TAILSTOCK)", e$
        pbld, n$, "G04", *dwell$, e$
        ]

psteadyrest$     #NCI code = 905 available variables:
      #stck_init_z, stck_final_z
      if toolchng <> two, ptoolend$
      toolend_flg = zero  #Do not execute ptoolend again after xfer
      dwell$ = 0.5
      pbld, n$, "M340", "(OPEN)", e$
      #pbld, n, "M79", "(UN-CLAMP STEADYREST)", e
      pbld, n$, "G479", "Q2", *stck_final_z$, "(POSITION STEADYREST)", e$
      #pbld, n, "M78", "(CLAMP STEADYREST)", e
      pbld, n$, "M341", "(CLOSE)", e$
      pbld, n$, "G04", *dwell$, e$

# --------------------------------------------------------------------------
# NCI file pre-read look ahead routines
# Build the toolchange buffer, sets cycle and turret flags
# --------------------------------------------------------------------------
pparameter$      #Information from parameters
      if prmcode$ = 10000, stoper = sparameter$
      if prmcode$ = 20007 & use_tlength = one,
        [
        v1 = rpar(sparameter$, 3)
        toollength = v3
        ]
      if prmcode$ = 20100,
        [
        v1 = rpar(sparameter$, 5)
        tool_ang = v5
        ]
      if prmcode$ = 20111, orient01 = rpar(sparameter$, 14)
      if prmcode$ = 20103, stinsert2 = sparameter$
      result = fprm (abs(lathecc))

pwrttparam$      #Information from parameters
      if opcode$ = 104, result = fprm (opcode$)

pwrtt$           #Buffer toolchange information, tooltable = 3 calls on 1003
      if use_only_tl,
        [
        lturret$ = one
        spindle_no$ = zero
        lathtype = one
        ]
      if gcode$ > 1000 & gcode$ <> 1003, pwrite_toolbuf
      if gcode$ = 1001, psetup
      pcut_cctyp
      if opcode$=104 | opcode$=105 | opcode$=three | opcode$=16, cc_pos$ = zero
      if gcode$ <> 1001, plast_recd
      pcur_recd
      if gcode$ <> 1003, cc_pos$ = zero
      !opcode$, !tool_op$
      if list_tools <> zero & t$ > zero & gcode$ <> 1003, ptoolcomment
      if gcode$ = 1003,
        [
        size1 = rbuf (one, zero)
        rc1 = one
        if rc1 < size1, preadcur_nxt
        if cc_1013$ = zero, cc_pos$ = zero
        ]

# --------------------------------------------------------------------------
# Buffer definitions
# --------------------------------------------------------------------------
#Buffer 1, toolchange information
wc1           : 1       #Initial count for write buffer 1
rc1           : 1       #Initial count for read buffer 1
nc1           : 2       #Initial count for read buffer 1 into next record
size1         : 0       #Buffer 1 size

# Current tool information
c1_gcode      : 0       #Buffer 1
c1_xh         : 0       #Buffer 1
c1_yh         : 0       #Buffer 1
c1_zh         : 0       #Buffer 1
c1_tox        : 0       #Buffer 1
c1_toy        : 0       #Buffer 1
c1_toz        : 0       #Buffer 1
c1_cc_pos     : 0       #Buffer 1
c1_tool       : 0       #Buffer 1
c1_tloffno    : 0       #Buffer 1
c1_maxss      : 0       #Buffer 1
c1_ss         : 0       #Buffer 1
c1_spdir      : 0       #Buffer 1
c1_css_actv   : 0       #Buffer 1
c1_fr_pos     : 0       #Buffer 1
c1_ipr_actv   : 0       #Buffer 1
c1_coolant    : 0       #Buffer 1
c1_nextdc     : 0       #Buffer 1
c1_posttype   : 0       #Buffer 1
c1_cuttype    : 0       #Buffer 1
c1_lathtype   : 0       #Buffer 1
c1_gcodecc    : 0       #Buffer 1
c1_lathecc    : 0       #Buffer 1
c1_millcc     : 0       #Buffer 1
c1_y_axis     : 0       #Buffer 1
c1_x_min      : 0       #Buffer 1
c1_x_max      : 0       #Buffer 1

# Next tool information
n1_gcode      : 0       #Buffer 1
n1_xh         : 0       #Buffer 1
n1_yh         : 0       #Buffer 1
n1_zh         : 0       #Buffer 1
n1_tox        : 0       #Buffer 1
n1_toy        : 0       #Buffer 1
n1_toz        : 0       #Buffer 1
n1_cc_pos     : 0       #Buffer 1
n1_tool       : 0       #Buffer 1
n1_tloffno    : 0       #Buffer 1
n1_maxss      : 0       #Buffer 1
n1_ss         : 0       #Buffer 1
n1_spdir      : 0       #Buffer 1
n1_css_actv   : 0       #Buffer 1
n1_fr_pos     : 0       #Buffer 1
n1_ipr_actv   : 0       #Buffer 1
n1_coolant    : 0       #Buffer 1
n1_nextdc     : 0       #Buffer 1
n1_posttype   : 0       #Buffer 1
n1_cuttype    : 0       #Buffer 1
n1_lathtype   : 0       #Buffer 1
n1_gcodecc    : 0       #Buffer 1
n1_lathecc    : 0       #Buffer 1
n1_millcc     : 0       #Buffer 1
n1_y_axis     : 0       #Buffer 1
n1_x_min      : 0       #Buffer 1
n1_x_max      : 0       #Buffer 1

fbuf 1 0 27 0 0         #Buffer 1
# --------------------------------------------------------------------------
#Buffer 2, recall lathe canned turning cycle line numbers
wc2           : 1       #Initial count for write buffer 2
rc2           : 1       #Initial count for read buffer 2
size2         : 0       #Buffer 2 size

fcc_subid     : 0       #Buffer 2
fcc_ng70s     : 0       #Buffer 2
fcc_ng70e     : 0       #Buffer 2

fbuf 2 0 3 0 0          #Buffer 3
# --------------------------------------------------------------------------
#Buffer 3, output strings for lathe canned turning cycles
wc3           : 1       #Initial count for write buffer 3
rc3           : 1       #Initial count for read buffer 3
size3         : 0       #Buffer 3 size

string3       : ""      #Buffer 3

fbuf 3 0 80 1 1         #Buffer 3
# --------------------------------------------------------------------------
#Top Turret info buffer for stagetools and syncing
wc4           : 1       #Initial count for write buffer 4
rc4           : 1       #Initial count for read buffer 4
size4         : 0       #Buffer 4 size

b4_tool       : 0       #Buffer 4
b4_spindle_no : 0
b4_posttype   : 0
b4_tloffno    : 0
b4_tlngno     : 0

fbuf 4 0 5 0 0          #Buffer 4
# --------------------------------------------------------------------------
#Lower Turret info buffer for stagetools and syncing
wc5           : 1       #Initial count for write buffer 5
rc5           : 1       #Initial count for read buffer 5
size5         : 0       #Buffer 5 size

b5_tool       : 0       #Buffer 5
b5_spindle_no : 0
b5_posttype   : 0
b5_tloffno    : 0
b5_tlngno     : 0

fbuf 5 0 5 0 0          #Buffer 5
# --------------------------------------------------------------------------
#Base is relative to WCS (Side plane on C-Axis Lathes)
matb1$        :   0
matb2$        :   1
matb3$        :   0
matb4$        :   0
matb5$        :   0
matb6$        :   1
matb7$        :   1
matb8$        :   0
matb9$        :   0

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
tool_cnt    : 0

cuttype     : 0     #Flag for cut type
                    #1 = Lathe
                    #2 = Right face cut (a = 90)
                    #-2 = Left face cut  (a = -90)
                    #3 = Cross cut      (a = 0)
                    #4 = Y axis substitution
                    #5 = Multisurf Rotary 4 / 5-axis (11 gcode)
                    #6 = B-Axis positioning

lathtype    : 0     #Lathe turret and spindle selection
                    #0 = Bottom turret/Left spindle
                    #1 = Top turret/Left spindle
                    #2 = Bottom turret/Right spindle
                    #3 = Top turret/Right spindle
lathecc     : 0     #Flag for canned turning cycle type
                    #1 = G71/G72 rough cycle
                    #2 = G73 pattern repeating cycle
                    #3 = G74/G75 groove cycle
                    #4 = Finish pass for types 1 and 2
                    #Neg.=rough and finish, Pos.=rough only
millcc      : 0     #Flag for mill conversion cycle type

sync_drill  : 0     #Flag for synchronous drilling
rigid_actv  : 0     #Flag for rigid

#Cantext activated flags
bld         : 0     #Block delete active
exact       : 0     #Exact stop active
chute       : 0     #Toggle for part catcher operation
tlstk       : 0     #Toggle for tailstock operation

#General user variables
vecx        : 0     #
vecy        : 0     #
vecz        : 0     #

xia         : 0     #Formated absolute value for X
yia         : 0     #Formated absolute value for Y
zia         : 0     #Formated absolute value for Z
cia         : 0     #Formated absolute value for C
bia         : 0     #Formated absolute value for B
copy_x      : 0     #X value copy, prevent compound operations
copy_y      : 0     #Y value copy, prevent compound operations
copy_z      : 0     #Z value copy, prevent compound operations
xa          : 0     #Absolute coordinate mapped value for X
ya          : 0     #Absolute coordinate mapped value for Y
za          : 0     #Absolute coordinate mapped value for Z
ua          : 0     #Absolute coordinate mapped value for U
va          : 0     #Absolute coordinate mapped value for V
wa          : 0     #Absolute coordinate mapped value for W
ia          : 0     #Absolute coordinate mapped value for I
ja          : 0     #Absolute coordinate mapped value for J
ka          : 0     #Absolute coordinate mapped value for K
cfeed_x     : 0     #Absolute mapped/rotated unshifted value for X
cfeed_y     : 0     #Absolute mapped/rotated unshifted value for Y
cfeed_z     : 0     #Absolute mapped/rotated unshifted value for Z
xca         : 0     #Absolute unshifted value for XC
yca         : 0     #Absolute unshifted value for YC
zca         : 0     #Absolute unshifted value for ZC
sav_xa      : 0     #X saved value
sav_ya      : 0     #Z saved value
sav_za      : 0     #Z saved value
sav_xh      : 0     #X saved value
sav_yh      : 0     #Z saved value
sav_zh      : 0     #Z saved value
sav_wcs     : 0     #Saved work offset
g49_mode    : 0     #Branch on 'use_g43' (0=Cancel with T0n00, 1=Cancel with G49)
conversion  : 12    #Unit conversion value, do not change
result      : 0     #Return value for functions
compok      : 1     #Flag to output cutter compensation
toolchng    : 2     #On a toolchange flag
plane$      : -1    #Initialize plane
fr_sel      : -1    #Initialize active feed type
mach_plane  : 0     #Plane mapped to machine
plane2      : 0     #Plane read from sw_string
sav_arcout  : arcoutput$ #Arc output type saved
breakarcss  : breakarcs$ #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs

#Parameter 20111 Values
orient01     : 0
orient02     : 0
orient03     : 0
orient04     : 0
orient05     : 0
orient06     : 0
orient07     : 0
orient08     : 0
orient09     : 0
orient10     : 0
orient11     : 0
orient12     : 0
lh_tool      : 0
vertical     : 0    #Current holder is vertical

sav_absinc   : 0    #Saved absolute/Incremental
spd_rev      : 0    #Flag to reverse spindle direction
sav_gcode    : 0    #Gcode saved
sav_feed     : 0    #Feed saved
sav_ipr      : 0    #IPR saved
sav_feedcc   : 0    #Feed saved, canned cycle
sav_iprcc    : 0    #IPR saved, canned cycle
sav_spdir    : 0    #Spindle direction saved
sav_omitsq   : 0    #Omitseq saved
sav_subout   : 0    #Saved subout
sav_frc_wcs  : 0    #Force work offset flag saved
sav_bug2     : bug2$ #Saved setting for bug2
sav_cutpos2  : 0    #Patch to handle cutpos2 flag through null toolchnages
cir_at_zero  : 0    #Arc center at centerline in XY plane, -1 if not plane 0
pnt_at_zero  : 0    #Position at centerline with milling
c_ax_flp     : 0    #G18 plane with C axis arcs in neg. range
home_type    : 0    #Flag for type of home location, read from misc. int.
rslt_plc     : 0    #Return value from plcval
rslt_upd     : 0    #Return value from updstr

#Drilling variables
drlgsel     : -1    #Drill Select Initialize
drillref    : -1    #Select drill reference
peckacel$   : 0     #Fractional percent to reduce peck2 when usecan.. : no
mdrl_dir    : 0     #Mill drill direction for boolean, 0 = face, 1 = cross
zdrl_x      : 0     #Drill point, mapped X
zdrl_y      : 0     #Drill point, mapped Y
zdrl_z      : 0     #Drill point, mapped Z

#Threading variables
nstart_cnt  : 0     #Counter for multiple threads
thd_vlen    : 0     #Incremental X move for G76 mult starts
xmaj_thd    : 0     #X major dia. from parameters
zstrt_thd   : 0     #Z start from parameters
zend_thd    : 0     #Z end from parameters
face_thd    : 0     #Face thread from parameters

#Spindle variables
max_speed   : 0     #Maximum spindle speed (set by turret definition)
min_speed   : 0     #Minimum spindle speed (set by turret definition)
speedrpm    : 0     #Spindle calculation RPM
g_speed     : 0     #Generic positive spindle speed (rpm or css)
g_spdir     : 0     #Generic spindle direction
speedx      : 0     #Test spindle calculation X position
gear_spd    : 0     #Absolute value of gear speed

# Lathe canned cycle variables
gcodecc     : 0     #Canned turning cycle gcode
y_axis      : 0     #Flag for Y axis machining (implies over center)
directcc    : 0     #Direction from parameters
dopeckcc    : 0     #Do peck from groove parameters
foundcc     : 0     #Return found from G70 read
cc_stop_fcc : 0     #Stop output with rough only
lcc_cc_pos  : 0     #Position for lathe canned cycle cutter comp. enable
lccdirx     : 0     #Canned cycle X vector direction
lccdirz     : 0     #Canned cycle Z vector direction
lcc_xcst    : 0     #Lathe canned cycle contour start position
lcc_ycst    : 0     #Lathe canned cycle contour start position
lcc_zcst    : 0     #Lathe canned cycle contour start position
lcc_xcend   : 0     #Lathe canned cycle contour end position
lcc_ycend   : 0     #Lathe canned cycle contour end position
lcc_zcend   : 0     #Lathe canned cycle contour end position
anglelcc    : 0     #Pattern offset angle
ncutslcc    : 0     #Number of passes

#Vector Varibles for Mapp ing and Rotatary Calculations
#Lathe - Uses top matrix - initialize here
m1$         : 1
m5$         : 1
m9$         : 1

cvec_xp     : 1     #Constant Vec X plus
cvec_xp1    : 0
cvec_xp2    : 0

cvec_xm     : -1    #Constant Vec X minus
cvec_xm1    : 0
cvec_xm2    : 0

cvec_yp     : 0     #Constant Vec Y plus
cvec_yp1    : 1
cvec_yp2    : 0

cvec_ym     : 0     #Constant Vec Y plus
cvec_ym1    : -1
cvec_ym2    : 0

#A rotation vector
aaxisx      : 1
aaxisy      : 0
aaxisz      : 0
#B rotation vector
baxisx      : 0
baxisy      : 1
baxisz      : 0
#C rotation vector
caxisx      : 0
caxisy      : 0
caxisz      : 1

#Mapping matrix
#Home position mapping matrix
hmtx1       : 1
hmtx2       : 0
hmtx3       : 0
hmtx4       : 0
hmtx5       : 1
hmtx6       : 0
hmtx7       : 0
hmtx8       : 0
hmtx9       : 1
#Toolplane matrix (m1-m9 in machine matrix, initial use)
tmtx1       : 1
tmtx2       : 0
tmtx3       : 0
tmtx4       : 0
tmtx5       : 1
tmtx6       : 0
tmtx7       : 0
tmtx8       : 0
tmtx9       : 1
#Cut type mapping matrix
mmtx1       : 1
mmtx2       : 0
mmtx3       : 0
mmtx4       : 0
mmtx5       : 1
mmtx6       : 0
mmtx7       : 0
mmtx8       : 0
mmtx9       : 1

#Side matrix
smtx1       : 0
smtx2       : 1
smtx3       : 0
smtx4       : 0
smtx5       : 0
smtx6       : 1
smtx7       : 1
smtx8       : 0
smtx9       : 0

#Cross matrix
cmtx1       : -1
cmtx2       : 0
cmtx3       : 0
cmtx4       : 0
cmtx5       : 0
cmtx6       : 1
cmtx7       : 0
cmtx8       : 1
cmtx9       : 0

#Back matrix
bmtx1       : 0
bmtx2       : -1
bmtx3       : 0
bmtx4       : 0
bmtx5       : 0
bmtx6       : 1
bmtx7       : -1
bmtx8       : 0
bmtx9       : 0

#Axis Subs matrix
amtx1       : 1
amtx2       : 0
amtx3       : 0
amtx4       : 0
amtx5       : 0
amtx6       : 1
amtx7       : 0
amtx8       : 1
amtx9       : 0

# Temporary return matrix
rmtx1       : 1
rmtx2       : 0
rmtx3       : 0
rmtx4       : 0
rmtx5       : 1
rmtx6       : 0
rmtx7       : 0
rmtx8       : 0
rmtx9       : 1

vzerox      : 0   #Defined Constant
vzeroy      : 0   #Defined Constant
vzeroz      : 0   #Defined Constant

vshftx      : 0   #Used for pivot point calculations
vshfty      : 0   #Used for pivot point calculations
vshftz      : 0   #Used for pivot point calculations

irotv       : 0   #Used for pivot point calculations
jrotv       : 0   #Used for pivot point calculations
krotv       : 0   #Used for pivot point calculations


#Rotary axis variables for calculations
c_axistype  : 0   #1 = C axis winds-up, 2 = C axis signed absolute
                  #3 = index positioning (do not set here, use string)
b_axistype  : 0   #1 = B axis winds-up, 2 = B axis signed absolute
                  #3 = index positioning (do not set here, use string)
ipr_type    : 0   #Feedrate for Rotary, 0 = UPM, 1 = DPM, 2 = 1/T
rapid_fr    : 0   #Read form question 38.
craw        : 0   #Initial c axis result from pxyzcout call
braw        : 0   #Initial b axis result from pxyzcout call
csav        : 0   #Initial c axis result from pxyzcout call
bsav        : 0   #Initial b axis result from pxyzcout call
czero_csav  : 0   #Save csav when circle at zero detected
c_wnd       : 0   #Calculation for c axis position tracking (abs-wind)
prvc_wnd    : 0   #Saved cout calculation from deg., this is cabs in mpfan
crev        : 0   #C axis wind-up multiplier
b_wnd       : 0   #Calculation for c axis position tracking (abs-wind)
prvb_wnd    : 0   #Saved cout calculation from deg., this is cabs in mpfan
brev        : 0   #C axis wind-up multiplier
prvfrdeg    : 0   #Feedrate deg/min actual
sav_crev    : 0   #Saved revolution counter
sav_brev    : 0   #Saved revolution counter
cindx_out   : c9k #Rotation direction calculation
bindx_out   : c9k #Rotation direction calculation

circum      : 0   #Circumference
ldelta      : 0   #Linear distance for deg/min, linear
cdelta      : 0   #Total linear and angular motion for deg/min
bdelta      : 0   #Total linear and angular motion for deg/min
cldelta     : 0   #Calculation for deg/min, linear and rotary


fr_scale    : 0   #Scale feedrate when programing pivot
ldelta_t    : 0   #Calculation for feed inverse time
ldelta_f_p  : 0   #Calculation for feed inverse time
ldelta_g    : 0   #Calculation for feed inverse time
c_deltax    : 0   #Calculation for feed inverse time
c_deltay    : 0   #Calculation for feed inverse time
c_deltaz    : 0   #Calculation for feed inverse time
circumh     : 0   #Calculation for feed inverse time, head
circumpt    : 0   #Calculation for feed inverse time, pri. table
circumst    : 0   #Calculation for feed inverse time, sec. table

c_clamp_actv : 0  #Flag to indicate clamp active
b_clamp_actv : 0  #Flag to indicate clamp active
c_brake_actv : 0  #Flag to indicate brake active
b_brake_actv : 0  #Flag to indicate brake active

g68_actv     : 0  #Flag to indicate that G68 is active

fmt     17  frdeg #Feedrate deg/min actual
fmt     17  frinv #Feedrate 1/t actual
fmt     20  cindx_mc #Rotation direction calculation
fmt     20  bindx_mc #Rotation direction calculation

#Plane/axis sign modifier (always 1 or -1)
pl_ax_m0x    : -1
pl_ax_m0y    : 1
pl_ax_m0z    : 1
pl_ax_m1x    : 1
pl_ax_m1y    : 1
pl_ax_m1z    : 1
pl_ax_m2x    : 1
pl_ax_m2y    : 1
pl_ax_m2z    : 1

# --------------------------------------------------------------------------
# Dual Turret Stagetool Option
# --------------------------------------------------------------------------
pgetnexttool  #Call to read next tool for the active turret
      tool_cnt = tool_cnt - one
      if c1_gcode = 1001, first_tool$ = t$
      if lturret$ = one | use_only_tl, #Upper Turret
        [
        size4 = rbuf(four, zero)
        if c1_gcode = 1001, rc4 = two
        if rc4 <= size4, b4_tool = rbuf(four, rc4)
        if tool_cnt = zero, b4_tool = first_tool$
        if not(g49_mode),
          [
          toolno = t$
          next_toolno = abs(b4_tool)
          ]
        else,
          [
          toolno = t$
          next_toolno = abs(b4_tool)
          ]
        ]
      else, #Lower Turret
        [
        size5 = rbuf(five, zero)
        if c1_gcode = 1001, rc5 = two
        if rc5 <= size5, b5_tool = rbuf(five, rc5)
        if tool_cnt = zero, b5_tool = first_tool$
        if not(g49_mode),
          [
          toolno = t$ * 100 + tloffno$
          if spindle_no$ = one, toolno = toolno + 30
          next_toolno = abs(b5_tool) * 100
          if spindle_no$ = one, next_toolno = next_toolno + 30
          ]
        else,
          [
          toolno = t$
          next_toolno = abs(b5_tool)
          ]
        ]

pwrite_toolbuf
      tool_cnt = tool_cnt + one

      if lturret$ = one | use_only_tl,
        [
        b4_tool = t$
        b4_spindle_no = spindle_no$
        b4_posttype = posttype$
        b4_tloffno = tloffno$
        b4_tlngno = tlngno$
        b4_tool = wbuf(four, wc4) #Upper
        ]
      else,
        [
        b5_tool = t$
        b5_spindle_no = spindle_no$
        b5_posttype = posttype$
        b5_tloffno = tloffno$
        b5_tlngno = tlngno$
        b5_tool = wbuf(five, wc5) #Lower
        ]

pvalidate_tlinfo
      if t$ < zero, t$ = abs(t$)
      if met_tool$, result = 90
      else, result = 90/25.4
      #Set light / heavy toolchange for Turret One
      if lturret$ = one & t$ < 1000,
        [
        if posttype$ = two | tldia$ <= result, t$ = t$ + 1000
        if posttype$ = one & tldia$ > result, t$ = t$ + 9000
        ]

      if tloffno$ > 1000 & tloffno$ < 2000, tloffno$ = tloffno$ - 1000
      if tloffno$ > 9000 & tloffno$ < 10000, tloffno$ = tloffno$ - 9000
      if tlngno$ > 1000 & tlngno$ < 2000, tlngno$ = tlngno$ - 1000
      if tlngno$ > 9000 & tlngno$ < 10000, tlngno$ = tlngno$ - 9000

pfc_clamp_off
      if spindle_no$, *sc_clamp_off_s
        else, *sc_clamp_off_m

pfc_brake_off
      if spindle_no$, *sc_brake_off_s
        else, *sc_brake_off_m

pfc_clamp_on
      if spindle_no$, *sc_clamp_on_s
        else, *sc_clamp_on_m

pfc_brake_on
      if spindle_no$, *sc_brake_on_s
        else, *sc_brake_on_m

pcrotretinc      #Reset the rotary axis revolution counter
      if frc_cinit,
        [
        crev = zero
        sav_crev = zero
        cabs = zero
        csav = zero
        c_wnd = zero
        prvc_wnd = zero
        cindx_out = zero
        if c_axistype = one,
          [
          if home_type = one, pfcout
          else,
            [
            cinc = zero
            cinc
            ]
          ]
        else,
          [
          pcindxclc
          if c_axistype = three,
            [
            cindx_out = cabs
            e$, pbld, n$, pcindex
            ]
          else, pfcout
          ]
        !csav, !cabs, !c_wnd
        ]

pbrotretinc      #Reset the rotary axis revolution counter
      if frc_binit,
        [
        if frc_binit = one,
          [
          brev = zero
          sav_brev = zero
          babs = zero
          bsav = zero
          b_wnd = zero
          prvb_wnd = zero
          bindx_out = zero
          ]
        else, #frc_binit = two
          [
          ps_inc_calc
          pb_tc_posn
          ]
        if b_axistype = one,
          [
          #if home_type = one, pfbout
          #else,
          #  [
          #  binc = zero
          #  if b_axis_mch, *binc
          #  ]
          pfbout
          ]
        else,
          [
          pbindxclc
          if b_axistype = three,
            [
            bindx_out = babs
            e$, pbld, n$, pbindex
            ]
          else, pfbout
          ]
        !bsav, !babs, !b_wnd
        ]
      if frc_binit = two, pe_inc_calc

preadcur_nxt    #Read current and next tool record
      c1_gcode = rbuf (one, rc1)     #Current tool record
      #Place buffered variables in post global variables
      cuttype = c1_cuttype
      lathtype = c1_lathtype
      lathecc = c1_lathecc
      gcodecc = c1_gcodecc
      y_axis = c1_y_axis
      millcc = c1_millcc
      n1_gcode = rbuf (one, nc1)     #Next tool record
      if cuttype = one, cc_1013$ = one
      else, cc_1013$ = zero
      if lathecc <> zero & lathecc <> four, compok = zero
      else, compok = one

mrapid$          #Output to NC of linear movement - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pzrapid$         #Linear movement in Z axis only - rapid, mill
      copy_x = vequ(x$)
      pm_ncoutput

pz$              #Linear movement in Z axis only - at feedrate, mill
      copy_x = vequ(x$)
      pm_ncoutput

mlin$            #Output to NC of linear movement - feed, mill
      copy_x = vequ(x$)
      pm_ncoutput

mcir$            #Output to NC of circular interpolation, mill
      pshft_map_ijk
      copy_x = vequ(x$)
      pm_ncoutput

lrapid$          #Rapid linear movement, lathe
      copy_x = vequ(x$)
      pl_ncoutput

llin$            #Linear line movement - at feedrate, lathe
      copy_x = vequ(x$)
      pl_ncoutput

lcir$            #Circular interpolation, lathe
      pshft_map_ijk
      copy_x = vequ(x$)
      pl_ncoutput

pmx$             #Output to NC of Multisurf Rotary, mill
      copy_x = vequ(x$)
      pm_ncoutput

lsof0$           #Start of file for tool zero, lathe
      lsof$

msof0$           #Start of file for tool zero, mill

#Pre-process rotary motion control flags, mill
pmx0$            #5 ax Drill
      if cuttype = five,
        [
        if drill5$ = one, z$ = initht$ * z_mult
        else,
          [
          if fr$ = -2, gcode$= zero
          else, gcode$ = one
          ]
        ]
plin0$           #Pre-linear movement postblock
      if posttype$ <> two,
        [
        preset_mod
        if y_axis = zero & millcc = zero & c_axistype <> three,
          [
          #Set brklinestype
          if abs(cuttype) = two, brklinestype$ = six
          if cuttype = three, brklinestype$ = four
          ]
        ]

pcir0$           #Pre-circular interpolation postblock
      pmap_plane
      if posttype$ <> two,
        [
        preset_mod
        pshft_map_xc
        if cuttype < five & y_axis = zero & millcc = zero,
          [
          #Set linarc, breakarcs and cir_at_zero
          if fmtrnd(xca) = zero & fmtrnd(yca) = zero,
            [
            #Set breakarcs and cir_at_zero
            breakarcs$ = zero
            #C axis move
            if mach_plane = zero,
              [
              cir_at_zero = one
              czero_csav = csav
              ]
            #Arc output
            if mach_plane = two, cir_at_zero = m_one
            ]
          if cir_at_zero = zero, linarc$ = one
          ]
        ]
      !ynci$
      if cuttype >= five & use_g68 = no$, linarc$ = one

# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
pdwell1         #Dwell output
      gcode$ = four  #for implied dwells
      pcan1, pbld, n$, *sgcode, *dwell$, strcantext, e$

pdwell2
      gcode$ = four  #for implied dwells
      dwell2 = (60 * dwell$) / (feed * speed)
      pcan1, pbld, n$, *sgcode, *dwell2, strcantext, e$

pbld            #Canned text - block delete
      if bld, '/'

pfbld           #Force block delete
      "/"

psgplane        #Machining plane
      if g68_actv = 0 & babs = 0, plane$ = 1
      if y_axis_mch, sgplane
      !plane$

pfsgplane       #Force machining plane
      if g68_actv = 0 & babs = 0, plane$ = 1
      *sgplane
      !plane$

pexct           #Canned text - exact stop
      if exact, 'G9'

psgcode         #Output the Gcode based on the current plane
      if c_ax_flp,
        [
        #Reverse arc direction for c_axis flip
        if gcode$ = two | gcode$ = three,
          [
          sav_gcode = gcode$
          gcode$ = abs (gcode$ - five)
          ]
        ]
      if plane$ = zero, `sgcode
      if plane$ = one, `sgcode1
      if plane$ = two, `sgcode2
      if c_ax_flp, gcode$ = sav_gcode

pfxout          #Force X axis output
      if absinc$ = zero, *xabs, !xinc
      else, *xinc, !xabs

pxout           #X output
      if absinc$ = zero, xabs, !xinc
      else, xinc, !xabs

pfyout          #Force Y axis output
      if y_axis_mch,
        [
        if absinc$ = zero, *yabs
        else, *yinc
        ]
      else, pchecky
      !yabs, !yinc

pyout           #Y output
      if y_axis_mch,
        [
        if absinc$ = zero, yabs
        else, yinc
        ]
      else, pchecky
      !yabs, !yinc

pchecky         #Y output should not happen on a c-axis lathe
      if not(toolchng) & yinc,
        [
        result = mprint(symoterror)
        ]

pfzout          #Force Z axis output
      if absinc$ = zero, *zabs, !zinc
      else, *zinc, !zabs

pzout           #Z output
      if absinc$ = zero, zabs, !zinc
      else, zinc, !zabs

pfbout          #Force B axis output
      if b_axis_mch & lturret$,
        [
        if b_axistype < three,
          [
          if b_axistype = one,
            [
            plimitB
            if absinc$ = zero, *babs, !binc
            else, *binc, !babs
            ]
          else, #Signed direction, no incremental
            [
            if bindx_mc = zero, result = nwadrs(sb_minus, babs)
            else, result = nwadrs(str_bax_abs, babs)
            *babs
            !b_wnd, !babs, !binc
            ]
          ]
        ]
        else, pcheckb
        !b_wnd, !babs, !binc

pbout           #B axis output
      if rot_BW = 0,# reatribution de B car on est en faite a 25 degree sur BW
      [
      if b_axis_mch & lturret$,
        [
        if posttype$ <> two & b_axistype < three,
          [
          if b_axistype = one,
            [
            plimitB
            if absinc$ = zero, babs, !binc
            else, binc, !babs
            ]
          else, #Signed direction, modality on c_wnd, no incremental
            [
            if prv_b_wnd <> b_wnd,
              [
              if bindx_mc = zero, result = nwadrs(sb_minus, babs)
              else, result = nwadrs(str_bax_abs, babs)
              *babs
              ]
            !b_wnd, !babs, !binc
            ]
          ]
        ]
      ]
        else, pcheckb
        !b_wnd, !babs, !binc

pcheckb         #B output should not happen on a c-axis lathe
      if (not(toolchng) & binc),
         [
         result = mprint(sbmoterror)
         ]

pfcout          #Force C axis output
      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one,
          [
          if absinc$ = zero, *cabs, !cinc
          else, *cinc, !cabs
          ]
        else, #Signed direction, no incremental
          [
          if cindx_mc = zero, result = nwadrs(sc_minus, cabs)
          else, result = nwadrs(str_cax_abs, cabs)
          *cabs
          !c_wnd, !cabs, !cinc
          ]
        ]

pcout           #C axis output
      if posttype$ <> two & c_axistype < three,
        [
        if c_axistype = one,
          [
          if absinc$ = zero, cabs, !cinc
          else, cinc, !cabs
          ]
        else, #Signed direction, modality on c_wnd, no incremental
          [
          if prv_c_wnd <> c_wnd,
            [
            if cindx_mc = zero, result = nwadrs(sc_minus, cabs)
            else, result = nwadrs(str_cax_abs, cabs)
            *cabs
            ]
          !c_wnd, !cabs, !cinc
          ]
        ]

pcindex         #Index output
      if c_axistype = three,
        [
        pbld, n$, `scindx_mc, cindx_out, e$
        !cabs, !cinc
        ]

pbindex         #Index output
      if b_axistype = three,
        [
        pbld, n$, `sbindx_mc, bindx_out, e$
        !babs, !binc
        ]

parc       #Select the arc output
      if arcoutput$ > zero,
        [
        if arcoutput$ < two,
          [
          #Arc output for R and R / R-
           if abs(sweep$)<=180 | arcoutput$=one, result = nwadrs(srad, arcrad$)
           else, result = nwadrs(srminus, arcrad$)
           *arcrad$
          ]
        else, # arcoutput = three uses IJK over 180
          [
          #Arc output for R / IJK
          if abs(sweep$)<=180,
            [
            result = nwadrs(srad, arcrad$)
            *arcrad$
            ]
          else, pijk
          ]
        ]
       else, pijk

pijk       #Arc output for IJK
      if arctype$ = one,
        [
        #Arc output for IJK, absolute
        iout = vequ(ia)
        if c_ax_flp, iout = -iout
        ]
      else,
        [
        #Arc output for IJK, start/center
        if arctype$ = two, iout = vsub(ia, prv_xa)
        if arctype$ >= three, iout = vsub(ia, xa)
        if arctype$ = four,
         [
         iout = abs(iout)
         jout = abs(jout)
         kout = abs(kout)
         ]
        if c_ax_flp, iout = -iout
        ]

      if iout_dia, iout = iout * dia_mult

      if posttype$ = two, *iout, *kout
      else,
        [
        result = nwadrs(stri, iout)
        result = nwadrs(strj, jout)
        result = nwadrs(strk, kout)
        if plane$ = zero,
          [
          if g68_actv & (use_g68 = two | (use_g68 = one & (babs <> zero & abs(babs) <> 90))),
            [
            *iout, *jout
            ]
          else, *iout, *jout
          ]
        if plane$ = one,
          [
          if g68_actv & (use_g68 = two | (use_g68 = one & (babs <> zero & abs(babs) <> 90))),
            [
            result = nwadrs(strj, kout)
            *iout, *kout
            ]
        else, *jout, *kout
          ]
        if plane$ = two,
          [
          if g68_actv & (use_g68 = two | (use_g68 = one & (babs <> zero & abs(babs) <> 90))),
            [
            result = nwadrs(stri, jout)
            result = nwadrs(strj, kout)
            *jout, *kout
            ]
          else, *jout, *kout
          ]
        ]

pffr            #Output feedrate, force
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      *feed

pfr             #Output feedrate
      if ipr_actv$ = zero, pfr_m
      else, pfr_l
      `feed

pfr_m           #Format feedrate for mill
      result = nwadrs(strf, feed)
#      result = newfs (17, feed)

pfr_l           #Format feedrate for lathe
      if opcode$ = 104,
        [
        #Format feedrate for lathe thread
        #result = nwadrs(stre, feed)
#        result = newfs (19, feed)
        ]
      else,
        [
        result = nwadrs(strf, feed)
#        result = newfs (18, feed)
        ]

pcc_capture     #Capture ends of canned turning path, stop output w/rough
      #Stop output in rough only lathe canned cycles
      #between rough and finish paths
      if cc_stop_fcc & rcc_flg$ = six, no_nc_out$ = one
      #Capture vector for G73 cycle
      if rpd_typ$ = six & abs(lathecc) = two,
        [
        if rcc_flg$ = one, lcc_xcst = vequ (copy_x)
        if rcc_flg$ = three, lcc_xcend = vequ (copy_x)
        ]

pcom_moveb      #Common motion preparation routines, before
      pshft_map_xa
      pxyzcout
      ps_inc_calc
      if babs > 180, babs = babs - 360

ppos_cax_lin    #Position C if from CL
      if (prv_pnt_at_zero) & c_axistype < three,
        [
        #Output to NC, C axis movement only - rapid deg/min
        sav_gcode = gcode$
        sav_feed = feed
        gcode$ = one
        if millcc = zero,
          [
          feed = maxfrdeg
          pbld, n$, psgcode, pfcout, pfbout, pffr, e$
          ]
        else, pbld, n$, psgcode, pfcout, pfbout, pfr, e$
        gcode$ = sav_gcode
        feed = sav_feed
        ]

pcom_movea      #Common motion preparation routines, after
      pcan2
      pe_inc_calc

ppos_pnt_zero   #Position C if from CL
      !pnt_at_zero
      pnt_at_zero = zero

#Mill canned cycle output
pmillccb        #Cross/Face canned cycle code, before
      if c1_millcc = n1_millcc & n1_millcc & n1_gcode = 1000
      & cutpos2$ = three,
        [
        sav_cutpos2 = two
        cutpos2$ = two
        ]
      if (cutpos2$ = one & abs(cuttype) = two) | (prv_cutpos2$ = one & cuttype = four),
        [
        result = newfs(two, cabs)
        result = newfs(two, cinc)
        ##result = nwadrs(stry, cabs)
        ##result = nwadrs(stry, cinc)

        #Cross/Face canned cycle start code
        if abs(cuttype) = two,
          [
          #Face canned cycle start code, G112 (break ramp)
          pbld, n$, *sg112, e$
          prv_xabs = c9k
          prv_xinc = c9k
          prv_cabs = c9k
          prv_cinc = c9k
          compok = one
          ]
        else,
          [
          #Cross canned cycle start code, G107
          pbld, pfsgplane, "W0.", "H0.", e$
          pbld, n$, *sg107, *crad, e$

          ]
        ]
      if cutpos2$ > zero & cutpos2$ < four,
        [
        #Change rapid to highest possible feedrate
        if gcode$ = zero,
          [
          gcode$ = one
          feed = rapid_fr
          ]
        ]

pmillcca        #Cross/Face canned cycle code, after
      if (cutpos2$ = four & abs(cuttype) = two) | (cutpos2$ = three & cuttype = four),
        [
        #Cross/Face canned cycle end code
        if abs(cuttype) = two, pbld, n$, sg113, e$  #Face
        else, pbld, n$, *sg108, "C0.", e$ #Cross
        result = newfs(11, cabs)
        result = newfs(14, cinc)
        ##result = nwadrs(strc, cabs)
        ##result = nwadrs(strc, cinc)
        ]

# --------------------------------------------------------------------------
# Lathe Tool B-Axis Angle Calculations and Variables
# --------------------------------------------------------------------------
#tempary varaibles for rpar 20000 parameters
v1 : 0
v2 : 0
v3 : 0
v4 : 0
v5 : 0
v6 : 0
v7 : 0
v8 : 0
v9 : 0

tool_ang  : 0   #Saved 20000 Parameter Value

tool_vecx : 0   #Result vector
tool_vecy : 0
tool_vecz : 0

pgetltoolang  #Calculate B-Axis from Tool Angle parameter
      axisx$ = vequ(caxisx)
      if orient$ = one | orient$ = two,
        tool_vecx = rotv(tool_ang, cvec_yp)
      if orient$ = three | orient$ = four,
        tool_vecx = rotv(tool_ang, cvec_ym)
      if orient$ = five | orient$ = eight,
        tool_vecx = rotv(tool_ang, cvec_xp)
      if orient$ = six | orient$ = seven,
        tool_vecx = rotv(tool_ang, cvec_xm)
      if bzero_vert, bsav = atan2((-tool_vecx*ccw_b_pos), tool_vecy)
        else, bsav = atan2((tool_vecy*ccw_b_pos), tool_vecx)

# --------------------------------------------------------------------------
# Position calculations, generally these do not need to be modified
# --------------------------------------------------------------------------
#The variables for absolute output are xabs, yabs, zabs.
#The variables for incremental output are xinc, yinc, zinc.
#They are found from the input variables x, y, z (typically) which are
#copied to copy_x, copy_y, copy_z.  These are passed to the mapping routine
#to get raw machine coordinates xa, ya, za.  These are used in pxyxcout to
#get the output xabs, yabs, zabs.  ps_inc_calc is called to get xinc, yinc,
#zinc.  cfeed_x, cfedd_y, cfeed_z are the unshifted positions for feed
#calculations.
# --------------------------------------------------------------------------
pmatrix_su      #Setup mapping matrix
      tmtx1 = matt(matb1$)
      tmtx1 = mmul(tmtx1, aaxisx)
      tmtx1 = mmul(tmtx1,m1$)
      hmtx1 = matt(m1$)
      hmtx1 = mmul(hmtx1, smtx1)
      mmtx1 = matt(m1$)
      if cuttype = one, mmtx1 = matt(smtx1) #Special case Turning
      if cuttype = four, mmtx1 = matt(amtx1)#Special case Axis Subs
      mmtx1 = mmul(mmtx1, matb1$)

[STARTBIN]

#Feedrate calculations
pfcalc          #Feedrate calculations, gcode 0 does not evaluate
      if posttype$ = two, fr_sel = ipr_actv$
      else, fr_sel = ipr_type + two
      sav_gcode = gcode$
      if convert_rpd$ & toolchng < one,
        [
        if gcode$ = zero,
          [
          gcode$ = one
          feed = rapid_fr
          ]
        ]
      if abs(c_wnd-prvc_wnd)<vtol$ | c_axistype=three | drillcur$
        | ipr_type=zero | prv_pnt_at_zero | sav_gcode = zero
        | use_fr = zero | (not(mill5$) & use_fr = two) | posttype$ = two, pfcalc_u_min
      else,
        [
        if use_fr = four, pfcalc_d_min
        else, pfcalc_inv
        ]
      if ipr_type <> prv_ipr_type | ipr_type = two, prv_feed = c9k

pfcalc_u_min    #Feedrate unit/min
      feed = fr_pos$
      if feed > maxfeedpm, feed = maxfeedpm
      prvfrdeg = feed

pfcalc_d_min    #Feedrate deg/min
      #Average last radius to current radius
      ldelta = ((cfeed_x+prv_cfeed_x)/two)^two+((cfeed_y+prv_cfeed_y)/two)^two
      circum = sqrt(ldelta) * two * pi$
      if circum = zero, circum = c9k          #Don't allow Zero
      ldelta = (cfeed_x-prv_cfeed_x)^two+(cfeed_y-prv_cfeed_y)^two
      ldelta = sqrt(ldelta+(cfeed_z-prv_cfeed_z)^two)
      cdelta = ((abs(c_wnd - prvc_wnd))/360)*circum
      bdelta = ((abs(b_wnd - prvb_wnd))/360)*circum
      if ldelta = zero, cldelta = cdelta
      else, cldelta = sqrt(cdelta^two + ldelta^two)
      if cldelta = zero, cldelta = c9k
      #Feedrate deg/min control and calculation
      frdeg = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
      if abs(frdeg - prvfrdeg) > frdegstp | ipr_type <> prv_ipr_type,
        [
        #Control output of frdeg
        prvfrdeg = frdeg
        feed = frdeg
        ]
      if fmtrnd(frdeg) = zero, feed = fr_pos$
      if frdeg > maxfrdeg, feed = maxfrdeg

pfcalc_inv    #Feedrate Inverse Time
      ldelta = ((cfeed_x+prv_cfeed_x)/two)^two+((cfeed_y+prv_cfeed_y)/two)^two
      circum = sqrt(ldelta) * two * pi$
      if circum = zero, circum = c9k          #Don't allow Zero
      ldelta = (cfeed_x-prv_cfeed_x)^two+(cfeed_y-prv_cfeed_y)^two
      ldelta = sqrt(ldelta+(cfeed_z-prv_cfeed_z)^two)
      cdelta = ((abs(c_wnd - prvc_wnd))/360)*circum
      bdelta = ((abs(b_wnd - prvb_wnd))/360)*circum
      cldelta = sqrt(cdelta^2 + bdelta^2)
      if ldelta = zero, cldelta = cdelta
      else, cldelta = sqrt(cdelta^two + ldelta^two)
      if cldelta = zero, cldelta = c9k
      #Feedrate inverse calculation
        result = force(feed, feed) #Always force feed
      frinv = fr_pos$/cldelta
      if frinv > maxfrinv, frinv = maxfrinv
      if frinv < minfrinv, frinv = minfrinv
      feed = frinv

#Incremental calculations
ps_inc_calc     #Incremental calculations, start
      xia = fmtrnd(xabs)
      yia = fmtrnd(yabs)
      zia = fmtrnd(zabs)
      xinc = vsub (xia, prv_xia)
      if posttype$ <> two, ps_cinc_calc
      bia = fmtrnd(babs)
      binc = bia - prv_bia

ps_cinc_calc    #Incremental calculations, start rotary
      cia = fmtrnd(cabs)
      cinc = cia - prv_cia

pe_inc_calc     #Incremental calculations, end
      prvc_wnd = fmtrnd(c_wnd)      #Avoid updating until called explicitly
      prvb_wnd = fmtrnd(b_wnd)
      !cfeed_x, !cfeed_y, !cfeed_z, !ipr_type  #These are used in pxyzcout
      !x$, !y$, !z$, !xa, !ya, !za
      !xia, !yia, !zia, !cia, !bia
      !cutpos2$

# --------------------------------------------------------------------------
# Mapping routines, maps input to basic machine coordinates (side view)
# --------------------------------------------------------------------------
pshft_map_xc    #Remove workshift and map to lathe coordinates, center
      xca = vadd (xc$, tox$)  #Always shift to origin
      if plane$ = one,
        [
        result = xca
        xca = zca
        zca = yca
        yca = result
        ]
      if plane$ = two,
        [
        result = yca
        yca = zca
        zca = result
        ]
      xca = vmap (xca, mmtx1)

pshft_map_ijk    #Remove workshift and map to lathe coordinates, ijk
      if arctype$ = one, #Absolute is shifted
        [
        if wcs_origin, ia = vadd (xc$, tox$)
        else,
          [
          ia = xc$
          ja = yc$
          ka = zc$
          ]
        ]
      else,
        [
        ia = xc$
        ja = yc$
        ka = zc$
        ]
      ia = vmap (ia, mmtx1)

pshft_map_xa     #Remove workshift and map to lathe coordinates, xyz
      if wcs_origin, xa = vadd (copy_x, tox$)
      else, xa = vequ (copy_x)
      xa = vmap (xa, mmtx1)
      if not(mill5$) & opcode$ <> 16, ua = vadd(xa, tmtx7)  #UVW add toolplane normal
      else, ua = vmap(u$,mmtx1)             #Map UVW position into machine base
      vecx = vsub(ua, xa)
      vecx = vnrm(vecx)

pmap_home     #Set the location for home position
      xa = vequ(xh$)
      if map_home,
        [
        if wcs_origin, xa = vadd(xa, tox$)
        xa = vmap(xa, hmtx1)
        ]
      pplane_mod
      cfeed_x = vequ(xa)
      pax_shift

pmap_plane    #Map NCI plane to machine plane
      mach_plane = plane$
      #Cross
      if cuttype = three & plane$ < two, mach_plane = abs(plane$ - one)
      #Top
      if (abs(cuttype) <= one | abs(cuttype) >= four),
      mach_plane = plane$ - one
      if mach_plane = m_one, mach_plane = two

pcur_recd       #Write to the current tool record
      c1_gcode = gcode$
      pmatrix_su
      pset_turret
      pmap_home
      c1_xh = vequ(xabs)
      c1_tox = vmap (tox$, mmtx1)
      c1_cc_pos = cc_pos$
      if gcode$ <> 1003, c1_tool = abs(t$)
      else, c1_tool = zero
      c1_tloffno = tloffno$
      c1_maxss = maxss$
      c1_ss = abs(ss$)
      if cool_w_spd = zero, c1_spdir = spdir$ + one
      else, c1_spdir = (spdir$ + one) + (fsg2(coolant$) * three)
      c1_css_actv = css_actv$
      c1_fr_pos = fr_pos$
      c1_ipr_actv = ipr_actv$
      c1_coolant = coolant$
      c1_nextdc = nextdc$
      c1_posttype = posttype$
      c1_cuttype = cuttype
      if use_only_tl, c1_lathtype = one
      else, c1_lathtype = lathtype
      c1_gcodecc = gcodecc
      c1_lathecc = lathecc
      c1_millcc = millcc
      c1_y_axis = y_axis
      if opcode$ = 104,
        [
        if face_thd <> two, x_min$ = abs(xmaj_thd)
        else,
          [
          if abs(zstrt_thd) > abs(zend_thd), x_min$ = abs(zstrt_thd)
          else, x_min$ = abs(zend_thd)
          ]
        x_max$ = x_min$
        ]
      c1_gcode = wbuf (one, wc1)

plast_recd      #Update the last record(s) for min-max and point
      rc1 = wc1 - one
      c1_gcode = rbuf (one, rc1)
      if prv_opcode$ <> 104,
        [
        c1_x_min = x_min$
        c1_x_max = x_max$
        ]
      rc1 = wc1 - one               #rc1 is used to write also
      c1_gcode = wbuf (one, rc1)

pcut_cctyp      #Find the type of cut for the tool buffer
                #y_axis
                #posttype
                #cuttype
                #lathtype
      y_axis = zero
      cuttype = zero
      if posttype$ = two, cuttype = one
      else,
        [
        if mill5$, cuttype = five
        else,
          [
          if rotary_type$ = one, cuttype = four
          else,
            [
            @m1$, @m2$, @m3$, @m7$, @m8$, @m9$
            if m7$ = m_one & m8$ = zero & m9$ = zero, cuttype = -2
            if m7$ = one & m8$ = zero & m9$ = zero, cuttype = two
            if m1$ = m_one & m2$ = zero & m3$ = zero, cuttype = three
            if rotary_type$ = three , y_axis = one
              #| (cuttype >= five & use_g68 = one), y_axis = one
            if cuttype = zero, cuttype = six
            ]
          ]
        ]
      lathtype = lturret$ + spindle_no$ * two
      #Check for errors
      if rotary_type$,
        [
        if (abs(cuttype) = two & rotary_axis$ <> three)
        | (cuttype = three & rotary_axis$ <> one),
          result = mprint(saxiserror)
        if cuttype = four & tlplnno$ <> one, result = mprint(stoperror)
        ]
      else,
        [
        if cuttype = zero, result = mprint(scutterror)
        ]
      #gcodecc, determine G74/G75 direction during processing
      #lathecc
      #millcc
      gcodecc = zero
      lathecc = zero
      if tool_op$ > 201,
        [
        if tool_op$ = 202 | tool_op$ = 203,
          [
          gcodecc = one
          lathecc = one
          if tool_op$ = 203, lathecc = m_one
          ]
        else,
          [
          if tool_op$ = 204 | tool_op$ = 205,
            [
            gcodecc = two
            lathecc = one
            if tool_op$ = 205, lathecc = m_one
            ]
          else,
            [
            if tool_op$ = 206 | tool_op$ = 207,
              [
              gcodecc = three
              lathecc = two
              if tool_op$ = 207, lathecc = -2
              ]
            else,
              [
              if tool_op$ = 208,
                [
                gcodecc = four
                lathecc = three
                ]
              ]
            ]
          ]
        ]
      if mi4$ <> zero & opcode$ <> three & (cuttype = four | abs(cuttype) = two),
         millcc = mi4$
      else, millcc = zero

psetup          #Setup post based on NCI settings
      home_type =  2 #mi1$
      sbufname3$ = spathnci$ + snamenci$ + sextext$
      spathext$ = spathnci$
      snameext$ = snamenci$
      #Set metric defaults
      if met_tool$ = one,
        [
        conversion = 1000
        ltol$ = ltol_m
        vtol$ = vtol_m
        maxfeedpm = maxfeedpm_m
        lcc_move = lcc_move_m
        ]

      #Setup for old or new style canned cycles
      if old_new_sw = one,
        [
        result = newfs (23, thddepth$)
        result = newfs (23, thdfirst$)
        ]
      else,
        [
        result = nwadrs (stra, thdang)
        result = nwadrs (stri, thdrdlt)
        result = nwadrs (strk, thddepth$)
        result = nwadrs (strd, thdfirst$)
        #Lathe canned cycle old style conversion
        result = nwadrs (strd, depthcc)
        result = nwadrs (strd, ncutscc)
        result = nwadrs (stri, g73x)
        result = nwadrs (strk, g73z)
        result = nwadrs (stri, grvspcc)
        result = nwadrs (strk, grvdpcc)
        ]
      #Setup for arctype setting
      if arctype$ = one | arctype$ = four,
        [
        result = newfs(two, i$)
        result = newfs(two, j$)
        result = newfs(two, k$)
        result = newfs(two, iout)
        result = newfs(two, jout)
        result = newfs(two, kout)
        ]
      else,
        [
        result = newfs(three, i$)
        result = newfs(three, j$)
        result = newfs(three, k$)
        result = newfs(three, iout)
        result = newfs(three, jout)
        result = newfs(three, kout)
        ]
      result = nwadrs(str_cax_abs, cabs)
      result = nwadrs(str_cax_inc, cinc)
      result = nwadrs(str_cindex, cindx_out)
      result = nwadrs(str_bindex, bindx_out)
      sc_minus = str_cax_abs + sc_minus

# --------------------------------------------------------------------------
# Turret and cut type change setup, do not edit
# --------------------------------------------------------------------------
pset_turret     #Set the machine conditions and mapping based on the turret
      if lathtype = one | use_only_tl, pltype1
      else,
        [
        if lathtype = zero, pltype0
        else,
          [
          if lathtype = two, pltype2
          else, pltype3
          ]
        ]
      psw_str_mult

pltype0         #Bottom turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        pcuttypldrl
        max_speed = max_speedl0
        min_speed = min_speedl0
        sw_string = scase_bl_c1
        ]
      else,
        [
        #Mill
        pcuttypmdrl
        max_speed = max_speedm0
        min_speed = min_speedm0
        sw_string = scase_bl_c2 #case two is the default
        if cuttype = -2, sw_string= scase_bl_c_2
        if cuttype = three,
          [
          if use_g68, sw_string = scase_bl_c3
          else, sw_string = scase_bl_c3p
          ]
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_bl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_bl_c4
        if cuttype = five,
          [
          if use_g68, sw_string = scase_bl_c5
          else, sw_string = scase_bl_c5p
          ]
        if cuttype = six,
          [
          if use_g68, sw_string = scase_bl_c6
          else, sw_string = scase_bl_c6p
          ]
        ]

pltype1         #Top turret/Left spindle
      if cuttype = one,
        [
        #Lathe
        pcuttypldrl
        max_speed = max_speedl1
        min_speed = min_speedl1
        sw_string = scase_tl_c1
        ]
      else,
        [
        #Mill
        pcuttypmdrl
        max_speed = max_speedm1
        min_speed = min_speedm1
        sw_string = scase_tl_c2 #case two is the default
        if cuttype = -2, sw_string = scase_tl_c_2
        if cuttype = three,
          [
          if use_g68, sw_string = scase_tl_c3
          else, sw_string = scase_tl_c3p
          ]
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tl_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tl_c4
        if cuttype = five,
          [
          if use_g68, sw_string = scase_tl_c5
          else, sw_string = scase_tl_c5p
          ]
        if cuttype = six,
          [
          if use_g68, sw_string = scase_tl_c6
          else, sw_string = scase_tl_c6p
          ]
        ]

pltype2         #Bottom turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        pcuttypldrl
        max_speed = max_speedl2
        min_speed = min_speedl2
        sw_string = scase_br_c1
        ]
      else,
        [
        #Mill
        pcuttypmdrl
        max_speed = max_speedm2
        min_speed = min_speedm2
        sw_string = scase_br_c2 #case two is the default
        if cuttype = -2, sw_string = scase_br_c_2
        if cuttype = three,
          [
          if use_g68, sw_string = scase_br_c3
          else, sw_string = scase_br_c3p
          ]
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_br_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_br_c4
        if cuttype = five,
          [
          if use_g68, sw_string = scase_br_c5
          else, sw_string = scase_br_c5p
          ]
        if cuttype = six,
          [
          if use_g68, sw_string = scase_br_c6
          else, sw_string = scase_br_c6p
          ]
        ]

pltype3         #Top turret/Right spindle
      if cuttype = one,
        [
        #Lathe
        pcuttypldrl
        max_speed = max_speedl3
        min_speed = min_speedl3
        sw_string = scase_tr_c1
        ]
      else,
        [
        #Mill
        pcuttypmdrl
        max_speed = max_speedm3
        min_speed = min_speedm3
        sw_string = scase_tr_c2 #case two is the default
        if cuttype = -2, sw_string = scase_tr_c_2
        if cuttype = three,
          [
          if use_g68, sw_string = scase_tr_c3
          else, sw_string = scase_tr_c3p
          ]
        if cuttype = four & abs(c1_millcc) = one, sw_string = scase_tr_c4c
        if cuttype = four & c1_millcc = zero, sw_string = scase_tr_c4
        if cuttype = five,
          [
          if use_g68, sw_string = scase_tr_c5
          else, sw_string = scase_tr_c5p
          ]
        if cuttype = six,
          [
          if use_g68, sw_string = scase_tr_c6
          else, sw_string = scase_tr_c6p
          ]
        ]

psw_str_mult    #Apply sw_string to variables and strings
      sg17  = "G17"
      sg18  = "G18"
      sg19  = "G19"
      sxg17 = "G17"
      sxg18 = "G18"
      sxg19 = "G19"
      #b axis type
      b_axistype = plcval (sw_string, 8)
      #c axis type
      c_axistype = plcval (sw_string, 9)
      #reverse spindle
      spd_rev = plcval (sw_string, 7)
      #plane 0
      rslt_plc = plcval (sw_string, 6)
       if rslt_plc = zero,
        [
        sg02 = sxg02
        sg03 = sxg03
        sg41 = sxg41
        sg42 = sxg42
        ]
      else,
        [
        sg02 = sxg03
        sg03 = sxg02
        sg41 = sxg42
        sg42 = sxg41
        ]
      #plane 1
      rslt_plc = plcval (sw_string, five)
      if rslt_plc = zero,
        [
        sg02_1 = sxg02
        sg03_1 = sxg03
        sg41_1 = sxg41
        sg42_1 = sxg42
        ]
      else,
        [
        sg02_1 = sxg03
        sg03_1 = sxg02
        sg41_1 = sxg42
        sg42_1 = sxg41
        ]
      #plane 2
      rslt_plc = plcval (sw_string, four)
      if rslt_plc = zero,
        [
        sg02_2 = sxg02
        sg03_2 = sxg03
        sg41_2 = sxg41
        sg42_2 = sxg42
        ]
      else,
        [
        sg02_2 = sxg03
        sg03_2 = sxg02
        sg41_2 = sxg42
        sg42_2 = sxg41
        ]
      #plane 0
      rslt_plc = plcval (sw_string, three)
      rslt_upd = updstr (swstr)
      plane2 = rslt_plc
      sg17 = swstr
      #plane 1
      rslt_plc = plcval (sw_string, two)
      rslt_upd = updstr (swstr)
      plane2 = rslt_plc
      sg19 = swstr
      #plane 2
      rslt_plc = plcval (sw_string, one)
      rslt_upd = updstr (swstr)
      plane2 = rslt_plc
      sg18 = swstr
      #plane 0, x axis
      rslt_plc = plcval (sw_string, m_one)
      pl_ax_m0x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -2)
      pl_ax_m0y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -3)
      pl_ax_m0z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -4)
      pl_ax_m1x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -5)
      pl_ax_m1y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -6)
      pl_ax_m1z = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -7)
      pl_ax_m2x = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -8)
      pl_ax_m2y = -((rslt_plc * two) - one)
      rslt_plc = plcval (sw_string, -9)
      pl_ax_m2z = -((rslt_plc * two) - one)

# --------------------------------------------------------------------------
#Saved values
# --------------------------------------------------------------------------
dia_mult_sav : dia_mult #Saved Value
spaces_sav   : spaces$
use_g68_sav  : 0

# --------------------------------------------------------------------------
# POST TEXT
# --------------------------------------------------------------------------
[CTRL_TEXT_XML_BEGIN]  # Post text edits MUST be made with Control Definition Manager.
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
	<control>
		<control_label>CTRL_MT_MILL|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]</text>
				<value>2</value>
			</misc_1>
			<misc_2>
				<text>Abs/Inc. [0=ABS, 1=INC]</text>
			</misc_2>
			<misc_3>
				<text>Ref. Return [0=G28,1=G30,2=G30P2,3=G30P3 etc.]</text>
			</misc_3>
			<misc_4>
				<text>Mill Cyc G107/G112 [0=OFF,1/-1=ON]</text>
			</misc_4>
			<misc_5>
				<text>C-Axis clamp [0=Off,1=Clamp,2=Brake,3=Both]</text>
			</misc_5>
			<misc_6>
				<text>B-Axis clamp [0=Off,1=Clamp,2=Brake,3=Both]</text>
			</misc_6>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>Percent of spindle speed to apply to live tool in synchronous drilling</text>
				<inch_value>50.</inch_value>
			</misc_1>
		</misc_reals>
		<simple_drill>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alesage 1</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alesage 2</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>Alesage indexe</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<simple_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 1</text>
			</description>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 2</text>
			</description>
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 3</text>
			</description>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Custom Drill Parameters 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Custom Drill Parameters 9</text>
			</description>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Custom Drill Parameters 10</text>
			</description>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Custom Drill Parameters 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Custom Drill Parameters 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Custom Drill Parameters 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Custom Drill Parameters 14</text>
			</description>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Custom Drill Parameters 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Custom Drill Parameters 16</text>
			</description>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Custom Drill Parameters 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Custom Drill Parameters 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Custom Drill Parameters 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Custom Drill Parameters 20</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Simple drill - no peck G83/G87</text>
			</simple_drill>
			<peck_drill>
				<text>Peck drill - full retract G83/G87</text>
			</peck_drill>
			<chip_break>
				<text>Chip break - incremental retract G83/G87</text>
			</chip_break>
			<tapping>
				<text>Tapping - feed in, reverse spindle - feed out G84/G88</text>
			</tapping>
			<boring_1>
				<text>Boring #1 - feed out G85/G89</text>
			</boring_1>
			<boring_2>
				<text>Boring #2 - stop spindle - rapid out G85/G89</text>
			</boring_2>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>Stop</text>
			</canned_text_1>
			<canned_text_2>
				<text>Ostop</text>
			</canned_text_2>
			<canned_text_3>
				<text>Bld on</text>
			</canned_text_3>
			<canned_text_4>
				<text>bLd off</text>
			</canned_text_4>
			<canned_text_5>
				<text>rEt. tlstk</text>
			</canned_text_5>
			<canned_text_6>
				<text>adV. tlstk</text>
			</canned_text_6>
			<canned_text_7>
				<text>Ret. chute</text>
			</canned_text_7>
			<canned_text_8>
				<text>Adv. chute</text>
			</canned_text_8>
			<canned_text_9>
				<text>eXstp on</text>
			</canned_text_9>
			<canned_text_10>
				<text>exstP off</text>
			</canned_text_10>
			<canned_text_11>
				<text>""</text>
			</canned_text_11>
		</canned_text>
	</control>
<control>
		<control_label>CTRL_MT_LATHE|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]</text>
				<value>2</value>
			</misc_1>
			<misc_2>
				<text>Abs/Inc. [0=ABS, 1=INC]</text>
			</misc_2>
			<misc_3>
				<text>Ref. Return [0=G28,1=G30,2=G30P2,3=G30P3 etc.]</text>
			</misc_3>
			<misc_7>
				<text>G361/G362 [0=G361,1=G362]</text>
			</misc_7>
		</misc_integers>
		<misc_reals>
			<misc_2>
				<text>G74 / G75 Backoff Value</text>
			</misc_2>
		</misc_reals>
		<simple_drill>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Chip break (G74)</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Taraudage</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Bore #1</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</bore1>
		<bore2>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<misc2>
			<description>
				<text>Misc. #2</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</misc2>
		<drill_cycle_9>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_9>
		<drill_cycle_10>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_10>
		<drill_cycle_11>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_11>
		<drill_cycle_12>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_12>
		<drill_cycle_13>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_13>
		<drill_cycle_14>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_14>
		<drill_cycle_15>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_15>
		<drill_cycle_16>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_16>
		<drill_cycle_17>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_17>
		<drill_cycle_18>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_18>
		<drill_cycle_19>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_19>
		<drill_cycle_20>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 1</text>
			</description>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 2</text>
			</description>
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 3</text>
			</description>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Custom Drill Parameters 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Custom Drill Parameters 9</text>
			</description>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Custom Drill Parameters 10</text>
			</description>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Custom Drill Parameters 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Custom Drill Parameters 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Custom Drill Parameters 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Custom Drill Parameters 14</text>
			</description>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Custom Drill Parameters 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Custom Drill Parameters 16</text>
			</description>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Custom Drill Parameters 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Custom Drill Parameters 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Custom Drill Parameters 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Custom Drill Parameters 20</text>
			</description>
		</drill_cycle_20_custom_parameters>
	</control>
	<control>
		<control_label>CTRL_MT_MILL|MORI_SEIKI NT_SERIES 5X MT_LATHE</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>Work Pos. [-1=REF,0=G50,1=HOME,2=G54s]</text>
				<value>2</value>
			</misc_1>
			<misc_2>
				<text>Abs/Inc. [0=ABS, 1=INC]</text>
			</misc_2>
			<misc_3>
				<text>Ref. Return [0=G28,1=G30,2=G30P2,3=G30P3 etc.]</text>
			</misc_3>
			<misc_4>
				<text>Mill Cyc G107/G112 [0=OFF,1/-1=ON]</text>
			</misc_4>
			<misc_5>
				<text>C-Axis clamp [0=Off,1=Clamp,2=Brake,3=Both]</text>
			</misc_5>
			<misc_6>
				<text>B-Axis clamp [0=Off,1=Clamp,2=Brake,3=Both]</text>
			</misc_6>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>% of spindle speed for live tool in sync drilling</text>
				<inch_value>50.</inch_value>
			</misc_1>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Percage/Lamage</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Brise copeaux</text>
			</description>
			<dwell>
				<text>""</text>
			</dwell>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Debourage</text>
			</description>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alesage 1</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alesage 2</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>Alesage indexe</text>
			</description>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<simple_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 1</text>
			</description>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 2</text>
			</description>
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 3</text>
			</description>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Custom Drill Parameters 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Custom Drill Parameters 9</text>
			</description>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Custom Drill Parameters 10</text>
			</description>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Custom Drill Parameters 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Custom Drill Parameters 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Custom Drill Parameters 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Custom Drill Parameters 14</text>
			</description>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Custom Drill Parameters 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Custom Drill Parameters 16</text>
			</description>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Custom Drill Parameters 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Custom Drill Parameters 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Custom Drill Parameters 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Custom Drill Parameters 20</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Simple drill - no peck G83/G87</text>
			</simple_drill>
			<peck_drill>
				<text>Peck drill - full retract G83/G87</text>
			</peck_drill>
			<chip_break>
				<text>Chip break - incremental retract G83/G87</text>
			</chip_break>
			<tapping>
				<text>Tapping - feed in, reverse spindle - feed out G84/G88</text>
			</tapping>
			<boring_1>
				<text>Boring #1 - feed out G85/G89</text>
			</boring_1>
			<boring_2>
				<text>Boring #2 - stop spindle - rapid out G85/G89</text>
			</boring_2>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>Stop</text>
			</canned_text_1>
			<canned_text_2>
				<text>Ostop</text>
			</canned_text_2>
			<canned_text_3>
				<text>Bld on</text>
			</canned_text_3>
			<canned_text_4>
				<text>bLd off</text>
			</canned_text_4>
			<canned_text_5>
				<text>rEt. tlstk</text>
			</canned_text_5>
			<canned_text_6>
				<text>adV. tlstk</text>
			</canned_text_6>
			<canned_text_7>
				<text>Ret. chute</text>
			</canned_text_7>
			<canned_text_8>
				<text>Adv. chute</text>
			</canned_text_8>
			<canned_text_9>
				<text>eXstp on</text>
			</canned_text_9>
			<canned_text_10>
				<text>exstP off</text>
			</canned_text_10>
			<canned_text_11>
				<text>""</text>
			</canned_text_11>
		</canned_text>
	</control>
	<control>
		<control_label>CTRL_MT_LATHE|MORI_SEIKI NT_SERIES 5X MT_LATHE</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>Origine. [-1=REF,0=G50,1=Machine,2=G54]</text>
			</misc_1>
			<misc_2>
				<text>Abs/Inc. [0=ABS, 1=INC]</text>
			</misc_2>
			<misc_3>
				<text>Ref. retour [0=G28,1=G30,2=G30P2,3=G30P3 etc.]</text>
			</misc_3>
			<misc_7>
				<text>G361/G362 [0=G361,1=G362]</text>
			</misc_7>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>% of spindle speed for live tool in sync drilling</text>
				<inch_value>50.</inch_value>
			</misc_1>
			<misc_2>
				<text>G74 / G75 Backoff Value</text>
			</misc_2>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Percage/Lamage</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Debourage ABS</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Debourage INC</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alesage</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</bore1>
		<bore2>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc1>
		<misc2>
			<description>
				<text>Misc. #2</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</misc2>
		<drill_cycle_9>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_9>
		<drill_cycle_10>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_10>
		<drill_cycle_11>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_11>
		<drill_cycle_12>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_12>
		<drill_cycle_13>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_13>
		<drill_cycle_14>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_14>
		<drill_cycle_15>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_15>
		<drill_cycle_16>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_16>
		<drill_cycle_17>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_17>
		<drill_cycle_18>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_18>
		<drill_cycle_19>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_19>
		<drill_cycle_20>
			<feed_rate>
				<text>""</text>
			</feed_rate>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 1</text>
			</description>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 2</text>
			</description>
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Custom Drill Parameters 3</text>
			</description>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Custom Drill Parameters 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Custom Drill Parameters 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Custom Drill Parameters 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Custom Drill Parameters 9</text>
			</description>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Custom Drill Parameters 10</text>
			</description>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Custom Drill Parameters 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Custom Drill Parameters 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Custom Drill Parameters 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Custom Drill Parameters 14</text>
			</description>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Custom Drill Parameters 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Custom Drill Parameters 16</text>
			</description>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Custom Drill Parameters 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Custom Drill Parameters 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Custom Drill Parameters 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Custom Drill Parameters 20</text>
			</description>
		</drill_cycle_20_custom_parameters>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
