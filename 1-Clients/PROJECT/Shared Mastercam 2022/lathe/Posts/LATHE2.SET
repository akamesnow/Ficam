[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V24.00 P2 E1 W24.00 T1648225310 M24.00 I0 O0
# Post Name           : Lathe2.set
# Product             : Lathe
# Machine Name        : Generic
# Control Name        : Generic
# Description         : Generic setup sheet for Lathe X
# Mill/Turn           : No
# 4-axis/Axis subs.   : No
# 5-axis              : No
# Executable          : MP 18.0
#
# WARNING: THIS POST IS GENERIC AND IS INTENDED FOR MODIFICATION TO
# THE MACHINE TOOL REQUIREMENTS AND PERSONAL PREFERENCE.
#
# --------------------------------------------------------------------------
# Revision log:
# --------------------------------------------------------------------------
# CNC 04/28/05  -  Initial Setup for Version X.
# CNC 11/15/05  -  Modified header section and layout, added new functionality
# CNC 01/20/06  -  Fixed buffer logic to correctly handle null toolchanges
# CNC 02/22/06  -  Added opcomment string reset in pcomment2
# CNC 03/14/06  -  Modified pdrillcyc to use nextdc$ rather than drillcyc$
# CNC 06/26/06  -  Initial post setup for Mastercam X2
# CNC 07/18/06  -  Added !op_id$ to psof$, ptlchg$ and ptlchg0$, removed tlchng_aft$
# CNC 10/31/07  -  Added sub_level$ override to pprep$
# CNC 12/18/07  -  Modified EOB (End of Block) in pprep$ postblock
# CNC 04/08/08  -  X3 release - no changes made
# CNC 01/26/09  -  Initial post update for Mastercam X4
# CNC 02/03/10  -  Initial post update for Mastercam X5
# CNC 08/17/10  -  Removed CD_VAR variables
# CNC 05/20/11  -  Initial post update for Mastercam X6
# CNC 09/16/11  -  Added plunge turn operation to String selector table.
# CNC 10/16/12  -  Initial post update for Mastercam X7
# CNC 02/06/14  -  Initial post update for Mastercam X8
# CNC 12/23/14  -  Initial post update for Mastercam X9
#
# --------------------------------------------------------------------------
# Features:
# --------------------------------------------------------------------------
# This post supports output for 2 axis turning.
# It is designed to support the features of Mastercam X Lathe.
#
# NEW FEATURES FOR X:
# - Supports X comments including machine name, group name and group comment output (see pcomment2)
#     Output of these comments is controlled by setting outputxcom in the Optional Output Settings area.
# - Enhanced output control via post switches (see Optional Output Settings area)
#
# --------------------------------------------------------------------------
# Misc. Values:
# --------------------------------------------------------------------------
# Integers:
#
# mi1 - mi10 (NOT USED)
#
# Reals:
#
# mr1 - mr10 (NOT USED)
#
# --------------------------------------------------------------------------
# Additional Notes:
# --------------------------------------------------------------------------
# File extension (.doc) is set internally in MP.  Use pprep$ postblock to override this setting.
#
# Rapid traverse times are determined by maximum rapid feedrates set in the selected Machine Definition
# Time estimates will be wrong if these settings are incorrect.
#
# END_HEADER$
#
# --------------------------------------------------------------------------
# Debugging and Factory Set Program Switches
# --------------------------------------------------------------------------
# Define constants
m_one        := -1
zero         := 0
one          := 1
two          := 2
three        := 3
four         := 4
five         := 5
c9k          := 9999
m_c9k        := -99999

bug1$        : 2     #0=No display, 1=Generic list box, 2=Editor
bug4$        : 1     #Debug output with the tilde '~'.
                     #A value greater the zero applies the variable formatting with
                     #debug output (default is typically FS 1 but not a guarantee).
                     #A value of zero gets the value directly with NO formatting.

linktolvar$  : 0     #Associate X tolerance variables to V9- variable?
linkplnvar$  : 1     #Associate X plane specific variables to V9- variable?
linklvar$    : 1     #Associate X lathe specific variables to V9- variable?

skp_lead_flgs$ : 0   #Do NOT use v9+ style contour flags
get_1004$    : 0     #Find gcode 1004 with getnextop?
rpd_typ_v7$  : 0     #Use Version 7 style contour flags/processing?
strtool_v7$  : 2     #Use Version 7+ toolname?
cant_tlchng$ : 1     #Ignore cantext entry on move with tlchng_aft
newglobal$   : 1     #Error checking for global variables
getnextop$   : 1     #Build the next variable table
tooltable$   : 3     #Pre-read, call the pwrtt postblock (DO NOT CHANGE!)

# --------------------------------------------------------------------------
# General Output Settings
# --------------------------------------------------------------------------
linarc$      : yes$  #Linearize arcs? (DO NOT CHANGE!)
progname$    : 1     #Use uppercase for program name (sprogname)

# --------------------------------------------------------------------------
# Optional Output Settings
# --------------------------------------------------------------------------
output_comments : yes$ #Output Operation Comments in tool list?

outputxcom   : yes$  #Output new X comments? (Machine name, Group comment, Group name)

xz_limits    : 2     #Output Max/Min X,Y,Z information?
                     #0 = Do NOT output ANY Max/Min X,Y,Z information.
                     #1 = Output Max/Min X,Y,Z info. ONLY for EACH tool (not Program)
                     #2 = Output Max/Min X,Y,Z info. ONLY for entire Program
                     #3 = Output Max/Min X,Y,Z info. for EACH tool AND Program (if > 1 tool)

# Individual axis output (if xz_limits > 0)
X_limits     : yes$  #Output Max/Min values for the X axis?
Z_limits     : yes$  #Output Max/Min values for the Z axis?

# Specific setting to allow tuning the cycle time calculations
# Set the time it takes for machine to do a toolchange
tlchgtime    : 0.1   #Tool Change Time (* in Minutes *)

time_est     : 3     #Output operation and/or cycle times?
                     #0 = Do NOT output time estimates (including det_time estimates below)
                     #1 = Output operation time ONLY for EACH tool (not Program)
                     #2 = Output comeplete cycle time ONLY for entire Program
                     #3 = Output operation time for EACH tool AND cycle time for Program (if > 1 tool)

# The 'det_time' switch allows selecting the output of "Detailed Times".
# In addition to the usual 'Cycle Time' you can get the time spent at
# RAPID and at FEEDRATE during the program.
# *IMPORTANT* -
# Note that the Program TOTAL TIME includes the Toolchange time(s),
# so it will be longer than the Total RAPID time + Total FEED time!
det_time     : 2     #Output Rapid/Feedrate times? (Requires time_est > 0)
                     #0 = Do NOT output ANY Rapid/Feedrate time breakdown.
                     #1 = Output Rapid/Feedrate times ONLY for EACH tool (not Program)
                     #2 = Output Rapid/Feedrate times ONLY at end for entire program
                     #3 = Output Rapid/Feedrate times for EACH tool AND Program (if > 1 tool)


show_lengths : 2     #Output Feed/Rapid path length information?
                     #0 = Do NOT output ANY Feed/Rapid path length information.
                     #1 = Output Feed/Rapid path length info. ONLY for EACH tool (not Program)
                     #2 = Output Feed/Rapid path length info. ONLY at end for entire program
                     #3 = Output Feed/Rapid path length info. for EACH tool AND Program (if > 1 tool)

stock_info   : yes$  #Display stock material and size?

# --------------------------------------------------------------------------
# Common User-defined Variable Initializations (not switches!)
# --------------------------------------------------------------------------
dia_mult     : 2     #Multiplier for output on X axis
drlgsel      : -1    #Selector variable for drill cycle string
tol          : 0.0001#Tolerence for feed rates set to zero
max_speed    : 10000 #Maximum spindle speed (used if maxss out of range)
min_speed    : 0     #Minimum spindle speed
strt_spd     : 0     #Test spindle speed
testx        : 0     #Test X position
ttltime      : 0     #Total operation time
tltime       : 0     #Feed time
trtime       : 0     #Rapid time
total        : 0     #Total machine time
tot_ltime    : 0     #Total FEED time
tot_rtime    : 0     #Total RAPID time
dx           : 0     #Delta X
dz           : 0     #Delta Z
cssflag      : 0     #Indicate if CSS calculations are required
cssarea      : 0     #CSS calculations
absfr        : 0     #CSS calculations (Feedrate as a POSITIVE value)
thdxr        : 0     #Thread rapid point X
xsav         : 0     #Thread saved point X
zsav         : 0     #Thread saved point Z
thdrapfr     : 0     #Rapid traverse rate when Threading (saved from 'fr')
maxss_x      : 0     #Clamp RPM occurs at the X axis position
len          : 0     #Length for calculation
len1         : 0     #Broken length
len2         : 0     #Broken length
percent      : 0     #Percent of length
tool_op1     : 0     #Operation comment selector variable (post calculated)
is_miscops   : 0     #Misc. Op. flag
tool_end     : no$   #End flag when scanning for CDC settings at Null tlchgs

# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Spacing strings
spaceit      : ""    #0 or 1 spaces depending on Inch/Metric output format
space1       : " "   #1 space
scommentspc  : "                     " #Space for comments

#Seperator lines
sepline      : "-------------------------------------------------"
sepline2     : "==========================================="
sepline3     : "================================================="

#Comment strings
snull        : ""    #Null string
smachname    : ""    #Machine name
sgrpcomm     : ""    #Group comment
sgrpname     : ""    #Group name
sopcomment   : ""    #Operation comment

#Misc. Ops. strings
sblank       : ""    #'Blank' empty string
smiscops_1   : ""    #String varaible to hold message line #1
smiscops_2   : ""    #String varaible to hold message line #2
smiscops_900 : " Stock Transfer "
smiscops_901 : " Stock Flip "
smiscops_902 : " Stock Advance "
smiscops_903 : " Chuck Clamp/Unclamp "
smiscops_904 : " Tailstock "
smiscops_905 : " Steady Rest "
stck_spindle0_0 : "Xfer Part from Left Spindle"
stck_spindle1_0 : "Xfer Part from Right Spindle"
stck_op0     : "Push stock"
stck_op1     : "Push stock with 'Use Tool Stop' option"
stck_op2     : "Pull stock"
stck_spindle0_1 : " - from Left Spindle"
stck_spindle1_1 : " - from Right Spindle"
sclmp_op0     : "Clamp"
sclmp_op1     : "Un-clamp"
sclmp_op2     : "Re-position"
sclmp_spindle0 : " - Left Spindle"
sclmp_spindle1 : " - Right Spindle"
stlstck_on0   : "Retract Tailstock"
stlstck_on1   : "Engage Tailstock"

# --------------------------------------------------------------------------
# General String select tables
# --------------------------------------------------------------------------
#Select operation note
sopid60 : "Rough"
sopid61 : "Finish"
sopid62 : "Grooving"
sopid63 : "Threading"
sopid64 : "Drill Cycle - "
sopid65 : "Point"
sopid66 : "Facing"
sopid67 : "Cutoff"
sopid68 : "Plunge Rough"
sopid69 : "Manual Entry"
sopid70 : "Merged ASCII"
sopid1  : ""         #Target string

fstrsel sopid60 tool_op1 sopid1 11 -1
# --------------------------------------------------------------------------
#Select operation note
sopid201 : "Canned Finish"
sopid202 : "Canned Rough"
sopid203 : "Canned Rough and Finish"
sopid204 : "Canned Rough Face"
sopid205 : "Canned Rough and Finish Face"
sopid206 : "Canned Pattern Repeat Rough"
sopid207 : "Canned Pattern Repeat Rough and Finish"
sopid208 : "Canned Groove Rough"
sopid209 : "Canned Groove Finish"
sopid210 : "Quick Rough"
sopid211 : "Quick Finish"
sopid212 : "Quick Groove"
sopid213 : "C-Hook Generated"
sopid214 : "Stock Transfer"
sopid215 : "Stock Flip"
sopid216 : "Bar Feed"
sopid217 : "Chuck Clamp/Un-Clamp"
sopid218 : "Tailstock Position"
sopid219 : "Steadyrest Position"
sopid220 : ""
sopid221 : ""
sopid222 : ""
sopid223 : ""
sopid224 : "PLUNGE TURN"
sopid2   : ""        #Target string

fstrsel sopid201 tool_op1 sopid2 24 -1
# --------------------------------------------------------------------------
#Select drill operation note
sdr00   : "Simple"       #drill - no dwell
sdrd0   : "Counterbore"  #drill - with dwell
sdr01   : "Peck"         #peck drill - no dwell
sdrd1   : "Peck"         #peck drill - with dwell
sdr02   : "Chip Break"   #chip break - no dwell
sdrd2   : "Chip Break"   #chip break - with dwell
sdr03   : "Tap"          #tap - right hand
sdrd3   : "Tap"          #tap - left hand
sdr04   : "Simple Bore"  #bore #1 - no dwell
sdrd4   : "Bore W/Dwell" #bore #1 - with dwell
sdr05   : "Bore W/Stop"  #bore #2 - no dwell
sdrd5   : "Bore W/Stop"  #bore #2 - with dwell
sdr06   : "Misc_1"       #misc #1 - no dwell
sdrd6   : "Misc_1"       #misc #1 - with dwell
sdr07   : "Misc_2"       #misc #2 - right hand
sdrd7   : "Misc_2"       #misc #2 - left hand
sdrillcyc : ""           #Target string

fstrsel sdr00 drlgsel sdrillcyc 16 -1
# --------------------------------------------------------------------------
# Month selector
smon0   : ""
smon1   : "Jan."
smon2   : "Feb."
smon3   : "Mar."
smon4   : "Apr."
smon5   : "May."
smon6   : "Jun."
smon7   : "Jul."
smon8   : "Aug."
smon9   : "Sep."
smon10  : "Oct."
smon11  : "Nov."
smon12  : "Dec."
smonth  : ""         #Target string

fstrsel smon0 month$ smonth 13 -1
# --------------------------------------------------------------------------
# Format statements - n=nonmodal, l=leading, t=trailing, i=inc, d=delta
# --------------------------------------------------------------------------
fs2  1  0.4 0.3      #Decimal, absolute, 4/3 place, default for initialize (:)
fs2  2  0.4 0.3n     #Decimal, absolute, 4/3 place, non-modal
fs2  3  1 0 1 0n     #Integer, not leading, non-modal
fs2  4  0.2 0.2n     #Decimal, absolute, 2 place, non-modal
fs2  5  1.4 1.3ltn   #Decimal, absolute, 4/3 place, leading&trailing, non-modal
fs2  6 +1.4 1.3ltn   #Decimal, absolute, 4/3 place, leading&trailing with SIGN
fs2  7  0.4 0.3ltn   #Decimal, 4/3 place, trailing, non-modal
fs2  8  0^2 0^2n     #Decimal, 2 place, omit decimal if whole number, non-modal
fs2  9  4 0 4 0l     #Integer, force four leading

# These formats used for 'Date' & 'Time'
fs2 17  1 0 1 0      #Integer, not leading
fs2 18  2.2 2.2lt    #Decimal, force two leading & two trailing (time2)
fs2 19  2 0 2 0t     #Integer, force trailing                   (hour)
fs2 20  0 2 0 2lt    #Integer, force leading & trailing         (min)

# --------------------------------------------------------------------------
# Format assignments
# --------------------------------------------------------------------------
fmt     9   progno$     #Program number
fmt     3   t$          #Tool number
fmt     7   tcr$        #Tool corner radius
fmt     3   tloffno$    #Diameter offset number
fmt     3   speed       #Spindle speed
fmt     3   maxss$      #Max Spindle speed
fmt     4   absfr       #Feedrate
fmt     2   llen        #Feed cut length
fmt     2   rlen        #Rapid traverse cut length
fmt     2   llen_total  #Feed cut length (program total)
fmt     2   rlen_total  #Rapid traverse cut length (program total)
fmt     3   thrs        #Time in hours
fmt     3   tmin        #Time in minutes
fmt     8   tsec        #Time in seconds
fmt     3   tcnt        #Tool Counter
fmt     3   custcycle   #Custom Cycle number
fmt     2   stck_ht$    #Stock Length
fmt     2   stck_wdth$  #Maximum Stock Diameter
# --------------------------------------------------------------------------
#Format the variables used to output the X,Z Max/Min values
fmt     6   max_Xpos
fmt     6   min_Xpos
fmt     6   max_Zpos
fmt     6   min_Zpos
# --------------------------------------------------------------------------
fmt     17  year2       #Calculated year value
fmt     18  time2       #Capture 24-hour time value into 'time2' variable
fmt     19  hour        #Hour
fmt     20  min         #Minutes
year2 = year$ + 2000

# --------------------------------------------------------------------------
# Tool Comment / Manual Entry Section
# --------------------------------------------------------------------------
pcomment$        #Comment from manual entry (must call pcomment2)
      pcomment2  #Required if doing boolean 'if' logic testing!

pcomment2        #Output Comment from manual entry
      sopcomment = snull
      #scomm$ = ucase (scomm$)
      if gcode$ = 1051, smachname = scomm$   #Machine name
      if gcode$ = 1052, sgrpcomm = scomm$    #Group comment
      if gcode$ = 1053, sgrpname = scomm$    #Group name
      if gcode$ = 1008, sopcomment = scomm$  #Operation comment

pdrillcyc        #Output drillcycle type note if canned cycle was programmed
      if opcode$ = five,
        [
        if nextdc$ = three | nextdc$ = 7, drlgsel = fsg1(-ss$) + nextdc$ * two
        else, drlgsel = fsg2(dwell$) + nextdc$ * two
        if drlgsel > 15,  #Custom canned cycle was programmed
          [
          custcycle = drlgsel - 7  #Shift it
          "Custom Cycle ", 35, *custcycle
          ]
        else, *sdrillcyc
        ]

#----------------------------------------------------------------------------
# Lathe 'Misc. Ops.' toolpath functions - comment output only!
# --------------------------------------------------------------------------
pmiscops         #Check if there was a Misc Ops. function programmed
      if is_miscops > 0 & (smiscops_1 <> sblank | smiscops_1 <> sblank),
        [
        " ", *e$  #Output a blank line
        if smiscops_1 <> sblank, "(*", smiscops_1, "*)", e$
        if smiscops_2 <> sblank, "(", smiscops_2, ")", e$
        " ", *e$  # Output a blank line
             ]
        is_miscops = 0  #Reset the flag
        smiscops_1 = sblank
        smiscops_2 = sblank

pmiscops_msg     #Output a message if a 'Misc Ops' function is programmed
      if gcode$ >= 900 & gcode$ <= 905,
        [
        is_miscops = gcode$
        if gcode$ = 900, smiscops_1 = smiscops_900
        if gcode$ = 901, smiscops_1 = smiscops_901
        if gcode$ = 902, smiscops_1 = smiscops_902
        if gcode$ = 903, smiscops_1 = smiscops_903
        if gcode$ = 904, smiscops_1 = smiscops_904
        if gcode$ = 905, smiscops_1 = smiscops_905
        ]

pstck_trans$     #Misc Ops. - Stock Xfer (NCI code = 900)
      #Available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_chuk_st_dz, stck_chuk_st_dx,
      #stck_chuk_end_dz, stck_chuk_end_dx
      pmiscops_msg   #Get the message for this Misc. Ops. function
      if stck_spindle$ = 0, smiscops_2 = stck_spindle0_0
      if stck_spindle$ = 1, smiscops_2 = stck_spindle1_0

pstck_flip$      #Misc Ops. - Stock Flip (NCI code = 901)
      #Available variables:
      #stck_spindle, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x
      pmiscops_msg   #Get the message for this Misc. Ops. function
      smiscops_2 = "Flip Stock"

pstck_bar_fd$    #Misc Ops. - Stock Advance (NCI code = 902)
      #Available variables:
      #stck_spindle, stck_op, stck_clear,
      #stck_grip, stck_init_z, stck_final_z,
      #stck_chuk_st_z, stck_chuk_st_x,
      #stck_chuk_end_z, stck_chuk_end_x,
      #stck_adv_fr, stck_appr_fr
      pmiscops_msg   #Get the message for this Misc. Ops. function
      if stck_op$ = 0, smiscops_2 = stck_op0
      if stck_op$ = 1, smiscops_2 = stck_op1
      if stck_op$ = 2, smiscops_2 = stck_op2
      #Build up the message string
      if stck_spindle$ = 0, smiscops_2 = smiscops_2  + stck_spindle0_1
      if stck_spindle$ = 1, smiscops_2 = smiscops_2  + stck_spindle1_1
      if stck_op$ = 1,  pmiscops

pchuck$          #Misc Ops. - Chuck (NCI code = 903)
      #Available variables:
      #clmp_spindle, clmp_op,  stck_chuk_st_z,
      #stck_chuk_st_x, stck_chuk_end_z, stck_chuk_end_x
      pmiscops_msg   #Get the message for this Misc. Ops. function
      if clmp_op$ = 0, smiscops_2 = sclmp_op0
      if clmp_op$ = 1, smiscops_2 = sclmp_op1
      if clmp_op$ = 2, smiscops_2 = sclmp_op2
      #Build up the message string
      if clmp_spindle$ = 0, smiscops_2 = smiscops_2 + sclmp_spindle0
      if clmp_spindle$ = 1, smiscops_2 = smiscops_2 + sclmp_spindle1

ptailstock$      #Misc Ops. - TailStock (NCI code = 904)
      #Available variables:
      #tlstck_on, stck_init_z, stck_final_z
      pmiscops_msg   #Get the message for this Misc. Ops. function
      if tlstck_on$ = 0, smiscops_2 = stlstck_on0
      if tlstck_on$ = 1, smiscops_2 = stlstck_on1

psteadyrest$     #Misc Ops. - SteadyRest (NCI code = 905)
      #Available variables:
      #stck_init_z, stck_final_z
      pmiscops_msg   #Get the message for this Misc. Ops. function
      smiscops_2 = "Position Steadyrest"

# --------------------------------------------------------------------------
# Start of File and Toolchange Setup
# --------------------------------------------------------------------------
ptimecalc        #Convert 24-hour time format into 12-hour AM/PM format
      if time$ >= 13, time2 = (time$ - 12)
      else, time2 = time$
      hour = int(time2), min = frac(time2)
      *hour, ":", *min,
      if time$ > 12, " PM"
      else, " AM"

pheader$         #Call before start of file
      if pst_rpd_fr$ <= 0, pst_rpd_fr$ = 300  #Make it greater than ZERO !
      if met_tool$ = one, spaceit = space1    #1 additional space for Metric output format
      "Customizable Lathe Setup Sheet - LATHE2.SET", e$
      sepline2, e$
      " ", e$  #Blank line
      "Program Name   = ", *sprogname$, e$
      if progno$ > zero, "Program Number = ", *progno$, e$
      #Date/Time output
      #"Date Processed = ", month$, "-", day$, "-", year$, e$   #Date output as month,day,year - Ex. 02-12-05
      "Date Processed = ", *smonth, " ", day$, " ", *year2, e$  #Date output as month,day,year - Ex. Feb. 12 2005
      #"Date Processed (DD-MM-YY) = ", date$, " Time(HH:MM) = ", time$, e$  #Date and time output Ex. 12-02-05 15:52
      #"Time           = ", time$, e$                           #24 hour time output - Ex. 15:52
      "Time           = ", ptimecalc, e$                        #12 hour time output 3:52 PM
      pstock_info  #Stock information output
      comment$
      if outputxcom,  #If start of file and outputxcom = yes$
        [
        if smachname <> snull, "Machine Name   = ", smachname, e$  #Machine name
        if sgrpcomm <> snull, "Group Comment  = ", sgrpcomm, e$    #Group comment
        if sgrpname <> snull, "Group Name     = ", sgrpname, e$    #Group name
        ]
      " ", e$  #Blank line
      "               Tool List", e$
      "               ---------", e$
      " ", e$  #Blank line
      "Num.  Off.   Rad.    Description/Comments", e$

psof0$           #Start of file for tool zero
      psof$

psof$            #Start of file for non-zero tool number
      psetup  #Call for toolchange info output
      !op_id$

ptlchg0$         #Call from NCI null tool change (tool number repeats)
      !gcode$
      if op_id$ <> prv_op_id$, ptlchg$
      !op_id$

ptlchg$          #Tool change - Output of time calculations for the last tool run
      #Calculate for the 'return to home' move at toolchange
      gcode$ = zero
      x$ = xh$, z$ = zh$
      prapid$
      ptooldata  #Total ending data for tool (Path Length and Times)
      comment$
      psetup     #Call for toolchange info output
      !op_id$

peof0$           #End of file for tool zero
      peof$

peof$            #End of file for non-zero tool - Output of time calculations for the last tool and total time
      #Calculate for the 'return to home' move at end of program
      gcode$ = zero
      x$ = xh$, z$ = zh$
      prapid$
      ptooldata  #Total ending data for tool (Path Length and Times)
      #Supress Program totals if only one tool or no output selected
      if tcnt > one & (xz_limits | show_lengths | time_est),
        [
        sepline3, e$
        " ", e$  #Blank line
        "Program Totals (", *tcnt, " Tools):", e$
        sepline, e$  #Output the separator '----' line

        #Output Max/Min X,Y,Z information
        if xz_limits = two | xz_limits = three,
          [
          preadbuf1e   #Read Buffer 1 (get X,Z extents of entire program)
          pMaxMin      #Output Max/Min X,Z coords for entire program
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Feed/Rapid path lengths
        if show_lengths = two | show_lengths = three,
          [
          "Total Feed Cut Length = ", *llen_total, e$
          "Total Rapid Traverse Length = ", *rlen_total, e$
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Rapid/Feedrate times
        if time_est > 0 & (det_time = two | det_time = three),
          [
          ttltime = tot_rtime
          "Total Rapid Time = ", ptimeout, e$
          ttltime = tot_ltime
          "Total Feed  Time = ", ptimeout, e$
          #sepline, e$  #Output the separator '----' line
          ]

        #Output Cycle Time information
        if time_est = two | time_est = three,
          [
          ttltime = total                #Transfer TOTAL program time
          "Cycle Time = ", ptimeout, e$  #Program Total time output
          ]
        ]

ptspace          #Creates spaces based on tool number
      if t$ < 10, space1

phspace          #Creates spaces based on length offset number
      if tlngno$ < 10, space1

pdspace          #Creates spaces based on diameter offset number
      if tloffno$ < 10, space1

pdiamspc         #Creates spaces based on diameter offset number
      if tldia$ < 10, space1

psetup           #Output of toolchange information
      pmiscops  #Check if there was a Misc Ops. function programmed
      !gcode$
      tcnt = tcnt + one  #Tool Counter
      preadbuf1t     #Read Buffer 1 (get XZ extents)
      if opcode$ > 100, opcode$ = opcode$ - 100  #'Adjust' opcode
      absfr = abs(fr$)
      pspindle
      cssflag = zero
      if ss$ < zero, cssflag = one
      sepline, e$  #Output the separator '----' line
      ptspace, *t$, "    ", pdspace, *tloffno$, "   ", pdiamspc, *tcr$, "  ",
        spaceit, "  ", *strtool$, e$
      if output_comments & sopcomment <> snull, scommentspc, sopcomment, e$  #Operation comment
      sepline, e$     #Output the separator '----' line
      llen = zero     #Reset counter for next tool
      rlen = zero     #Reset counter for next tool
      tltime = zero   #Reset counter for next tool
      trtime = zero   #Reset counter for next tool
      ttltime = zero  #Reset counter for next tool
      x$ = xh$, z$ = zh$
      !x$, !z$  #Update previous [prv_?] variables

ptooldata        #Total ending data for tool (Path Length and Times)
      #Output Max/Min X,Y,Z information
      if xz_limits = one | xz_limits = three,
        [
        pMaxMin      #Output Max/Min X,Z coords during this tool operation
        #sepline, e$  #Output the separator '----' line
        ]

      #Output Feed/Rapid path lengths
      if show_lengths = one | show_lengths = three,
        [
        "Tool Feed Cut Length = ", *llen, e$
        "Tool Rapid Traverse Length = ", *rlen, e$
        #sepline, e$  #Output the separator '----' line
        ]
      llen_total = llen_total + llen  #Keep running total for Program
      rlen_total = rlen_total + rlen  #Keep running total for Program

      #Output Rapid/Feedrate times
      if time_est > 0 & (det_time = one | det_time = three),
        [
        ttltime = trtime
        "Rapid Time = ", ptimeout, e$  #Time at RAPID RATE (for last tool)
        ttltime = tltime
        "Feed Time  = ", ptimeout, e$  #Time at FEEDRATE (for last tool)
        #sepline, e$  #Output the separator '----' line
        ]

      pttltime  #Total tool times
      #Output Cycle Time information
      if time_est = one | time_est = three,
        [
        "Operation Time = ", ptimeout, e$  #This operations time output
        #sepline, e$  #Output the separator '----' line
        ]

pthrminsec       #Convert minutes to hr/min/sec format
      thrs = int(ttltime / 60)
      tmin = int(ttltime - thrs * 60)
      tsec = (ttltime - thrs * 60 - tmin) * 60

pttltime         #Total tool times and total program time
      tot_ltime = tot_ltime + tltime      #Total FEED time
      tot_rtime = tot_rtime + trtime      #Total RAPID time
      ttltime = tltime + trtime           #Calc. current Tool Time
      total = ttltime + total + tlchgtime #Calc. total Program Time

ptimeout         #Output "times"
      pthrminsec  #Convert minutes to hr/min/sec format
      #Output 'HOURS'
      if thrs = one, *thrs, " Hour, "
      if thrs > one, *thrs, " Hours, "
      #Output 'MINUTES'
      if tmin = one, *tmin, " Minute, "
      if tmin > one, *tmin, " Minutes, "
      #Output 'SECONDS'
      if tsec > zero, *tsec, " Seconds"

ptimer           #Rapid time and length calc
      rlen = rlen + len            #Running total RAPID length
      trtime = rlen / pst_rpd_fr$  #Running total RAPID time

ptimel           #Feed time and length calc, RPM and IPM
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$              #Was already in IPM
      if absfr < tol, absfr = tol    #Make sure it is valid
      tltime = tltime + len / absfr  #Calc. total Feed time

ptimecs2_1a      #Feed time and length calc, CSS
      speed = abs(ss$)
      absfr = abs(fr$)
      if absfr < tol, absfr = tol         #Make sure it is valid
      if speed = zero, speed = min_speed  #Make sure it is valid
      if met_tool$ = zero, tltime = tltime + (cssarea * (one / (absfr * 12 * speed)))
      else, tltime = tltime + (cssarea * (one / (absfr * 1000 * speed)))

ptimecs2_1       #Feed time and length calc, CSS
      cssarea = pi$ * len * (abs(prv_x$) + abs(x$))
      ptimecs2_1a

ptimecs2_2a      #Feed time and length calc, CSS
      percent = abs(prv_x$ - maxss_x) / abs(dx)
      len1 = len * percent
      len2 = len * (one - percent)
      cssarea = pi$ * len1 * (abs(prv_x$) + abs(maxss_x))
      ptimecs2_1a
      speed = maxss$
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$               #Was already in IPM
      if absfr < tol, absfr = tol     #Make sure it is valid
      tltime = tltime + len2 / absfr  #Running total FEED time

ptimecs2_2       #Feed time and length calc, CSS
      if abs(prv_x$) = maxss_x, ptimecs1
      else, ptimecs2_2a

ptimecs2_3a      #Feed time and length calc, CSS
      percent = abs(prv_x$ - maxss_x) / abs(dx)
      len1 = len * percent
      len2 = len * (one - percent)
      speed = maxss$
      if fr$ < zero, absfr = abs(speed * fr$)  #Convert IPR to IPM
      else, absfr = fr$               #Was already in IPM
      if absfr < tol, absfr = tol     #Make sure it is valid
      tltime = tltime + len1 / absfr  #Running total FEED time
      cssarea = pi$ * len2 * (abs(x$) + abs(maxss_x))
      ptimecs2_1a

ptimecs2_3       #Feed time and length calc, CSS
      if abs(prv_x$) = maxss_x, ptimecs2_1
      else, ptimecs2_3a

ptimecs2         #Feed time and length calc, CSS and dx
      if abs(x$) >  maxss_x & abs(prv_x$) >  maxss_x, ptimecs2_1
      if abs(x$) <  maxss_x & abs(prv_x$) >= maxss_x, ptimecs2_2
      if abs(x$) >  maxss_x & abs(prv_x$) <= maxss_x, ptimecs2_3
      if abs(x$) <= maxss_x & abs(prv_x$) <= maxss_x, ptimecs1

ptimecs1         #Feed time and length calc, CSS and no dx
      speed = abs(ss$)
      testx = abs(x$)
      pspindle2         #Spindle speed calculations for CSS
      pspindle3         #MAX/MIN spindle checking for CSS
      speed = strt_spd
      ptimel            #FEED time and length calc.

ptimecss         #Feed time and length calc, CSS
      if abs(dx) <= mtol$, ptimecs1  #No X axis motion
      else, ptimecs2                 #Yes, there was X axis motion

ptimelsw         #Feed time and length calc
      if cssflag = one, ptimecss     #Need to calc. for CSS
      else, ptimel                   #No, direct RPM is active

ptime            #Distance calculations
      tlrad$ = zero
      dx = x$ - prv_x$
      dz = z$ - prv_z$
      len = sqrt(dx^2 + dz^2)
      if gcode$ = zero, ptimer            #RAPID time and length calc
      if gcode$ = one, ptimelsw           #FEED  time and length calc
      if gcode$ = one, llen = llen + len  #Keep running total
      !x$, !z$  #Update previous [prv_?] variables

pMaxMin          #Output Max/Min X,Z coordinates
      max_Xpos = max_Xpos * dia_mult
      min_Xpos = min_Xpos * dia_mult
      if X_limits = yes$, "Max_X = ", *max_Xpos, "  Min_X = ", *min_Xpos, e$
      if Z_limits = yes$, "Max_Z = ", *max_Zpos, "  Min_Z = ", *min_Zpos, e$

pspindle3        #MAX/MIN spindle speed checking for CSS
      if strt_spd > maxss$, strt_spd = maxss$
      if strt_spd < min_speed, strt_spd = min_speed

pspindle2        #Spindle speed calculations for CSS
      if testx < 0.001, testx = 0.001
      if met_tool$ = zero, strt_spd = (12 * speed) / (pi$ * testx * two)  #Inch
      else, strt_spd = (1000 * speed) / (pi$ * testx * two)  #Metric

pspindle1        #Spindle speed calculations for CSS
      testx = abs(xr$)
      if opcode$ = four, testx = abs(xr$)   #Threading
      if opcode$ = five, testx = abs(tcr$)  #Drilling
      pspindle2  #Spindle speed calculations for CSS

pspindle         #Spindle speed calculations for RPM
      if maxss$ = zero, maxss$ = max_speed  #Use RPM limit from this post
      speed = abs(ss$)
      if ss$ < zero, pspindle1           #CSS is active
      if ss$ > zero, strt_spd = speed    #RPM is active
      pspindle3                          #MAX/MIN spindle checking for CSS
      if opcode$ = four, ss$ = strt_spd  #Convert thread to RPM
      if opcode$ = five, ss$ = strt_spd  #Convert drill to RPM
      speed = abs(ss$)
      if met_tool$ = zero, maxss_x = (12 * speed) / (pi$ * maxss$ * two)  #Inch
      else, maxss_x = (1000 * speed) / (pi$ * maxss$ * two)  #Metric

pspindleim       #Spindle speed inch / metric
      if met_tool$ = zero, " SFPM"
      else, " SMPM"

pfrminim         #Feed per MIN inch / metric
      if met_tool$ = zero, " IN/MIN"
      else, " MM/MIN"

pfrrevim         #Feed per REV inch / metric
      if met_tool$ = zero, " IN/REV"
      else, " MM/REV"

pstock_info      #Output stock information if requested
      if stock_info,
        [
        "Material Type  = "
        if stck_matl$ = "None" | stck_matl$ = "", "*Not Defined*", e$  #No material type was selected
        else, stck_matl$, e$
        ]
      if stock_info & tlplnno$ = five, #ONLY if in SIDE plane (Top for Lathe)
        [
        #If any stock values are empty, disable don't output
        if stck_ht$ > 0 & stck_wdth$ > 0,
          [
          "Stock Length   = ", stck_ht$, e$
          "Stock Max Dia. = ", stck_wdth$, e$
          ]
        ]

# --------------------------------------------------------------------------
# Motion NC output
# --------------------------------------------------------------------------
prapid$          #Output to NC of linear movement - rapid
      ptime

plin$            #Output to NC of linear movement - feed
      ptime

pthread0$        #Threading override
      thdtype$ = zero     #Long cycle
      thdrapfr = fr$  #Capture rapid traverse rate
      fr$ = thdlead$  #This is the Feedrate (from 'thdlead')

pthrg32_1$       #1st threading first position (at clearance)
      gcode$ = zero
      fr$ = thdrapfr
      ptime

pthrg32_2$       #2nd threading position (at thread position)
      gcode$ = zero
      fr$ = thdrapfr
      ptime

pthrg32_3$       #3rd threading position (thread cut pass)
      gcode$ = one
      fr$ = thdlead$ * speed  #Need to pass IPM feedrate
      ptime

pthrg32_4$       #4th threading position (pull-off clearance move)
      gcode$ = zero
      fr$ = thdrapfr

# --------------------------------------------------------------------------
# Parameter read postblocks:
# --------------------------------------------------------------------------
pprep$           #Pre-process postblock
#Allows post instructions after the post is parsed but before the NC and NCI file are opened.
#DO NOT ATTEMPT TO OUTPUT TO THE NC FILE IN THIS POSTBLOCK (OR ANY POSTBLOCKS YOU MAY CALL FROM HERE)
#BECAUSE THE NC OUTPUT FILE IS NOT YET OPENED!
      sub_level$ = 0     #Force subs off
      subout$ = 0        #Force output stream to NC file
      comm_filter$ = 0   #Allow output of all comments
      #sextnc$ = ".doc"  #Uncomment and change extension here to override
      #Force longhand drilling cycles for proper time estimate
      lusecandrill$ = no$   #Use canned cycle for drill
      lusecanpeck$  = no$   #Use canned cycle for Peck
      lusecanchip$  = no$   #Use canned cycle for Chip Break
      lusecantap$   = no$   #Use canned cycle for Tap
      lusecanbore1$ = no$   #Use canned cycle for Bore1
      lusecanbore2$ = no$   #Use canned cycle for Bore2
      lusecanmisc1$ = no$   #Use canned cycle for Misc1
      lusecanmisc2$ = no$   #Use canned cycle for Misc2
      spaces$ = 0
      use_alt_eob$ = no$

pwrtt$           #Pre-read NCI file
      pwritbuf1  #Write MAX/MIN X,Z values to Buffer 1
      !op_id$

pparameter$      #Read operation parameters
      #rd_params is used to call pparameter postblock and read the parameters of the operation specified in rd_param_op_no
      #"pparameter", ~prmcode$, ~sparameter$, e$

# --------------------------------------------------------------------------
# Buffer 1 definition (for Max/Min X,Z storage)
# --------------------------------------------------------------------------
rc1          : 2     #Buffer1 READ pointer (YES, '2' is correct for this case!)
wc1          : 1     #Buffer1 WRITE pointer
size1        : 0     #To hold 'size' of Buffer 1

b1_gcode     : 0     #Stored in Buffer #1
b1_tcode     : 0     #        "
b1_xmax      : 0     #        "
b1_xmin      : 0     #        "
b1_zmax      : 0     #        "
b1_zmin      : 0     #        "

fbuf 1 0 6 0 0       #Declare Buffer1 to hold Min/Max X,Z axis info.

# --------------------------------------------------------------------------
# Buffer 1  Read / Write Routines
# --------------------------------------------------------------------------
pinit            #Initialize the limit checking variables
      max_Xpos = m_c9k  #Initialize
      min_Xpos = c9k    #     "
      max_Zpos = m_c9k  #     "
      min_Zpos = c9k    #     "

plimits          #Check for NEW X,Z limits
      if b1_xmax > max_Xpos, max_Xpos = b1_xmax
      if b1_xmin < min_Xpos, min_Xpos = b1_xmin
      if b1_zmax > max_Zpos, max_Zpos = b1_zmax
      if b1_zmin < min_Zpos, min_Zpos = b1_zmin

pwritbuf1        #Write Buffer 1
      b1_gcode = gcode$
      if gcode$ = 1002 & op_id$ = prv_op_id$, b1_gcode = 1000
      if gcode$ = 1000 & op_id$ <> prv_op_id$, b1_gcode = 1002
      b1_tcode = t$
      b1_xmax  = x_max$
      b1_xmin  = x_min$
      b1_zmax  = z_max$
      b1_zmin  = z_min$
      b1_gcode = wbuf(one, wc1)  #Write the record

preadbuf1t       #Read Buffer 1 (at the toolchanges for X,Z limits)
      pinit                      #Initialize the limit checking variables
      b1_gcode = rbuf(one, rc1)  #Read a record from the Buffer
      plimits                    #Check for NEW limits

      #Loop thru possible NULL toolchanges
      while b1_gcode = 1000,  #Find the next NON-NULL toolchange
        [
        b1_gcode = rbuf(one, rc1)  #Read the next record from the Buffer
        plimits                    #Check for NEW limits
        ]

preadbuf1e       #Read Buffer 1 (at the END of Program for X,Z limits)
      pinit                    #Initialize the limit checking variables
      size1 = rbuf(one, zero)  #Get the size of the Buffer 1
      rc1 = two                #Reset read pointer (SKIP 1st record!)
      while rc1 <= size1,      #Loop thru entire program
        [
        b1_gcode = rbuf(one, rc1)  #Read a record from the Buffer
        plimits                    #Check for NEW limits
        ]

# --------------------------------------------------------------------------
#
