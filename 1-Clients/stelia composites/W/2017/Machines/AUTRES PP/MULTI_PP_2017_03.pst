[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V19.00 P0 E1 W19.00 T1473932983 M19.00 I0 O0
#region   DEBUT PST #OK
# ----------------------------------------
# -   Post pro fraisage 5 axes           -
# -   Version origine pour 8.0                        -
# ----------------------------------------
# -     MASTERCAM V2017  F.I.CAM         -
# ----------------------------------------

#[STARTBIN]
#property of ficam, Eric Dauvilliers, e.dauvilliers@ficam.com, +332 37 26 28 10

# - commancé le : 16/05/01  Par : Eric Dauvilliers-
# - Pour la société : COMPOSITES AQUITAINE-M6
# - Armoire CN      : siemens 840d et Num 1060          - 
# - Nom MACHINE     : MULTI_PP_2016_09            - 
# - Fichier associé :       -
# ----------------------------------------
# - Variable mi1    : ajout de tour sur C au debut du prog 
# - Variable mi2    : sens d'attaque A+ ou A- 
# - Variable mi3    : retournement de tete a plan secu mi2 ou sur place 0 ou 1          
# - Variable mi1    :
# - Variable mr7    : angle maxi pour G9                    
# - Variable mr8    : dec x                   
# - Variable mr9    : dec Y                   
# - Variable mr10   : dec Z                    
# - Variable mr1    : valeur de recul suivent axes outil pour degagement
# - Variable mi2    : Coordone Z de retournement
# - VARIABLE MI10   : flag pour arret programme avant OP

# ----------------------------------------
# -   DESCRIPTION DES MODIFICATIONS      -
#
# le 09/07/2001 - modif position percage 5 axes, ajout date heure nom prog,voir prot3 G151 S0 ou c0 a0 
# le 17/07/2001 - modif G1 G93- M7 M150 M9 gestion entre phase, G80 en fin de cycle
# le 23/07/2001 - modif Z pour ER , N32000 max, et autre
# le 05/08/2001 - point x y z abs 3d entre transition de plan (dur dur),+ divers 
# le 06/08/2001 - G0 du 1 er et dernier mouv en 5 axes continues puis G93, + divers
# le 03/09/2001 - Ajt n prog + divers fautes ortho + espace, alti de retour OK, xy 3D ABS OK entre cycle 5 ax, A et C au + tot OK
# le 06/10/2001 - modif entete G77 etc..,remonte alt retournement meme en 3d
# le 12/10/2001 - modif bug bute retournement
# le 13/10/2001 - option E5300xx en place
# le 20/10/2001 - arret prog mi10 et modif xyz sur meme ligne en percage
# le 9/11/2001  - G151 S0 sur arret prog, remonte z secu que entre op differante, correction bug de pp17 pp18 pp19
# le 12/07/2005 - correction de différent prob suite passage eric sur site
# le 21/07/2005 - correction de BUG-PP-BA, de BUG-PP-BB, et BUG-PP-BC.
# Le 30/09/2005 - correction de BUG-PP-URGA ET URGB
# Le 27/07/2009 - correction de bug de liaisons entre operation 
# Le 28/07/2009 - Integration d'une téte a renvoie d'angle double 
# Dev PP renvoi LE 31 juil 2009 reste a finir percage 5 axes avec renvoi, trouver ou est en pdril_2 xrprint_BG, yrprint_BG et zrprint_BG 
# Dev normal, gere les altitude plan de securite en percage normal 
# le 28/10/2009 Finition des dev pour renvoie d'angle
# le 8 juin 2010 finition du percage 5 axes avec gestion des hauteur
# ajout d'un cycle de contour en dent de scie
# ajout de commentaires en cantext
# le 26 avril 2011 15h10 =>finition pour plan secu ou retraction renvoi d'angle 
# le 26 avril 2011 15h45 => ajout pour rediction de bruit outil vertical de la variale cone_mini
# le 26 avril 2011 16h35 => correction orthographe
# le 26 avril 2011 17h25 => finition plan de secu avec renvoi angle en 5 x et 3d
# le 26 avril 2011 18h35 => inversion du G9
# le 27 avril 2011 11h11 => sup du retour plan secu en arret prog M01 
# le 27 avril 2011 15h05 => warning sur rattrpage d'angle
# le  5 juin  2012 15h00 => dev pour rotation automatic pour choix plan en vrac ( le x toujours horizontal n'est plus necessaire si calculduplan = 1 )
# le  6 juin  2012 11h00 => debut de transformation pour passage de num en siemens
# le  3 sep   2012 14h30 => Debut essai avec le creno
# le  du 3 au 7 sep => M7M8M9 , outil par nom, control outil, gestion aspi, usure outil, macro debut fin, cycle helicoide, etc..
# le 28 - 11 - 2012 = > revision 2 cycle caq triple spiral + debut goute d'eau
# le 29 - 11 - 2012 => modification pp suite essai du fabfla
# ----------------------------------------
#
#============================================================================
# POST-PROCESSEUR 5 NUM 1060 TETE TWIST   A porté par C + tete renvois d'angle 
# machine creneau industiel client concept industriel
# DEV ERIC DAUVILLIERS Sté FICAM 02.37.26.28.10
#                              |
# axe C               90       |  axe A                  x
# vu de dessus                 |  vu de coté             |
#                180       0   |                 -90     |    90
#                              |                         
#                     270      |                         0
#============================================================================
# VARIABLES ANGULAIRE MINI  ET MAXI DES AXES DE ROTATIONs 
#endregion

#region   REGLAGES DU PST #OK
#region STRINGS
cone_mini = 0.001  # valeur angulaire a partir duquel on fais du A0 C0, evite le bruit 
sderoul : "ATTENTION OPERATION DE RETOURNEMENT EN 5 AXES "
sderoul_AG : ""
sderoul_BG : ""
sderoul_CG : ""
sderoul_DG : ""
senroul_AG : ""
senroul_BG : ""
senroul_CG : ""
senroul_DG : ""
sderoul_aff_AG : "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
sderoul_aff_BG : "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
sderoul_aff_CG : "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
sderoul_aff_DG : "MACHINE STEMA01 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
senroul_aff_AG : "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
senroul_aff_BG : "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
senroul_aff_CG : "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
senroul_aff_DG : "MACHINE STEMA01 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
slettreA : "A"
slettreB : "B"
slettreC : "C"
space : " "
sopration : "Operation N°"

calculduplan = 1   #laisser le pp recalculer xyz suivant rotation non sur axe x 
sra : ""
fmt "" 4 nbcaracter
srenvoi : ""
srenvoi_droite : "RA1"
srenvoi_gauche : "RA2"

# Changer les valeurs entre "" pour chois entre 0 et 6 sur parametre valeur optionnel cycle 832
scycle832_a : "CYCLE832(0.2,11112101)"
scycle832_b : "CYCLE832(0.2,11112101)"
scycle832_c : "CYCLE832(0.2,11112101)"
scycle832_d : "CYCLE832(0.2,11112101)"
scycle832_e : "CYCLE832(0.2,11112101)"
scycle832_f : "CYCLE832(0.2,11112101)"
scycle832_anul : "CYCLE832 ()"

susure_outil_1 : ""
susure_outil_2 : ""
susure_outil_3 : ""
susure_outil_4 : ""
susure_outil_5 : ""
susure_outil_6 : ""
susure_outil_7 : ""
susure_outil_8 : ""
susure_outil_9 : ""
susure_outil_10 : ""
susure_outil_11 : ""
susure_outil_12 : ""
susure_outil_13 : ""
susure_outil_14 : ""
susure_outil_15 : ""
susure_outil_16 : ""
susure_outil_17 : ""
susure_outil_18 : ""
susure_outil_19 : ""
susure_outil_20 : ""
susure_outil_21 : ""
susure_outil_22 : ""
susure_outil_23 : ""
susure_outil_24 : ""
susure_outil_25 : ""
susure_outil_26 : ""
susure_outil_27 : ""
susure_outil_28 : ""
susure_outil_29 : ""
susure_outil_30 : ""
sdim_outillage : ""

snumligne : ""

scsplane: ""
stlplane : ""
swcsplane : ""
#endregion
#region FS
#--------------------------------- FORMATS ----------------------------------
fs  1  1.9
fs  2  1.3n
fs  3  1 0n
fs  4  1 0
fs  5  1.0n
fs  6  5 0
fs  7  1.4n
fs  8  1.3
fs  9  1 3t
fs 10  1.2
fs 11  1.6
fs 12  1.4
fs 13 +1.4ln
fs 14  3.2ltn
fs 15  1.2ltn
#fs 16  1
fs 17  1.1  #quotient mi1
fs 18  1.1  #reste decimale quotient mi1
fs 19  1.3lt
fs 20  4 0
#endregion
#region FMT
#--------------------------- AFFECTATIONS FORMATS ---------------------------
fmt  ""  1 cycle_800
fmt  "X" 1 xr$
fmt  "Y" 1 yr$
fmt  "Z" 1 zr$
fmt  "ZR" 2 oldzr
fmt    2 mr3$
fmt "" 3 tete_rev_ang_droite
fmt "" 3 tete_rev_ang_gauche
fmt "val dec tete=" 8 dec_axe_tete
fmt  "X" 2 xdep
fmt  "Y" 2 ydep
fmt  "Z" 2 zdep
fmt  "X" 1 x$
fmt  "Y" 1 y$
fmt  "Z" 1 z$
fmt "X" 1 drl_init_x$
fmt "Y" 1 drl_init_y$
fmt "Z" 1 drl_init_z$
fmt "Z" 1 drl_sel_ref$
fmt "VX" 1 vec_reel_x
fmt "VY" 1 vec_reel_y
fmt "VZ" 1 vec_reel_z
fmt "NX" 2 nextx$
fmt "NU" 2 nextu$
fmt "ret" 2 retplangarde
fmt "A" 2 move_ang$
fmt  "X" 1 xcal
fmt  "Y" 1 ycal
fmt  "Z" 1 zcal
fmt  "Z" 1 zrcal
fmt  "X" 2 tox4$
fmt  "Y" 2 toy4$
fmt  "Z" 2 toz4$
fmt "cone_mini" 1 cone_mini
fmt  "C" 1 axeccalra
fmt  "difc" 8 difanglec
fmt  "difa" 8 difanglea
fmt      1 new_m7
fmt      1 new_m8
fmt "M1=" 1 m1$
fmt "M2=" 1 m2$
fmt "M3=" 1 m3$
fmt "M4=" 1 m4$
fmt "M5=" 1 m5$
fmt "M6=" 1 m6$
fmt "M7=" 1 m7$
fmt "M8=" 1 m8$
fmt "M9=" 1 m9$
fmt      7 mini_a_reel
fmt      7 sortie
fmt  ""  3 mod5xcont
fmt  "Tourne=" 1 tourne
fmt "cal du plan =" 1 calculduplan
fmt "5 axes horizontal" 2 vertical_z
fmt  "C" 12 axeC1
fmt  "A" 12 axeA1
fmt  "C" 12 minC
fmt  "C" 12 maxC
fmt  "NB" 8 nbt
fmt  "DC" 12 dep_axe_c     #angle de depart axe c 
fmt  "A" 12 prvaxea
fmt  "DAC" 12 dif_axe_c
fmt  "DAC" 12 dif_axe_c2
fmt  "ABSD" 8 absdif
fmt  "ABSD" 8 absdif2
fmt  "DEB" 4 debut
fmt  "X" 1 xdeg1
fmt  "Y" 1 ydeg1
fmt  "Z" 1 zdeg1
fmt  "X" 1 xdeg2
fmt  "Y" 1 ydeg2
fmt  "X" 1 xdeg3
fmt  "Y" 1 ydeg3
fmt  "Z" 1 zdeg3
fmt  "X" 2 xdegrap
fmt  "Y" 2 ydegrap
fmt  "Z" 2 zdegrap
fmt  "X" 1 xdegrap1
fmt  "Y" 1 ydegrap1
fmt  "Z" 1 zdegrap1
fmt  "X" 1 xdegrap2
fmt  "Y" 1 ydegrap2
fmt  "Z" 1 zdegrap2
fmt  "X" 1 xdegrap3
fmt  "Y" 1 ydegrap3
fmt  "Z" 1 zdegrap3
fmt  "X" 1 xdegvec
fmt  "Y" 1 ydegvec
fmt  "Z" 1 zdegvec
fmt "sav_x_pmx" 1 sav_x_pmx
fmt "sav_y_pmx" 1 sav_y_pmx
fmt "sav_z_pmx" 1 sav_z_pmx
fmt "sav_u_pmx" 1 sav_u_pmx
fmt "sav_v_pmx" 1 sav_v_pmx
fmt "sav_w_pmx" 1 sav_w_pmx
fmt  "OLV" 8 old_longvec
fmt  "Z" 8 lastz
fmt  "N" 4 n$
fmt "R" 1 result        # resultat de calcul
# Format des variable ecritent dans le post pro
fmt "Z" 2 zsecuprint
fmt "" 1 m1print
fmt "" 1 m2print
fmt "" 1 m3print
fmt "" 1 m4print
fmt "" 1 m5print
fmt "" 1 m6print
fmt "" 1 m7print
fmt "" 1 m8print
fmt "" 1 m9print
fmt  "X" 1 u$
fmt  "Y" 1 v$
fmt  "Z" 1 w$
fmt  "X" 1 ucal
fmt  "Y" 1 vcal
fmt  "Z" 1 wcal
fmt  "U" 1 old_u
fmt  "V" 1 old_v
fmt  "W" 1 old_w
fmt  2 Du
fmt  2 Dv
fmt  2 Dw
fmt "D" 2 deltaUVW
fmt  2 Dx
fmt  2 Dy
fmt  2 Dz
fmt "D" 2 deltaXYZ
fmt "LV" 2 longvec
fmt  "Vx" 1 Vx
fmt  "Vy" 1 Vy
fmt  "Vz" 1 Vz
fmt  "X" 1 xcor
fmt  "Y" 1 ycor
fmt  "Z" 1 zcor
fmt  "I" 2 i$
fmt  "J" 2 j$
fmt  "K" 2 k$
fmt  "F" 4 fr$ #OK
fmt  "S" 3 old_ss
fmt  "L" 2 lubrif
fmt  "L" 2 lubrif_m7
fmt  "L" 2 lubrif_m8
fmt  "L" 2 lubrif_m207
fmt  "L" 2 lubrif_m200
fmt  "L" 2 old_lubrif_m7
fmt  "L" 2 old_lubrif_m8
fmt  "L" 2 old_lubrif_m207
fmt  "L" 2 old_lubrif_m200
fmt  "L" 2 coolant$
fmt     3 opcode$
fmt  "G" 4 gcode$
fmt  "%" 6 progno$
fmt     3 spdlon
fmt  "T" 3 t$
fmt  "T" 3 next_tool$
fmt  "D" 3 tloffno$
fmt  "D" 4 tlngno$
fmt  "G" 3 cc$
fmt     2 tldia$
fmt     2 tlrad$
fmt  "OP" 3 op_id$
fmt  "LOP" 3 lastopid
fmt  "M" 3 lstation$
fmt  "M" 3 oldstation
fmt  "T" 1 typepercage
fmt  "" 8 depth$
fmt  "" 8 refht$
fmt  "" 8 initht$
fmt  "" 2 dwell$
fmt  "" 2 peckclr$
fmt  "" 2 peck1$
fmt  "" 2 peck2$
fmt  ""  2 shftdrl$
fmt  ""  2 retr$
fmt  "F" 3 frplunge$ #OK
fmt "" 8 avance_plonge
fmt "" 8 tosz$
fmt     3 mi1$
fmt     3 mi4$
fmt     3 mi8$
fmt "old_mi8" 3 oldmi8
fmt     3 old_mi1
fmt  "G" 3 mi2$
fmt  "P" 2 passe
fmt  "Z" 2 mr1$
fmt  "Z" 2 mr2$
fmt  ""   3 trans_mi1$
fmt  ""   3 trans_mi2$
fmt  "OP" 3 operation
fmt  "LUB" 8 lub
fmt  "PPR" 8 ppr
fmt  "X" 1 x1
fmt  "Y" 1 y1
fmt  "X" 1 x2
fmt  "Y" 1 y2
fmt  "Z" 1 z2
fmt  "X" 1 x3
fmt  "Y" 1 y3
fmt  "Z" 1 z3
fmt  "X" 1 x4
fmt  "Y" 1 y4
fmt  "Z" 1 z4
fmt  "X" 8 xaproche
fmt  "Y" 8 yaproche
fmt  "aCAl" 12 axeacal
fmt  "CCAl" 12 axeccal
fmt  "Pl" 2 plinc5a
fmt  "XV" 2 vieuxx
fmt  "YV" 2 vieuxy
fmt  "ZV" 2 vieuxz
fmt  "dx" 2 deltax
fmt  "dy" 2 deltay
fmt  "dz" 2 deltaz
fmt  "E" 3 e53
fmt     3 e40
fmt     8 vale53
fmt  "P" 2 pasmi7
fmt  "P" 2 pasn
fmt  "ANG" 2 move_ang3$
fmt "" 4 oscilliation
fmt "" 4 paquet_mi4
fmt "" 4 paquet_mi5
fmt "" 4 paquet_mi8
fmt "compteur_descrip" 2 compteur_descrip
fmt 4 av_travail
fmt 4 av_plonge
fmt 4 av_retract
compteur_descrip : 0
fmt 2 debut_pp
debut_pp : 0
fmt 2 rattrapage_angle
cycle_800 = 0 #0 pour trans Arot, 1 pour cycle 800
fmt 2 delta_rot_C
delta_rot_C = 175
#endregion
#region FQ
fq 1 t$ "MACHINE STC9101 PROGRAMME COMPLET, ATTENTION PRISE D'OUTIL INTERDIT (Sauf si 51-52-61 OU 62) ?"
fq 4 t$ "MACHINE STC9101 PROGRAMME PARTITIONNÉ, ATTENTION PRISE D'OUTIL INTERDIT (Sauf si 51-52-61 OU 62) ?"
fmt  8 vectdeg
fq   2 vectdeg "Limite angle atteint! Longeur du vecteur de recul"

snomprog : ""
fq   3 snomprog "ASSUREZ VOUS QUE LA LETTRE U (RAMDISK) EST MONTEE SINON LES PROGRAMMES NE SERONT PAS GENERES, ENTREZ LE NOM DU PROGRAMMEUR ?"

fmt "hops" 4 HOPS

srefpiec : ""
fq 7 srefpiec "REFERENCE PIECE ? ( 15 characteres maxi )"

smesage : ""
fq 10 smesage "MACHINE STC9101, STC9103, STC9110 et STEMA01 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_AG : ""
#fq 10 smesage_AG "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_BG : ""
#fq 11 smesage_BG "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_CG : ""
#fq 12 smesage_CG "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

fq 13 trplus_AG "MACHINE STC9101 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 14 trplus_BG "MACHINE STC9103 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 15 trplus_CG "MACHINE STC9110 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 151 trplus_DG "MACHINE STEMA01 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 16 trplus_AM "MACHINE STC9101 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 17 trplus_BM "MACHINE STC9103 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 18 trplus_CM "MACHINE STC9110 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 181 trplus_DM "MACHINE STEMA01 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 19 axeC_AG "MACHINE STC9101 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 20 axeC_BG "MACHINE STC9103 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 21 axeC_CG "MACHINE STC9110 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 211 axeC_DG "MACHINE STEMA01 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 22 axeC_AM "MACHINE STC9101 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 23 axeC_BM "MACHINE STC9103 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 24 axeC_CM "MACHINE STC9110 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 241 axeC_DM "MACHINE STEMA01 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

#endregion
#region Le reste (LUB, GCODE, usecandrill, etc,...)
#-----------------------------Variable pour OUTILS----------------------------------------
fmt   2 paramT1         # Né outil
fmt   2 paramT2         # Type d'outil
fmt   2 paramT3         # longeur sorti outil 
fmt   2 paramT4         # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt   3 paramT5         # Diametre
fmt   3 paramT6         # Rayon de bout
fmt   3 paramT7         # Nombre de filet par mm
fmt   3 paramT8         # Angle de bout
fmt   5 paramT9         # Né de correcteur de rayon
fmt   5 paramT10        # Né de correcteur de longeur
fmt   3 paramT11        # Avance travail
fmt   3 paramT12        # Avance plongee
fmt   3 paramT13        # Avance retraction
fmt   5 paramT14        # Vitesse de broche
fmt   5 paramT15        # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt   5 paramT16    " DENTS" # Nombre de dents
#---------------------------------------------------------------------------
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
#---------------------------------------------------------------------------
#omitround$ : 1
#sub_level$ = 1
rattrapage_angle = 0  #permettre ou non le rattrapage d'angle 0 pour non 1 pour oui
mrg_subfile$
auxprg$ = 2
extprg$ = 2
lccprg$ = 2
subprg$    : yes$
mergesub$  : 0
getnextop$ : 1
mill      : 1
spaces$    : 1
no$        = 0
#progno$    : 100
seqmax$    = 32000
omitseq$   : no$
frrapid   : 300
frmax     : 300
ssmax     : 34000
breakarcs$ : 0       #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arctype$   : 1       # Arc center 1=abs, 2=inc, 3=st-cen, 4=unsigned inc.
do_full_arc$ : 0     #Allow full circle output? 0=no, 1=yes
helix_arc$   : 2     #Support helix arc output, 0=no, 1=all planes, 2=XY plane only
ncldr$     : 20      # No. of leader characters
ldrcode$   : 65      # Leader character dec. equiv.
bldnxtool$ : yes$    # Build next tool table
tooltable$ : yes$
opcode$    : 1
nobrk$     : yes$    # Omit breakup of rapid linear motion? yes/no(xy,z or z,xy)
x$         : 9999
y$         : 9999
z$         : 9999
i$         : 0
j$         : 0
k$         : 0
gcode$     :   -1
strtool_v7$ : 1
rotaxtyp$   : 3
nbr_cht    : 0
gfr        : 1
#sextnc$      : ""
operation   : 0
sx_label : ""
sy_label : ""
sz_label : ""
si_label : ""
sj_label : ""
sk_label : ""
sxr_label : ""
syr_label : ""
szr_label : ""
smr2_label : ""
soutil : ""
svide : ""
oldmi8 : 0
smi4_str : ""
smi5_str : ""
smi8_str : ""
#---------------------------------------------------------------------
usecandrill$ : yes$
usecanpeck$  : yes$
usecanchip$  : yes$
usecantap$   : no$
usecanbore1$ : yes$
usecanbore2$ : no$
usecanmisc1$ : yes$
usecanmisc2$ : no$
#----------------------------------------------------------------------
fastmode$  : 1
bug1$   : 5            # 1 = Output post to screen - 2 = output leader to screen
bug2$   : 40           # Add postline label to each line at column 'bug2'
bug3$   : 50           # Add whatline to each line
bug4$   : 60           # Add nci no
whatno$ : yes$         # Ignore whatline branches to plin1 etc.?
linktolvar$    : 1     # Associer les variables de tolérance X aux variables V9-
linkplnvar$    : 1     # Associer les variables spécifiques plan X aux variables V9-?
linklvar$      : 1     # Associer les variables spécifiques X Tournage aux variables V9-
cant_tlchng$   : 1     # Ignorer entrée de texte programmé au changement avec tlchng_aft?
newglobal$     : 0     # Activer la vérification d'erreur pour les variables globales?
#----------------------------------------------------------------------------

sm93    : "G93"
sm94 : "G94"
sgfr : ""

fstrsel  sm93 gfr sgfr 2 -1

sg00    : "G0"
sg01    : "G1"
sg02    : "G2"
sg03    : "G3"
sg04    : "G1"
sgcode : ""

fstrsel  sg00 gcode$ sgcode 5 -1

spl00    : "G17"
spl01    : "G19"
spl02    : "G18"
spl03 : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1

sm00    : "M4"
sm01    : "M5"
sm02    : "M3"
spdlon ??
#CNC<<ECHEC>>spdlon
#CNC<<MSG -ERREUR(703)>> Label found in another type list

spdlsel = fsg3(ss$)
#spdlsel = fsg3(ss)+(coolant*3)

fstrsel  sm00 spdlsel spdlon 3 -1
#endregion
#endregion

#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE #OK
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE AG
fmt  "%" 20 mr1_AG
fmt      7 mini_a_AG
fmt      7 maxi_a_AG
fmt      7 mini_c_AG
fmt      7 maxi_c_AG
fmt "Z" 2 zsecu_AG
fmt  "X" 2 x3dprint_AG
fmt  "Y" 2 y3dprint_AG
fmt  "Z" 2 z3dprint_AG
fmt  "C" 7 axeCpos1_AG
fmt  "A" 7 axeApos1_AG
fmt  "EA" 7 axeApos_AG
fmt  "EC" 7 axeCpos_AG
fmt  "EU" 2 tox4print_AG
fmt  "EV" 2 toy4print_AG
fmt  "EW" 2 toz4print_AG
fmt  "I" 2 iprint_AG
fmt  "J" 2 jprint_AG
fmt  "K" 2 kprint_AG
fmt  "I" 2 xc_AG
fmt  "J" 2 yc_AG
fmt "X" 2 xrprint_AG
fmt "Y" 2 yrprint_AG
fmt "Z" 2 zrprint_AG
fmt "X" 2 xrprintrap_AG
fmt "Y" 2 yrprintrap_AG
fmt "Z" 2 zrprintrap_AG
fmt "Y" 2 depthprint_AG
fmt "Y" 2 refhtprint_AG
fmt "Y" 2 inithtprint_AG
fmt "Z" 2 mr2print_AG
fmt "S" 3 ssprint_AG
fmt "G04 F" 2 tempo_AG " ; temporisation "
fmt  "T" 3 tprint_AG
fmt  "" 3 tprint2_AG
fmt "E80004=" 2 vale84_AG
fmt  "N" 3 nplus_AG
fmt  "Z" 2 z1_AG
fmt  "Z" 2 prvmr2_AG
fmt "X" 8 xprint_AG
fmt "Y" 8 yprint_AG
fmt "Z" 8 zprint_AG
fmt "X" 8 xgarde_AG
fmt "Y" 8 ygarde_AG
fmt "Z" 8 zgarde_AG
fmt  "F" 4 avance_AG
fmt  "F" 10 fr5axe_AG
fmt  "F" 10 frbase_AG
fmt  "K" 2 pas_AG
fmt  "X" 2 xdeg_AG
fmt  "Y" 2 ydeg_AG
fmt  "Z" 2 zdeg_AG
fmt  "Z" 1 zdeg2_AG
fmt  "C" 12 prvaxec_AG
fmt  "X" 1 old_x_AG
fmt  "Y" 1 old_y_AG
fmt  "Z" 1 old_z_AG
fmt  "X" 2 old_x_print_AG
fmt  "Y" 2 old_y_print_AG
fmt  "Z" 2 old_z_print_AG
fmt  "C" 12 axeC_AG
fmt  "A" 12 axeA_AG
fmt  "Z" 2 old_zinitht_AG
fmt "Z" 2 dest_ret_5x_AG
fmt "Z" 2 old_dest_ret_5x_AG
fmt  "ER" 8 initht5x_AG
fmt  "Z" 8 zinitht_AG
fmt  "" 2 sdis_AG
fmt  "X" 2 xabs_AG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_AG
fmt  "Z" 2 zabs_AG
fmt "Z" 2 z_retraction_AG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_AG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_AG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_AG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_AG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_AG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_AG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_AG
fmt "Z" 3 prof_2_AG
fmt "Z" 3 prof_3_AG
fmt "Z" 3 prof_4_AG
fmt "Z" 3 prof_5_AG
fmt "Z" 3 prof_1_rel_AG
fmt "Z" 3 prof_2_rel_AG
fmt "Z" 3 prof_3_rel_AG
fmt "Z" 3 prof_4_rel_AG
fmt "Z" 3 prof_5_rel_AG
fmt "G4 F" 15 tempo_1_AG
fmt "G4 F" 15 tempo_2_AG
fmt "G4 F" 15 tempo_3_AG
fmt "G4 F" 15 tempo_4_AG
fmt "G4 F" 15 tempo_5_AG
fmt  "Z" 8 zaproche_AG
fmt "" 3 tete_rev_ang_11
fmt "" 3 tete_rev_ang_12
fmt "" 3 tete_rev_ang_21
fmt "" 3 tete_rev_ang_22
fmt  "LT" 8 station_tool
fmt  "abs_inc" 4 abs_inc
fmt  "X" 2 xinc_abs
fmt  "Y" 2 yinc_abs
fmt  "Z" 2 zinc_abs
fmt     9 mr8_AG
fmt     9 mr9_AG
fmt     9 mr10_AG
fmt     9 mr4_AG
fmt  "op" 1 prvop_id_AG
fmt     3 spdlon_AG
fmt 2 ecrigeneral_AG
fmt  "OP" 3 operation_AG
fmt  "E" 3 e53_AG
fmt  "DEB" 4 debut_AG
fmt  "OPERATION "  5 numop_AG
fmt 2 erreur_AG
fmt  "Z" 8 depth_AG
fmt  "EH" 8 refht_AG
fmt  "ER" 8 initht_AG
fmt  "EF" 2 dwell_AG
fmt  "EP" 2 peckclr_AG
fmt  "P" 2 peck1_AG
fmt  "Q" 2 peck2_AG
fmt     3 mi4_AG
fmt  "M" 3 oldstation_AG
fmt     3 mi5_AG
fmt  "M" 3 oldmi5_AG
fmt     3 mi8_AG
fmt  "M" 3 oldmi8_AG
fmt "DEC_X_AG " 2 DEC_X_AG
fmt "DEC_Y_AG " 2 DEC_Y_AG
fmt "DEC_Z_AG " 2 DEC_Z_AG
fmt "prog_AG" 2 prog_AG
fmt "DEC X = "  2 mr8AF_AG
fmt "DEC Y = "  2 mr9AF_AG
fmt "DEC Z = "  2 mr10AF_AG
fmt "Mi2 pour A base =" 4 mi2_A_base_AG
fmt "Mi1 pour C base =" 4 mi1_C_base_AG
fmt  "TR" 4 trplus_AG
fmt  "I" 7 invers_AG
fmt  "D" 1 deja_AG
fmt  "VX" 1 old_vx_AG
fmt  "VY" 1 old_vy_AG
fmt  "VZ" 1 old_vz_AG
fmt  "Vx" 1 Vx_AG
fmt  "Vy" 1 Vy_AG
fmt  "Vz" 1 Vz_AG
fmt     2 typcycle_AG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_AG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_AG
fmt "old_sub_trnstyp_AG" 4 old_sub_trnstyp_AG
fmt "old_sub_totl_no_AG" 4 old_sub_totl_no_AG
fmt  "NB" 8 nbt_AG
fmt  "CT" 4 cont_axe_c_AG     #compte tour axe c
fmt  ""  3 changop_AG
fmt  "F" 4 fretrait_AG
fmt  "X" 2 old_tox4_AG
fmt  "Y" 2 old_toy4_AG
fmt  "Z" 2 old_toz4_AG
fmt  "EC" 7 old_axeCpos_AG
fmt  "EA" 7 old_axeApos_AG
fmt      7 oldreel_axeCpos_AG
fmt      7 reel_axeCpos_AG
fmt      7 difaxecpos_AG
fmt      7 comptour_AG
fmt      7 naxecpos_AG
fmt "renv angle on off=" 4 tete_rev_AG
fmt  "cosangle" 11 cosangle_AG
fmt "LP12=" 1 long_p12_AG
fmt "LP23=" 1 long_p23_AG
fmt "LP13=" 1 long_p13_AG
fmt "Angle5x=" 1 ang5x_AG
fmt  "X" 1 old_x_5x_AG
fmt  "Y" 1 old_y_5x_AG
fmt  "Z" 1 old_z_5x_AG

fretrait_AG : 500
nbt_AG = 2            # nombre de tour possible pour retournement
old_sub_trnstyp_AG : -1
old_sub_totl_no_AG : -1
prog_AG : -1
operation_AG : 0
drill5axes_AG  : 0

tete_rev_ang_11 = 51 # numero de la tete a renvoie d'angle numero 1 broche numero 1
tete_rev_ang_12 = 52 # numero de la tete a renvoie d'angle numero 1 broche numero 2
tete_rev_ang_21 = 61 # numero de la tete a renvoie d'angle numero 2 broche numero 1
tete_rev_ang_22 = 62 # numero de la tete a renvoie d'angle numero 2 broche numero 2
mini_a_AG =   -110.001
maxi_a_AG = 110.001
mini_c_AG = -365.001
maxi_c_AG = 365.001
zsecu_AG = 1500   # valeur altitude de securité en Z
dec_tete_AG = 113.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_AG : 100
gfr_AG : 1
smi4_str_AG : ""
smi5_str_AG : ""
smi8_str_AG : ""
SDEC_X_AG : ""
SDEC_Y_AG : ""
SDEC_Z_AG : ""
sprog_complet_AG : ""
sprog_NOK_AG : "STC9101 : NON"
sprog_OK_AG : "STC9101 : OUI"

sm93_AG    : "G93"
sm94_AG : "G94"
sgfr_AG : ""

fstrsel  sm93_AG gfr_AG sgfr_AG 2 -1

spl00_AG    : "G17"
spl01_AG    : "G19"
spl02_AG    : "G18"
spl03_AG : ""
splcode_AG : ""

fstrsel  spl00_AG plane$ splcode_AG 4 -1

sm00_AG    : "M4"
sm01_AG    : "M5"
sm02_AG    : "M3"
spdlon_AG ??
spdlsel_AG = fsg3(ss$)

fstrsel  sm00_AG spdlsel_AG spdlon_AG 3 -1

stringtxt1_AG : "$ BRIDER LA PIECE AVEC VIS"
stringtxt2_AG : "$ OTER LES VIS"
stringtxt3_AG : "$ BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_AG : "$ OTER LES SERRE-JOINTS"
stringtxt5_AG : "$ OTER LES CHUTES"
stringtxt6_AG : "$ BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_AG : "$ NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_AG : "TEXTE8"
stringtxt9_AG : "TEXTE9"
stringtxt10_AG : "TEXTE10"

fmt 4 deja_gcode_AG
pgcode_AG #modalité pgcode_AG

            if (gcode$ = 0) & (deja_gcode_AG <> 0), "G0",  deja_gcode_AG = 0
            if (gcode$ = 1) & (deja_gcode_AG <> 1), "G1",  deja_gcode_AG = 1
            if (gcode$ = 2) & (deja_gcode_AG <> 2), "G2",  deja_gcode_AG = 2
            if (gcode$ = 3) & (deja_gcode_AG <> 3), "G3",  deja_gcode_AG = 3
            if (gcode$ = 4) & (deja_gcode_AG <> 4), "G1",  deja_gcode_AG = 4

pgcode_force_AG #modalité pgcode_AG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE BG

fmt      7 mini_a_BG
fmt      7 maxi_a_BG
fmt      7 mini_c_BG
fmt      7 maxi_c_BG
fmt "Z" 2 zsecu_BG
fmt  "X" 2 x3dprint_BG
fmt  "Y" 2 y3dprint_BG
fmt  "Z" 2 z3dprint_BG
fmt  "C" 7 axeCpos1_BG
fmt  "A" 7 axeApos1_BG
fmt  "X=" 7 axeApos_BG
fmt  "Z=" 7 axeCpos_BG
fmt "X" 2 tox4print_BG
fmt "Y" 2 toy4print_BG
fmt "Z" 2 toz4print_BG
fmt  "I" 2 iprint_BG
fmt  "J" 2 jprint_BG
fmt  "K" 2 kprint_BG
fmt "X" 2 xrprint_BG
fmt "Y" 2 yrprint_BG
fmt "Z" 2 zrprint_BG
fmt "X" 2 xrprintrap_BG
fmt "Y" 2 yrprintrap_BG
fmt "Z" 2 zrprintrap_BG
fmt "Y" 2 depthprint_BG
fmt "Y" 2 refhtprint_BG
fmt "Y" 2 inithtprint_BG
fmt "Z" 2 mr2print_BG
fmt "S" 3 ssprint_BG
fmt "G04 F" 2 tempo_BG " ; temporisation "
fmt  "T" 3 tprint_BG
fmt  "" 3 tprint2_BG
fmt "E80004=" 2 vale84_BG
fmt  "N" 3 nplus_BG
fmt  "Z" 2 z1_BG
fmt  "Z" 2 prvmr2_BG
fmt "X" 8 xprint_BG
fmt "Y" 8 yprint_BG
fmt "Z" 8 zprint_BG
fmt "X" 8 xgarde_BG
fmt "Y" 8 ygarde_BG
fmt "Z" 8 zgarde_BG
fmt  "F" 4 avance_BG
fmt  "F" 10 fr5axe_BG
fmt  "F" 10 frbase_BG
fmt  "K" 2 pas_BG
fmt  "X" 2 xdeg_BG
fmt  "Y" 2 ydeg_BG
fmt  "Z" 2 zdeg_BG
fmt  "Z" 1 zdeg2_BG
fmt  "C" 12 prvaxec_BG
fmt  "X" 1 old_x_BG
fmt  "Y" 1 old_y_BG
fmt  "Z" 1 old_z_BG
fmt  "X" 2 old_x_print_BG
fmt  "Y" 2 old_y_print_BG
fmt  "Z" 2 old_z_print_BG
fmt  "C" 12 axeC_BG
fmt  "A" 12 axeA_BG
fmt  "Z" 2 old_zinitht_BG
fmt "Z" 2 dest_ret_5x_BG
fmt "Z" 2 old_dest_ret_5x_BG
fmt  "" 8 initht5x_BG
fmt  "Z" 8 zinitht_BG
fmt  "" 2 sdis_BG
fmt  "X" 2 xabs_BG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_BG
fmt  "Z" 2 zabs_BG
fmt "Z" 2 z_retraction_BG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_BG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_BG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_BG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_BG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_BG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_BG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_BG
fmt "Z" 3 prof_2_BG
fmt "Z" 3 prof_3_BG
fmt "Z" 3 prof_4_BG
fmt "Z" 3 prof_5_BG
fmt "Z" 3 prof_1_rel_BG
fmt "Z" 3 prof_2_rel_BG
fmt "Z" 3 prof_3_rel_BG
fmt "Z" 3 prof_4_rel_BG
fmt "Z" 3 prof_5_rel_BG
fmt "G4 F" 15 tempo_1_BG
fmt "G4 F" 15 tempo_2_BG
fmt "G4 F" 15 tempo_3_BG
fmt "G4 F" 15 tempo_4_BG
fmt "G4 F" 15 tempo_5_BG
fmt  "Z" 8 zaproche_BG
fmt  "X,ORI_X1" 13 mr8_BG
fmt  "Y,ORI_Y1" 13 mr9_BG
fmt  "Z,ORI_Z1" 13 mr10_BG
fmt  "USURE_L(" 2 mr4_BG ")"
fmt  "op" 1 prvop_id_BG
fmt     3 spdlon_BG
fmt 2 ecrigeneral_BG
fmt  "OP" 3 operation_BG
fmt  "E" 3 e53_BG
fmt  "DEB" 4 debut_BG
fmt  "OPERATION "  5 numop_BG
fmt 2 erreur_BG
fmt     3 mi4_BG
fmt  "M" 3 oldstation_BG
fmt     3 mi5_BG
fmt  "M" 3 oldmi5_BG
fmt     3 mi8_BG
fmt  "M" 3 oldmi8_BG
fmt "DEC_X_BG " 2 DEC_X_BG
fmt "DEC_Y_BG " 2 DEC_Y_BG
fmt "DEC_Z_BG " 2 DEC_Z_BG
fmt "prog_BG" 2 prog_BG
fmt "DEC X = "  2 mr8AF_BG
fmt "DEC Y = "  2 mr9AF_BG
fmt "DEC Z = "  2 mr10AF_BG
fmt "Mi2 pour A base =" 4 mi2_A_base_BG
fmt "Mi1 pour C base =" 4 mi1_C_base_BG
fmt  "TR" 4 trplus_BG
fmt  "I" 7 invers_BG
fmt  "D" 1 deja_BG
fmt  "VX" 1 old_vx_BG
fmt  "VY" 1 old_vy_BG
fmt  "VZ" 1 old_vz_BG
fmt  "Vx" 1 Vx_BG
fmt  "Vy" 1 Vy_BG
fmt  "Vz" 1 Vz_BG
fmt     2 typcycle_BG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_BG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_BG
fmt "old_sub_trnstyp_BG" 4 old_sub_trnstyp_BG
fmt "old_sub_totl_no_BG" 4 old_sub_totl_no_BG
fmt  "NB" 8 nbt_BG
fmt  "CT" 4 cont_axe_c_BG     #compte tour axe c
fmt  ""  3 changop_BG
fmt  "F" 4 fretrait_BG
fmt  "X" 2 old_tox4_BG
fmt  "Y" 2 old_toy4_BG
fmt  "Z" 2 old_toz4_BG
fmt  "EC" 7 old_axeCpos_BG
fmt  "EA" 7 old_axeApos_BG
fmt      7 oldreel_axeCpos_BG
fmt      7 reel_axeCpos_BG
fmt      7 difaxecpos_BG
fmt      7 comptour_BG
fmt      7 naxecpos_BG
fmt "renv angle on off=" 4 tete_rev_BG
fmt  "cosangle" 11 cosangle_BG
fmt "LP12=" 1 long_p12_BG
fmt "LP23=" 1 long_p23_BG
fmt "LP13=" 1 long_p13_BG
fmt "Angle5x=" 1 ang5x_BG
fmt  "X" 1 old_x_5x_BG
fmt  "Y" 1 old_y_5x_BG
fmt  "Z" 1 old_z_5x_BG

fretrait_BG : 500
nbt_BG = 2            # nombre de tour possible pour retournement
old_sub_trnstyp_BG : -1
old_sub_totl_no_BG : -1
prog_BG : -1
operation_BG : 0
drill5axes_BG  : 0

mini_a_BG =   -110.001
maxi_a_BG = 110.001
mini_c_BG = -365.001
maxi_c_BG = 365.001
zsecu_BG = 800   # valeur altitude de securité en Z
dec_tete_BG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_BG : 100
gfr_BG : 1
smi4_str_BG : ""
smi5_str_BG : ""
smi8_str_BG : ""
SDEC_X_BG : ""
SDEC_Y_BG : ""
SDEC_Z_BG : ""
sprog_complet_BG : ""
sprog_NOK_BG : "STC9103 : NON"
sprog_OK_BG : "STC9103 : OUI"

sm93_BG    : "G93"
sm94_BG : "G94"
sgfr_BG : ""

fstrsel  sm93_BG gfr_BG sgfr_BG 2 -1

spl00_BG    : "G17"
spl01_BG    : "G19"
spl02_BG    : "G18"
spl03_BG : ""
splcode_BG : ""

fstrsel  spl00_BG plane$ splcode_BG 4 -1

sm00_BG    : "M4"
sm01_BG    : "M5"
sm02_BG    : "M3"
spdlon_BG ??
spdlsel_BG = fsg3(ss$)

fstrsel  sm00_BG spdlsel_BG spdlon_BG 3 -1

stringtxt1_BG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_BG : "OTER LES VIS"
stringtxt3_BG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_BG : "OTER LES SERRE-JOINTS"
stringtxt5_BG : "OTER LES CHUTES"
stringtxt6_BG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_BG : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_BG : "TEXTE8"
stringtxt9_BG : "TEXTE9"
stringtxt10_BG : "TEXTE10"
spalpeur_BG : "PALPEUR_3D"

fmt 4 deja_gcode_BG
pgcode_BG #modalité pgcode_BG

            if (gcode$ = 0) & (deja_gcode_BG <> 0), "G0",  deja_gcode_BG = 0
            if (gcode$ = 1) & (deja_gcode_BG <> 1), "G1",  deja_gcode_BG = 1
            if (gcode$ = 2) & (deja_gcode_BG <> 2), "G2",  deja_gcode_BG = 2
            if (gcode$ = 3) & (deja_gcode_BG <> 3), "G3",  deja_gcode_BG = 3
            if (gcode$ = 4) & (deja_gcode_BG <> 4), "G1",  deja_gcode_BG = 4

pgcode_force_BG #modalité pgcode_BG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE CG

fmt      7 mini_a_CG
fmt      7 maxi_a_CG
fmt      7 mini_c_CG
fmt      7 maxi_c_CG
fmt      7 mini_c_sans_cloche_CG
fmt      7 maxi_c_sans_cloche_CG
fmt      7 mini_c_avec_cloche_CG
fmt      7 maxi_c_avec_cloche_CG
fmt "Z" 2 zsecu_CG
fmt  "X" 2 x3dprint_CG
fmt  "Y" 2 y3dprint_CG
fmt  "Z" 2 z3dprint_CG
fmt  "C" 7 axeCpos1_CG
fmt  "B" 7 axeApos1_CG
fmt  "X=" 7 axeApos_CG
fmt  "Z=" 7 axeCpos_CG
fmt  "" 7 axeApos_cycle800_CG
fmt  "" 7 axeCpos_cycle800_CG
fmt "X" 2 tox4print_CG
fmt "Y" 2 toy4print_CG
fmt "Z" 2 toz4print_CG
fmt  "I" 2 iprint_CG
fmt  "J" 2 jprint_CG
fmt  "K" 2 kprint_CG
fmt "X" 2 xrprint_CG
fmt "Y" 2 yrprint_CG
fmt "Z" 2 zrprint_CG
fmt "X" 2 xrprintrap_CG
fmt "Y" 2 yrprintrap_CG
fmt "Z" 2 zrprintrap_CG
fmt "Y" 2 depthprint_CG
fmt "Y" 2 refhtprint_CG
fmt "Y" 2 inithtprint_CG
fmt "Z" 2 mr2print_CG
fmt "S" 3 ssprint_CG
fmt "G04 F" 2 tempo_CG " ; temporisation "
fmt  "T" 3 tprint_CG
fmt  "" 3 tprint2_CG
fmt "E80004=" 2 vale84_CG
fmt  "N" 3 nplus_CG
fmt  "Z" 2 z1_CG
fmt  "Z" 2 prvmr2_CG
fmt "X" 19 xprint_CG
fmt "Y" 19 yprint_CG
fmt "Z" 19 zprint_CG
fmt "X" 8 xgarde_CG
fmt "Y" 8 ygarde_CG
fmt "Z" 8 zgarde_CG
fmt  "F" 4 avance_CG
fmt  "F" 10 fr5axe_CG
fmt  "F" 10 frbase_CG
fmt  "F" 4 fr_CG
fmt  "K" 2 pas_CG
fmt  "X" 2 xdeg_CG
fmt  "Y" 2 ydeg_CG
fmt  "Z" 2 zdeg_CG
fmt  "Z" 1 zdeg2_CG
fmt  "C" 12 prvaxec_CG
fmt  "X" 1 old_x_CG
fmt  "Y" 1 old_y_CG
fmt  "Z" 1 old_z_CG
fmt  "X" 2 old_x_print_CG
fmt  "Y" 2 old_y_print_CG
fmt  "Z" 2 old_z_print_CG
fmt  "C" 12 axeC_CG
fmt  "B" 12 axeA_CG
fmt  "Z" 2 old_zinitht_CG
fmt "Z" 2 dest_ret_5x_CG
fmt "Z" 2 old_dest_ret_5x_CG
fmt  "" 8 initht5x_CG
fmt  "Z" 8 zinitht_CG
fmt  "" 2 sdis_CG
fmt  "X" 2 xabs_CG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_CG
fmt  "Z" 2 zabs_CG
fmt "Z" 2 z_retraction_CG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_CG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_CG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_CG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_CG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_CG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_CG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_CG
fmt "Z" 3 prof_2_CG
fmt "Z" 3 prof_3_CG
fmt "Z" 3 prof_4_CG
fmt "Z" 3 prof_5_CG
fmt "Z" 3 prof_1_rel_CG
fmt "Z" 3 prof_2_rel_CG
fmt "Z" 3 prof_3_rel_CG
fmt "Z" 3 prof_4_rel_CG
fmt "Z" 3 prof_5_rel_CG
fmt "G4 F" 15 tempo_1_CG
fmt "G4 F" 15 tempo_2_CG
fmt "G4 F" 15 tempo_3_CG
fmt "G4 F" 15 tempo_4_CG
fmt "G4 F" 15 tempo_5_CG
fmt  "Z" 8 zaproche_CG
fmt  "X" 8 xaproche_CG
fmt  "Y" 8 yaproche_CG
fmt  "X,ORI_X1" 13 mr8_CG
fmt  "Y,ORI_Y1" 13 mr9_CG
fmt  "Z,ORI_Z1" 13 mr10_CG
fmt  "LONG_COR=" 2 mr4_CG
fmt  "op" 1 prvop_id_CG
fmt     3 spdlon_CG
fmt 2 ecrigeneral_CG
fmt  "OP" 3 operation_CG
fmt  "E" 3 e53_CG
fmt  "DEB" 4 debut_CG
fmt  "OPERATION "  5 numop_CG
fmt 2 erreur_CG
fmt     3 mi4_CG
fmt  "M" 3 oldstation_CG
fmt     3 mi5_CG
fmt  "M" 3 oldmi5_CG
fmt     3 mi8_CG
fmt  "M" 3 oldmi8_CG
fmt "DEC_X_CG " 2 DEC_X_CG
fmt "DEC_Y_CG " 2 DEC_Y_CG
fmt "DEC_Z_CG " 2 DEC_Z_CG
fmt "POURCENTAGE_AVANCE_CG" 2 POURCENTAGE_AVANCE_CG
fmt "prog_CG" 2 prog_CG
fmt "DEC X = "  2 mr8AF_CG
fmt "DEC Y = "  2 mr9AF_CG
fmt "DEC Z = "  2 mr10AF_CG
fmt "Mi2 pour A base =" 4 mi2_A_base_CG
fmt "Mi1 pour C base =" 4 mi1_C_base_CG
fmt  "TR" 4 trplus_CG
fmt  "I" 7 invers_CG
fmt  "D" 1 deja_CG
fmt  "VX" 1 old_vx_CG
fmt  "VY" 1 old_vy_CG
fmt  "VZ" 1 old_vz_CG
fmt  "Vx" 1 Vx_CG
fmt  "Vy" 1 Vy_CG
fmt  "Vz" 1 Vz_CG
fmt  "F" 3 frplunge_CG
fmt     2 typcycle_CG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_CG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_CG
fmt "old_sub_trnstyp_CG" 4 old_sub_trnstyp_CG
fmt "old_sub_totl_no_CG" 4 old_sub_totl_no_CG
fmt  "NB" 8 nbt_CG
fmt 4 blocaxe_CG
fmt  "CT" 4 cont_axe_c_CG     #compte tour axe c
fmt  ""  3 changop_CG
fmt "" 8 avance_plonge_CG
fmt  "F" 4 fretrait_CG
fmt "LONG_MAX=" 15 LONG_MAX_CG
fmt "LONG_MIN=" 15 LONG_MIN_CG
fmt  "num garage" 12 garage_CG
fmt  "X" 2 old_tox4_CG
fmt  "Y" 2 old_toy4_CG
fmt  "Z" 2 old_toz4_CG
fmt  "EC" 7 old_axeCpos_CG
fmt  "EA" 7 old_axeApos_CG
fmt      7 oldreel_axeCpos_CG
fmt      7 reel_axeCpos_CG
fmt      7 difaxecpos_CG
fmt      7 comptour_CG
fmt      7 naxecpos_CG
fmt "renv angle on off=" 4 tete_rev_CG
fmt 2 change_outil_CG
fmt  "cosangle" 11 cosangle_CG
fmt "LP12=" 1 long_p12_CG
fmt "LP23=" 1 long_p23_CG
fmt "LP13=" 1 long_p13_CG
fmt "Angle5x=" 1 ang5x_CG
fmt  "X" 1 old_x_5x_CG
fmt  "Y" 1 old_y_5x_CG
fmt  "Z" 1 old_z_5x_CG

change_outil_CG : 0
garage_CG : 0
fretrait_CG : 500
nbt_CG = 1            # nombre de tour possible pour retournement
old_sub_trnstyp_CG : -1
old_sub_totl_no_CG : -1
prog_CG : -1
operation_CG : 0
drill5axes_CG  : 0

mini_a_CG =   -120.001
maxi_a_CG = 120.001
mini_c_CG : -185.001
maxi_c_CG : 185.001
mini_c_sans_cloche_CG = -270.001
maxi_c_sans_cloche_CG = 270.001
mini_c_avec_cloche_CG = -185.001
maxi_c_avec_cloche_CG = 185.001
zsecu_CG = 800   # valeur altitude de securité en Z
dec_tete_CG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_CG : 100
gfr_CG : 1
smi4_str_CG : ""
smi5_str_CG : ""
smi8_str_CG : ""
SDEC_X_CG : ""
SDEC_Y_CG : ""
SDEC_Z_CG : ""
SPOURCENTAGE_AVANCE_CG : ""
SCLOCHE_ACTIVE_CG : ""
STRING_CLOCHE_ACTIVE_CG : "Autre Info n°  2 : cloche montée OUI"
STRING_CLOCHE_DESACTIVE_CG : "Autre Info n°  2 : cloche montée NON"
sprog_complet_CG : ""
sprog_NOK_CG : "STC9110 : NON"
sprog_OK_CG : "STC9110 : OUI"

sm93_CG    : "G93"
sm94_CG : "G94"
sgfr_CG : ""

fstrsel  sm93_CG gfr_CG sgfr_CG 2 -1

spl00_CG    : "G17"
spl01_CG    : "G19"
spl02_CG    : "G18"
spl03_CG : ""
splcode_CG : ""

fstrsel  spl00_CG plane$ splcode_CG 4 -1

sm00_CG    : "M4"
sm01_CG    : "M5"
sm02_CG    : "M3"
spdlon_CG ??
spdlsel_CG = fsg3(ss$)

fstrsel  sm00_CG spdlsel_CG spdlon_CG 3 -1

stringtxt1_CG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_CG : "OTER LES VIS"
stringtxt3_CG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_CG : "OTER LES SERRE-JOINTS"
stringtxt5_CG : "OTER LES CHUTES"
stringtxt6_CG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_CG : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_CG : "TEXTE8"
stringtxt9_CG : "TEXTE9"
stringtxt10_CG : "TEXTE10"
spalpeur_CG : "PALPEUR_3D"

fmt 4 deja_gcode_CG
pgcode_CG #modalité pgcode_CG

            if (gcode$ = 0) & (deja_gcode_CG <> 0), "G0",  deja_gcode_CG = 0
            if (gcode$ = 1) & (deja_gcode_CG <> 1), "G1",  deja_gcode_CG = 1
            if (gcode$ = 2) & (deja_gcode_CG <> 2), "G2",  deja_gcode_CG = 2
            if (gcode$ = 3) & (deja_gcode_CG <> 3), "G3",  deja_gcode_CG = 3
            if (gcode$ = 4) & (deja_gcode_CG <> 4), "G1",  deja_gcode_CG = 4

pgcode_force_CG #modalité pgcode_CG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE DG

fmt      7 mini_a_DG
fmt      7 maxi_a_DG
fmt      7 mini_c_DG
fmt      7 maxi_c_DG
fmt      7 mini_c_sans_cloche_DG
fmt      7 maxi_c_sans_cloche_DG
fmt      7 mini_c_avec_cloche_DG
fmt      7 maxi_c_avec_cloche_DG
fmt "Z" 2 zsecu_DG
fmt  "X" 2 x3dprint_DG
fmt  "Y" 2 y3dprint_DG
fmt  "Z" 2 z3dprint_DG
fmt  "C" 7 axeCpos1_DG
fmt  "B" 7 axeApos1_DG
fmt  "X=" 7 axeApos_DG
fmt  "Z=" 7 axeCpos_DG
fmt  "" 7 axeApos_cycle800_DG
fmt  "" 7 axeCpos_cycle800_DG
fmt "X" 2 tox4print_DG
fmt "Y" 2 toy4print_DG
fmt "Z" 2 toz4print_DG
fmt  "I" 2 iprint_DG
fmt  "J" 2 jprint_DG
fmt  "K" 2 kprint_DG
fmt "X" 2 xrprint_DG
fmt "Y" 2 yrprint_DG
fmt "Z" 2 zrprint_DG
fmt "X" 2 xrprintrap_DG
fmt "Y" 2 yrprintrap_DG
fmt "Z" 2 zrprintrap_DG
fmt "Y" 2 depthprint_DG
fmt "Y" 2 refhtprint_DG
fmt "Y" 2 inithtprint_DG
fmt "Z" 2 mr2print_DG
fmt "S" 3 ssprint_DG
fmt "G04 F" 2 tempo_DG " ; temporisation "
fmt  "T" 3 tprint_DG
fmt  "" 3 tprint2_DG
fmt "E80004=" 2 vale84_DG
fmt  "N" 3 nplus_DG
fmt  "Z" 2 z1_DG
fmt  "Z" 2 prvmr2_DG
fmt "X" 19 xprint_DG
fmt "Y" 19 yprint_DG
fmt "Z" 19 zprint_DG
fmt "X" 8 xgarde_DG
fmt "Y" 8 ygarde_DG
fmt "Z" 8 zgarde_DG
fmt  "F" 4 avance_DG
fmt  "F" 10 fr5axe_DG
fmt  "F" 10 frbase_DG
fmt  "F" 4 fr_DG
fmt  "K" 2 pas_DG
fmt  "X" 2 xdeg_DG
fmt  "Y" 2 ydeg_DG
fmt  "Z" 2 zdeg_DG
fmt  "Z" 1 zdeg2_DG
fmt  "C" 12 prvaxec_DG
fmt  "X" 1 old_x_DG
fmt  "Y" 1 old_y_DG
fmt  "Z" 1 old_z_DG
fmt  "X" 2 old_x_print_DG
fmt  "Y" 2 old_y_print_DG
fmt  "Z" 2 old_z_print_DG
fmt  "C" 12 axeC_DG
fmt  "B" 12 axeA_DG
fmt  "Z" 2 old_zinitht_DG
fmt "Z" 2 dest_ret_5x_DG
fmt "Z" 2 old_dest_ret_5x_DG
fmt  "" 8 initht5x_DG
fmt  "Z" 8 zinitht_DG
fmt  "" 2 sdis_DG
fmt  "X" 2 xabs_DG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_DG
fmt  "Z" 2 zabs_DG
fmt "Z" 2 z_retraction_DG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_DG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_DG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_DG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_DG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_DG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_DG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_DG
fmt "Z" 3 prof_2_DG
fmt "Z" 3 prof_3_DG
fmt "Z" 3 prof_4_DG
fmt "Z" 3 prof_5_DG
fmt "Z" 3 prof_1_rel_DG
fmt "Z" 3 prof_2_rel_DG
fmt "Z" 3 prof_3_rel_DG
fmt "Z" 3 prof_4_rel_DG
fmt "Z" 3 prof_5_rel_DG
fmt "G4 F" 15 tempo_1_DG
fmt "G4 F" 15 tempo_2_DG
fmt "G4 F" 15 tempo_3_DG
fmt "G4 F" 15 tempo_4_DG
fmt "G4 F" 15 tempo_5_DG
fmt  "Z" 8 zaproche_DG
fmt  "X" 8 xaproche_DG
fmt  "Y" 8 yaproche_DG
fmt  "X,ORI_X1" 13 mr8_DG
fmt  "Y,ORI_Y1" 13 mr9_DG
fmt  "Z,ORI_Z1" 13 mr10_DG
fmt  "LONG_COR=" 2 mr4_DG
fmt  "op" 1 prvop_id_DG
fmt     3 spdlon_DG
fmt 2 ecrigeneral_DG
fmt  "OP" 3 operation_DG
fmt  "E" 3 e53_DG
fmt  "DEB" 4 debut_DG
fmt  "OPERATION "  5 numop_DG
fmt 2 erreur_DG
fmt     3 mi4_DG
fmt  "M" 3 oldstation_DG
fmt     3 mi5_DG
fmt  "M" 3 oldmi5_DG
fmt     3 mi8_DG
fmt  "M" 3 oldmi8_DG
fmt "DEC_X_DG " 2 DEC_X_DG
fmt "DEC_Y_DG " 2 DEC_Y_DG
fmt "DEC_Z_DG " 2 DEC_Z_DG
fmt "POURCENTAGE_AVANCE_DG" 2 POURCENTAGE_AVANCE_DG
fmt "prog_DG" 2 prog_DG
fmt "DEC X = "  2 mr8AF_DG
fmt "DEC Y = "  2 mr9AF_DG
fmt "DEC Z = "  2 mr10AF_DG
fmt "Mi2 pour A base =" 4 mi2_A_base_DG
fmt "Mi1 pour C base =" 4 mi1_C_base_DG
fmt  "TR" 4 trplus_DG
fmt  "I" 7 invers_DG
fmt  "D" 1 deja_DG
fmt  "VX" 1 old_vx_DG
fmt  "VY" 1 old_vy_DG
fmt  "VZ" 1 old_vz_DG
fmt  "Vx" 1 Vx_DG
fmt  "Vy" 1 Vy_DG
fmt  "Vz" 1 Vz_DG
fmt  "F" 3 frplunge_DG
fmt     2 typcycle_DG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_DG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_DG
fmt "old_sub_trnstyp_DG" 4 old_sub_trnstyp_DG
fmt "old_sub_totl_no_DG" 4 old_sub_totl_no_DG
fmt  "NB" 8 nbt_DG
fmt 4 blocaxe_DG
fmt  "CT" 4 cont_axe_c_DG     #compte tour axe c
fmt  ""  3 changop_DG
fmt "" 8 avance_plonge_DG
fmt  "F" 4 fretrait_DG
fmt "LONG_MAX=" 15 LONG_MAX_DG
fmt "LONG_MIN=" 15 LONG_MIN_DG
fmt  "num garage" 12 garage_DG
fmt  "X" 2 old_tox4_DG
fmt  "Y" 2 old_toy4_DG
fmt  "Z" 2 old_toz4_DG
fmt  "EC" 7 old_axeCpos_DG
fmt  "EA" 7 old_axeApos_DG
fmt      7 oldreel_axeCpos_DG
fmt      7 reel_axeCpos_DG
fmt      7 difaxecpos_DG
fmt      7 comptour_DG
fmt      7 naxecpos_DG
fmt "renv angle on off=" 4 tete_rev_DG
fmt 2 change_outil_DG
fmt  "cosangle" 11 cosangle_DG
fmt "LP12=" 1 long_p12_DG
fmt "LP23=" 1 long_p23_DG
fmt "LP13=" 1 long_p13_DG
fmt "Angle5x=" 1 ang5x_DG
fmt  "X" 1 old_x_5x_DG
fmt  "Y" 1 old_y_5x_DG
fmt  "Z" 1 old_z_5x_DG

change_outil_DG : 0
garage_DG : 0
fretrait_DG : 500
nbt_DG = 1            # nombre de tour possible pour retournement
old_sub_trnstyp_DG : -1
old_sub_totl_no_DG : -1
prog_DG : -1
operation_DG : 0
drill5axes_DG  : 0

mini_a_DG =   -120.001
maxi_a_DG = 120.001
mini_c_DG : -185.001
maxi_c_DG : 185.001
mini_c_sans_cloche_DG = -270.001
maxi_c_sans_cloche_DG = 270.001
mini_c_avec_cloche_DG = -185.001
maxi_c_avec_cloche_DG = 185.001
zsecu_DG = 800   # valeur altitude de securité en Z
dec_tete_DG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_DG : 100
gfr_DG : 1
smi4_str_DG : ""
smi5_str_DG : ""
smi8_str_DG : ""
SDEC_X_DG : ""
SDEC_Y_DG : ""
SDEC_Z_DG : ""
SPOURCENTAGE_AVANCE_DG : ""
SCLOCHE_ACTIVE_DG : ""
STRING_CLOCHE_ACTIVE_DG : "Autre Info n°  2 : cloche montée OUI"
STRING_CLOCHE_DESACTIVE_DG : "Autre Info n°  2 : cloche montée NON"
sprog_complet_DG : ""
sprog_NOK_DG : "STEMA01 : NON"
sprog_OK_DG : "STEMA01 : OUI"

sm93_DG    : "G93"
sm94_DG : "G94"
sgfr_DG : ""

fstrsel  sm93_DG gfr_DG sgfr_DG 2 -1

spl00_DG    : "G17"
spl01_DG    : "G19"
spl02_DG    : "G18"
spl03_DG : ""
splcode_DG : ""

fstrsel  spl00_DG plane$ splcode_DG 4 -1

sm00_DG    : "M4"
sm01_DG    : "M5"
sm02_DG    : "M3"
spdlon_DG ??
spdlsel_DG = fsg3(ss$)

fstrsel  sm00_DG spdlsel_DG spdlon_DG 3 -1

stringtxt1_DG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_DG : "OTER LES VIS"
stringtxt3_DG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_DG : "OTER LES SERRE-JOINTS"
stringtxt5_DG : "OTER LES CHUTES"
stringtxt6_DG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_DG : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_DG : "TEXTE8"
stringtxt9_DG : "TEXTE9"
stringtxt10_DG : "TEXTE10"
spalpeur_DG : "PALPEUR_3D"

fmt 4 deja_gcode_DG
pgcode_DG #modalité pgcode_DG

            if (gcode$ = 0) & (deja_gcode_DG <> 0), "G0",  deja_gcode_DG = 0
            if (gcode$ = 1) & (deja_gcode_DG <> 1), "G1",  deja_gcode_DG = 1
            if (gcode$ = 2) & (deja_gcode_DG <> 2), "G2",  deja_gcode_DG = 2
            if (gcode$ = 3) & (deja_gcode_DG <> 3), "G3",  deja_gcode_DG = 3
            if (gcode$ = 4) & (deja_gcode_DG <> 4), "G1",  deja_gcode_DG = 4

pgcode_force_DG #modalité pgcode_DG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE AM

fmt      7 mini_a_AM
fmt      7 maxi_a_AM
fmt      7 mini_c_AM
fmt      7 maxi_c_AM
fmt "Z" 2 zsecu_AM
fmt  "X" 2 x3dprint_AM
fmt  "Y" 2 y3dprint_AM
fmt  "Z" 2 z3dprint_AM
fmt  "C" 7 axeCpos1_AM
fmt  "A" 7 axeApos1_AM
fmt  "EA" 7 axeApos_AM
fmt  "EC" 7 axeCpos_AM
fmt  "EU" 2 tox4print_AM
fmt  "EV" 2 toy4print_AM
fmt  "EW" 2 toz4print_AM
fmt  "I" 2 iprint_AM
fmt  "J" 2 jprint_AM
fmt  "K" 2 kprint_AM
fmt  "I" 2 xc_AM
fmt  "J" 2 yc_AM
fmt "X" 2 xrprint_AM
fmt "Y" 2 yrprint_AM
fmt "Z" 2 zrprint_AM
fmt "X" 2 xrprintrap_AM
fmt "Y" 2 yrprintrap_AM
fmt "Z" 2 zrprintrap_AM
fmt "Y" 2 depthprint_AM
fmt "Y" 2 refhtprint_AM
fmt "Y" 2 inithtprint_AM
fmt "Z" 2 mr2print_AM
fmt "@ROTATION_BROCHE@" 3 ssprint_AM
fmt "G04 F" 2 tempo_AM " ; temporisation "
fmt  "T" 3 tprint_AM
fmt  "" 3 tprint2_AM
fmt "E80004=" 2 vale84_AM
fmt  "N" 3 nplus_AM
fmt  "Z" 2 z1_AM
fmt  "Z" 2 prvmr2_AM
fmt "X" 8 xprint_AM
fmt "Y" 8 yprint_AM
fmt "Z" 8 zprint_AM
fmt "X" 8 xgarde_AM
fmt "Y" 8 ygarde_AM
fmt "Z" 8 zgarde_AM
fmt  "@AVANCE_TRAVAIL_STD@" 4 avance_AM
fmt  "@AVANCE_TRAVAIL_STD@" 10 fr5axe_AM
fmt  "@AVANCE_TRAVAIL_STD@" 10 frbase_AM
fmt   10 fr5axe_flag_AM
fmt   10 frbase_flag_AM
fmt  "K" 2 pas_AM
fmt  "X" 2 xdeg_AM
fmt  "Y" 2 ydeg_AM
fmt  "Z" 2 zdeg_AM
fmt  "Z" 1 zdeg2_AM
fmt  "C" 12 prvaxec_AM
fmt  "X" 1 old_x_AM
fmt  "Y" 1 old_y_AM
fmt  "Z" 1 old_z_AM
fmt  "X" 2 old_x_print_AM
fmt  "Y" 2 old_y_print_AM
fmt  "Z" 2 old_z_print_AM
fmt  "C" 12 axeC_AM
fmt  "A" 12 axeA_AM
fmt  "Z" 2 old_zinitht_AM
fmt "Z" 2 dest_ret_5x_AM
fmt "Z" 2 old_dest_ret_5x_AM
fmt  "ER" 8 initht5x_AM
fmt  "Z" 8 zinitht_AM
fmt  "" 2 sdis_AM
fmt  "X" 2 xabs_AM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_AM
fmt  "Z" 2 zabs_AM
fmt "Z" 2 z_retraction_AM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_AM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_AM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_AM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_AM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_AM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_AM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_AM
fmt "Z" 3 prof_2_AM
fmt "Z" 3 prof_3_AM
fmt "Z" 3 prof_4_AM
fmt "Z" 3 prof_5_AM
fmt "Z" 3 prof_1_rel_AM
fmt "Z" 3 prof_2_rel_AM
fmt "Z" 3 prof_3_rel_AM
fmt "Z" 3 prof_4_rel_AM
fmt "Z" 3 prof_5_rel_AM
fmt "G4 F" 15 tempo_1_AM
fmt "G4 F" 15 tempo_2_AM
fmt "G4 F" 15 tempo_3_AM
fmt "G4 F" 15 tempo_4_AM
fmt "G4 F" 15 tempo_5_AM
fmt  "Z" 8 zaproche_AM
fmt     9 mr8_AM
fmt     9 mr9_AM
fmt     9 mr10_AM
fmt     9 mr4_AM
fmt  "op" 1 prvop_id_AM
fmt     3 spdlon_AM
fmt 2 ecrigeneral_AM
fmt "Old progno" 4 old_progno_AM
fmt  "OP" 3 operation_AM
fmt  "E" 3 e53_AM
fmt  "DEB" 4 debut_AM
fmt  "OPERATION "  5 numop_AM
fmt 6 numprg_concat_AM
fmt 6 cont_mi10_AM
fmt 2 old_mi10_AM
fmt 5 numop_garage_AM
fmt 2 erreur_AM
fmt 6 numprg_garage_AM
fmt 6 old_numprg_garage_AM
fmt  "D" 4 tlngno_AM
fmt  "Z" 8 depth_AM
fmt  "EH" 8 refht_AM
fmt  "ER" 8 initht_AM
fmt  "EF" 2 dwell_AM
fmt  "EP" 2 peckclr_AM
fmt  "P" 2 peck1_AM
fmt  "Q" 2 peck2_AM
fmt     3 mi4_AM
fmt  "M" 3 oldstation_AM
fmt     3 mi5_AM
fmt  "M" 3 oldmi5_AM
fmt     3 mi8_AM
fmt  "M" 3 oldmi8_AM
fmt "DEC_X_AM " 2 DEC_X_AM
fmt "DEC_Y_AM " 2 DEC_Y_AM
fmt "DEC_Z_AM " 2 DEC_Z_AM
fmt "prog_AM" 2 prog_AM
fmt "Mi2 pour A base =" 4 mi2_A_base_AM
fmt "Mi1 pour C base =" 4 mi1_C_base_AM
fmt  "TR" 4 trplus_AM
fmt  "I" 7 invers_AM
fmt  "D" 1 deja_AM
fmt  "VX" 1 old_vx_AM
fmt  "VY" 1 old_vy_AM
fmt  "VZ" 1 old_vz_AM
fmt  "Vx" 1 Vx_AM
fmt  "Vy" 1 Vy_AM
fmt  "Vz" 1 Vz_AM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fr_AM
fmt  "@AVANCE_TRAVAIL_STD@" 3 frplunge_AM
fmt "@AVANCE_TRAVAIL_STD@" 5 f_ent_cir_AM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_hel_AM                                   # avance de l'helicoide 
fmt "@AVANCE_TRAVAIL_STD@" 5 f_spiral_AM                                    # avance de la spiral
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_fin_AM                                   # avance sur la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_sor_cir_AM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_base_AM                                      # avance de base du cycle
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_1_AM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_2_AM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_3_AM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_4_AM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_5_AM
fmt     2 typcycle_AM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_AM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_AM
fmt "old_sub_trnstyp_AM" 4 old_sub_trnstyp_AM
fmt "old_sub_totl_no_AM" 4 old_sub_totl_no_AM
fmt  "CT" 4 cont_axe_c_AM     #compte tour axe c
fmt  ""  3 changop_AM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fretrait_AM
fmt  "X" 2 old_tox4_AM
fmt  "Y" 2 old_toy4_AM
fmt  "Z" 2 old_toz4_AM
fmt  "EC" 7 old_axeCpos_AM
fmt  "EA" 7 old_axeApos_AM
fmt      7 oldreel_axeCpos_AM
fmt      7 reel_axeCpos_AM
fmt      7 difaxecpos_AM
fmt      7 comptour_AM
fmt      7 naxecpos_AM
fmt "renv angle on off=" 4 tete_rev_AM
fmt  "cosangle" 11 cosangle_AM
fmt "LP12=" 1 long_p12_AM
fmt "LP23=" 1 long_p23_AM
fmt "LP13=" 1 long_p13_AM
fmt "Angle5x=" 1 ang5x_AM
fmt  "X" 1 old_x_5x_AM
fmt  "Y" 1 old_y_5x_AM
fmt  "Z" 1 old_z_5x_AM

fretrait_AM : 500
old_sub_trnstyp_AM : -1
old_sub_totl_no_AM : -1
prog_AM : -1
cont_mi10_AM : 0
operation_AM : 0
drill5axes_AM  : 0

mini_a_AM =   -110.001
maxi_a_AM = 110.001
mini_c_AM = -365.001
maxi_c_AM = 365.001
zsecu_AM = 1500   # valeur altitude de securité en Z
dec_tete_AM = 113.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_AM : 100
gfr_AM : 1
sprog_concat_AM : ""

sm93_AM    : "G93"
sm94_AM : "G94"
sgfr_AM : ""

fstrsel  sm93_AM gfr_AM sgfr_AM 2 -1

spl00_AM    : "G17"
spl01_AM    : "G19"
spl02_AM    : "G18"
spl03_AM : ""
splcode_AM : ""

fstrsel  spl00_AM plane$ splcode_AM 4 -1

sm00_AM    : "M4"
sm01_AM    : "M5"
sm02_AM    : "M3"
spdlon_AM ??
spdlsel_AM = fsg3(ss$)

fstrsel  sm00_AM spdlsel_AM spdlon_AM 3 -1

stringtxt1_AM : "$ BRIDER LA PIECE AVEC VIS"
stringtxt2_AM : "$ OTER LES VIS"
stringtxt3_AM : "$ BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_AM : "$ OTER LES SERRE-JOINTS"
stringtxt5_AM : "$ OTER LES CHUTES"
stringtxt6_AM : "$ BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_AM : "$ NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_AM : "TEXTE8"
stringtxt9_AM : "TEXTE9"
stringtxt10_AM : "TEXTE10"

fmt 4 deja_gcode_AM
pgcode_AM #modalité pgcode_AM

            if (gcode$ = 0) & (deja_gcode_AM <> 0), "G0",  deja_gcode_AM = 0
            if (gcode$ = 1) & (deja_gcode_AM <> 1), "G1",  deja_gcode_AM = 1
            if (gcode$ = 2) & (deja_gcode_AM <> 2), "G2",  deja_gcode_AM = 2
            if (gcode$ = 3) & (deja_gcode_AM <> 3), "G3",  deja_gcode_AM = 3
            if (gcode$ = 4) & (deja_gcode_AM <> 4), "G1",  deja_gcode_AM = 4

pgcode_force_AM #modalité pgcode_AM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE BM

fmt      7 mini_a_BM
fmt      7 maxi_a_BM
fmt      7 mini_c_BM
fmt      7 maxi_c_BM
fmt "Z" 2 zsecu_BM
fmt  "X" 2 x3dprint_BM
fmt  "Y" 2 y3dprint_BM
fmt  "Z" 2 z3dprint_BM
fmt  "C" 7 axeCpos1_BM
fmt  "A" 7 axeApos1_BM
fmt  "X=" 7 axeApos_BM
fmt  "Z=" 7 axeCpos_BM
fmt "X" 2 tox4print_BM
fmt "Y" 2 toy4print_BM
fmt "Z" 2 toz4print_BM
fmt  "I" 2 iprint_BM
fmt  "J" 2 jprint_BM
fmt  "K" 2 kprint_BM
fmt "X" 2 xrprint_BM
fmt "Y" 2 yrprint_BM
fmt "Z" 2 zrprint_BM
fmt "X" 2 xrprintrap_BM
fmt "Y" 2 yrprintrap_BM
fmt "Z" 2 zrprintrap_BM
fmt "Y" 2 depthprint_BM
fmt "Y" 2 refhtprint_BM
fmt "Y" 2 inithtprint_BM
fmt "Z" 2 mr2print_BM
fmt "@ROTATION_BROCHE@" 3 ssprint_BM
fmt "G04 F" 2 tempo_BM " ; temporisation "
fmt  "T" 3 tprint_BM
fmt  "" 3 tprint2_BM
fmt "E80004=" 2 vale84_BM
fmt  "N" 3 nplus_BM
fmt  "Z" 2 z1_BM
fmt  "Z" 2 prvmr2_BM
fmt "X" 8 xprint_BM
fmt "Y" 8 yprint_BM
fmt "Z" 8 zprint_BM
fmt "X" 8 xgarde_BM
fmt "Y" 8 ygarde_BM
fmt "Z" 8 zgarde_BM
fmt  "@AVANCE_TRAVAIL_STD@" 4 avance_BM
fmt  "@AVANCE_TRAVAIL_STD@" 10 fr5axe_BM
fmt  "@AVANCE_TRAVAIL_STD@" 10 frbase_BM
fmt   10 fr5axe_flag_BM
fmt   10 frbase_flag_BM
fmt  "K" 2 pas_BM
fmt  "X" 2 xdeg_BM
fmt  "Y" 2 ydeg_BM
fmt  "Z" 2 zdeg_BM
fmt  "Z" 1 zdeg2_BM
fmt  "C" 12 prvaxec_BM
fmt  "X" 1 old_x_BM
fmt  "Y" 1 old_y_BM
fmt  "Z" 1 old_z_BM
fmt  "X" 2 old_x_print_BM
fmt  "Y" 2 old_y_print_BM
fmt  "Z" 2 old_z_print_BM
fmt  "C" 12 axeC_BM
fmt  "A" 12 axeA_BM
fmt  "Z" 2 old_zinitht_BM
fmt "Z" 2 dest_ret_5x_BM
fmt "Z" 2 old_dest_ret_5x_BM
fmt  "" 8 initht5x_BM
fmt  "Z" 8 zinitht_BM
fmt  "" 2 sdis_BM
fmt  "X" 2 xabs_BM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_BM
fmt  "Z" 2 zabs_BM
fmt "Z" 2 z_retraction_BM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_BM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_BM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_BM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_BM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_BM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_BM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_BM
fmt "Z" 3 prof_2_BM
fmt "Z" 3 prof_3_BM
fmt "Z" 3 prof_4_BM
fmt "Z" 3 prof_5_BM
fmt "Z" 3 prof_1_rel_BM
fmt "Z" 3 prof_2_rel_BM
fmt "Z" 3 prof_3_rel_BM
fmt "Z" 3 prof_4_rel_BM
fmt "Z" 3 prof_5_rel_BM
fmt "G4 F" 15 tempo_1_BM
fmt "G4 F" 15 tempo_2_BM
fmt "G4 F" 15 tempo_3_BM
fmt "G4 F" 15 tempo_4_BM
fmt "G4 F" 15 tempo_5_BM
fmt  "Z" 8 zaproche_BM
fmt  "X,ORI_X1" 13 mr8_BM
fmt  "Y,ORI_Y1" 13 mr9_BM
fmt  "Z,ORI_Z1" 13 mr10_BM
fmt  "USURE_L(" 2 mr4_BM ")"
fmt  "op" 1 prvop_id_BM
fmt     3 spdlon_BM
fmt 2 ecrigeneral_BM
fmt "Old progno" 4 old_progno_BM
fmt  "OP" 3 operation_BM
fmt  "E" 3 e53_BM
fmt  "DEB" 4 debut_BM
fmt  "OPERATION "  5 numop_BM
fmt 6 numprg_concat_BM
fmt 6 cont_mi10_BM
fmt 2 old_mi10_BM
fmt 5 numop_garage_BM
fmt 2 erreur_BM
fmt 6 numprg_garage_BM
fmt 6 old_numprg_garage_BM
fmt     3 mi4_BM
fmt  "M" 3 oldstation_BM
fmt     3 mi5_BM
fmt  "M" 3 oldmi5_BM
fmt     3 mi8_BM
fmt  "M" 3 oldmi8_BM
fmt "DEC_X_BM " 2 DEC_X_BM
fmt "DEC_Y_BM " 2 DEC_Y_BM
fmt "DEC_Z_BM " 2 DEC_Z_BM
fmt "prog_BM" 2 prog_BM
fmt "Mi2 pour A base =" 4 mi2_A_base_BM
fmt "Mi1 pour C base =" 4 mi1_C_base_BM
fmt  "TR" 4 trplus_BM
fmt  "I" 7 invers_BM
fmt  "D" 1 deja_BM
fmt  "VX" 1 old_vx_BM
fmt  "VY" 1 old_vy_BM
fmt  "VZ" 1 old_vz_BM
fmt  "Vx" 1 Vx_BM
fmt  "Vy" 1 Vy_BM
fmt  "Vz" 1 Vz_BM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fr_BM
fmt  "@AVANCE_TRAVAIL_STD@" 3 frplunge_BM
fmt "@AVANCE_TRAVAIL_STD@" 5 f_ent_cir_BM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_hel_BM                                   # avance de l'helicoide 
fmt "@AVANCE_TRAVAIL_STD@" 5 f_spiral_BM                                    # avance de la spiral
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_fin_BM                                   # avance sur la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_sor_cir_BM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_base_BM                                      # avance de base du cycle
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_1_BM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_2_BM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_3_BM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_4_BM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_5_BM
fmt     2 typcycle_BM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_BM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_BM
fmt "old_sub_trnstyp_BM" 4 old_sub_trnstyp_BM
fmt "old_sub_totl_no_BM" 4 old_sub_totl_no_BM
fmt  "CT" 4 cont_axe_c_BM     #compte tour axe c
fmt  ""  3 changop_BM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fretrait_BM
fmt  "X" 2 old_tox4_BM
fmt  "Y" 2 old_toy4_BM
fmt  "Z" 2 old_toz4_BM
fmt  "EC" 7 old_axeCpos_BM
fmt  "EA" 7 old_axeApos_BM
fmt      7 oldreel_axeCpos_BM
fmt      7 reel_axeCpos_BM
fmt      7 difaxecpos_BM
fmt      7 comptour_BM
fmt      7 naxecpos_BM
fmt "renv angle on off=" 4 tete_rev_BM
fmt  "cosangle" 11 cosangle_BM
fmt "LP12=" 1 long_p12_BM
fmt "LP23=" 1 long_p23_BM
fmt "LP13=" 1 long_p13_BM
fmt "Angle5x=" 1 ang5x_BM
fmt  "X" 1 old_x_5x_BM
fmt  "Y" 1 old_y_5x_BM
fmt  "Z" 1 old_z_5x_BM

fretrait_BM : 500
old_sub_trnstyp_BM : -1
old_sub_totl_no_BM : -1
prog_BM : -1
cont_mi10_BM : 0
operation_BM : 0
drill5axes_BM  : 0

mini_a_BM =   -110.001
maxi_a_BM = 110.001
mini_c_BM = -365.001
maxi_c_BM = 365.001
zsecu_BM = 800   # valeur altitude de securité en Z
dec_tete_BM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_BM : 100
gfr_BM : 1
sprog_concat_BM : ""

sm93_BM    : "G93"
sm94_BM : "G94"
sgfr_BM : ""

fstrsel  sm93_BM gfr_BM sgfr_BM 2 -1

spl00_BM    : "G17"
spl01_BM    : "G19"
spl02_BM    : "G18"
spl03_BM : ""
splcode_BM : ""

fstrsel  spl00_BM plane$ splcode_BM 4 -1

sm00_BM    : "M4"
sm01_BM    : "M5"
sm02_BM    : "M3"
spdlon_BM ??
spdlsel_BM = fsg3(ss$)

fstrsel  sm00_BM spdlsel_BM spdlon_BM 3 -1

stringtxt1_BM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_BM : "OTER LES VIS"
stringtxt3_BM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_BM : "OTER LES SERRE-JOINTS"
stringtxt5_BM : "OTER LES CHUTES"
stringtxt6_BM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_BM : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_BM : "TEXTE8"
stringtxt9_BM : "TEXTE9"
stringtxt10_BM : "TEXTE10"
spalpeur_BM : "PALPEUR_3D"

fmt 4 deja_gcode_BM
pgcode_BM #modalité pgcode_BM

            if (gcode$ = 0) & (deja_gcode_BM <> 0), "G0",  deja_gcode_BM = 0
            if (gcode$ = 1) & (deja_gcode_BM <> 1), "G1",  deja_gcode_BM = 1
            if (gcode$ = 2) & (deja_gcode_BM <> 2), "G2",  deja_gcode_BM = 2
            if (gcode$ = 3) & (deja_gcode_BM <> 3), "G3",  deja_gcode_BM = 3
            if (gcode$ = 4) & (deja_gcode_BM <> 4), "G1",  deja_gcode_BM = 4

pgcode_force_BM #modalité pgcode_BM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE CM

fmt      7 mini_a_CM
fmt      7 maxi_a_CM
fmt      7 mini_c_CM
fmt      7 maxi_c_CM
fmt      7 mini_c_sans_cloche_CM
fmt      7 maxi_c_sans_cloche_CM
fmt      7 mini_c_avec_cloche_CM
fmt      7 maxi_c_avec_cloche_CM
fmt "Z" 2 zsecu_CM
fmt  "X" 2 x3dprint_CM
fmt  "Y" 2 y3dprint_CM
fmt  "Z" 2 z3dprint_CM
fmt  "C" 7 axeCpos1_CM
fmt  "B" 7 axeApos1_CM
fmt  "X=" 7 axeApos_CM
fmt  "Z=" 7 axeCpos_CM
fmt  "" 7 axeApos_cycle800_CM
fmt  "" 7 axeCpos_cycle800_CM
fmt "X" 2 tox4print_CM
fmt "Y" 2 toy4print_CM
fmt "Z" 2 toz4print_CM
fmt  "I" 2 iprint_CM
fmt  "J" 2 jprint_CM
fmt  "K" 2 kprint_CM
fmt "X" 2 xrprint_CM
fmt "Y" 2 yrprint_CM
fmt "Z" 2 zrprint_CM
fmt "X" 2 xrprintrap_CM
fmt "Y" 2 yrprintrap_CM
fmt "Z" 2 zrprintrap_CM
fmt "Y" 2 depthprint_CM
fmt "Y" 2 refhtprint_CM
fmt "Y" 2 inithtprint_CM
fmt "Z" 2 mr2print_CM
fmt "@ROTATION_BROCHE@" 3 ssprint_CM
fmt "G04 F" 2 tempo_CM " ; temporisation "
fmt  "T" 3 tprint_CM
fmt  "" 3 tprint2_CM
fmt "E80004=" 2 vale84_CM
fmt  "N" 3 nplus_CM
fmt  "Z" 2 z1_CM
fmt  "Z" 2 prvmr2_CM
fmt "X" 19 xprint_CM
fmt "Y" 19 yprint_CM
fmt "Z" 19 zprint_CM
fmt "X" 8 xgarde_CM
fmt "Y" 8 ygarde_CM
fmt "Z" 8 zgarde_CM
fmt  "@AVANCE_TRAVAIL_STD@" 4 avance_CM
fmt  "@AVANCE_TRAVAIL_STD@" 10 fr5axe_CM
fmt  "@AVANCE_TRAVAIL_STD@" 10 frbase_CM
fmt   10 fr5axe_flag_CM
fmt   10 frbase_flag_CM
fmt  "K" 2 pas_CM
fmt  "X" 2 xdeg_CM
fmt  "Y" 2 ydeg_CM
fmt  "Z" 2 zdeg_CM
fmt  "Z" 1 zdeg2_CM
fmt  "C" 12 prvaxec_CM
fmt  "X" 1 old_x_CM
fmt  "Y" 1 old_y_CM
fmt  "Z" 1 old_z_CM
fmt  "X" 2 old_x_print_CM
fmt  "Y" 2 old_y_print_CM
fmt  "Z" 2 old_z_print_CM
fmt  "C" 12 axeC_CM
fmt  "B" 12 axeA_CM
fmt  "Z" 2 old_zinitht_CM
fmt "Z" 2 dest_ret_5x_CM
fmt "Z" 2 old_dest_ret_5x_CM
fmt  "" 8 initht5x_CM
fmt  "Z" 8 zinitht_CM
fmt  "" 2 sdis_CM
fmt  "X" 2 xabs_CM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_CM
fmt  "Z" 2 zabs_CM
fmt "Z" 2 z_retraction_CM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_CM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_CM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_CM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_CM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_CM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_CM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_CM
fmt "Z" 3 prof_2_CM
fmt "Z" 3 prof_3_CM
fmt "Z" 3 prof_4_CM
fmt "Z" 3 prof_5_CM
fmt "Z" 3 prof_1_rel_CM
fmt "Z" 3 prof_2_rel_CM
fmt "Z" 3 prof_3_rel_CM
fmt "Z" 3 prof_4_rel_CM
fmt "Z" 3 prof_5_rel_CM
fmt "G4 F" 15 tempo_1_CM
fmt "G4 F" 15 tempo_2_CM
fmt "G4 F" 15 tempo_3_CM
fmt "G4 F" 15 tempo_4_CM
fmt "G4 F" 15 tempo_5_CM
fmt  "Z" 8 zaproche_CM
fmt  "X" 8 xaproche_CM
fmt  "Y" 8 yaproche_CM
fmt  "X,ORI_X1" 13 mr8_CM
fmt  "Y,ORI_Y1" 13 mr9_CM
fmt  "Z,ORI_Z1" 13 mr10_CM
fmt  "LONG_COR=" 2 mr4_CM
fmt  "op" 1 prvop_id_CM
fmt     3 spdlon_CM
fmt 2 ecrigeneral_CM
fmt "Old progno" 4 old_progno_CM
fmt  "OP" 3 operation_CM
fmt  "E" 3 e53_CM
fmt  "DEB" 4 debut_CM
fmt  "OPERATION "  5 numop_CM
fmt 6 numprg_concat_CM
fmt 6 cont_mi10_CM
fmt 2 old_mi10_CM
fmt 5 numop_garage_CM
fmt 2 erreur_CM
fmt 6 numprg_garage_CM
fmt 6 old_numprg_garage_CM
fmt     3 mi4_CM
fmt  "M" 3 oldstation_CM
fmt     3 mi5_CM
fmt  "M" 3 oldmi5_CM
fmt     3 mi8_CM
fmt  "M" 3 oldmi8_CM
fmt "DEC_X_CM " 2 DEC_X_CM
fmt "DEC_Y_CM " 2 DEC_Y_CM
fmt "DEC_Z_CM " 2 DEC_Z_CM
fmt "POURCENTAGE_AVANCE_CM" 2 POURCENTAGE_AVANCE_CM
fmt "prog_CM" 2 prog_CM
fmt "Mi2 pour A base =" 4 mi2_A_base_CM
fmt "Mi1 pour C base =" 4 mi1_C_base_CM
fmt  "TR" 4 trplus_CM
fmt  "I" 7 invers_CM
fmt  "D" 1 deja_CM
fmt  "VX" 1 old_vx_CM
fmt  "VY" 1 old_vy_CM
fmt  "VZ" 1 old_vz_CM
fmt  "Vx" 1 Vx_CM
fmt  "Vy" 1 Vy_CM
fmt  "Vz" 1 Vz_CM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fr_CM
fmt  "@AVANCE_TRAVAIL_STD@" 3 frplunge_CM
fmt "@AVANCE_TRAVAIL_STD@" 5 f_ent_cir_CM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_hel_CM                                   # avance de l'helicoide 
fmt "@AVANCE_TRAVAIL_STD@" 5 f_spiral_CM                                    # avance de la spiral
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_fin_CM                                   # avance sur la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_sor_cir_CM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_base_CM                                      # avance de base du cycle
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_1_CM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_2_CM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_3_CM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_4_CM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_5_CM
fmt     2 typcycle_CM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_CM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_CM
fmt "old_sub_trnstyp_CM" 4 old_sub_trnstyp_CM
fmt "old_sub_totl_no_CM" 4 old_sub_totl_no_CM
fmt 4 blocaxe_CM
fmt  "CT" 4 cont_axe_c_CM     #compte tour axe c
fmt  ""  3 changop_CM
fmt "" 8 avance_plonge_CM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fretrait_CM
fmt "LONG_MAX=" 15 LONG_MAX_CM
fmt "LONG_MIN=" 15 LONG_MIN_CM
fmt  "X" 2 old_tox4_CM
fmt  "Y" 2 old_toy4_CM
fmt  "Z" 2 old_toz4_CM
fmt  "EC" 7 old_axeCpos_CM
fmt  "EA" 7 old_axeApos_CM
fmt      7 oldreel_axeCpos_CM
fmt      7 reel_axeCpos_CM
fmt      7 difaxecpos_CM
fmt      7 comptour_CM
fmt      7 naxecpos_CM
fmt "renv angle on off=" 4 tete_rev_CM
fmt  "cosangle" 11 cosangle_CM
fmt "LP12=" 1 long_p12_CM
fmt "LP23=" 1 long_p23_CM
fmt "LP13=" 1 long_p13_CM
fmt "Angle5x=" 1 ang5x_CM
fmt  "X" 1 old_x_5x_CM
fmt  "Y" 1 old_y_5x_CM
fmt  "Z" 1 old_z_5x_CM

fretrait_CM : 500
old_sub_trnstyp_CM : -1
old_sub_totl_no_CM : -1
prog_CM : -1
cont_mi10_CM : 0
operation_CM : 0
drill5axes_CM  : 0

mini_a_CM =   -120.001
maxi_a_CM = 120.001
mini_c_CM : -185.001
maxi_c_CM : 185.001
mini_c_sans_cloche_CM = -270.001
maxi_c_sans_cloche_CM = 270.001
mini_c_avec_cloche_CM = -185.001
maxi_c_avec_cloche_CM = 185.001
zsecu_CM = 800   # valeur altitude de securité en Z
dec_tete_CM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_CM : 100
gfr_CM : 1
sprog_concat_CM : ""

sm93_CM    : "G93"
sm94_CM : "G94"
sgfr_CM : ""

fstrsel  sm93_CM gfr_CM sgfr_CM 2 -1

spl00_CM    : "G17"
spl01_CM    : "G19"
spl02_CM    : "G18"
spl03_CM : ""
splcode_CM : ""

fstrsel  spl00_CM plane$ splcode_CM 4 -1

sm00_CM    : "M4"
sm01_CM    : "M5"
sm02_CM    : "M3"
spdlon_CM ??
spdlsel_CM = fsg3(ss$)

fstrsel  sm00_CM spdlsel_CM spdlon_CM 3 -1

stringtxt1_CM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_CM : "OTER LES VIS"
stringtxt3_CM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_CM : "OTER LES SERRE-JOINTS"
stringtxt5_CM : "OTER LES CHUTES"
stringtxt6_CM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_CM : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_CM : "TEXTE8"
stringtxt9_CM : "TEXTE9"
stringtxt10_CM : "TEXTE10"
spalpeur_CM : "PALPEUR_3D"

fmt 4 deja_gcode_CM
pgcode_CM #modalité pgcode_CM

            if (gcode$ = 0) & (deja_gcode_CM <> 0), "G0",  deja_gcode_CM = 0
            if (gcode$ = 1) & (deja_gcode_CM <> 1), "G1",  deja_gcode_CM = 1
            if (gcode$ = 2) & (deja_gcode_CM <> 2), "G2",  deja_gcode_CM = 2
            if (gcode$ = 3) & (deja_gcode_CM <> 3), "G3",  deja_gcode_CM = 3
            if (gcode$ = 4) & (deja_gcode_CM <> 4), "G1",  deja_gcode_CM = 4

pgcode_force_CM #modalité pgcode_CM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE DM

fmt      7 mini_a_DM
fmt      7 maxi_a_DM
fmt      7 mini_c_DM
fmt      7 maxi_c_DM
fmt      7 mini_c_sans_cloche_DM
fmt      7 maxi_c_sans_cloche_DM
fmt      7 mini_c_avec_cloche_DM
fmt      7 maxi_c_avec_cloche_DM
fmt "Z" 2 zsecu_DM
fmt  "X" 2 x3dprint_DM
fmt  "Y" 2 y3dprint_DM
fmt  "Z" 2 z3dprint_DM
fmt  "C" 7 axeCpos1_DM
fmt  "B" 7 axeApos1_DM
fmt  "X=" 7 axeApos_DM
fmt  "Z=" 7 axeCpos_DM
fmt  "" 7 axeApos_cycle800_DM
fmt  "" 7 axeCpos_cycle800_DM
fmt "X" 2 tox4print_DM
fmt "Y" 2 toy4print_DM
fmt "Z" 2 toz4print_DM
fmt  "I" 2 iprint_DM
fmt  "J" 2 jprint_DM
fmt  "K" 2 kprint_DM
fmt "X" 2 xrprint_DM
fmt "Y" 2 yrprint_DM
fmt "Z" 2 zrprint_DM
fmt "X" 2 xrprintrap_DM
fmt "Y" 2 yrprintrap_DM
fmt "Z" 2 zrprintrap_DM
fmt "Y" 2 depthprint_DM
fmt "Y" 2 refhtprint_DM
fmt "Y" 2 inithtprint_DM
fmt "Z" 2 mr2print_DM
fmt "@ROTATION_BROCHE@" 3 ssprint_DM
fmt "G04 F" 2 tempo_DM " ; temporisation "
fmt  "T" 3 tprint_DM
fmt  "" 3 tprint2_DM
fmt "E80004=" 2 vale84_DM
fmt  "N" 3 nplus_DM
fmt  "Z" 2 z1_DM
fmt  "Z" 2 prvmr2_DM
fmt "X" 19 xprint_DM
fmt "Y" 19 yprint_DM
fmt "Z" 19 zprint_DM
fmt "X" 8 xgarde_DM
fmt "Y" 8 ygarde_DM
fmt "Z" 8 zgarde_DM
fmt  "@AVANCE_TRAVAIL_STD@" 4 avance_DM
fmt  "@AVANCE_TRAVAIL_STD@" 10 fr5axe_DM
fmt  "@AVANCE_TRAVAIL_STD@" 10 frbase_DM
fmt   10 fr5axe_flag_DM
fmt   10 frbase_flag_DM
fmt  "K" 2 pas_DM
fmt  "X" 2 xdeg_DM
fmt  "Y" 2 ydeg_DM
fmt  "Z" 2 zdeg_DM
fmt  "Z" 1 zdeg2_DM
fmt  "C" 12 prvaxec_DM
fmt  "X" 1 old_x_DM
fmt  "Y" 1 old_y_DM
fmt  "Z" 1 old_z_DM
fmt  "X" 2 old_x_print_DM
fmt  "Y" 2 old_y_print_DM
fmt  "Z" 2 old_z_print_DM
fmt  "C" 12 axeC_DM
fmt  "B" 12 axeA_DM
fmt  "Z" 2 old_zinitht_DM
fmt "Z" 2 dest_ret_5x_DM
fmt "Z" 2 old_dest_ret_5x_DM
fmt  "" 8 initht5x_DM
fmt  "Z" 8 zinitht_DM
fmt  "" 2 sdis_DM
fmt  "X" 2 xabs_DM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_DM
fmt  "Z" 2 zabs_DM
fmt "Z" 2 z_retraction_DM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_DM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_DM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_DM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_DM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_DM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_DM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_DM
fmt "Z" 3 prof_2_DM
fmt "Z" 3 prof_3_DM
fmt "Z" 3 prof_4_DM
fmt "Z" 3 prof_5_DM
fmt "Z" 3 prof_1_rel_DM
fmt "Z" 3 prof_2_rel_DM
fmt "Z" 3 prof_3_rel_DM
fmt "Z" 3 prof_4_rel_DM
fmt "Z" 3 prof_5_rel_DM
fmt "G4 F" 15 tempo_1_DM
fmt "G4 F" 15 tempo_2_DM
fmt "G4 F" 15 tempo_3_DM
fmt "G4 F" 15 tempo_4_DM
fmt "G4 F" 15 tempo_5_DM
fmt  "Z" 8 zaproche_DM
fmt  "X" 8 xaproche_DM
fmt  "Y" 8 yaproche_DM
fmt  "X,ORI_X1" 13 mr8_DM
fmt  "Y,ORI_Y1" 13 mr9_DM
fmt  "Z,ORI_Z1" 13 mr10_DM
fmt  "LONG_COR=" 2 mr4_DM
fmt  "op" 1 prvop_id_DM
fmt     3 spdlon_DM
fmt 2 ecrigeneral_DM
fmt "Old progno" 4 old_progno_DM
fmt  "OP" 3 operation_DM
fmt  "E" 3 e53_DM
fmt  "DEB" 4 debut_DM
fmt  "OPERATION "  5 numop_DM
fmt 6 numprg_concat_DM
fmt 6 cont_mi10_DM
fmt 2 old_mi10_DM
fmt 5 numop_garage_DM
fmt 2 erreur_DM
fmt 6 numprg_garage_DM
fmt 6 old_numprg_garage_DM
fmt     3 mi4_DM
fmt  "M" 3 oldstation_DM
fmt     3 mi5_DM
fmt  "M" 3 oldmi5_DM
fmt     3 mi8_DM
fmt  "M" 3 oldmi8_DM
fmt "DEC_X_DM " 2 DEC_X_DM
fmt "DEC_Y_DM " 2 DEC_Y_DM
fmt "DEC_Z_DM " 2 DEC_Z_DM
fmt "POURCENTAGE_AVANCE_DM" 2 POURCENTAGE_AVANCE_DM
fmt "prog_DM" 2 prog_DM
fmt "Mi2 pour A base =" 4 mi2_A_base_DM
fmt "Mi1 pour C base =" 4 mi1_C_base_DM
fmt  "TR" 4 trplus_DM
fmt  "I" 7 invers_DM
fmt  "D" 1 deja_DM
fmt  "VX" 1 old_vx_DM
fmt  "VY" 1 old_vy_DM
fmt  "VZ" 1 old_vz_DM
fmt  "Vx" 1 Vx_DM
fmt  "Vy" 1 Vy_DM
fmt  "Vz" 1 Vz_DM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fr_DM
fmt  "@AVANCE_TRAVAIL_STD@" 3 frplunge_DM
fmt "@AVANCE_TRAVAIL_STD@" 5 f_ent_cir_DM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_hel_DM                                   # avance de l'helicoide 
fmt "@AVANCE_TRAVAIL_STD@" 5 f_spiral_DM                                    # avance de la spiral
fmt "@AVANCE_TRAVAIL_STD@" 5 f_int_fin_DM                                   # avance sur la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_sor_cir_DM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE_TRAVAIL_STD@" 5 f_base_DM                                      # avance de base du cycle
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_1_DM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_2_DM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_3_DM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_4_DM
fmt "@AVANCE_TRAVAIL_STD@" 4 avance_5_DM
fmt     2 typcycle_DM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_DM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_DM
fmt "old_sub_trnstyp_DM" 4 old_sub_trnstyp_DM
fmt "old_sub_totl_no_DM" 4 old_sub_totl_no_DM
fmt 4 blocaxe_DM
fmt  "CT" 4 cont_axe_c_DM     #compte tour axe c
fmt  ""  3 changop_DM
fmt "" 8 avance_plonge_DM
fmt  "@AVANCE_TRAVAIL_STD@" 4 fretrait_DM
fmt "LONG_MAX=" 15 LONG_MAX_DM
fmt "LONG_MIN=" 15 LONG_MIN_DM
fmt  "X" 2 old_tox4_DM
fmt  "Y" 2 old_toy4_DM
fmt  "Z" 2 old_toz4_DM
fmt  "EC" 7 old_axeCpos_DM
fmt  "EA" 7 old_axeApos_DM
fmt      7 oldreel_axeCpos_DM
fmt      7 reel_axeCpos_DM
fmt      7 difaxecpos_DM
fmt      7 comptour_DM
fmt      7 naxecpos_DM
fmt "renv angle on off=" 4 tete_rev_DM
fmt  "cosangle" 11 cosangle_DM
fmt "LP12=" 1 long_p12_DM
fmt "LP23=" 1 long_p23_DM
fmt "LP13=" 1 long_p13_DM
fmt "Angle5x=" 1 ang5x_DM
fmt  "X" 1 old_x_5x_DM
fmt  "Y" 1 old_y_5x_DM
fmt  "Z" 1 old_z_5x_DM

fretrait_DM : 500
old_sub_trnstyp_DM : -1
old_sub_totl_no_DM : -1
prog_DM : -1
cont_mi10_DM : 0
operation_DM : 0
drill5axes_DM  : 0

mini_a_DM =   -120.001
maxi_a_DM = 120.001
mini_c_DM : -185.001
maxi_c_DM : 185.001
mini_c_sans_cloche_DM = -270.001
maxi_c_sans_cloche_DM = 270.001
mini_c_avec_cloche_DM = -185.001
maxi_c_avec_cloche_DM = 185.001
zsecu_DM = 800   # valeur altitude de securité en Z
dec_tete_DM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_DM : 100
gfr_DM : 1
sprog_concat_DM : ""

sm93_DM    : "G93"
sm94_DM : "G94"
sgfr_DM : ""

fstrsel  sm93_DM gfr_DM sgfr_DM 2 -1

spl00_DM    : "G17"
spl01_DM    : "G19"
spl02_DM    : "G18"
spl03_DM : ""
splcode_DM : ""

fstrsel  spl00_DM plane$ splcode_DM 4 -1

sm00_DM    : "M4"
sm01_DM    : "M5"
sm02_DM    : "M3"
spdlon_DM ??
spdlsel_DM = fsg3(ss$)

fstrsel  sm00_DM spdlsel_DM spdlon_DM 3 -1

stringtxt1_DM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_DM : "OTER LES VIS"
stringtxt3_DM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_DM : "OTER LES SERRE-JOINTS"
stringtxt5_DM : "OTER LES CHUTES"
stringtxt6_DM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_DM : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8_DM : "TEXTE8"
stringtxt9_DM : "TEXTE9"
stringtxt10_DM : "TEXTE10"
spalpeur_DM : "PALPEUR_3D"

fmt 4 deja_gcode_DM
pgcode_DM #modalité pgcode_DM

            if (gcode$ = 0) & (deja_gcode_DM <> 0), "G0",  deja_gcode_DM = 0
            if (gcode$ = 1) & (deja_gcode_DM <> 1), "G1",  deja_gcode_DM = 1
            if (gcode$ = 2) & (deja_gcode_DM <> 2), "G2",  deja_gcode_DM = 2
            if (gcode$ = 3) & (deja_gcode_DM <> 3), "G3",  deja_gcode_DM = 3
            if (gcode$ = 4) & (deja_gcode_DM <> 4), "G1",  deja_gcode_DM = 4

pgcode_force_DM #modalité pgcode_DM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region FLAGS POUR PROG CONCATENES
#SARRET_LUB : "@ARRET_LUB@" #OK
#SROTATION_BROCHE_ARRET : "@ROTATION_BROCHE_ARRET@" #PAS OK
#SARRET_ASPI : "@ARRET_ASPI@" #OK
#SCORRECTEUR_LONGUEUR : "@CORRECTEUR_LONGUEUR@" #PAS OK
#SCHARGEMENT_OUTIL : "@CHARGEMENT_OUTIL@" #PAS OK
#SCORRECTEUR_DYN_LG_OUTIL : "@CORRECTEUR_DYN_LG_OUTIL@" #PAS OK
#SROTATION_BROCHE_HORAIRE : "@ROTATION_BROCHE_HORAIRE@" #PAS OK
#SROTATION_BROCHE_TRIGO : "@ROTATION_BROCHE_TRIGO@" #PAS OK
#SNOM_OUTIL : "@NOM_OUTIL@" #OK
#SCLOCHE : "@CLOCHE@" #OK
#SMARCHE_ASPI : "@MARCHE_ASPI@" #OK
#SDEC_ORIGINE_TYPE_G : "@DEC_ORIGINE_TYPE_G@" #PAS OK
#SVALIDATION_SECU_Z : "@VALIDATION_SECU_Z@" #PAS OK
#SSHUNT_SECU_Z : "@SHUNT_SECU_Z@" #PAS OK
SAVANCE_TRAVAIL_INVERSE : "@AVANCE_TRAVAIL_INVERSE@" #PAS OK
SAVANCE_TRAVAIL_STANDARD : "@AVANCE_TRAVAIL_STD@" #PAS OK
SAVANCE_PLONGEE_INVERSE : "@AVANCE_PLONGEE_INVERSE@" #PAS OK
SAVANCE_PLONGEE_STANDARD : "@AVANCE_PLONGEE_STD@" #PAS OK
#SDEBUT_LUB : "@DEBUT_LUB@" #OK
#SAVANCE_TRAVAIL : "@AVANCE@" #a rajouter
#SROTATION_BROCHE : "@ROTATION_BROCHE@" #a rajouter
#endregion
#endregion

#region   REPERTOIRES #OK       
#region CREATION DU REPERTOIRE
#---------------- BLOCS DE PRE TRAITEMENT POST PRO POUR CREATION DU REPERTOIRE programme et des sous repertoire machine ---------------------------------
# INITIALISATION DES STRING
spathgeneral : ""
spathgeneral_ramdisk : ""
spathgeneral_pur : ""
spathmchineA : ""
spathmchineB : ""
spathmchineC : ""
spathmchineD : ""
spathmchineA_ramdisk : ""
spathmchineB_ramdisk : ""
spathmchineC_ramdisk : ""
spathmchineD_ramdisk : ""
snumprog : ""
smachineA : "\STC9101\"   # nom de la machine A determinant le repertoire
smachineB : "\STC9103\"   # nom de la machine B determinant le repertoire   
smachineC : "\STC9110\"   # nom de la machine C determinant le repertoire
smachineD : "\STEMA01\"   # nom de la machine C determinant le repertoire
smachine_AG : "STC9101"
smachine_BG : "STC9103"
smachine_CG : "STC9110"
smachine_DG : "STEMA01"
sextmachineA : "xpi"      # extention pour les programme machine A
sextmachineC : "mpf"      # extention pour les programme machine B
sextmachineB : "mpf"      # extention pour les programme machine C
sextmachineD : "mpf"      # extention pour les programme machine D
smkdir : "Y:\CFAO\2017\Machines\creedir.exe"  # ou et nom de l'executable permetant la creation de repertoire
srmdir : "Y:\CFAO\2017\Machines\effacedir.exe"
sdpdir : "Y:\CFAO\2017\Machines\deplacedir.exe"
sramdisk : "U:\POST\"
sentre_cote = no2asc(34)  # permet d'afficher les " en debut et fin de string de rertoires
sunderscore = "_"
# INITIALISATION DES variables
fmt "Old progno" 4 old_progno

pgestion_rep       # Destruction-creation des repertoire ou placer les programmes
            subprg$ = 2    # 0 pas de sorti Sub, 1 sort mais ecrase a chaque fois, 2 remplis a chaque fois sans effacaer passif
            smcname$ = ucase(smcname$)
            snamenc$ = ucase(snamenc$)                  # servira a cree la racine du repertoire des programmes
            spathgeneral = spathnc$ + snamenc$          # racine du repertoire des programme
            spathgeneral_ramdisk = sramdisk + snamenc$          # racine du repertoire des programmes dans ramdisk

            spathmchineA_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineA + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine A
            spathmchineB_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineB + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine B
            spathmchineC_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineC + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine C
            spathmchineD_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineD + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine D
            #######################################
            #"voir le entre cote=", sentre_cote, e$
            #"voir nom=", *snamenc$, e$ 
            #"voir spathgeneral = ", spathgeneral,e$
            #######################################

            spathgeneral_pur = sentre_cote + spathgeneral + sentre_cote
            result = launch(srmdir, spathgeneral_pur)   # destruction du repertoire existant et toute son arboressance pour faire place neuve
            result = launch(smkdir, spathmchineA_ramdisk)       # execution d'une commande exterieur pour la creation du repertoire de la Machine A
            result = launch(smkdir, spathmchineB_ramdisk)       # execution d'une commande exterieur pour la creation du repertoire de la Machine B
            result = launch(smkdir, spathmchineC_ramdisk)       # execution d'une commande exterieur pour la creation du repertoire de la Machine C
            result = launch(smkdir, spathmchineD_ramdisk)       # execution d'une commande exterieur pour la creation du repertoire de la Machine D
            spathmchineA_ramdisk =  spathgeneral_ramdisk + smachineA    # racine du repertoire des programme pour la machine A pour la redirection
            spathmchineB_ramdisk =  spathgeneral_ramdisk + smachineB    # racine du repertoire des programme pour la machine B pour la redirection
            spathmchineC_ramdisk =  spathgeneral_ramdisk + smachineC    # racine du repertoire des programme pour la machine C pour la redirection
            spathmchineD_ramdisk =  spathgeneral_ramdisk + smachineD    # racine du repertoire des programme pour la machine D pour la redirection

            spathmchineA =  spathgeneral + smachineA    # racine du repertoire des programme pour affichage dans fichier TXT
            spathmchineB =  spathgeneral + smachineB    # racine du repertoire des programme pour affichage dans fichier TXT
            spathmchineC =  spathgeneral + smachineC    # racine du repertoire des programme pour affichage dans fichier TXT
            spathmchineD =  spathgeneral + smachineD    # racine du repertoire des programme pour affichage dans fichier TXT
            subout$=1

pdestruc_rep       # Destruction-creation des repertoire ou placer les programmes
            #if (erreur_CG = 1) | (erreur_CM = 1), clearsub$
            clearsub$
            subprg$ = 2    # 0 pas de sorti Sub, 1 sort mais ecrase a chaque fois, 2 remplis a chaque fois sans effacaer passif
            smcname$ = ucase(smcname$)
            snamenc$ = ucase(snamenc$)                  # servira a cree la racine du repertoire des programmes
            spathgeneral = spathnc$ + snamenc$          # racine du repertoire des programme
            spathgeneral_ramdisk = sramdisk + snamenc$          # racine du repertoire des programmes dans ramdisk          
            spathmchineA_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineA + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine A
            spathmchineB_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineB + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine B
            spathmchineC_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineC + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine C
            spathmchineD_ramdisk =  sentre_cote + spathgeneral_ramdisk + smachineD + sentre_cote    # racine du repertoire pour creation du repertoire pour la machine D
            spathgeneral_pur = sentre_cote + spathgeneral + sentre_cote
            #result = launch(srmdir, spathgeneral_pur)   # destruction du repertoire existant et toute son arboressance pour faire place neuve
            if (erreur_AG = 1) | (erreur_AM = 1), result = launch(srmdir, spathmchineA_ramdisk), result = launch(smkdir, spathmchineA_ramdisk)      # execution d'une commande exterieur pour la creation du repertoire de la Machine A
            if (erreur_BG = 1) | (erreur_BM = 1), result = launch(srmdir, spathmchineB_ramdisk), result = launch(smkdir, spathmchineB_ramdisk)      # execution d'une commande exterieur pour la creation du repertoire de la Machine B
            if (erreur_CG = 1) | (erreur_CM = 1), result = launch(srmdir, spathmchineC_ramdisk), result = launch(smkdir, spathmchineC_ramdisk)      # execution d'une commande exterieur pour la creation du repertoire de la Machine C
            if (erreur_DG = 1) | (erreur_DM = 1), result = launch(srmdir, spathmchineD_ramdisk), result = launch(smkdir, spathmchineD_ramdisk)      # execution d'une commande exterieur pour la creation du repertoire de la Machine D
            subout$=1

#endregion
#region CHANGEMENT DE REPERTOIRE
pchange_AG   # attribution direction pour machine A
        snumligne = "AG"
        if prog_AG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir
                spathsub$ = spathmchineA_ramdisk   # attribution du repertoire 
                snamesub$ = snamenc$        # attribution du nom du fichier a ecrire
                sextsub$ = sextmachineA     # attribution de l'extention du fichier a ecrire
                subout$=1                   # on active l'ecriture dans le fichier Sub
                newsub$                     # on ouvre le fichier
                #if old_progno <> progno$,
                if ecrigeneral_AG = 0,
                        [
                        if (erreur_AG = 0) & (erreur_AM = 0),   [
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "       dans ",spathmchineA,  e$
                                                                subout$ = 1
                                                                ecrigeneral_AG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_AG = 1, subout$ = 3
pchange_BG   # attribution direction pour machine B    
        snumligne = "BG"
        if prog_BG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir 
                spathsub$ = spathmchineB_ramdisk    # attribution du repertoire 
                snamesub$ = snamenc$
                sextsub$ = sextmachineB
                subout$=1
                newsub$
                #if old_progno <> progno$,
                if ecrigeneral_BG = 0,
                        [
                        if (erreur_BG = 0) & (erreur_BM = 0),   [
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "       dans ",spathmchineB,  e$
                                                                subout$ = 1
                                                                ecrigeneral_BG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_BG = 1, subout$ = 3
pchange_CG   # attribution direction pour machine C
        snumligne = "CG"
        if prog_CG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir
                spathsub$ = spathmchineC_ramdisk
                snamesub$ = snamenc$
                sextsub$ = sextmachineC
                subout$=1
                newsub$
                #if old_progno <> progno$,
                if ecrigeneral_CG = 0,
                        [
                        if (erreur_CG = 0) & (erreur_CM = 0),   [
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "       dans ",spathmchineC,  e$
                                                                subout$ = 1
                                                                ecrigeneral_CG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_CG = 1, subout$ = 3
pchange_DG   # attribution direction pour machine D
        snumligne = "DG"
        if prog_DG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir
                spathsub$ = spathmchineD_ramdisk
                snamesub$ = snamenc$
                sextsub$ = sextmachineD
                subout$=1
                newsub$
                #if old_progno <> progno$,
                if ecrigeneral_DG = 0,
                        [
                        if (erreur_DG = 0) & (erreur_DM = 0),   [
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "       dans ",spathmchineD,  e$
                                                                subout$ = 1
                                                                ecrigeneral_DG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_DG = 1, subout$ = 3
pchange_AM   # attribution direction pour machine A
        snumligne = "AM"
        if prog_AM = 1,
                [
                subout$=0
                pnumprog_AM
                spathsub$ = spathmchineA_ramdisk   # attribution du repertoire 
                snamesub$ = snumprog + sunderscore + snamenc$       # attribution du nom du fichier a ecrire
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineA     # attribution de l'extention du fichier a ecrire
                subout$=1                   # on active l'ecriture dans le fichier Sub
                newsub$                     # on ouvre le fichier 
                if old_progno_AM <> numprg_concat_AM,
                        [
                        if (erreur_AG = 0) & (erreur_AM = 0),   [
                                                                clearsub$
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "    dans ",spathmchineA,  e$
                                                                subout$ = 1
                                                                old_progno_AM = numprg_concat_AM
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_AM = 1, subout$ = 3
pchange_BM   # attribution direction pour machine B
        snumligne = "BM"
        if prog_BM = 1,
                [
                subout$=0
                pnumprog_BM
                spathsub$ = spathmchineB_ramdisk    # attribution du repertoire
                snamesub$ = snumprog + sunderscore + snamenc$
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineB
                subout$=1
                newsub$
                if old_progno_BM <> numprg_concat_BM,
                        [
                        if (erreur_BG = 0) & (erreur_BM = 0),   [
                                                                clearsub$
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "    dans ",spathmchineB,  e$
                                                                subout$ = 1
                                                                old_progno_BM = numprg_concat_BM
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_BM = 1, subout$ = 3
pchange_CM   # attribution direction pour machine C
        snumligne = "CM"
        if prog_CM = 1,
                [
                subout$=0
                pnumprog_CM
                spathsub$ = spathmchineC_ramdisk
                snamesub$ = snumprog + sunderscore + snamenc$
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineC
                subout$=1
                newsub$
                if old_progno_CM <> numprg_concat_CM,
                        [
                        if (erreur_CG = 0) & (erreur_CM = 0),   [
                                                                clearsub$
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "    dans ",spathmchineC,  e$
                                                                subout$ = 1
                                                                old_progno_CM = numprg_concat_CM
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_CM = 1, subout$ = 3
pchange_DM   # attribution direction pour machine C
        snumligne = "DM"
        if prog_DM = 1,
                [
                subout$=0
                pnumprog_DM
                spathsub$ = spathmchineD_ramdisk
                snamesub$ = snumprog + sunderscore + snamenc$
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineD
                subout$=1
                newsub$
                if old_progno_DM <> numprg_concat_DM,
                        [
                        if (erreur_DG = 0) & (erreur_DM = 0),   [
                                                                clearsub$
                                                                subout$ = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                "- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "    dans ",spathmchineD,  e$
                                                                subout$ = 1
                                                                old_progno_DM = numprg_concat_DM
                                                                ]
                        ]
                ]
        else, subout$ = 3
		if plus_ecrire_DM = 1, subout$ = 3
#endregion
#region pgestion_prog
pgestion_prog

            if sprog_complet_AG = sprog_OK_AG, prog_AG = 1
            if sprog_complet_AG = sprog_NOK_AG, prog_AG = 0
            if sprog_complet_BG = sprog_OK_BG, prog_BG = 1
            if sprog_complet_BG = sprog_NOK_BG, prog_BG = 0
            if sprog_complet_CG = sprog_OK_CG, prog_CG = 1
            if sprog_complet_CG = sprog_NOK_CG, prog_CG = 0
            if sprog_complet_DG = sprog_OK_DG, prog_DG = 1
            if sprog_complet_DG = sprog_NOK_DG, prog_DG = 0
            if sprog_concat_AM = sprog_OK_AG, prog_AM = 1
            if sprog_concat_AM = sprog_NOK_AG, prog_AM = 0
            if sprog_concat_BM = sprog_OK_BG, prog_BM = 1
            if sprog_concat_BM = sprog_NOK_BG, prog_BM = 0
            if sprog_concat_CM = sprog_OK_CG, prog_CM = 1
            if sprog_concat_CM = sprog_NOK_CG, prog_CM = 0
            if sprog_concat_DM = sprog_OK_DG, prog_DM = 1
            if sprog_concat_DM = sprog_NOK_DG, prog_DM = 0

pgestion_valeur_C_CLOCHE_CG

                                if SCLOCHE_ACTIVE_CG = STRING_CLOCHE_ACTIVE_CG, [
                                                                                mini_c_CG = mini_c_avec_cloche_CG
                                                                                maxi_c_CG = maxi_c_avec_cloche_CG
                                                                                axeA_cloche_moins_CG = -60
                                                                                axeA_cloche_plus_CG = 60

                                                                                mini_c_CM = mini_c_avec_cloche_CM
                                                                                maxi_c_CM = maxi_c_avec_cloche_CM
                                                                                axeA_cloche_moins_CM = -60
                                                                                axeA_cloche_plus_CM = 60
                                                                                ]
                                if SCLOCHE_ACTIVE_CG = STRING_CLOCHE_DESACTIVE_CG,  [
                                                                                    mini_c_CG = mini_c_sans_cloche_CG
                                                                                    maxi_c_CG = maxi_c_sans_cloche_CG
                                                                                    axeA_cloche_moins_CG = -120.001
                                                                                    axeA_cloche_plus_CG = 120.001

                                                                                    mini_c_CM = mini_c_sans_cloche_CM
                                                                                    maxi_c_CM = maxi_c_sans_cloche_CM
                                                                                    axeA_cloche_moins_CM = -120.001
                                                                                    axeA_cloche_plus_CM = 120.001
                                                                                    ]
                                                                                #subout$ = 0
                                                                                #*mini_c_CG, e$
                                                                                #*maxi_c_CG, e$
                                                                                #*axeA_cloche_moins_CG, e$
                                                                                #*axeA_cloche_plus_CG, e$
                                                                                #" ", e$
                                                                                #*mini_c_CM, e$
                                                                                #*maxi_c_CM, e$
                                                                                #*axeA_cloche_moins_CM, e$
                                                                                #*axeA_cloche_plus_CM, e$                                   

pgestion_valeur_C_CLOCHE_DG

                                if SCLOCHE_ACTIVE_DG = STRING_CLOCHE_ACTIVE_DG, [
                                                                                mini_c_DG = mini_c_avec_cloche_DG
                                                                                maxi_c_DG = maxi_c_avec_cloche_DG
                                                                                axeA_cloche_moins_DG = -60
                                                                                axeA_cloche_plus_DG = 60

                                                                                mini_c_DM = mini_c_avec_cloche_DM
                                                                                maxi_c_DM = maxi_c_avec_cloche_DM
                                                                                axeA_cloche_moins_DM = -60
                                                                                axeA_cloche_plus_DM = 60
                                                                                ]
                                if SCLOCHE_ACTIVE_DG = STRING_CLOCHE_DESACTIVE_DG,  [
                                                                                    mini_c_DG = mini_c_sans_cloche_DG
                                                                                    maxi_c_DG = maxi_c_sans_cloche_DG
                                                                                    axeA_cloche_moins_DG = -120.001
                                                                                    axeA_cloche_plus_DG = 120.001

                                                                                    mini_c_DM = mini_c_sans_cloche_DM
                                                                                    maxi_c_DM = maxi_c_sans_cloche_DM
                                                                                    axeA_cloche_moins_DM = -120.001
                                                                                    axeA_cloche_plus_DM = 120.001
                                                                                    ]
                                                                                #subout$ = 0
                                                                                #*mini_c_DG, e$
                                                                                #*maxi_c_DG, e$
                                                                                #*axeA_cloche_moins_DG, e$
                                                                                #*axeA_cloche_plus_DG, e$
                                                                                #" ", e$
                                                                                #*mini_c_DM, e$
                                                                                #*maxi_c_DM, e$
                                                                                #*axeA_cloche_moins_DM, e$
                                                                                #*axeA_cloche_plus_DM, e$                                                                                       



#endregion
#region pnumprog

pnumprog_AM

                numprg_concat_AM = numprg_garage_AM + cont_mi10_AM
                snumprog = no2str(numprg_concat_AM)
                snumprog = "%" + snumprog
pnumprog_BM

                numprg_concat_BM = numprg_garage_BM + cont_mi10_BM
                snumprog = no2str(numprg_concat_BM)
                snumprog = "%" + snumprog
pnumprog_CM

                numprg_concat_CM = numprg_garage_CM + cont_mi10_CM
                snumprog = no2str(numprg_concat_CM)
                snumprog = "%" + snumprog
pnumprog_DM

                numprg_concat_DM = numprg_garage_DM + cont_mi10_DM
                snumprog = no2str(numprg_concat_DM)
                snumprog = "%" + snumprog
#endregion
#region pcont_garage
pcont_garage_AM
                if op_id$ <> prvop_id_AM,
                [
                numprg_garage_AM = progno$ * 10
                if numprg_garage_AM <> old_numprg_garage_AM, cont_mi10_AM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_AM = cont_mi10_AM + 1
                if numprg_garage_AM = old_numprg_garage_AM, [
                                                        if mi10$ = 0 & old_mi10_AM = 1, psortie_garage_AM
                                                        if mi10$ = 0 & old_mi10_AM = -1, psortie_garage_AM
                                                        ]
                if cont_mi10_AM >= 9, psortie_garage2_AM
                old_mi10_AM = mi10$
                ]
pcont_garage_BM
                if op_id$ <> prvop_id_BM,
                [
                numprg_garage_BM = progno$ * 10
                if numprg_garage_BM <> old_numprg_garage_BM, cont_mi10_BM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_BM = cont_mi10_BM + 1
                if numprg_garage_BM = old_numprg_garage_BM, [
                                                        if mi10$ = 0 & old_mi10_BM = 1, psortie_garage_BM
                                                        if mi10$ = 0 & old_mi10_BM = -1, psortie_garage_BM
                                                        ]
                if cont_mi10_BM >= 9, psortie_garage2_BM
                old_mi10_BM = mi10$
                ]
pcont_garage_CM
                if op_id$ <> prvop_id_CM,
                [
                numprg_garage_CM = progno$ * 10
                if numprg_garage_CM <> old_numprg_garage_CM, cont_mi10_CM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_CM = cont_mi10_CM + 1
                if numprg_garage_CM = old_numprg_garage_CM, [
                                                        if mi10$ = 0 & old_mi10_CM = 1, psortie_garage_CM
                                                        if mi10$ = 0 & old_mi10_CM = -1, psortie_garage_CM
                                                        ]
                if cont_mi10_CM >= 9, psortie_garage2_CM
                old_mi10_CM = mi10$
                ]
pcont_garage_DM
                if op_id$ <> prvop_id_DM,
                [
                numprg_garage_DM = progno$ * 10
                if numprg_garage_DM <> old_numprg_garage_DM, cont_mi10_DM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_DM = cont_mi10_DM + 1
                if numprg_garage_DM = old_numprg_garage_DM, [
                                                        if mi10$ = 0 & old_mi10_DM = 1, psortie_garage_DM
                                                        if mi10$ = 0 & old_mi10_DM = -1, psortie_garage_DM
                                                        ]
                if cont_mi10_DM >= 9, psortie_garage2_DM
                old_mi10_DM = mi10$
                ]
#endregion
#region pdecomposition_mi1

fmt "mi1_trans_AG " 17 mi1_trans_AG
fmt "mi1_mirro_AG " 17 mi1_mirro_AG
fmt "mi1_rotat_AG " 17 mi1_rotat_AG
fmt "mi1_trans_AM " 17 mi1_trans_AM
fmt "mi1_mirro_AM " 17 mi1_mirro_AM
fmt "mi1_rotat_AM " 17 mi1_rotat_AM

fmt "mi1_trans_BG " 17 mi1_trans_BG
fmt "mi1_mirro_BG " 17 mi1_mirro_BG
fmt "mi1_rotat_BG " 17 mi1_rotat_BG
fmt "mi1_trans_BM " 17 mi1_trans_BM
fmt "mi1_mirro_BM " 17 mi1_mirro_BM
fmt "mi1_rotat_BM " 17 mi1_rotat_BM

fmt "mi1_trans_CG " 17 mi1_trans_CG
fmt "mi1_mirro_CG " 17 mi1_mirro_CG
fmt "mi1_rotat_CG " 17 mi1_rotat_CG
fmt "mi1_trans_CM " 17 mi1_trans_CM
fmt "mi1_mirro_CM " 17 mi1_mirro_CM
fmt "mi1_rotat_CM " 17 mi1_rotat_CM

fmt "mi1_trans_CG " 17 mi1_trans_DG
fmt "mi1_mirro_CG " 17 mi1_mirro_DG
fmt "mi1_rotat_CG " 17 mi1_rotat_DG
fmt "mi1_trans_DM " 17 mi1_trans_DM
fmt "mi1_mirro_DM " 17 mi1_mirro_DM
fmt "mi1_rotat_DM " 17 mi1_rotat_DM

fmt "mi1_quot_1 " 17 mi1_quot_1
fmt "mi1_quot_2 " 17 mi1_quot_2
fmt "mi1_quot_3 " 17 mi1_quot_3
fmt "mi1_quot_4 " 17 mi1_quot_4
fmt "mi1_quot_5 " 17 mi1_quot_5
fmt "mi1_quot_6 " 17 mi1_quot_6
fmt "mi1_quot_7 " 17 mi1_quot_7
fmt "mi1_quot_8 " 17 mi1_quot_8
fmt "mi1_quot_9 " 17 mi1_quot_9
fmt "mi1_quot_10 " 17 mi1_quot_10
fmt "mi1_quot_11 " 17 mi1_quot_11
fmt "mi1_quot_12 " 17 mi1_quot_12

fmt "mi1_rest_quot_1 " 18 mi1_rest_quot_1
fmt "mi1_rest_quot_2 " 18 mi1_rest_quot_2
fmt "mi1_rest_quot_3 " 18 mi1_rest_quot_3
fmt "mi1_rest_quot_4 " 18 mi1_rest_quot_4
fmt "mi1_rest_quot_5 " 18 mi1_rest_quot_5
fmt "mi1_rest_quot_6 " 18 mi1_rest_quot_6
fmt "mi1_rest_quot_7 " 18 mi1_rest_quot_7
fmt "mi1_rest_quot_8 " 18 mi1_rest_quot_8
fmt "mi1_rest_quot_9 " 18 mi1_rest_quot_9
fmt "mi1_rest_quot_10 " 18 mi1_rest_quot_10
fmt "mi1_rest_quot_11 " 18 mi1_rest_quot_11
fmt "mi1_rest_quot_12 " 18 mi1_rest_quot_12

pdecomposition_mi1
                        if mi1$ < 0, psortie_mi1
                        mi1_quot_1 = mi1$ / 3
                        mi1_rest_quot_1 = frac(mi1_quot_1) * 10
                        mi1_quot_1 = int(mi1_quot_1)
                        mi1_quot_2 = mi1_quot_1 / 3
                        mi1_rest_quot_2 = frac(mi1_quot_2) * 10
                        mi1_quot_2 = int(mi1_quot_2)
                        mi1_quot_3 = mi1_quot_2 / 3
                        mi1_rest_quot_3 = frac(mi1_quot_3) * 10
                        mi1_quot_3 = int(mi1_quot_3)
                        mi1_quot_4 = mi1_quot_3 / 3
                        mi1_rest_quot_4 = frac(mi1_quot_4) * 10
                        mi1_quot_4 = int(mi1_quot_4)
                        mi1_quot_5 = mi1_quot_4 / 3
                        mi1_rest_quot_5 = frac(mi1_quot_5) * 10
                        mi1_quot_5 = int(mi1_quot_5)
                        mi1_quot_6 = mi1_quot_5 / 3
                        mi1_rest_quot_6 = frac(mi1_quot_6) * 10
                        mi1_quot_6 = int(mi1_quot_6)
                        mi1_quot_7 = mi1_quot_6 / 3
                        mi1_rest_quot_7 = frac(mi1_quot_7) * 10
                        mi1_quot_7 = int(mi1_quot_7)
                        mi1_quot_8 = mi1_quot_7 / 3
                        mi1_rest_quot_8 = frac(mi1_quot_8) * 10
                        mi1_quot_8 = int(mi1_quot_8)
                        mi1_quot_9 = mi1_quot_8 / 3
                        mi1_rest_quot_9 = frac(mi1_quot_9) * 10
                        mi1_quot_9 = int(mi1_quot_9)
                        mi1_quot_10 = mi1_quot_9 / 3
                        mi1_rest_quot_10 = frac(mi1_quot_10) * 10
                        mi1_quot_10 = int(mi1_quot_10)
                        mi1_quot_11 = mi1_quot_10 / 3
                        mi1_rest_quot_11 = frac(mi1_quot_11) * 10
                        mi1_quot_11 = int(mi1_quot_11)
                        mi1_quot_12 = mi1_quot_11 / 3
                        mi1_rest_quot_12 = frac(mi1_quot_12) * 10
                        mi1_quot_12 = int(mi1_quot_12)

                        mi1_rest_quot_1 = int(mi1_rest_quot_1)
                        mi1_rest_quot_2 = int(mi1_rest_quot_2)
                        mi1_rest_quot_3 = int(mi1_rest_quot_3)
                        mi1_rest_quot_4 = int(mi1_rest_quot_4)
                        mi1_rest_quot_5 = int(mi1_rest_quot_5)
                        mi1_rest_quot_6 = int(mi1_rest_quot_6)
                        mi1_rest_quot_7 = int(mi1_rest_quot_7)
                        mi1_rest_quot_8 = int(mi1_rest_quot_8)
                        mi1_rest_quot_9 = int(mi1_rest_quot_9)
                        mi1_rest_quot_10 = int(mi1_rest_quot_10)
                        mi1_rest_quot_11 = int(mi1_rest_quot_11)
                        mi1_rest_quot_12 = int(mi1_rest_quot_12)

                        mi1_trans_AG = mi1_rest_quot_1 / 3
                        mi1_trans_AG = int(mi1_trans_AG)
                        mi1_trans_AM = mi1_trans_AG

                        mi1_mirro_AG = mi1_rest_quot_2 / 3
                        mi1_mirro_AG = int(mi1_mirro_AG)
                        mi1_mirro_AM = mi1_mirro_AG

                        mi1_rotat_AG = mi1_rest_quot_3 / 3
                        mi1_rotat_AG = int(mi1_rotat_AG)
                        mi1_rotat_AM = mi1_rotat_AG

                        mi1_trans_BG = mi1_rest_quot_4 / 3
                        mi1_trans_BG = int(mi1_trans_BG)
                        mi1_trans_BM = mi1_trans_BG

                        mi1_mirro_BG = mi1_rest_quot_5 / 3
                        mi1_mirro_BG = int(mi1_mirro_BG)
                        mi1_mirro_BM = mi1_mirro_BG

                        mi1_rotat_BG = mi1_rest_quot_6 / 3
                        mi1_rotat_BG = int(mi1_rotat_BG)
                        mi1_rotat_BM = mi1_rotat_BG

                        mi1_trans_CG = mi1_rest_quot_7 / 3
                        mi1_trans_CG = int(mi1_trans_CG)
                        mi1_trans_CM = mi1_trans_CG

                        mi1_mirro_CG = mi1_rest_quot_8 / 3
                        mi1_mirro_CG = int(mi1_mirro_CG)
                        mi1_mirro_CM = mi1_mirro_CG

                        mi1_rotat_CG = mi1_rest_quot_9 / 3
                        mi1_rotat_CG = int(mi1_rotat_CG)
                        mi1_rotat_CM = mi1_rotat_CG

                        mi1_trans_DG = mi1_rest_quot_10 / 3
                        mi1_trans_DG = int(mi1_trans_DG)
                        mi1_trans_DM = mi1_trans_DG

                        mi1_mirro_DG = mi1_rest_quot_11 / 3
                        mi1_mirro_DG = int(mi1_mirro_DG)
                        mi1_mirro_DM = mi1_mirro_DG

                        mi1_rotat_DG = mi1_rest_quot_12 / 3
                        mi1_rotat_DG = int(mi1_rotat_DG)
                        mi1_rotat_DM = mi1_rotat_DG

                        #"voir", e$
                        #*mi1_quot_1, *mi1_rest_quot_1, *mi1_trans_AG, e$
                        #*mi1_quot_2, *mi1_rest_quot_2, *mi1_mirro_AG, e$
                        #*mi1_quot_3, *mi1_rest_quot_3, *mi1_rotat_AG, e$
                        #*mi1_quot_4, *mi1_rest_quot_4, *mi1_trans_BG, e$
                        #*mi1_quot_5, *mi1_rest_quot_5, *mi1_mirro_BG, e$
                        #*mi1_quot_6, *mi1_rest_quot_6, *mi1_rotat_BG, e$
                        #*mi1_quot_7, *mi1_rest_quot_7, *mi1_trans_CG, e$
                        #*mi1_quot_8, *mi1_rest_quot_8, *mi1_mirro_CG, e$
                        #*mi1_quot_9, *mi1_rest_quot_9, *mi1_rotat_CG, e$
                        #" ", e$
                        #*mi1_trans_AM, e$
                        #*mi1_mirro_AM, e$
                        #*mi1_rotat_AM, e$
                        #*mi1_trans_BM, e$
                        #*mi1_mirro_BM, e$
                        #*mi1_rotat_BM, e$
                        #*mi1_trans_CM, e$
                        #*mi1_mirro_CM, e$
                        #*mi1_rotat_CM, e$
#endregion
#region pdecomposition_mi2

fmt "mi2_trans_AG " 17 mi2_trans_AG
fmt "mi2_mirro_AG " 17 mi2_mirro_AG
fmt "mi2_rotat_AG " 17 mi2_rotat_AG
fmt "mi2_trans_AM " 17 mi2_trans_AM
fmt "mi2_mirro_AM " 17 mi2_mirro_AM
fmt "mi2_rotat_AM " 17 mi2_rotat_AM

fmt "mi2_trans_BG " 17 mi2_trans_BG
fmt "mi2_mirro_BG " 17 mi2_mirro_BG
fmt "mi2_rotat_BG " 17 mi2_rotat_BG
fmt "mi2_trans_BM " 17 mi2_trans_BM
fmt "mi2_mirro_BM " 17 mi2_mirro_BM
fmt "mi2_rotat_BM " 17 mi2_rotat_BM

fmt "mi2_trans_CG " 17 mi2_trans_CG
fmt "mi2_mirro_CG " 17 mi2_mirro_CG
fmt "mi2_rotat_CG " 17 mi2_rotat_CG
fmt "mi2_trans_CM " 17 mi2_trans_CM
fmt "mi2_mirro_CM " 17 mi2_mirro_CM
fmt "mi2_rotat_CM " 17 mi2_rotat_CM

fmt "mi2_trans_CG " 17 mi2_trans_DG
fmt "mi2_mirro_CG " 17 mi2_mirro_DG
fmt "mi2_rotat_CG " 17 mi2_rotat_DG
fmt "mi2_trans_CM " 17 mi2_trans_DM
fmt "mi2_mirro_CM " 17 mi2_mirro_DM
fmt "mi2_rotat_CM " 17 mi2_rotat_DM

fmt "mi2_quot_1 " 17 mi2_quot_1
fmt "mi2_quot_2 " 17 mi2_quot_2
fmt "mi2_quot_3 " 17 mi2_quot_3
fmt "mi2_quot_4 " 17 mi2_quot_4
fmt "mi2_quot_5 " 17 mi2_quot_5
fmt "mi2_quot_6 " 17 mi2_quot_6
fmt "mi2_quot_7 " 17 mi2_quot_7
fmt "mi2_quot_8 " 17 mi2_quot_8
fmt "mi2_quot_9 " 17 mi2_quot_9
fmt "mi2_quot_10 " 17 mi2_quot_10
fmt "mi2_quot_11 " 17 mi2_quot_11
fmt "mi2_quot_12 " 17 mi2_quot_12

fmt "mi2_rest_quot_1 " 18 mi2_rest_quot_1
fmt "mi2_rest_quot_2 " 18 mi2_rest_quot_2
fmt "mi2_rest_quot_3 " 18 mi2_rest_quot_3
fmt "mi2_rest_quot_4 " 18 mi2_rest_quot_4
fmt "mi2_rest_quot_5 " 18 mi2_rest_quot_5
fmt "mi2_rest_quot_6 " 18 mi2_rest_quot_6
fmt "mi2_rest_quot_7 " 18 mi2_rest_quot_7
fmt "mi2_rest_quot_8 " 18 mi2_rest_quot_8
fmt "mi2_rest_quot_9 " 18 mi2_rest_quot_9
fmt "mi2_rest_quot_10 " 18 mi2_rest_quot_10
fmt "mi2_rest_quot_11 " 18 mi2_rest_quot_11
fmt "mi2_rest_quot_12 " 18 mi2_rest_quot_12
pdecomposition_mi2
                        if mi2$ < 0, psortie_mi2
                        mi2_quot_1 = mi2$ / 3
                        mi2_rest_quot_1 = frac(mi2_quot_1) * 10
                        mi2_quot_1 = int(mi2_quot_1)
                        mi2_quot_2 = mi2_quot_1 / 3
                        mi2_rest_quot_2 = frac(mi2_quot_2) * 10
                        mi2_quot_2 = int(mi2_quot_2)
                        mi2_quot_3 = mi2_quot_2 / 3
                        mi2_rest_quot_3 = frac(mi2_quot_3) * 10
                        mi2_quot_3 = int(mi2_quot_3)
                        mi2_quot_4 = mi2_quot_3 / 3
                        mi2_rest_quot_4 = frac(mi2_quot_4) * 10
                        mi2_quot_4 = int(mi2_quot_4)
                        mi2_quot_5 = mi2_quot_4 / 3
                        mi2_rest_quot_5 = frac(mi2_quot_5) * 10
                        mi2_quot_5 = int(mi2_quot_5)
                        mi2_quot_6 = mi2_quot_5 / 3
                        mi2_rest_quot_6 = frac(mi2_quot_6) * 10
                        mi2_quot_6 = int(mi2_quot_6)
                        mi2_quot_7 = mi2_quot_6 / 3
                        mi2_rest_quot_7 = frac(mi2_quot_7) * 10
                        mi2_quot_7 = int(mi2_quot_7)
                        mi2_quot_8 = mi2_quot_7 / 3
                        mi2_rest_quot_8 = frac(mi2_quot_8) * 10
                        mi2_quot_8 = int(mi2_quot_8)
                        mi2_quot_9 = mi2_quot_8 / 3
                        mi2_rest_quot_9 = frac(mi2_quot_9) * 10
                        mi2_quot_9 = int(mi2_quot_9)
                        mi2_quot_10 = mi2_quot_9 / 3
                        mi2_rest_quot_10 = frac(mi2_quot_10) * 10
                        mi2_quot_10 = int(mi2_quot_10)
                        mi2_quot_11 = mi2_quot_10 / 3
                        mi2_rest_quot_11 = frac(mi2_quot_11) * 10
                        mi2_quot_11 = int(mi2_quot_11)
                        mi2_quot_12 = mi2_quot_11 / 3
                        mi2_rest_quot_12 = frac(mi2_quot_12) * 10
                        mi2_quot_12 = int(mi2_quot_12)

                        mi2_rest_quot_1 = int(mi2_rest_quot_1)
                        mi2_rest_quot_2 = int(mi2_rest_quot_2)
                        mi2_rest_quot_3 = int(mi2_rest_quot_3)
                        mi2_rest_quot_4 = int(mi2_rest_quot_4)
                        mi2_rest_quot_5 = int(mi2_rest_quot_5)
                        mi2_rest_quot_6 = int(mi2_rest_quot_6)
                        mi2_rest_quot_7 = int(mi2_rest_quot_7)
                        mi2_rest_quot_8 = int(mi2_rest_quot_8)
                        mi2_rest_quot_9 = int(mi2_rest_quot_9)
                        mi2_rest_quot_10 = int(mi2_rest_quot_10)
                        mi2_rest_quot_11 = int(mi2_rest_quot_11)
                        mi2_rest_quot_12 = int(mi2_rest_quot_12)

                        mi2_trans_AG = mi2_rest_quot_1 / 3
                        mi2_trans_AG = int(mi2_trans_AG)
                        mi2_trans_AM = mi2_trans_AG

                        mi2_mirro_AG = mi2_rest_quot_2 / 3
                        mi2_mirro_AG = int(mi2_mirro_AG)
                        mi2_mirro_AM = mi2_mirro_AG

                        mi2_rotat_AG = mi2_rest_quot_3 / 3
                        mi2_rotat_AG = int(mi2_rotat_AG)
                        mi2_rotat_AM = mi2_rotat_AG

                        mi2_trans_BG = mi2_rest_quot_4 / 3
                        mi2_trans_BG = int(mi2_trans_BG)
                        mi2_trans_BM = mi2_trans_BG

                        mi2_mirro_BG = mi2_rest_quot_5 / 3
                        mi2_mirro_BG = int(mi2_mirro_BG)
                        mi2_mirro_BM = mi2_mirro_BG

                        mi2_rotat_BG = mi2_rest_quot_6 / 3
                        mi2_rotat_BG = int(mi2_rotat_BG)
                        mi2_rotat_BM = mi2_rotat_BG

                        mi2_trans_CG = mi2_rest_quot_7 / 3
                        mi2_trans_CG = int(mi2_trans_CG)
                        mi2_trans_CM = mi2_trans_CG

                        mi2_mirro_CG = mi2_rest_quot_8 / 3
                        mi2_mirro_CG = int(mi2_mirro_CG)
                        mi2_mirro_CM = mi2_mirro_CG

                        mi2_rotat_CG = mi2_rest_quot_9 / 3
                        mi2_rotat_CG = int(mi2_rotat_CG)
                        mi2_rotat_CM = mi2_rotat_CG

                        mi2_trans_DG = mi2_rest_quot_10 / 3
                        mi2_trans_DG = int(mi2_trans_DG)
                        mi2_trans_DM = mi2_trans_DG

                        mi2_mirro_DG = mi2_rest_quot_11 / 3
                        mi2_mirro_DG = int(mi2_mirro_DG)
                        mi2_mirro_DM = mi2_mirro_DG

                        mi2_rotat_DG = mi2_rest_quot_12 / 3
                        mi2_rotat_DG = int(mi2_rotat_DG)
                        mi2_rotat_DM = mi2_rotat_DG

                        #"voir", e$
                        #*mi2_quot_1, *mi2_rest_quot_1, *mi2_trans_AG, e$
                        #*mi2_quot_2, *mi2_rest_quot_2, *mi2_mirro_AG, e$
                        #*mi2_quot_3, *mi2_rest_quot_3, *mi2_rotat_AG, e$
                        #*mi2_quot_4, *mi2_rest_quot_4, *mi2_trans_BG, e$
                        #*mi2_quot_5, *mi2_rest_quot_5, *mi2_mirro_BG, e$
                        #*mi2_quot_6, *mi2_rest_quot_6, *mi2_rotat_BG, e$
                        #*mi2_quot_7, *mi2_rest_quot_7, *mi2_trans_CG, e$
                        #*mi2_quot_8, *mi2_rest_quot_8, *mi2_mirro_CG, e$
                        #*mi2_quot_9, *mi2_rest_quot_9, *mi2_rotat_CG, e$
                        #" ", e$
                        #*mi2_trans_AM, e$
                        #*mi2_mirro_AM, e$
                        #*mi2_rotat_AM, e$
                        #*mi2_trans_BM, e$
                        #*mi2_mirro_BM, e$
                        #*mi2_rotat_BM, e$
                        #*mi2_trans_CM, e$
                        #*mi2_mirro_CM, e$
                        #*mi2_rotat_CM, e$
#endregion
#region pdecomposition_mi4
pdecomposition_mi4    # sortie des parties d'une chaine numerique
            if (mi4$ < 1000) & (mi4$ <> 0), [
                                            if mi4$ < 1000,  [
                                                            smi4_str=no2str(mi4$)
                                                            paquet_mi4 = 3
                                                            smi4_str_AG = brksps(paquet_mi4,smi4_str)
                                                            paquet_mi4 = 2
                                                            smi4_str_BG = brksps(paquet_mi4,smi4_str)
                                                            smi4_str_CG = smi4_str
                                                            smi4_str_DG = "0"
                                                            mi4_AG = plcval(smi4_str_AG,1)
                                                            mi4_BG = plcval(smi4_str_BG,1)
                                                            mi4_CG = plcval(smi4_str_CG,1)
                                                            mi4_DG = plcval(smi4_str_DG,1)
                                                            mi4_AM = plcval(smi4_str_AG,1)
                                                            mi4_BM = plcval(smi4_str_BG,1)
                                                            mi4_CM = plcval(smi4_str_CG,1)
                                                            mi4_DM = plcval(smi4_str_DG,1)
                                                            ]
                                            if mi4$ < 100,  [
                                                            smi4_str=no2str(mi4$)
                                                            paquet_mi4 = 2
                                                            smi4_str_AG = brksps(paquet_mi4,smi4_str)
                                                            smi4_str_BG = smi4_str
                                                            smi4_str_CG = "0"
                                                            smi4_str_DG = "0"
                                                            mi4_AG = plcval(smi4_str_AG,1)
                                                            mi4_BG = plcval(smi4_str_BG,1)
                                                            mi4_CG = plcval(smi4_str_CG,1)
                                                            mi4_DG = plcval(smi4_str_DG,1)
                                                            mi4_AM = plcval(smi4_str_AG,1)
                                                            mi4_BM = plcval(smi4_str_BG,1)
                                                            mi4_CM = plcval(smi4_str_CG,1)
                                                            mi4_DM = plcval(smi4_str_DG,1)
                                                            ]
                                            if mi4$ < 10,   [
                                                            smi4_str=no2str(mi4$)
                                                            paquet_mi4 = 1
                                                            smi4_str_AG = smi4_str
                                                            smi4_str_BG = "0"
                                                            smi4_str_CG = "0"
                                                            smi4_str_DG = "0"
                                                            mi4_AG = plcval(smi4_str_AG,1)
                                                            mi4_BG = plcval(smi4_str_BG,1)
                                                            mi4_CG = plcval(smi4_str_CG,1)
                                                            mi4_DG = plcval(smi4_str_DG,1)
                                                            mi4_AM = plcval(smi4_str_AG,1)
                                                            mi4_BM = plcval(smi4_str_BG,1)
                                                            mi4_CM = plcval(smi4_str_CG,1)
                                                            mi4_DM = plcval(smi4_str_DG,1)
                                                            ]

                                            ]

                    else,   [
                            smi4_str=no2str(mi4$)
                            paquet_mi4 = 4
                            smi4_str_AG = brksps(paquet_mi4,smi4_str)
                            paquet_mi4 = 3
                            smi4_str_BG = brksps(paquet_mi4,smi4_str)
                            paquet_mi4 = 2
                            smi4_str_CG = brksps(paquet_mi4,smi4_str)
                            smi4_str_DG = smi4_str
                            mi4_AG = plcval(smi4_str_AG,1)
                            mi4_BG = plcval(smi4_str_BG,1)
                            mi4_CG = plcval(smi4_str_CG,1)
                            mi4_DG = plcval(smi4_str_DG,1)
                            mi4_AM = plcval(smi4_str_AG,1)
                            mi4_BM = plcval(smi4_str_BG,1)
                            mi4_CM = plcval(smi4_str_CG,1)
                            mi4_DM = plcval(smi4_str_DG,1)
                            ]

                    if mi4$ = 0,    [
                                    mi4_AG = 0
                                    mi4_BG = 0
                                    mi4_CG = 0
                                    mi4_DG = 0
                                    mi4_AM = 0
                                    mi4_BM = 0
                                    mi4_CM = 0
                                    mi4_DM = 0
                                    ]
                    #"voir smi4_str_AG ",  *smi4_str_AG, " voir smi4_str_BG ",  *smi4_str_BG, " voir smi4_str_CG ", *smi4_str_CG, e$
                    #"mi4_AG ",  *mi4_AG, " mi4_BG ",  *mi4_BG, " mi4_CG ", *mi4_CG, e$
                    if mi5_BG = 1,  [
                                    if mi4_BG = 1, mi4_BG = 11
                                    if mi4_BG = 2, mi4_BG = 12
                                    if mi4_BG = 3, mi4_BG = 13
                                    if mi4_BG = 4, mi4_BG = 14
                                    if mi4_BG = 5, mi4_BG = 21
                                    if mi4_BG = 6, mi4_BG = 22
                                    if mi4_BG = 7, mi4_BG = 23
                                    if mi4_BG = 8, mi4_BG = 24
                                    ]
                    if mi5_CG = 1,  [
                                    if mi4_CG = 1, mi4_CG = 11
                                    if mi4_CG = 2, mi4_CG = 12
                                    if mi4_CG = 3, mi4_CG = 13
                                    if mi4_CG = 4, mi4_CG = 14
                                    if mi4_CG = 5, mi4_CG = 21
                                    if mi4_CG = 6, mi4_CG = 22
                                    if mi4_CG = 7, mi4_CG = 23
                                    if mi4_CG = 8, mi4_CG = 24
                                    ]
                    if mi5_DG = 1,  [
                                    if mi4_DG = 1, mi4_DG = 11
                                    if mi4_DG = 2, mi4_DG = 12
                                    if mi4_DG = 3, mi4_DG = 13
                                    if mi4_DG = 4, mi4_DG = 14
                                    if mi4_DG = 5, mi4_DG = 21
                                    if mi4_DG = 6, mi4_DG = 22
                                    if mi4_DG = 7, mi4_DG = 23
                                    if mi4_DG = 8, mi4_DG = 24
                                    ]
                    if mi5_BM = 1,  [
                                    if mi4_BM = 1, mi4_BM = 11
                                    if mi4_BM = 2, mi4_BM = 12
                                    if mi4_BM = 3, mi4_BM = 13
                                    if mi4_BM = 4, mi4_BM = 14
                                    if mi4_BM = 5, mi4_BM = 21
                                    if mi4_BM = 6, mi4_BM = 22
                                    if mi4_BM = 7, mi4_BM = 23
                                    if mi4_BM = 8, mi4_BM = 24
                                    ]
                    if mi5_CM = 1,  [
                                    if mi4_CM = 1, mi4_CM = 11
                                    if mi4_CM = 2, mi4_CM = 12
                                    if mi4_CM = 3, mi4_CM = 13
                                    if mi4_CM = 4, mi4_CM = 14
                                    if mi4_CM = 5, mi4_CM = 21
                                    if mi4_CM = 6, mi4_CM = 22
                                    if mi4_CM = 7, mi4_CM = 23
                                    if mi4_CM = 8, mi4_CM = 24
                                    ]
                    if mi5_DM = 1,  [
                                    if mi4_DM = 1, mi4_DM = 11
                                    if mi4_DM = 2, mi4_DM = 12
                                    if mi4_DM = 3, mi4_DM = 13
                                    if mi4_DM = 4, mi4_DM = 14
                                    if mi4_DM = 5, mi4_DM = 21
                                    if mi4_DM = 6, mi4_DM = 22
                                    if mi4_DM = 7, mi4_DM = 23
                                    if mi4_DM = 8, mi4_DM = 24
                                    ]
#endregion
#region pdecomposition_mi5
pdecomposition_mi5    # sortie des parties d'une chaine numerique
                    smi5_str=no2str(mi5$)
                    paquet_mi5 = 4
                    smi5_str_AG = brksps(paquet_mi5,smi5_str)
                    paquet_mi5 = 3
                    smi5_str_BG = brksps(paquet_mi5,smi5_str)
                    paquet_mi5 = 2
                    smi5_str_CG = brksps(paquet_mi5,smi5_str)
                    smi5_str_DG = smi5_str
                    mi5_AG = plcval(smi5_str_AG,1)
                    mi5_BG = plcval(smi5_str_BG,1)
                    mi5_CG = plcval(smi5_str_CG,1)
                    mi5_DG = plcval(smi5_str_DG,1)
                    mi5_AM = plcval(smi5_str_AG,1)
                    mi5_BM = plcval(smi5_str_BG,1)
                    mi5_CM = plcval(smi5_str_CG,1)
                    mi5_DM = plcval(smi5_str_DG,1)
                    #"voir smi5_str_AG ",  *smi5_str_AG, " voir smi5_str_BG ",  *smi5_str_BG, " voir smi5_str_CG ", *smi5_str_CG, e$
                    #"mi5_AG ",  *mi5_AG, " mi5_BG ",  *mi5_BG, " mi5_CG ", *mi5_CG, e$
#endregion
#region pdecomposition_mi8
pdecomposition_mi8    # sortie des parties d'une chaine numerique
                    smi8_str=no2str(mi8$)
                    paquet_mi8 = 4
                    smi8_str_AG = brksps(paquet_mi8,smi8_str)
                    paquet_mi8 = 3
                    smi8_str_BG = brksps(paquet_mi8,smi8_str)
                    paquet_mi8 = 2
                    smi8_str_CG = brksps(paquet_mi8,smi8_str)
                    smi8_str_DG = smi8_str
                    mi8_AG = plcval(smi8_str_AG,1)
                    mi8_BG = plcval(smi8_str_BG,1)
                    mi8_CG = plcval(smi8_str_CG,1)
                    mi8_DG = plcval(smi8_str_DG,1)
                    mi8_AM = plcval(smi8_str_AG,1)
                    mi8_BM = plcval(smi8_str_BG,1)
                    mi8_CM = plcval(smi8_str_CG,1)
                    mi8_DM = plcval(smi8_str_DG,1)
                    #"voir smi8_str_AG ",  *smi8_str_AG, " voir smi8_str_BG ",  *smi8_str_BG, " voir smi8_str_CG ", *smi8_str_CG, e$
                    #"mi8_AG ",  *mi8_AG, " mi8_BG ",  *mi8_BG, " mi8_CG ", *mi8_CG, e$
#endregion
#region pnumligne

fmt  "N" 4 n_AG
fmt  "N" 4 n_BG
fmt  "N" 4 n_CG
fmt  "N" 4 n_DG
fmt  "N" 4 n_AM
fmt  "N" 4 n_BM
fmt  "N" 4 n_CM
fmt  "N" 4 n_DM
n_AG : 0
n_BG : 0
n_CG : 0
n_DG : 0
n_AM : 0
n_BM : 0
n_CM : 0
n_DM : 0

pnumligne
        if snumligne = "AG",    [
                                !seqmax$
                                if n_AG = seqmax$, n_AG = 0
                                n_AG = n_AG + 5, `n_AG
                                ]
        if snumligne = "BG", n_BG = n_BG + 5, `n_BG
        if snumligne = "CG", n_CG = n_CG + 5, `n_CG
        if snumligne = "DG", n_DG = n_DG + 5, `n_DG
        if snumligne = "AM",    [
                                !seqmax$
                                if n_AM = seqmax$, n_AM = 0
                                n_AM = n_AM + 5, `n_AM
                                ]
        if snumligne = "BM", n_BM = n_BM + 5, `n_BM
        if snumligne = "CM", n_CM = n_CM + 5, `n_CM
        if snumligne = "DM", n_DM = n_DM + 5, `n_DM
#endregion
#endregion

#region   ERREURS #OK
#region   Strings erreur
serreur_visu_descripteur : "ATTENTION ARRET POST-PRO : Soit la case (sortir descripteur de fichier MCX) est décochée, soit le fichier programme ne contient pas de descripteur d'usinage !!!"
serreur_visu_descripteur_erreur : "ATTENTION ARRET POST-PRO : Le descripteur est une ancienne version, il convient de le remplacer et insérer le numéro de programme dans la case MR1 des valeurs optionnelles !!!"
serreur_visu_descripteur_erreur2 : "ATTENTION ARRET POST-PRO : Le descripteur ne contient pas le nombre de lignes requises, vérifier si il a été copié correctement."
serreur_visu_transformation : "ATTENTION ARRET POST-PRO : La case (sous programmme, absolu) dans l'opération de transformation est décochée !!!"
serreur_mi1 : "ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle C ne doit pas etre inférieure à 0 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur_mi2 : "ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle A ou B ne doit pas etre inférieure à 0 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreurtest_outil : "ATTENTION ARRET POST-PRO : La case (Code outil du fournisseur) doit être remplie - Opération n°"
serreurplan5X : "ATTENTION ARRET POST-PRO : Les plans de construtions et d'usinages autres que le plan de dessus à 0,0,0 en usinage 5X sont interdits - Opération n°"

serreur_visu_general : ""
#region erreurs AG
serreur_dec_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : Valeurs des décalages égales à 0 dans le descripteur, êtes vous sûr de vouloir continuer?"
serreur_delta_rot_C_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_num_prog_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Numéro de programme incorrect dans les valeurs optionnelles !!! Il doit être compris entre 1 et 8999 "
serreur_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_AG  : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_AG  : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_AG  : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_AG  : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_AG   : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_AG   : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_AG : ""
#endregion
#region erreurs BG
serreur_dec_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : Valeurs des décalages égales à 0 dans le descripteur, êtes vous sûr de vouloir continuer?"
serreur_delta_rot_C_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_BG  : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_BG  : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_BG  : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_BG  : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_BG   : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_BG   : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_BG : ""
#endregion
#region erreurs CG
serreur_dec_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : Valeurs des décalages égales à 0 dans le descripteur, êtes vous sûr de vouloir continuer?"
serreur_delta_rot_C_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_CG  : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_CG  : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_CG  : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_CG  : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_CG   : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_CG   : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_CG : ""
#endregion
#region erreurs DG
serreur_dec_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION : Valeurs des décalages égales à 0 dans le descripteur, êtes vous sûr de vouloir continuer?"
serreur_delta_rot_C_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_DG  : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_DG  : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_DG  : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_DG  : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_DG   : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_DG   : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_DG : ""
#endregion
#region erreurs AM
serreur_delta_rot_C_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_AM  : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_AM  : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_AM  : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_AM  : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_AM   : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_AM   : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_AM : ""
#endregion
#region erreurs BM
serreur_delta_rot_C_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_BM  : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_BM  : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_BM  : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_BM  : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_BM   : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_BM   : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_BM : ""
#endregion
#region erreurs CM
serreur_delta_rot_C_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_CM  : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_CM  : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_CM  : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_CM  : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_CM   : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_CM   : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_CM : ""
#endregion
#region erreurs DM
serreur_delta_rot_C_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_DM  : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_DM  : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_DM  : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_DM  : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_DM   : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_DM   : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_DM : ""
#endregion
#endregion
#region   pbloc sortie
fmt 2 plus_ecrire_AG
fmt 2 plus_ecrire_BG
fmt 2 plus_ecrire_CG
fmt 2 plus_ecrire_DG
fmt 2 plus_ecrire_AM
fmt 2 plus_ecrire_BM
fmt 2 plus_ecrire_CM
fmt 2 plus_ecrire_DM
plus_ecrire_AG : 0
plus_ecrire_BG : 0
plus_ecrire_CG : 0
plus_ecrire_DG : 0
plus_ecrire_AM : 0
plus_ecrire_BM : 0
plus_ecrire_CM : 0
plus_ecrire_DM : 0
psortieplan5X
            numop_AG = numop_AG + 1
            serreur_visu_general = serreurplan5X + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner

psortietest_outil

            serreur_visu_general = serreurtest_outil + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner

######################################################
psortie_axeC_5X_AG

            if prog_AG = 1 & erreur_AG <> 1,    [
            serreur_visu_AG = serreur_delta_rot_C_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_BG

            if prog_BG = 1 & erreur_BG <> 1,    [
            serreur_visu_BG = serreur_delta_rot_C_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_CG

            if prog_CG = 1 & erreur_CG <> 1,    [
            serreur_visu_CG = serreur_delta_rot_C_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner  
                            ]

######################################################
psortie_axeC_5X_DG

            if prog_DG = 1 & erreur_DG <> 1,    [
            serreur_visu_DG = serreur_delta_rot_C_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_AM

            if prog_AM = 1 & erreur_AM <> 1,    [
            serreur_visu_AM = serreur_delta_rot_C_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_BM

            if prog_BM = 1 & erreur_BM <> 1,    [
            serreur_visu_BM = serreur_delta_rot_C_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_CM

            if prog_CM = 1 & erreur_CM <> 1,    [
            serreur_visu_CM = serreur_delta_rot_C_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner  
                            ]
######################################################
psortie_axeC_5X_DM

            if prog_DM = 1 & erreur_DM <> 1,    [
            serreur_visu_DM = serreur_delta_rot_C_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner  
                            ]
######################################################                          
psortie_ratrap_enroul_AG

            if prog_AG = 1 | prog_AM = 1,   [
            senroul_AG = senroul_aff_AG + slettreC + no2str(axeC_AG) + space + slettreA + no2str(axeA_AG) + space + sopration + no2str(numop_AG)
            subout$ = 4
            *senroul_AG, e$
            result = mprint(senroul_AG)
            subout$ = 3
			pchange_AG
			*senroul_AG, e$
			plus_ecrire_AG = 1
            #erreur_AG = 1, erreur_AM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_enroul_AM

            if prog_AG = 1 | prog_AM = 1,   [
            senroul_AG = senroul_aff_AG + slettreC + no2str(axeC_AM) + space + slettreA + no2str(axeA_AM) + space + sopration + no2str(numop_AG)
            subout$ = 4
            #*senroul_AG, e$
            #result = mprint(senroul_AG)
            subout$ = 3
			pchange_AM
			*senroul_AG, e$
			plus_ecrire_AM = 1
            #erreur_AG = 1, erreur_AM = 1 #, exitpost$ # abandonner
											]
###################################################### 
psortie_ratrap_enroul_BG

            if prog_BG = 1 | prog_BM = 1,   [
            senroul_BG = senroul_aff_BG + slettreC + no2str(axeC_BG) + space + slettreA + no2str(axeA_BG) + space + sopration + no2str(numop_BG)
            subout$ = 4
            *senroul_BG, e$
            result = mprint(senroul_BG)
            subout$ = 3
			pchange_BG
			*senroul_BG, e$
			plus_ecrire_BG = 1
            #erreur_BG = 1, erreur_BM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_enroul_BM

            if prog_BG = 1 | prog_BM = 1,   [
            senroul_BG = senroul_aff_BG + slettreC + no2str(axeC_BM) + space + slettreA + no2str(axeA_BM) + space + sopration + no2str(numop_BG)
            subout$ = 4
            #*senroul_BG, e$
            #result = mprint(senroul_BG)
            subout$ = 3
			pchange_BM
			*senroul_BG, e$
			plus_ecrire_BM = 1
            #erreur_BG = 1, erreur_BM = 1 #, exitpost$ # abandonner
                                            ]											
###################################################### 
psortie_ratrap_enroul_CG

            if prog_CG = 1 | prog_CM = 1,   [
            senroul_CG = senroul_aff_CG + slettreC + no2str(axeC_CG) + space + slettreB + no2str(axeA_CG) + space + sopration + no2str(numop_CG)
            subout$ = 4
            *senroul_CG, e$
            result = mprint(senroul_CG)
            subout$ = 3
			pchange_CG
			*senroul_CG, e$
			plus_ecrire_CG = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_enroul_CM

            if prog_CG = 1 | prog_CM = 1,   [
            senroul_CG = senroul_aff_CG + slettreC + no2str(axeC_CM) + space + slettreB + no2str(axeA_CM) + space + sopration + no2str(numop_CG)
            subout$ = 4
            #*senroul_CG, e$
            #result = mprint(senroul_CG)
            subout$ = 3
			pchange_CM
			*senroul_CG, e$
			plus_ecrire_CM = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]											
###################################################### 
psortie_ratrap_enroul_DG

            if prog_DG = 1 | prog_CM = 1,   [
            senroul_DG = senroul_aff_DG + slettreC + no2str(axeC_DG) + space + slettreB + no2str(axeA_DG) + space + sopration + no2str(numop_DG)
            subout$ = 4
            *senroul_DG, e$
            result = mprint(senroul_DG)
            subout$ = 3
			pchange_DG
			*senroul_DG, e$
			plus_ecrire_DG = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_enroul_DM

            if prog_DG = 1 | prog_CM = 1,   [
            senroul_DG = senroul_aff_DG + slettreC + no2str(axeC_DM) + space + slettreB + no2str(axeA_DM) + space + sopration + no2str(numop_DG)
            subout$ = 4
            #*senroul_DG, e$
            #result = mprint(senroul_DG)
            subout$ = 3
			pchange_DM
			*senroul_DG, e$
			plus_ecrire_DM = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]											
###################################################### 
psortie_ratrap_planinc_enroul_CG

            if prog_CG = 1 | prog_CM = 1,   [
            senroul_CG = senroul_aff_CG + slettreC + no2str(axeCpos1_CG) + space + slettreB + no2str(axeApos1_CG) + space + sopration + no2str(numop_CG)
            subout$ = 4
            *senroul_CG, e$
            result = mprint(senroul_CG)
            subout$ = 3
			pchange_CG
			*senroul_CG, e$
			plus_ecrire_CG = 1
			plus_ecrire_CM = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]

psortie_ratrap_planinc_deroul_CG

            if prog_CG = 1 | prog_CM = 1,   [
            sderoul_CG = sderoul_aff_CG + slettreC + no2str(axeCpos1_CG) + space + slettreB + no2str(axeApos1_CG) + space + sopration + no2str(numop_CG)
            subout$ = 4
            *sderoul_CG, e$
            result = mprint(sderoul_CG)
            subout$ = 3
			pchange_CG
			*sderoul_CG, e$
			plus_ecrire_CG = 1
			plus_ecrire_CM = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]
###################################################### 
psortie_ratrap_planinc_enroul_DG

            if prog_DG = 1 | prog_CM = 1,   [
            senroul_DG = senroul_aff_DG + slettreC + no2str(axeCpos1_DG) + space + slettreB + no2str(axeApos1_DG) + space + sopration + no2str(numop_DG)
            subout$ = 4
            *senroul_DG, e$
            result = mprint(senroul_DG)
            subout$ = 3
			pchange_DG
			*senroul_DG, e$
			plus_ecrire_DG = 1
			plus_ecrire_DM = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]

psortie_ratrap_planinc_deroul_DG

            if prog_DG = 1 | prog_CM = 1,   [
            sderoul_DG = sderoul_aff_DG + slettreC + no2str(axeCpos1_DG) + space + slettreB + no2str(axeApos1_DG) + space + sopration + no2str(numop_DG)
            subout$ = 4
            *sderoul_DG, e$
            result = mprint(sderoul_DG)
            subout$ = 3
			pchange_DG
			*sderoul_DG, e$
			plus_ecrire_DG = 1
			plus_ecrire_DM = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]
###################################################### 
psortie_ratrap_deroul_AG

            if prog_AG = 1 | prog_AM = 1,   [
            sderoul_AG = sderoul_aff_AG + slettreC + no2str(axeC_AG) + space + slettreA + no2str(axeA_AG) + space + sopration + no2str(numop_AG)
            subout$ = 4
            *sderoul_AG, e$
            result = mprint(sderoul_AG)
            subout$ = 3
			pchange_AG
			*sderoul_AG, e$
			plus_ecrire_AG = 1
            #erreur_AG = 1, erreur_AM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_deroul_AM

            if prog_AG = 1 | prog_AM = 1,   [
            sderoul_AG = sderoul_aff_AG + slettreC + no2str(axeC_AM) + space + slettreA + no2str(axeA_AM) + space + sopration + no2str(numop_AG)
            subout$ = 4
            #*sderoul_AG, e$
            #result = mprint(sderoul_AG)
            subout$ = 3
			pchange_AM
			*sderoul_AG, e$
			plus_ecrire_AM = 1
            #erreur_AG = 1, erreur_AM = 1 #, exitpost$ # abandonner
                                            ]
###################################################### 
psortie_ratrap_deroul_BG

            if prog_BG = 1 | prog_BM = 1,   [
            sderoul_BG = sderoul_aff_BG + slettreC + no2str(axeC_BG) + space + slettreA + no2str(axeA_BG) + space + sopration + no2str(numop_BG)
            subout$ = 4
            *sderoul_BG, e$
            result = mprint(sderoul_BG)
            subout$ = 3
			pchange_BG
			*sderoul_BG, e$
			plus_ecrire_BG = 1
            #erreur_BG = 1, erreur_BM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_deroul_BM

            if prog_BG = 1 | prog_BM = 1,   [
            sderoul_BG = sderoul_aff_BG + slettreC + no2str(axeC_BM) + space + slettreA + no2str(axeA_BM) + space + sopration + no2str(numop_BG)
            subout$ = 4
            #*sderoul_BG, e$
            #result = mprint(sderoul_BG)
            subout$ = 3
			pchange_BM
			*sderoul_BG, e$
			plus_ecrire_BM = 1
            #erreur_BG = 1, erreur_BM = 1 #, exitpost$ # abandonner
                                            ]
###################################################### 
psortie_ratrap_deroul_CG

            if prog_CG = 1 | prog_CM = 1,   [
            sderoul_CG = sderoul_aff_CG + slettreC + no2str(axeC_CG) + space + slettreB + no2str(axeA_CG) + space + sopration + no2str(numop_CG)
            subout$ = 4
            *sderoul_CG, e$
            result = mprint(sderoul_CG)
            subout$ = 3
			pchange_CG
			*sderoul_CG, e$
			plus_ecrire_CG = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_deroul_CM

            if prog_CG = 1 | prog_CM = 1,   [
            sderoul_CG = sderoul_aff_CG + slettreC + no2str(axeC_CM) + space + slettreB + no2str(axeA_CM) + space + sopration + no2str(numop_CG)
            subout$ = 4
            #*sderoul_CG, e$
            #result = mprint(sderoul_CG)
            subout$ = 3
			pchange_CM
			*sderoul_CG, e$
			plus_ecrire_CM = 1
            #erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
                                            ]											
###################################################### 
psortie_ratrap_deroul_DG

            if prog_DG = 1 | prog_CM = 1,   [
            sderoul_DG = sderoul_aff_DG + slettreC + no2str(axeC_DG) + space + slettreB + no2str(axeA_DG) + space + sopration + no2str(numop_DG)
            subout$ = 4
            *sderoul_DG, e$
            result = mprint(sderoul_DG)
            subout$ = 3
			pchange_DG
			*sderoul_DG, e$
			plus_ecrire_DG = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]
psortie_ratrap_deroul_DM

            if prog_DG = 1 | prog_CM = 1,   [
            sderoul_DG = sderoul_aff_DG + slettreC + no2str(axeC_DM) + space + slettreB + no2str(axeA_DM) + space + sopration + no2str(numop_DG)
            subout$ = 4
            #*sderoul_DG, e$
            #result = mprint(sderoul_DG)
            subout$ = 3
			pchange_DM
			*sderoul_DG, e$
			plus_ecrire_DM = 1
            #erreur_DG = 1, erreur_DM = 1 #, exitpost$ # abandonner
                                            ]
###################################################### 
psortie_num_prog_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreur_num_prog_AG
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ # abandonner
                            ]
######################################################          
psortie_transformation

            serreur_visu_general = serreur_visu_transformation
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner

######################################################
psortie_mi1

            serreur_visu_general = serreur_mi1 + no2str(numop_AG + 1)
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner

######################################################
psortie_mi2

            serreur_visu_general = serreur_mi2 + no2str(numop_AG + 1)
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner          

######################################################
psortie_descripteur

            serreur_visu_general = serreur_visu_descripteur
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner 

psortie_descripteur_erreur

            serreur_visu_general = serreur_visu_descripteur_erreur
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner   

psortie_descripteur_erreur2

            serreur_visu_general = serreur_visu_descripteur_erreur2
            subout$ = 4
            *serreur_visu_general, e$
            result = mprint(serreur_visu_general)
            subout$ = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1, erreur_DG = 1, erreur_DM = 1
            peof$, exitpost$ # abandonner   

psortie_dec_AG

            if prog_AG = 1 & erreur_AG <> 1,    [
            serreur_visu_AG = serreur_dec_AG
            result = mprint(serreur_visu_AG,2)
            if result = 2, subout$ = 4, *serreur_visu_AG, e$, subout$ = 3, erreur_AG = 1, erreur_AM = 1
                            ]
psortie_dec_BG

            if prog_BG = 1 & erreur_BG <> 1,    [
            serreur_visu_BG = serreur_dec_BG
            result = mprint(serreur_visu_BG,2)
            if result = 2, subout$ = 4, *serreur_visu_BG, e$, subout$ = 3, erreur_BG = 1, erreur_BM = 1
                            ]
psortie_dec_CG

            if prog_CG = 1 & erreur_CG <> 1,    [
            serreur_visu_CG = serreur_dec_CG
            result = mprint(serreur_visu_CG,2)
            if result = 2, subout$ = 4, *serreur_visu_CG, e$, subout$ = 3, erreur_CG = 1, erreur_CM = 1
                            ]

psortie_dec_DG

            if prog_DG = 1 & erreur_DG <> 1,    [
            serreur_visu_DG = serreur_dec_DG
            result = mprint(serreur_visu_DG,2)
            if result = 2, subout$ = 4, *serreur_visu_DG, e$, subout$ = 3, erreur_DG = 1, erreur_DM = 1
                            ]
######################################################
psortie_garage2_AM

            if prog_AM = 1, [
            numop_garage_AM = numop_AM + 1
            serreur_visu_AM = serreur_garage2_AM + no2str(numop_garage_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage2_BM

            if prog_BM = 1, [
            numop_garage_BM = numop_BM + 1
            serreur_visu_BM = serreur_garage2_BM + no2str(numop_garage_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage2_CM

            if prog_CM = 1, [
            numop_garage_CM = numop_CM + 1
            serreur_visu_CM = serreur_garage2_CM + no2str(numop_garage_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage2_DM

            if prog_DM = 1, [
            numop_garage_DM = numop_DM + 1
            serreur_visu_DM = serreur_garage2_DM + no2str(numop_garage_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner 
                            ]

######################################################

psortie_garage_AM

            if prog_AM = 1, [
            numop_garage_AM = numop_AM + 1
            serreur_visu_AM = serreur_garage_AM + no2str(numop_garage_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage_BM

            if prog_BM = 1, [
            numop_garage_BM = numop_BM + 1
            serreur_visu_BM = serreur_garage_BM + no2str(numop_garage_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage_CM

            if prog_CM = 1, [
            numop_garage_CM = numop_CM + 1
            serreur_visu_CM = serreur_garage_CM + no2str(numop_garage_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
                            ]

psortie_garage_DM

            if prog_DM = 1, [
            numop_garage_DM = numop_DM + 1
            serreur_visu_DM = serreur_garage_DM + no2str(numop_garage_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner 
                            ]
######################################################

psortie15_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreumr_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ # abandonner  
                            ]

psortie15_BG

            if prog_BG = 1, [
            serreur_visu_BG = serreumr_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner 
                            ]

psortie15_CG

            if prog_CG = 1, [
            serreur_visu_CG = serreumr_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner
                            ]

psortie15_DG

            if prog_DG = 1, [
            serreur_visu_DG = serreumr_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner
                            ]

psortie15_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreumr_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner 
                            ]

psortie15_BM

            if prog_BM = 1, [
            serreur_visu_BM = serreumr_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
                            ]

psortie15_CM

            if prog_CM = 1, [
            serreur_visu_CM = serreumr_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
                            ]

psortie15_DM

            if prog_DM = 1, [
            serreur_visu_DM = serreumr_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner 
                            ]
######################################################                          

psortie14_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreurarretprog_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ # abandonner
                            ]

psortie14_BG

            if prog_BG = 1, [
            serreur_visu_BG = serreurarretprog_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner
                            ]

psortie14_CG

            if prog_CG = 1, [
            serreur_visu_CG = serreurarretprog_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner 
                            ]

psortie14_DG

            if prog_DG = 1, [
            serreur_visu_DG = serreurarretprog_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner 
                            ]
psortie14_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreurarretprog_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner
                            ]

psortie14_BM

            if prog_BM = 1, [
            serreur_visu_BM = serreurarretprog_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner
                            ]

psortie14_CM

            if prog_CM = 1, [
            serreur_visu_CM = serreurarretprog_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
                            ]

psortie14_DM

            if prog_DM = 1, [
            serreur_visu_DM = serreurarretprog_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner 
                            ]
######################################################                  

psortie13_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreurpolarA_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ 
                            ]

psortie13_BG   # avertissement si osciliation double 

            if prog_BG = 1, [
            serreur_visu_BG = serreurpolarA_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner 
                            ]

psortie13_CG   # avertissement si osciliation double 

            if prog_CG = 1, [
            serreur_visu_CG = serreurpolarA_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner 
                            ]
psortie13_DG   # avertissement si osciliation double 

            if prog_DG = 1, [
            serreur_visu_DG = serreurpolarA_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner 
                            ]
psortie13_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreurpolarA_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$  
                            ]

psortie13_BM   # avertissement si osciliation double 

            if prog_BM = 1, [
            serreur_visu_BM = serreurpolarA_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
                            ]

psortie13_CM   # avertissement si osciliation double 

            if prog_CM = 1, [
            serreur_visu_CM = serreurpolarA_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner  
                            ]
psortie13_DM   # avertissement si osciliation double 

            if prog_DM = 1, [
            serreur_visu_DM = serreurpolarA_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner  
                            ]
######################################################                      

psortie12_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreuroscil_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$
                            ]

psortie12_BG

            if prog_BG = 1, [
            serreur_visu_BG = serreuroscil_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$
                            ]

psortie12_CG

            if prog_CG = 1, [
            serreur_visu_CG = serreuroscil_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$     
                            ]
psortie12_DG

            if prog_DG = 1, [
            serreur_visu_DG = serreuroscil_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$     
                            ]
psortie12_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreuroscil_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$
                            ]

psortie12_BM

            if prog_BM = 1, [
            serreur_visu_BM = serreuroscil_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$
                            ]

psortie12_CM

            if prog_CM = 1, [
            serreur_visu_CM = serreuroscil_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$
                            ]
psortie12_DM

            if prog_DM = 1, [
            serreur_visu_DM = serreuroscil_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$
                            ]
######################################################                      

psortie11_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreurimp_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$
                            ]

psortie11_BG   # avertissement si angle A impossible

            if prog_BG = 1, [
            serreur_visu_BG = serreurimp_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner
                            ]

psortie11_CG   # avertissement si angle A impossible

            if prog_CG = 1, [
            serreur_visu_CG = serreurimp_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner
                            ]
psortie11_DG   # avertissement si angle A impossible

            if prog_DG = 1, [
            serreur_visu_DG = serreurimp_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner
                            ]
psortie11_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreurimp_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$
                            ]

psortie11_BM   # avertissement si angle A impossible

            if prog_BM = 1, [
            serreur_visu_BM = serreurimp_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner
                            ]

psortie11_CM   # avertissement si angle A impossible

            if prog_CM = 1, [
            serreur_visu_CM = serreurimp_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner
                            ]
psortie11_DM   # avertissement si angle A impossible

            if prog_DM = 1, [
            serreur_visu_DM = serreurimp_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner
                            ]
######################################################                  

psortie10_AG

            if prog_AG = 1, [
            serreur_visu_AG = serreuraxeA_AG + no2str(numop_AG)
            subout$ = 4
            *serreur_visu_AG, e$
            result = mprint(serreur_visu_AG)
            subout$ = 3
            erreur_AG = 1
            #exitpost$ # abandonner
                            ]

psortie10_BG

            if prog_BG = 1, [
            serreur_visu_BG = serreuraxeA_BG + no2str(numop_BG)
            subout$ = 4
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            subout$ = 3
            erreur_BG = 1
            #exitpost$ # abandonner
                            ]

psortie10_CG

            if prog_CG = 1, [
            serreur_visu_CG = serreuraxeA_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
            #exitpost$ # abandonner
                            ]
psortie10_DG

            if prog_DG = 1, [
            serreur_visu_DG = serreuraxeA_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
            #exitpost$ # abandonner
                            ]
psortie10_AM

            if prog_AM = 1, [
            serreur_visu_AM = serreuraxeA_AM + no2str(numop_AM)
            subout$ = 4
            *serreur_visu_AM, e$
            result = mprint(serreur_visu_AM)
            subout$ = 3
            erreur_AM = 1
            #exitpost$ # abandonner
                            ]

psortie10_BM

            if prog_BM = 1, [
            serreur_visu_BM = serreuraxeA_BM + no2str(numop_BM)
            subout$ = 4
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            subout$ = 3
            erreur_BM = 1
            #exitpost$ # abandonner
                            ]

psortie10_CM

            if prog_CM = 1, [
            serreur_visu_CM = serreuraxeA_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
            #exitpost$ # abandonner
                            ]
psortie10_DM

            if prog_DM = 1, [
            serreur_visu_DM = serreuraxeA_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
            #exitpost$ # abandonner
                            ]
######################################################                      

psortie9_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_BG = 1, [
            result = mprint(serreurblum4_BG, 3)
            subout$ = 4
            serreurblum4_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie9_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_CG = 1, [
            result = mprint(serreurblum4_CG, 3)
            subout$ = 4
            serreurblum4_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]

psortie9_DG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_DG = 1, [
            result = mprint(serreurblum4_DG, 3)
            subout$ = 4
            serreurblum4_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]

psortie9_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_BM = 1, [
            result = mprint(serreurblum4_BM, 3)
            subout$ = 4
            serreurblum4_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie9_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_CM = 1, [
            result = mprint(serreurblum4_CM, 3)
            subout$ = 4
            serreurblum4_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]

psortie9_DM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_DM = 1, [
            result = mprint(serreurblum4_DM, 3)
            subout$ = 4
            serreurblum4_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################                  

psortie8_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_BG = 1, [
            result = mprint(serreurblum3_BG, 3)
            subout$ = 4
            serreurblum3_BG , e$#, exitpost$ # abandonner   
            subout$ = 3
            erreur_BG = 1
                            ]

psortie8_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_CG = 1, [
            result = mprint(serreurblum3_CG, 3)
            subout$ = 4
            serreurblum3_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]

psortie8_DG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_DG = 1, [
            result = mprint(serreurblum3_DG, 3)
            subout$ = 4
            serreurblum3_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]

psortie8_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_BM = 1, [
            result = mprint(serreurblum3_BM, 3)
            subout$ = 4
            serreurblum3_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie8_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_CM = 1, [
            result = mprint(serreurblum3_CM, 3)
            subout$ = 4
            serreurblum3_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]

psortie8_DM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 

            if prog_DM = 1, [
            result = mprint(serreurblum3_DM, 3)
            subout$ = 4
            serreurblum3_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################                  

psortie7_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_BG = 1, [
            result = mprint(serreurblum2_BG, 3)
            subout$ = 4
            serreurblum2_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie7_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_CG = 1, [
            result = mprint(serreurblum2_CG, 3)
            subout$ = 4
            serreurblum2_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]

psortie7_DG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_DG = 1, [
            result = mprint(serreurblum2_DG, 3)
            subout$ = 4
            serreurblum2_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]

psortie7_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_BM = 1, [
            result = mprint(serreurblum2_BM, 3)
            subout$ = 4
            serreurblum2_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie7_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_CM = 1, [
            result = mprint(serreurblum2_CM, 3)
            subout$ = 4
            serreurblum2_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]

psortie7_DM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage

            if prog_DM = 1, [
            result = mprint(serreurblum2_DM, 3)
            subout$ = 4
            serreurblum2_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################                  

psortie6_BG  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_BG = 1, [
            result = mprint(serreurblum1_BG, 3)
            subout$ = 4
            serreurblum1_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie6_CG  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_CG = 1, [
            result = mprint(serreurblum1_CG, 3)
            subout$ = 4
            serreurblum1_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
psortie6_DG  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_DG = 1, [
            result = mprint(serreurblum1_DG, 3)
            subout$ = 4
            serreurblum1_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
psortie6_BM  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_BM = 1, [
            result = mprint(serreurblum1_BM, 3)
            subout$ = 4
            serreurblum1_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie6_CM  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_CM = 1, [
            result = mprint(serreurblum1_CM, 3)
            subout$ = 4
            serreurblum1_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
psortie6_DM  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes

            if prog_DM = 1, [
            result = mprint(serreurblum1_DM, 3)
            subout$ = 4
            serreurblum1_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################                  

psortie5_BG  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_BG = 1, [
            result = mprint(serreuroutil_BG, 3)
            subout$ = 4
            serreuroutil_BG , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            subout$ = 3
            erreur_BG = 1
                            ]

psortie5_CG  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_CG = 1, [
            result = mprint(serreuroutil_CG, 3)
            subout$ = 4
            serreuroutil_CG , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            subout$ = 3
            erreur_CG = 1
                            ]
psortie5_DG  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_DG = 1, [
            result = mprint(serreuroutil_DG, 3)
            subout$ = 4
            serreuroutil_DG , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            subout$ = 3
            erreur_DG = 1
                            ]
psortie5_BM  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_BM = 1, [
            result = mprint(serreuroutil_BM, 3)
            subout$ = 4
            serreuroutil_BM , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner     
            subout$ = 3
            erreur_BM = 1
                            ]

psortie5_CM  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_CM = 1, [
            result = mprint(serreuroutil_CM, 3)
            subout$ = 4
            serreuroutil_CM , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            subout$ = 3
            erreur_CM = 1
                            ]
psortie5_DM  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification

            if prog_DM = 1, [
            result = mprint(serreuroutil_DM, 3)
            subout$ = 4
            serreuroutil_DM , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################                  

psortie4_BG  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_BG = 1, [
            result = mprint(serreurlub_BG, 3)
            subout$ = 4
            serreurlub_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie4_CG  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_CG = 1, [
            result = mprint(serreurlub_CG, 3)
            subout$ = 4
            serreurlub_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
psortie4_DG  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_DG = 1, [
            result = mprint(serreurlub_DG, 3)
            subout$ = 4
            serreurlub_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
psortie4_BM  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_BM = 1, [
            result = mprint(serreurlub_BM, 3)
            subout$ = 4
            serreurlub_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie4_CM  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_CM = 1, [
            result = mprint(serreurlub_CM, 3)
            subout$ = 4
            serreurlub_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
psortie4_DM  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification

            if prog_DM = 1, [
            result = mprint(serreurlub_DM, 3)
            subout$ = 4
            serreurlub_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]

######################################################                  

psortie3_BG  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_BG = 1, [
            result = mprint(serreurcloche_BG, 3)
            subout$ = 4
            serreurcloche_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie3_CG  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_CG = 1, [
            result = mprint(serreurcloche_CG, 3)
            subout$ = 4
            serreurcloche_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
psortie3_DG  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_DG = 1, [
            result = mprint(serreurcloche_DG, 3)
            subout$ = 4
            serreurcloche_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
psortie3_BM  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_BM = 1, [
            result = mprint(serreurcloche_BM, 3)
            subout$ = 4
            serreurcloche_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie3_CM  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_CM = 1, [
            result = mprint(serreurcloche_CM, 3)
            subout$ = 4
            serreurcloche_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
psortie3_DM  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle

            if prog_DM = 1, [
            result = mprint(serreurcloche_DM, 3)
            subout$ = 4
            serreurcloche_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################          

psortie2_BG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_BG = 1, [
            result = mprint(serreurcycle_BG, 3)
            subout$ = 4
            serreurcycle_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie2_CG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_CG = 1, [
            result = mprint(serreurcycle_CG, 3)
            subout$ = 4
            serreurcycle_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
psortie2_DG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_DG = 1, [
            result = mprint(serreurcycle_DG, 3)
            subout$ = 4
            serreurcycle_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
psortie2_BM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_BM = 1, [
            result = mprint(serreurcycle_BM, 3)
            subout$ = 4
            serreurcycle_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie2_CM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_CM = 1, [
            result = mprint(serreurcycle_CM, 3)
            subout$ = 4
            serreurcycle_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
psortie2_DM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_DM = 1, [
            result = mprint(serreurcycle_DM, 3)
            subout$ = 4
            serreurcycle_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################          

psortie_AG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_AG = 1, [
            result = mprint(serreur_AG, 3)
            subout$ = 4
            serreur_AG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_AG = 1
                            ]

psortie_BG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_BG = 1, [
            result = mprint(serreur_BG, 3)
            subout$ = 4
            serreur_BG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]

psortie_CG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_CG = 1, [
            result = mprint(serreur_CG, 3)
            subout$ = 4
            serreur_CG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
psortie_DG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_DG = 1, [
            result = mprint(serreur_DG, 3)
            subout$ = 4
            serreur_DG , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
psortie_AM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_AM = 1, [
            result = mprint(serreur_AM, 3)
            subout$ = 4
            serreur_AM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_AM = 1
                            ]

psortie_BM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_BM = 1, [
            result = mprint(serreur_BM, 3)
            subout$ = 4
            serreur_BM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]

psortie_CM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_CM = 1, [
            result = mprint(serreur_CM, 3)
            subout$ = 4
            serreur_CM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
psortie_DM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle

            if prog_DM = 1, [
            result = mprint(serreur_DM, 3)
            subout$ = 4
            serreur_DM , e$#, exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
######################################################
#endregion
#endregion 

#region Gestion de cloche 9110

fmt "gestion cloche " 1 gestion_cloche_CG
fmt "change cloche "  1 change_cloche_CG
fmt  "B" 12 axeA_cloche_CG

fmt  "B" 12 axeA_cloche_moins_CG
fmt  "B" 12 axeA_cloche_plus_CG
fmt  "B" 12 axeA_cloche_moins_CM
fmt  "B" 12 axeA_cloche_plus_CM

fmt  "B" 7 axeApos1_cloche_CG
fmt  "C" 7 axeCpos1_cloche_CG
fmt "flagmr2_CG" 1 flagmr2_CG
fmt "old_opcode_cloche_CG" 1 old_opcode_cloche_CG

fmt "gestion cloche " 1 gestion_cloche_CM
fmt "change cloche "  1 change_cloche_CM
fmt  "B" 12 axeA_cloche_CM
fmt  "B" 7 axeApos1_cloche_CM
fmt "flagmr2_CM" 1 flagmr2_CM
fmt "old_opcode_cloche_CM" 1 old_opcode_cloche_CM

serreumrcloche_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"
serreumrcloche_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"


pgarage_CG


        if (old_opcode_cloche_CG = 13) | (old_opcode_cloche_CG = 14) | (old_opcode_cloche_CG = 17) | (old_opcode_cloche_CG = 18),[
        if ((mi5_CG = 1) | (mi5_CG = 9)),   [
                                            if axeA_CG > 0 & axeC_CG > 0, garage_CG = 1
                                            if axeA_CG > 0 & axeC_CG < 0, garage_CG = 2
                                            if axeA_CG < 0, garage_CG = 3
                                            if axeA_CG = 0 & axeC_CG > 0, garage_CG = 4
                                            if axeA_CG = 0 & axeC_CG < 0, garage_CG = 5
                                            if axeA_CG = 0 & axeC_CG = 0, garage_CG = 6
                                            ]

                                    else,   [
                                            if axeA_CG > 0, garage_CG = 7
                                            if axeA_CG < 0 & axeC_CG > 0, garage_CG = 8
                                            if axeA_CG < 0 & axeC_CG < 0, garage_CG = 9
                                            if axeA_CG = 0, garage_CG = 10
                                            ]
                                                                                                                                ]

        else,   [
        if ((mi5_CG = 1) | (mi5_CG = 9)),   [
                                            if axeApos1_cloche_CG > 0 & axeCpos1_cloche_CG > 0, garage_CG = 1
                                            if axeApos1_cloche_CG > 0 & axeCpos1_cloche_CG < 0, garage_CG = 2
                                            if axeApos1_cloche_CG < 0,  garage_CG = 3
                                            if axeApos1_cloche_CG = 0 & axeCpos1_cloche_CG > 0, garage_CG = 4
                                            if axeApos1_cloche_CG = 0 & axeCpos1_cloche_CG < 0, garage_CG = 5
                                            if axeApos1_cloche_CG = 0 & axeCpos1_cloche_CG = 0, garage_CG = 6
                                            ]

                                    else,   [
                                            if axeApos1_cloche_CG > 0, garage_CG = 7
                                            if axeApos1_cloche_CG < 0 & axeCpos1_cloche_CG > 0, garage_CG = 8
                                            if axeApos1_cloche_CG < 0 & axeCpos1_cloche_CG < 0, garage_CG = 9
                                            if axeApos1_cloche_CG = 0, garage_CG = 10
                                            ]
                                                                                                                                ]
        #"voir garage tototo", *garage_CG, e$

pgestionduB_cloche_CG

            #"voir", *old_opcode_cloche_CG, e$
            if gestion_cloche_CG = 0,   [
                                        if (old_opcode_cloche_CG = 13) | (old_opcode_cloche_CG = 14) | (old_opcode_cloche_CG = 17) | (old_opcode_cloche_CG = 18),[
                                                                if (change_cloche_CG = 1) & (axeA_CG > axeA_cloche_plus_CG), axeA_cloche_CG = 60
                                                                if (change_cloche_CG = 1) & (axeA_CG < axeA_cloche_moins_CG), axeA_cloche_CG = -60
                                                                ]
                                                        else,   [
                                                                if (change_cloche_CG = 1) & (axeApos1_cloche_CG > axeA_cloche_plus_CG), axeA_cloche_CG = 60
                                                                if (change_cloche_CG = 1) & (axeApos1_cloche_CG < axeA_cloche_moins_CG), axeA_cloche_CG = -60
                                                                ]
                                        if (change_cloche_CG = 1) & garage_CG <> 0, [
                                                                                    if garage_CG = 1, axeA_cloche_CG = 0
                                                                                    if garage_CG = 2, axeA_cloche_CG = 0
                                                                                    if garage_CG = 3, axeA_cloche_CG = 0
                                                                                    if garage_CG = 4, axeA_cloche_CG = 0
                                                                                    if garage_CG = 5, axeA_cloche_CG = 0
                                                                                    if garage_CG = 6, axeA_cloche_CG = 0
                                                                                    if garage_CG = 7, axeA_cloche_CG = 0
                                                                                    if garage_CG = 8, axeA_cloche_CG = 0
                                                                                    if garage_CG = 9, axeA_cloche_CG = 0
                                                                                    if garage_CG = 10, axeA_cloche_CG = 0
                                                                                    garage_CG = 0
                                                                                    ]
                                        gestion_cloche_CG = 1
                                        ]
                                        #"voir", *axeA_cloche_CG, e$
pgestionduB_cloche_CM

            #"voir", *old_opcode_cloche_CM, e$
            if gestion_cloche_CM = 0,   [
                                        if (old_opcode_cloche_CM = 13) | (old_opcode_cloche_CM = 14) | (old_opcode_cloche_CM = 17) | (old_opcode_cloche_CM = 18),[
                                                                if (change_cloche_CM = 1) & (axeA_CM > axeA_cloche_plus_CM), axeA_cloche_CM = 60
                                                                if (change_cloche_CM = 1) & (axeA_CM < axeA_cloche_moins_CM), axeA_cloche_CM = -60
                                                                ]
                                                        else,   [
                                                                if (change_cloche_CM = 1) & (axeApos1_cloche_CM > axeA_cloche_plus_CG), axeA_cloche_CM = 60
                                                                if (change_cloche_CM = 1) & (axeApos1_cloche_CM < axeA_cloche_moins_CM), axeA_cloche_CM = -60
                                                                ]
                                        gestion_cloche_CM = 1
                                        ]
                                        #"voir", *axeA_cloche_CM, e$

psortie_cloche_CG

            if prog_CG = 1, [
            serreur_visu_CG = serreumrcloche_CG + no2str(numop_CG)
            subout$ = 4
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            subout$ = 3
            erreur_CG = 1
                            ]

psortie_cloche_CM

            if prog_CM = 1, [
            serreur_visu_CM = serreumrcloche_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
                            ]

pprep_cloche_CG
            flagmr2_CG = 0
            axeApos1_cloche_CG = axeApos1_CG
            axeCpos1_cloche_CG = axeCpos1_CG
            axeA_cloche_CG = 0
            if oldstation_CG <> mi4_CG, change_cloche_CG = 1
            else, change_cloche_CG = 0
            gestion_cloche_CG = 0

            #if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
            #else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG

pprep_cloche_CM
            flagmr2_CM = 0
            axeApos1_cloche_CM = axeApos1_CM
            axeA_cloche_CM = 0
            if oldstation_CM <> mi4_CM, change_cloche_CM = 1
            else, change_cloche_CM = 0
            gestion_cloche_CM = 0

            #if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
            #else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM

#endregion

#region Gestion de cloche STEMA01

fmt "gestion cloche " 1 gestion_cloche_DG
fmt "change cloche "  1 change_cloche_DG
fmt  "B" 12 axeA_cloche_DG

fmt  "B" 12 axeA_cloche_moins_DG
fmt  "B" 12 axeA_cloche_plus_DG
fmt  "B" 12 axeA_cloche_moins_DM
fmt  "B" 12 axeA_cloche_plus_DM

fmt  "B" 7 axeApos1_cloche_DG
fmt  "C" 7 axeCpos1_cloche_DG
fmt "flagmr2_DG" 1 flagmr2_DG
fmt "old_opcode_cloche_DG" 1 old_opcode_cloche_DG

fmt "gestion cloche " 1 gestion_cloche_DM
fmt "change cloche "  1 change_cloche_DM
fmt  "B" 12 axeA_cloche_DM
fmt  "B" 7 axeApos1_cloche_DM
fmt "flagmr2_DM" 1 flagmr2_DM
fmt "old_opcode_cloche_DM" 1 old_opcode_cloche_DM

serreumrcloche_DG : "- MACHINE STEMA01 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"
serreumrcloche_DM : "- MACHINE STEMA01 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"


pgarage_DG


        if (old_opcode_cloche_DG = 13) | (old_opcode_cloche_DG = 14) | (old_opcode_cloche_DG = 17) | (old_opcode_cloche_DG = 18),[
        if ((mi5_DG = 1) | (mi5_DG = 9)),   [
                                            if axeA_DG > 0 & axeC_DG > 0, garage_DG = 1
                                            if axeA_DG > 0 & axeC_DG < 0, garage_DG = 2
                                            if axeA_DG < 0, garage_DG = 3
                                            if axeA_DG = 0 & axeC_DG > 0, garage_DG = 4
                                            if axeA_DG = 0 & axeC_DG < 0, garage_DG = 5
                                            if axeA_DG = 0 & axeC_DG = 0, garage_DG = 6
                                            ]

                                    else,   [
                                            if axeA_DG > 0, garage_DG = 7
                                            if axeA_DG < 0 & axeC_DG > 0, garage_DG = 8
                                            if axeA_DG < 0 & axeC_DG < 0, garage_DG = 9
                                            if axeA_DG = 0, garage_DG = 10
                                            ]
                                                                                                                                ]

        else,   [
        if ((mi5_DG = 1) | (mi5_DG = 9)),   [
                                            if axeApos1_cloche_DG > 0 & axeCpos1_cloche_DG > 0, garage_DG = 1
                                            if axeApos1_cloche_DG > 0 & axeCpos1_cloche_DG < 0, garage_DG = 2
                                            if axeApos1_cloche_DG < 0,  garage_DG = 3
                                            if axeApos1_cloche_DG = 0 & axeCpos1_cloche_DG > 0, garage_DG = 4
                                            if axeApos1_cloche_DG = 0 & axeCpos1_cloche_DG < 0, garage_DG = 5
                                            if axeApos1_cloche_DG = 0 & axeCpos1_cloche_DG = 0, garage_DG = 6
                                            ]

                                    else,   [
                                            if axeApos1_cloche_DG > 0, garage_DG = 7
                                            if axeApos1_cloche_DG < 0 & axeCpos1_cloche_DG > 0, garage_DG = 8
                                            if axeApos1_cloche_DG < 0 & axeCpos1_cloche_DG < 0, garage_DG = 9
                                            if axeApos1_cloche_DG = 0, garage_DG = 10
                                            ]
                                                                                                                                ]
        #"voir garage tototo", *garage_DG, e$

pgestionduB_cloche_DG

            #"voir", *old_opcode_cloche_DG, e$
            if gestion_cloche_DG = 0,   [
                                        if (old_opcode_cloche_DG = 13) | (old_opcode_cloche_DG = 14) | (old_opcode_cloche_DG = 17) | (old_opcode_cloche_DG = 18),[
                                                                if (change_cloche_DG = 1) & (axeA_DG > axeA_cloche_plus_DG), axeA_cloche_DG = 60
                                                                if (change_cloche_DG = 1) & (axeA_DG < axeA_cloche_moins_DG), axeA_cloche_DG = -60
                                                                ]
                                                        else,   [
                                                                if (change_cloche_DG = 1) & (axeApos1_cloche_DG > axeA_cloche_plus_DG), axeA_cloche_DG = 60
                                                                if (change_cloche_DG = 1) & (axeApos1_cloche_DG < axeA_cloche_moins_DG), axeA_cloche_DG = -60
                                                                ]
                                        if (change_cloche_DG = 1) & garage_DG <> 0, [
                                                                                    if garage_DG = 1, axeA_cloche_DG = 0
                                                                                    if garage_DG = 2, axeA_cloche_DG = 0
                                                                                    if garage_DG = 3, axeA_cloche_DG = 0
                                                                                    if garage_DG = 4, axeA_cloche_DG = 0
                                                                                    if garage_DG = 5, axeA_cloche_DG = 0
                                                                                    if garage_DG = 6, axeA_cloche_DG = 0
                                                                                    if garage_DG = 7, axeA_cloche_DG = 0
                                                                                    if garage_DG = 8, axeA_cloche_DG = 0
                                                                                    if garage_DG = 9, axeA_cloche_DG = 0
                                                                                    if garage_DG = 10, axeA_cloche_DG = 0
                                                                                    garage_DG = 0
                                                                                    ]
                                        gestion_cloche_DG = 1
                                        ]
                                        #"voir", *axeA_cloche_DG, e$
pgestionduB_cloche_DM

            #"voir", *old_opcode_cloche_DM, e$
            if gestion_cloche_DM = 0,   [
                                        if (old_opcode_cloche_DM = 13) | (old_opcode_cloche_DM = 14) | (old_opcode_cloche_DM = 17) | (old_opcode_cloche_DM = 18),[
                                                                if (change_cloche_DM = 1) & (axeA_DM > axeA_cloche_plus_DM), axeA_cloche_DM = 60
                                                                if (change_cloche_DM = 1) & (axeA_DM < axeA_cloche_moins_DM), axeA_cloche_DM = -60
                                                                ]
                                                        else,   [
                                                                if (change_cloche_DM = 1) & (axeApos1_cloche_DM > axeA_cloche_plus_DG), axeA_cloche_DM = 60
                                                                if (change_cloche_DM = 1) & (axeApos1_cloche_DM < axeA_cloche_moins_DM), axeA_cloche_DM = -60
                                                                ]
                                        gestion_cloche_DM = 1
                                        ]
                                        #"voir", *axeA_cloche_DM, e$

psortie_cloche_DG

            if prog_DG = 1, [
            serreur_visu_DG = serreumrcloche_DG + no2str(numop_DG)
            subout$ = 4
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            subout$ = 3
            erreur_DG = 1
                            ]

psortie_cloche_DM

            if prog_DM = 1, [
            serreur_visu_DM = serreumrcloche_DM + no2str(numop_DM)
            subout$ = 4
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            subout$ = 3
            erreur_DM = 1
                            ]

pprep_cloche_DG
            flagmr2_DG = 0
            axeApos1_cloche_DG = axeApos1_DG
            axeCpos1_cloche_DG = axeCpos1_DG
            axeA_cloche_DG = 0
            if oldstation_DG <> mi4_DG, change_cloche_DG = 1
            else, change_cloche_DG = 0
            gestion_cloche_DG = 0

            #if (mi4_DG > 0) & (mi4_DG <> 9), mini_c_DG = mini_c_avec_cloche_DG, maxi_c_DG = maxi_c_avec_cloche_DG
            #else, mini_c_DG = mini_c_sans_cloche_DG, maxi_c_DG = maxi_c_sans_cloche_DG

pprep_cloche_DM
            flagmr2_DM = 0
            axeApos1_cloche_DM = axeApos1_DM
            axeA_cloche_DM = 0
            if oldstation_DM <> mi4_DM, change_cloche_DM = 1
            else, change_cloche_DM = 0
            gestion_cloche_DM = 0

            #if (mi4_DM > 0) & (mi4_DM <> 9), mini_c_DM = mini_c_avec_cloche_DM, maxi_c_DM = maxi_c_avec_cloche_DM
            #else, mini_c_DM = mini_c_sans_cloche_DM, maxi_c_DM = maxi_c_sans_cloche_DM

#endregion

#region   PPRINT #OK
pprint_debut  # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle 1 er point de passage pour percage            
#region PPRINT AG
pprint_AG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle

        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22,
            [   # on est dans le cas renvoie d'angle  
            ssprint_AG = ss$ * 0.5

            if ssprint_AG > 2500,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_AG = 1, [
                subout$ = 4
                result = mprint(serreurss_AG, 3)
                serreurss_AG , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_AG = 1
                                ]
                ]
            tete_rev_AG = 1
            dec_axe_tete = dec_tete_AG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sorti d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
            if t$ = tete_rev_ang_11 , tprint_AG = 50
            if t$ = tete_rev_ang_12 , tprint_AG = 50
            if t$ = tete_rev_ang_21 , tprint_AG = 60
            if t$ = tete_rev_ang_22 , tprint_AG = 60

             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_AG = u$ - x$
                Vy_AG = v$ - y$
                Vz_AG = w$ - z$
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)

                xdegvec  = (Vx_AG / longvec) * dec_axe_tete
                ydegvec  = (Vy_AG / longvec) * dec_axe_tete
                zdegvec  = (Vz_AG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AG cal", axeCcalra

                xdeg_AG = xdegvec  + x$
                ydeg_AG = ydegvec  + y$
                zdeg_AG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AG = z$
                xdeg1 = xdeg_AG * cos(axeccalra) - ydeg_AG * sin(axeccalra)
                ydeg1 = xdeg_AG * sin(axeccalra) + ydeg_AG * cos(axeccalra)
                zdeg1 = zdeg_AG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AG - xdeg3)
                y4 = y3 + (ydeg_AG - ydeg3)
                z4 = z3 + (zdeg_AG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AG = xdeg_AG
                yprint_AG = ydeg_AG
                zprint_AG = zdeg_AG

                xcal = xdeg_AG
                ycal = ydeg_AG
                zcal = zdeg_AG

                xrprint_AG = xdegvec + xr$
                yrprint_AG = ydegvec + yr$
                zrprint_AG = zdegvec + zr$

                mr2print_AG = mr2$
                zsecuprint = zsecu_AG

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continus avec renvoi d'angle  

            if mod5xcont = 2,
                [# on est dans le cas percage 5 axes  avec renvoi d'angle
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_AG = u$ - x$
                Vy_AG = v$ - y$
                Vz_AG = w$ - z$
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)

                xdegvec = (Vx_AG / longvec) * dec_axe_tete
                ydegvec = (Vy_AG / longvec) * dec_axe_tete
                zdegvec = (Vz_AG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AG cal", axeCcalra


                xdeg_AG = xdegvec + x$
                ydeg_AG = ydegvec + y$
                zdeg_AG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AG = z$
                xdeg1 = xdeg_AG * cos(axeccalra) - ydeg_AG * sin(axeccalra)
                ydeg1 = xdeg_AG * sin(axeccalra) + ydeg_AG * cos(axeccalra)
                zdeg1 = zdeg_AG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AG - xdeg3)
                y4 = y3 + (ydeg_AG - ydeg3)
                z4 = z3 + (zdeg_AG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AG = xdeg_AG
                yprint_AG = ydeg_AG
                zprint_AG = zdeg_AG

                xcal = xdeg_AG
                ycal = ydeg_AG
                zcal = zdeg_AG

                xrprint_AG = xdegvec + drl_init_x$
                yrprint_AG = ydegvec + drl_init_y$
                zrprint_AG = zdegvec + drl_init_z$
                xrprintrap_AG = xdegvec + sav_x_pmx
                yrprintrap_AG = ydegvec + sav_y_pmx
                zrprintrap_AG = zdegvec + sav_z_pmx

                xgarde_AG = xdegvec + u$
                ygarde_AG = ydegvec + v$
                zgarde_AG = zdegvec + w$


                mr2print_AG = mr2$
                zsecuprint = zsecu_AG


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_AG = x$ * -1
                        yprint_AG = y$
                        zprint_AG = z$ + dec_axe_tete

                        iprint_AG = i$ * -1
                        jprint_AG = j$
                        xc_AG = xc$ * -1
                        yc_AG = yc$
                        kprint_AG = k$ + dec_axe_tete

                        xrprint_AG = xr$ * -1
                        yrprint_AG = yr$
                        zrprint_AG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_AG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_AG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_AG = z$ + dec_axe_tete

                        iprint_AG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_AG = (j$*cos(tourne) - i$*sin(tourne))
                        xc_AG = (yc$*sin(tourne) + xc$*cos(tourne)) * -1
                        yc_AG = (yc$*cos(tourne) - xc$*sin(tourne))
                        kprint_AG = k$ + dec_axe_tete

                        xrprint_AG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_AG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_AG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_AG = tox4$
                toy4print_AG = toy4$
                toz4print_AG = toz4$

                depthprint_AG = depth$ + dec_axe_tete
                refhtprint_AG = refht$ + dec_axe_tete
                inithtprint_AG = initht$ + dec_axe_tete

                mr2print_AG = mr2$
                zsecuprint = zsecu_AG

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_AG = ss$
          tprint_AG =  t$
          tete_rev_AG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_AG = x$
          yprint_AG = y$
          zprint_AG = z$

          xrprint_AG = xr$
          yrprint_AG = yr$
          zrprint_AG = zr$

          iprint_AG = i$
          jprint_AG = j$
          xc_AG = xc$
          yc_AG = yc$
          kprint_AG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_AG = y$*sin(tourne) + x$*cos(tourne)
          yprint_AG = y$*cos(tourne) - x$*sin(tourne)
          zprint_AG = z$

          xrprint_AG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_AG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_AG = zr$

          iprint_AG = j$*sin(tourne) + i$*cos(tourne)
          jprint_AG = j$*cos(tourne) - i$*sin(tourne)
          xc_AG = yc$*sin(tourne) + xc$*cos(tourne)
          yc_AG = yc$*cos(tourne) - xc$*sin(tourne)
          kprint_AG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          tox4print_AG = tox4$
          toy4print_AG = toy4$
          toz4print_AG = toz4$

          mr2print_AG = mr2$
          zsecuprint = zsecu_AG
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"


          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid

        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$

#endregion
#region PPRINT BG
pprint_BG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_BG = ss$ * 1

            if ssprint_BG > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_BG = 1, [
                subout$ = 4
                result = mprint(serreurss_BG, 3)
                serreurss_BG , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_BG = 1
                                ]
                ]
            tete_rev_BG = 1
            dec_axe_tete = dec_tete_BG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_BG = u$ - x$
                Vy_BG = v$ - y$
                Vz_BG = w$ - z$
                @Vx_BG,@Vy_BG,@Vz_BG
                longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)

                xdegvec  = (Vx_BG / longvec) * dec_axe_tete
                ydegvec  = (Vy_BG / longvec) * dec_axe_tete
                zdegvec  = (Vz_BG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BG cal", axeCcalra

                xdeg_BG = xdegvec  + x$
                ydeg_BG = ydegvec  + y$
                zdeg_BG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BG = z$
                xdeg1 = xdeg_BG * cos(axeccalra) - ydeg_BG * sin(axeccalra)
                ydeg1 = xdeg_BG * sin(axeccalra) + ydeg_BG * cos(axeccalra)
                zdeg1 = zdeg_BG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BG - xdeg3)
                y4 = y3 + (ydeg_BG - ydeg3)
                z4 = z3 + (zdeg_BG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BG = xdeg_BG
                yprint_BG = ydeg_BG
                zprint_BG = zdeg_BG

                xcal = xdeg_BG
                ycal = ydeg_BG
                zcal = zdeg_BG

                xrprint_BG = xdegvec + xr$
                yrprint_BG = ydegvec + yr$
                zrprint_BG = zdegvec + zr$

                mr2print_BG = mr2$
                zsecuprint = zsecu_BG

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_BG = u$ - x$
                Vy_BG = v$ - y$
                Vz_BG = w$ - z$
                @Vx_BG,@Vy_BG,@Vz_BG
                longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)

                xdegvec = (Vx_BG / longvec) * dec_axe_tete
                ydegvec = (Vy_BG / longvec) * dec_axe_tete
                zdegvec = (Vz_BG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BG cal", axeCcalra


                xdeg_BG = xdegvec + x$
                ydeg_BG = ydegvec + y$
                zdeg_BG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BG = z$
                xdeg1 = xdeg_BG * cos(axeccalra) - ydeg_BG * sin(axeccalra)
                ydeg1 = xdeg_BG * sin(axeccalra) + ydeg_BG * cos(axeccalra)
                zdeg1 = zdeg_BG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BG - xdeg3)
                y4 = y3 + (ydeg_BG - ydeg3)
                z4 = z3 + (zdeg_BG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BG = xdeg_BG
                yprint_BG = ydeg_BG
                zprint_BG = zdeg_BG

                xcal = xdeg_BG
                ycal = ydeg_BG
                zcal = zdeg_BG

                xrprint_BG = xdegvec + drl_init_x$
                yrprint_BG = ydegvec + drl_init_y$
                zrprint_BG = zdegvec + drl_init_z$
                xrprintrap_BG = xdegvec + sav_x_pmx
                yrprintrap_BG = ydegvec + sav_y_pmx
                zrprintrap_BG = zdegvec + sav_z_pmx

                xgarde_BG = xdegvec + u$
                ygarde_BG = ydegvec + v$
                zgarde_BG = zdegvec + w$


                mr2print_BG = mr2$
                zsecuprint = zsecu_BG


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_BG = x$ * -1
                        yprint_BG = y$
                        zprint_BG = z$ + dec_axe_tete

                        iprint_BG = i$ * -1
                        jprint_BG = j$
                        kprint_BG = k$ + dec_axe_tete

                        xrprint_BG = xr$ * -1
                        yrprint_BG = yr$
                        zrprint_BG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_BG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_BG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_BG = z$ + dec_axe_tete

                        iprint_BG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_BG = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_BG = k$ + dec_axe_tete

                        xrprint_BG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_BG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_BG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_BG = tox4$
                toy4print_BG = toy4$
                toz4print_BG = toz4$

                depthprint_BG = depth$ + dec_axe_tete
                refhtprint_BG = refht$ + dec_axe_tete
                inithtprint_BG = initht$ + dec_axe_tete

                mr2print_BG = mr2$
                zsecuprint = zsecu_BG

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_BG = ss$
          tprint_BG =  t$
          tete_rev_BG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_BG = x$
          yprint_BG = y$
          zprint_BG = z$

          xrprint_BG = xr$
          yrprint_BG = yr$
          zrprint_BG = zr$

          iprint_BG = i$
          jprint_BG = j$
          kprint_BG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_BG = y$*sin(tourne) + x$*cos(tourne)
          yprint_BG = y$*cos(tourne) - x$*sin(tourne)
          zprint_BG = z$

          xrprint_BG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_BG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_BG = zr$

          iprint_BG = j$*sin(tourne) + i$*cos(tourne)
          jprint_BG = j$*cos(tourne) - i$*sin(tourne)
          kprint_BG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_BG = tox4$
          toy4print_BG = toy4$
          toz4print_BG = toz4$


          mr2print_BG = mr2$
          zsecuprint = zsecu_BG
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_BG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT CG
pprint_CG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_CG = ss$ * 1

            if ssprint_CG > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_CG = 1, [
                subout$ = 4
                result = mprint(serreurss_CG, 3)
                serreurss_CG , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_CG = 1
                                ]
                ]
            tete_rev_CG = 1
            dec_axe_tete = dec_tete_CG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_CG = u$ - x$
                Vy_CG = v$ - y$
                Vz_CG = w$ - z$
                @Vx_CG,@Vy_CG,@Vz_CG
                longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)

                xdegvec  = (Vx_CG / longvec) * dec_axe_tete
                ydegvec  = (Vy_CG / longvec) * dec_axe_tete
                zdegvec  = (Vz_CG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CG cal", axeCcalra

                xdeg_CG = xdegvec  + x$
                ydeg_CG = ydegvec  + y$
                zdeg_CG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CG = z$
                xdeg1 = xdeg_CG * cos(axeccalra) - ydeg_CG * sin(axeccalra)
                ydeg1 = xdeg_CG * sin(axeccalra) + ydeg_CG * cos(axeccalra)
                zdeg1 = zdeg_CG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CG - xdeg3)
                y4 = y3 + (ydeg_CG - ydeg3)
                z4 = z3 + (zdeg_CG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CG = xdeg_CG
                yprint_CG = ydeg_CG
                zprint_CG = zdeg_CG

                xcal = xdeg_CG
                ycal = ydeg_CG
                zcal = zdeg_CG

                xrprint_CG = xdegvec + xr$
                yrprint_CG = ydegvec + yr$
                zrprint_CG = zdegvec + zr$

                mr2print_CG = mr2$
                zsecuprint = zsecu_CG

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_CG = u$ - x$
                Vy_CG = v$ - y$
                Vz_CG = w$ - z$
                @Vx_CG,@Vy_CG,@Vz_CG
                longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)

                xdegvec = (Vx_CG / longvec) * dec_axe_tete
                ydegvec = (Vy_CG / longvec) * dec_axe_tete
                zdegvec = (Vz_CG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CG cal", axeCcalra


                xdeg_CG = xdegvec + x$
                ydeg_CG = ydegvec + y$
                zdeg_CG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CG = z$
                xdeg1 = xdeg_CG * cos(axeccalra) - ydeg_CG * sin(axeccalra)
                ydeg1 = xdeg_CG * sin(axeccalra) + ydeg_CG * cos(axeccalra)
                zdeg1 = zdeg_CG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CG - xdeg3)
                y4 = y3 + (ydeg_CG - ydeg3)
                z4 = z3 + (zdeg_CG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CG = xdeg_CG
                yprint_CG = ydeg_CG
                zprint_CG = zdeg_CG

                xcal = xdeg_CG
                ycal = ydeg_CG
                zcal = zdeg_CG

                xrprint_CG = xdegvec + drl_init_x$
                yrprint_CG = ydegvec + drl_init_y$
                zrprint_CG = zdegvec + drl_init_z$
                xrprintrap_CG = xdegvec + sav_x_pmx
                yrprintrap_CG = ydegvec + sav_y_pmx
                zrprintrap_CG = zdegvec + sav_z_pmx

                xgarde_CG = xdegvec + u$
                ygarde_CG = ydegvec + v$
                zgarde_CG = zdegvec + w$


                mr2print_CG = mr2$
                zsecuprint = zsecu_CG


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_CG = x$ * -1
                        yprint_CG = y$
                        zprint_CG = z$ + dec_axe_tete

                        iprint_CG = i$ * -1
                        jprint_CG = j$
                        kprint_CG = k$ + dec_axe_tete

                        xrprint_CG = xr$ * -1
                        yrprint_CG = yr$
                        zrprint_CG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_CG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_CG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_CG = z$ + dec_axe_tete

                        iprint_CG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_CG = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_CG = k$ + dec_axe_tete

                        xrprint_CG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_CG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_CG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_CG = tox4$
                toy4print_CG = toy4$
                toz4print_CG = toz4$

                depthprint_CG = depth$ + dec_axe_tete
                refhtprint_CG = refht$ + dec_axe_tete
                inithtprint_CG = initht$ + dec_axe_tete

                mr2print_CG = mr2$
                zsecuprint = zsecu_CG

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_CG = ss$
          tprint_CG =  t$
          tete_rev_CG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_CG = x$
          yprint_CG = y$
          zprint_CG = z$

          xrprint_CG = xr$
          yrprint_CG = yr$
          zrprint_CG = zr$

          iprint_CG = i$
          jprint_CG = j$
          kprint_CG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_CG = y$*sin(tourne) + x$*cos(tourne)
          yprint_CG = y$*cos(tourne) - x$*sin(tourne)
          zprint_CG = z$

          xrprint_CG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_CG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_CG = zr$

          iprint_CG = j$*sin(tourne) + i$*cos(tourne)
          jprint_CG = j$*cos(tourne) - i$*sin(tourne)
          kprint_CG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_CG = tox4$
          toy4print_CG = toy4$
          toz4print_CG = toz4$


          mr2print_CG = mr2$
          zsecuprint = zsecu_CG
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_CG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT DG
pprint_DG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_DG = ss$ * 1

            if ssprint_DG > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_DG = 1, [
                subout$ = 4
                result = mprint(serreurss_DG, 3)
                serreurss_DG , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_DG = 1
                                ]
                ]
            tete_rev_DG = 1
            dec_axe_tete = dec_tete_DG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_DG = u$ - x$
                Vy_DG = v$ - y$
                Vz_DG = w$ - z$
                @Vx_DG,@Vy_DG,@Vz_DG
                longvec=sqrt(Vx_DG * Vx_DG + Vy_DG * Vy_DG + Vz_DG * Vz_DG)

                xdegvec  = (Vx_DG / longvec) * dec_axe_tete
                ydegvec  = (Vy_DG / longvec) * dec_axe_tete
                zdegvec  = (Vz_DG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_DG cal", axeCcalra

                xdeg_DG = xdegvec  + x$
                ydeg_DG = ydegvec  + y$
                zdeg_DG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_DG = z$
                xdeg1 = xdeg_DG * cos(axeccalra) - ydeg_DG * sin(axeccalra)
                ydeg1 = xdeg_DG * sin(axeccalra) + ydeg_DG * cos(axeccalra)
                zdeg1 = zdeg_DG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_DG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_DG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_DG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_DG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_DG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_DG - xdeg3)
                y4 = y3 + (ydeg_DG - ydeg3)
                z4 = z3 + (zdeg_DG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_DG = xdeg_DG
                yprint_DG = ydeg_DG
                zprint_DG = zdeg_DG

                xcal = xdeg_DG
                ycal = ydeg_DG
                zcal = zdeg_DG

                xrprint_DG = xdegvec + xr$
                yrprint_DG = ydegvec + yr$
                zrprint_DG = zdegvec + zr$

                mr2print_DG = mr2$
                zsecuprint = zsecu_DG

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_DG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_DG = u$ - x$
                Vy_DG = v$ - y$
                Vz_DG = w$ - z$
                @Vx_DG,@Vy_DG,@Vz_DG
                longvec=sqrt(Vx_DG * Vx_DG + Vy_DG * Vy_DG + Vz_DG * Vz_DG)

                xdegvec = (Vx_DG / longvec) * dec_axe_tete
                ydegvec = (Vy_DG / longvec) * dec_axe_tete
                zdegvec = (Vz_DG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_DG cal", axeCcalra


                xdeg_DG = xdegvec + x$
                ydeg_DG = ydegvec + y$
                zdeg_DG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_DG = z$
                xdeg1 = xdeg_DG * cos(axeccalra) - ydeg_DG * sin(axeccalra)
                ydeg1 = xdeg_DG * sin(axeccalra) + ydeg_DG * cos(axeccalra)
                zdeg1 = zdeg_DG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_DG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_DG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_DG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_DG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_DG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_DG - xdeg3)
                y4 = y3 + (ydeg_DG - ydeg3)
                z4 = z3 + (zdeg_DG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_DG = xdeg_DG
                yprint_DG = ydeg_DG
                zprint_DG = zdeg_DG

                xcal = xdeg_DG
                ycal = ydeg_DG
                zcal = zdeg_DG

                xrprint_DG = xdegvec + drl_init_x$
                yrprint_DG = ydegvec + drl_init_y$
                zrprint_DG = zdegvec + drl_init_z$
                xrprintrap_DG = xdegvec + sav_x_pmx
                yrprintrap_DG = ydegvec + sav_y_pmx
                zrprintrap_DG = zdegvec + sav_z_pmx

                xgarde_DG = xdegvec + u$
                ygarde_DG = ydegvec + v$
                zgarde_DG = zdegvec + w$


                mr2print_DG = mr2$
                zsecuprint = zsecu_DG


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_DG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_DG = x$ * -1
                        yprint_DG = y$
                        zprint_DG = z$ + dec_axe_tete

                        iprint_DG = i$ * -1
                        jprint_DG = j$
                        kprint_DG = k$ + dec_axe_tete

                        xrprint_DG = xr$ * -1
                        yrprint_DG = yr$
                        zrprint_DG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_DG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_DG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_DG = z$ + dec_axe_tete

                        iprint_DG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_DG = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_DG = k$ + dec_axe_tete

                        xrprint_DG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_DG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_DG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_DG = tox4$
                toy4print_DG = toy4$
                toz4print_DG = toz4$

                depthprint_DG = depth$ + dec_axe_tete
                refhtprint_DG = refht$ + dec_axe_tete
                inithtprint_DG = initht$ + dec_axe_tete

                mr2print_DG = mr2$
                zsecuprint = zsecu_DG

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_DG)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_DG)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_DG)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_DG)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_DG)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_DG)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_DG)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_DG)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_DG)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_DG)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_DG = ss$
          tprint_DG =  t$
          tete_rev_DG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_DG = x$
          yprint_DG = y$
          zprint_DG = z$

          xrprint_DG = xr$
          yrprint_DG = yr$
          zrprint_DG = zr$

          iprint_DG = i$
          jprint_DG = j$
          kprint_DG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_DG = y$*sin(tourne) + x$*cos(tourne)
          yprint_DG = y$*cos(tourne) - x$*sin(tourne)
          zprint_DG = z$

          xrprint_DG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_DG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_DG = zr$

          iprint_DG = j$*sin(tourne) + i$*cos(tourne)
          jprint_DG = j$*cos(tourne) - i$*sin(tourne)
          kprint_DG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_DG = tox4$
          toy4print_DG = toy4$
          toz4print_DG = toz4$


          mr2print_DG = mr2$
          zsecuprint = zsecu_DG
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_DG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DG)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT AM
pprint_AM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle

        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22,
            [   # on est dans le cas renvoie d'angle  
            ssprint_AM = ss$ * 0.5

            if ssprint_AM > 2500,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_AM = 1, [
                subout$ = 4
                result = mprint(serreurss_AM, 3)
                serreurss_AM , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_AM = 1
                                ]
                ]
            tete_rev_AM = 1
            dec_axe_tete = dec_tete_AM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sorti d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
            if t$ = tete_rev_ang_11 , tprint_AM = 50
            if t$ = tete_rev_ang_12 , tprint_AM = 50
            if t$ = tete_rev_ang_21 , tprint_AM = 60
            if t$ = tete_rev_ang_22 , tprint_AM = 60

             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_AM = u$ - x$
                Vy_AM = v$ - y$
                Vz_AM = w$ - z$
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)

                xdegvec  = (Vx_AM / longvec) * dec_axe_tete
                ydegvec  = (Vy_AM / longvec) * dec_axe_tete
                zdegvec  = (Vz_AM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AM cal", axeCcalra

                xdeg_AM = xdegvec  + x$
                ydeg_AM = ydegvec  + y$
                zdeg_AM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AM = z$
                xdeg1 = xdeg_AM * cos(axeccalra) - ydeg_AM * sin(axeccalra)
                ydeg1 = xdeg_AM * sin(axeccalra) + ydeg_AM * cos(axeccalra)
                zdeg1 = zdeg_AM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AM - xdeg3)
                y4 = y3 + (ydeg_AM - ydeg3)
                z4 = z3 + (zdeg_AM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AM = xdeg_AM
                yprint_AM = ydeg_AM
                zprint_AM = zdeg_AM

                xcal = xdeg_AM
                ycal = ydeg_AM
                zcal = zdeg_AM

                xrprint_AM = xdegvec + xr$
                yrprint_AM = ydegvec + yr$
                zrprint_AM = zdegvec + zr$

                mr2print_AM = mr2$
                zsecuprint = zsecu_AM

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continus avec renvoi d'angle  

            if mod5xcont = 2,
                [# on est dans le cas percage 5 axes  avec renvoi d'angle
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_AM = u$ - x$
                Vy_AM = v$ - y$
                Vz_AM = w$ - z$
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)

                xdegvec = (Vx_AM / longvec) * dec_axe_tete
                ydegvec = (Vy_AM / longvec) * dec_axe_tete
                zdegvec = (Vz_AM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AM cal", axeCcalra


                xdeg_AM = xdegvec + x$
                ydeg_AM = ydegvec + y$
                zdeg_AM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AM = z$
                xdeg1 = xdeg_AM * cos(axeccalra) - ydeg_AM * sin(axeccalra)
                ydeg1 = xdeg_AM * sin(axeccalra) + ydeg_AM * cos(axeccalra)
                zdeg1 = zdeg_AM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AM - xdeg3)
                y4 = y3 + (ydeg_AM - ydeg3)
                z4 = z3 + (zdeg_AM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AM = xdeg_AM
                yprint_AM = ydeg_AM
                zprint_AM = zdeg_AM

                xcal = xdeg_AM
                ycal = ydeg_AM
                zcal = zdeg_AM

                xrprint_AM = xdegvec + drl_init_x$
                yrprint_AM = ydegvec + drl_init_y$
                zrprint_AM = zdegvec + drl_init_z$
                xrprintrap_AM = xdegvec + sav_x_pmx
                yrprintrap_AM = ydegvec + sav_y_pmx
                zrprintrap_AM = zdegvec + sav_z_pmx

                xgarde_AM = xdegvec + u$
                ygarde_AM = ydegvec + v$
                zgarde_AM = zdegvec + w$


                mr2print_AM = mr2$
                zsecuprint = zsecu_AM


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_AM = x$ * -1
                        yprint_AM = y$
                        zprint_AM = z$ + dec_axe_tete

                        iprint_AM = i$ * -1
                        jprint_AM = j$
                        xc_AM = xc$ * -1
                        yc_AM = yc$
                        kprint_AM = k$ + dec_axe_tete

                        xrprint_AM = xr$ * -1
                        yrprint_AM = yr$
                        zrprint_AM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_AM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_AM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_AM = z$ + dec_axe_tete

                        iprint_AM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_AM = (j$*cos(tourne) - i$*sin(tourne))
                        xc_AM = (yc$*sin(tourne) + xc$*cos(tourne)) * -1
                        yc_AM = (yc$*cos(tourne) - xc$*sin(tourne))
                        kprint_AM = k$ + dec_axe_tete

                        xrprint_AM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_AM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_AM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_AM = tox4$
                toy4print_AM = toy4$
                toz4print_AM = toz4$

                depthprint_AM = depth$ + dec_axe_tete
                refhtprint_AM = refht$ + dec_axe_tete
                inithtprint_AM = initht$ + dec_axe_tete

                mr2print_AM = mr2$
                zsecuprint = zsecu_AM

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_AM = ss$
          tprint_AM =  t$
          tete_rev_AM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_AM = x$
          yprint_AM = y$
          zprint_AM = z$

          xrprint_AM = xr$
          yrprint_AM = yr$
          zrprint_AM = zr$

          iprint_AM = i$
          jprint_AM = j$
          xc_AM = xc$
          yc_AM = yc$
          kprint_AM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_AM = y$*sin(tourne) + x$*cos(tourne)
          yprint_AM = y$*cos(tourne) - x$*sin(tourne)
          zprint_AM = z$

          xrprint_AM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_AM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_AM = zr$

          iprint_AM = j$*sin(tourne) + i$*cos(tourne)
          jprint_AM = j$*cos(tourne) - i$*sin(tourne)
          xc_AM = yc$*sin(tourne) + xc$*cos(tourne)
          yc_AM = yc$*cos(tourne) - xc$*sin(tourne)
          kprint_AM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          tox4print_AM = tox4$
          toy4print_AM = toy4$
          toz4print_AM = toz4$

          mr2print_AM = mr2$
          zsecuprint = zsecu_AM
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$

#endregion
#region PPRINT BM
pprint_BM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_BM = ss$ * 1

            if ssprint_BM > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_BM = 1, [
                subout$ = 4
                result = mprint(serreurss_BM, 3)
                serreurss_BM , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_BM = 1
                                ]
                ]
            tete_rev_BM = 1
            dec_axe_tete = dec_tete_BM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_BM = u$ - x$
                Vy_BM = v$ - y$
                Vz_BM = w$ - z$
                @Vx_BM,@Vy_BM,@Vz_BM
                longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)

                xdegvec  = (Vx_BM / longvec) * dec_axe_tete
                ydegvec  = (Vy_BM / longvec) * dec_axe_tete
                zdegvec  = (Vz_BM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BM cal", axeCcalra

                xdeg_BM = xdegvec  + x$
                ydeg_BM = ydegvec  + y$
                zdeg_BM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BM = z$
                xdeg1 = xdeg_BM * cos(axeccalra) - ydeg_BM * sin(axeccalra)
                ydeg1 = xdeg_BM * sin(axeccalra) + ydeg_BM * cos(axeccalra)
                zdeg1 = zdeg_BM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BM - xdeg3)
                y4 = y3 + (ydeg_BM - ydeg3)
                z4 = z3 + (zdeg_BM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BM = xdeg_BM
                yprint_BM = ydeg_BM
                zprint_BM = zdeg_BM

                xcal = xdeg_BM
                ycal = ydeg_BM
                zcal = zdeg_BM

                xrprint_BM = xdegvec + xr$
                yrprint_BM = ydegvec + yr$
                zrprint_BM = zdegvec + zr$

                mr2print_BM = mr2$
                zsecuprint = zsecu_BM

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_BM = u$ - x$
                Vy_BM = v$ - y$
                Vz_BM = w$ - z$
                @Vx_BM,@Vy_BM,@Vz_BM
                longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)

                xdegvec = (Vx_BM / longvec) * dec_axe_tete
                ydegvec = (Vy_BM / longvec) * dec_axe_tete
                zdegvec = (Vz_BM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BM cal", axeCcalra


                xdeg_BM = xdegvec + x$
                ydeg_BM = ydegvec + y$
                zdeg_BM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BM = z$
                xdeg1 = xdeg_BM * cos(axeccalra) - ydeg_BM * sin(axeccalra)
                ydeg1 = xdeg_BM * sin(axeccalra) + ydeg_BM * cos(axeccalra)
                zdeg1 = zdeg_BM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BM - xdeg3)
                y4 = y3 + (ydeg_BM - ydeg3)
                z4 = z3 + (zdeg_BM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BM = xdeg_BM
                yprint_BM = ydeg_BM
                zprint_BM = zdeg_BM

                xcal = xdeg_BM
                ycal = ydeg_BM
                zcal = zdeg_BM

                xrprint_BM = xdegvec + drl_init_x$
                yrprint_BM = ydegvec + drl_init_y$
                zrprint_BM = zdegvec + drl_init_z$
                xrprintrap_BM = xdegvec + sav_x_pmx
                yrprintrap_BM = ydegvec + sav_y_pmx
                zrprintrap_BM = zdegvec + sav_z_pmx

                xgarde_BM = xdegvec + u$
                ygarde_BM = ydegvec + v$
                zgarde_BM = zdegvec + w$


                mr2print_BM = mr2$
                zsecuprint = zsecu_BM


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_BM = x$ * -1
                        yprint_BM = y$
                        zprint_BM = z$ + dec_axe_tete

                        iprint_BM = i$ * -1
                        jprint_BM = j$
                        kprint_BM = k$ + dec_axe_tete

                        xrprint_BM = xr$ * -1
                        yrprint_BM = yr$
                        zrprint_BM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_BM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_BM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_BM = z$ + dec_axe_tete

                        iprint_BM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_BM = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_BM = k$ + dec_axe_tete

                        xrprint_BM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_BM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_BM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_BM = tox4$
                toy4print_BM = toy4$
                toz4print_BM = toz4$

                depthprint_BM = depth$ + dec_axe_tete
                refhtprint_BM = refht$ + dec_axe_tete
                inithtprint_BM = initht$ + dec_axe_tete

                mr2print_BM = mr2$
                zsecuprint = zsecu_BM

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_BM = ss$
          tprint_BM =  t$
          tete_rev_BM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_BM = x$
          yprint_BM = y$
          zprint_BM = z$

          xrprint_BM = xr$
          yrprint_BM = yr$
          zrprint_BM = zr$

          iprint_BM = i$
          jprint_BM = j$
          kprint_BM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_BM = y$*sin(tourne) + x$*cos(tourne)
          yprint_BM = y$*cos(tourne) - x$*sin(tourne)
          zprint_BM = z$

          xrprint_BM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_BM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_BM = zr$

          iprint_BM = j$*sin(tourne) + i$*cos(tourne)
          jprint_BM = j$*cos(tourne) - i$*sin(tourne)
          kprint_BM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_BM = tox4$
          toy4print_BM = toy4$
          toz4print_BM = toz4$


          mr2print_BM = mr2$
          zsecuprint = zsecu_BM
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_BM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT CM
pprint_CM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_CM = ss$ * 1

            if ssprint_CM > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_CM = 1, [
                subout$ = 4
                result = mprint(serreurss_CM, 3)
                serreurss_CM , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_CM = 1
                                ]
                ]
            tete_rev_CM = 1
            dec_axe_tete = dec_tete_CM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_CM = u$ - x$
                Vy_CM = v$ - y$
                Vz_CM = w$ - z$
                @Vx_CM,@Vy_CM,@Vz_CM
                longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)

                xdegvec  = (Vx_CM / longvec) * dec_axe_tete
                ydegvec  = (Vy_CM / longvec) * dec_axe_tete
                zdegvec  = (Vz_CM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CM cal", axeCcalra

                xdeg_CM = xdegvec  + x$
                ydeg_CM = ydegvec  + y$
                zdeg_CM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CM = z$
                xdeg1 = xdeg_CM * cos(axeccalra) - ydeg_CM * sin(axeccalra)
                ydeg1 = xdeg_CM * sin(axeccalra) + ydeg_CM * cos(axeccalra)
                zdeg1 = zdeg_CM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CM - xdeg3)
                y4 = y3 + (ydeg_CM - ydeg3)
                z4 = z3 + (zdeg_CM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CM = xdeg_CM
                yprint_CM = ydeg_CM
                zprint_CM = zdeg_CM

                xcal = xdeg_CM
                ycal = ydeg_CM
                zcal = zdeg_CM

                xrprint_CM = xdegvec + xr$
                yrprint_CM = ydegvec + yr$
                zrprint_CM = zdegvec + zr$

                mr2print_CM = mr2$
                zsecuprint = zsecu_CM

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_CM = u$ - x$
                Vy_CM = v$ - y$
                Vz_CM = w$ - z$
                @Vx_CM,@Vy_CM,@Vz_CM
                longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)

                xdegvec = (Vx_CM / longvec) * dec_axe_tete
                ydegvec = (Vy_CM / longvec) * dec_axe_tete
                zdegvec = (Vz_CM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CM cal", axeCcalra


                xdeg_CM = xdegvec + x$
                ydeg_CM = ydegvec + y$
                zdeg_CM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CM = z$
                xdeg1 = xdeg_CM * cos(axeccalra) - ydeg_CM * sin(axeccalra)
                ydeg1 = xdeg_CM * sin(axeccalra) + ydeg_CM * cos(axeccalra)
                zdeg1 = zdeg_CM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CM - xdeg3)
                y4 = y3 + (ydeg_CM - ydeg3)
                z4 = z3 + (zdeg_CM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CM = xdeg_CM
                yprint_CM = ydeg_CM
                zprint_CM = zdeg_CM

                xcal = xdeg_CM
                ycal = ydeg_CM
                zcal = zdeg_CM

                xrprint_CM = xdegvec + drl_init_x$
                yrprint_CM = ydegvec + drl_init_y$
                zrprint_CM = zdegvec + drl_init_z$
                xrprintrap_CM = xdegvec + sav_x_pmx
                yrprintrap_CM = ydegvec + sav_y_pmx
                zrprintrap_CM = zdegvec + sav_z_pmx

                xgarde_CM = xdegvec + u$
                ygarde_CM = ydegvec + v$
                zgarde_CM = zdegvec + w$


                mr2print_CM = mr2$
                zsecuprint = zsecu_CM


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_CM = x$ * -1
                        yprint_CM = y$
                        zprint_CM = z$ + dec_axe_tete

                        iprint_CM = i$ * -1
                        jprint_CM = j$
                        kprint_CM = k$ + dec_axe_tete

                        xrprint_CM = xr$ * -1
                        yrprint_CM = yr$
                        zrprint_CM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_CM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_CM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_CM = z$ + dec_axe_tete

                        iprint_CM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_CM = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_CM = k$ + dec_axe_tete

                        xrprint_CM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_CM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_CM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_CM = tox4$
                toy4print_CM = toy4$
                toz4print_CM = toz4$

                depthprint_CM = depth$ + dec_axe_tete
                refhtprint_CM = refht$ + dec_axe_tete
                inithtprint_CM = initht$ + dec_axe_tete

                mr2print_CM = mr2$
                zsecuprint = zsecu_CM

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_CM = ss$
          tprint_CM =  t$
          tete_rev_CM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_CM = x$
          yprint_CM = y$
          zprint_CM = z$

          xrprint_CM = xr$
          yrprint_CM = yr$
          zrprint_CM = zr$

          iprint_CM = i$
          jprint_CM = j$
          kprint_CM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_CM = y$*sin(tourne) + x$*cos(tourne)
          yprint_CM = y$*cos(tourne) - x$*sin(tourne)
          zprint_CM = z$

          xrprint_CM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_CM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_CM = zr$

          iprint_CM = j$*sin(tourne) + i$*cos(tourne)
          jprint_CM = j$*cos(tourne) - i$*sin(tourne)
          kprint_CM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_CM = tox4$
          toy4print_CM = toy4$
          toz4print_CM = toz4$


          mr2print_CM = mr2$
          zsecuprint = zsecu_CM
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_CM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT DM
pprint_DM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_DM = ss$ * 1

            if ssprint_DM > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                if prog_DM = 1, [
                subout$ = 4
                result = mprint(serreurss_DM, 3)
                serreurss_DM , e$#, exitpost$ # abandonner
                subout$ = 3
                erreur_DM = 1
                                ]
                ]
            tete_rev_DM = 1
            dec_axe_tete = dec_tete_DM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_DM = u$ - x$
                Vy_DM = v$ - y$
                Vz_DM = w$ - z$
                @Vx_DM,@Vy_DM,@Vz_DM
                longvec=sqrt(Vx_DM * Vx_DM + Vy_DM * Vy_DM + Vz_DM * Vz_DM)

                xdegvec  = (Vx_DM / longvec) * dec_axe_tete
                ydegvec  = (Vy_DM / longvec) * dec_axe_tete
                zdegvec  = (Vz_DM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_DM cal", axeCcalra

                xdeg_DM = xdegvec  + x$
                ydeg_DM = ydegvec  + y$
                zdeg_DM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_DM = z$
                xdeg1 = xdeg_DM * cos(axeccalra) - ydeg_DM * sin(axeccalra)
                ydeg1 = xdeg_DM * sin(axeccalra) + ydeg_DM * cos(axeccalra)
                zdeg1 = zdeg_DM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_DM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_DM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_DM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_DM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_DM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_DM - xdeg3)
                y4 = y3 + (ydeg_DM - ydeg3)
                z4 = z3 + (zdeg_DM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_DM = xdeg_DM
                yprint_DM = ydeg_DM
                zprint_DM = zdeg_DM

                xcal = xdeg_DM
                ycal = ydeg_DM
                zcal = zdeg_DM

                xrprint_DM = xdegvec + xr$
                yrprint_DM = ydegvec + yr$
                zrprint_DM = zdegvec + zr$

                mr2print_DM = mr2$
                zsecuprint = zsecu_DM

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_DM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_DM = u$ - x$
                Vy_DM = v$ - y$
                Vz_DM = w$ - z$
                @Vx_DM,@Vy_DM,@Vz_DM
                longvec=sqrt(Vx_DM * Vx_DM + Vy_DM * Vy_DM + Vz_DM * Vz_DM)

                xdegvec = (Vx_DM / longvec) * dec_axe_tete
                ydegvec = (Vy_DM / longvec) * dec_axe_tete
                zdegvec = (Vz_DM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_DM cal", axeCcalra


                xdeg_DM = xdegvec + x$
                ydeg_DM = ydegvec + y$
                zdeg_DM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_DM = z$
                xdeg1 = xdeg_DM * cos(axeccalra) - ydeg_DM * sin(axeccalra)
                ydeg1 = xdeg_DM * sin(axeccalra) + ydeg_DM * cos(axeccalra)
                zdeg1 = zdeg_DM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_DM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_DM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_DM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_DM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_DM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_DM - xdeg3)
                y4 = y3 + (ydeg_DM - ydeg3)
                z4 = z3 + (zdeg_DM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_DM = xdeg_DM
                yprint_DM = ydeg_DM
                zprint_DM = zdeg_DM

                xcal = xdeg_DM
                ycal = ydeg_DM
                zcal = zdeg_DM

                xrprint_DM = xdegvec + drl_init_x$
                yrprint_DM = ydegvec + drl_init_y$
                zrprint_DM = zdegvec + drl_init_z$
                xrprintrap_DM = xdegvec + sav_x_pmx
                yrprintrap_DM = ydegvec + sav_y_pmx
                zrprintrap_DM = zdegvec + sav_z_pmx

                xgarde_DM = xdegvec + u$
                ygarde_DM = ydegvec + v$
                zgarde_DM = zdegvec + w$


                mr2print_DM = mr2$
                zsecuprint = zsecu_DM


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_DM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_DM = x$ * -1
                        yprint_DM = y$
                        zprint_DM = z$ + dec_axe_tete

                        iprint_DM = i$ * -1
                        jprint_DM = j$
                        kprint_DM = k$ + dec_axe_tete

                        xrprint_DM = xr$ * -1
                        yrprint_DM = yr$
                        zrprint_DM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_DM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_DM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_DM = z$ + dec_axe_tete

                        iprint_DM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_DM = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_DM = k$ + dec_axe_tete

                        xrprint_DM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_DM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_DM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_DM = tox4$
                toy4print_DM = toy4$
                toz4print_DM = toz4$

                depthprint_DM = depth$ + dec_axe_tete
                refhtprint_DM = refht$ + dec_axe_tete
                inithtprint_DM = initht$ + dec_axe_tete

                mr2print_DM = mr2$
                zsecuprint = zsecu_DM

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_DM)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_DM)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_DM)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_DM)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_DM)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_DM)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_DM)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_DM)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_DM)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_DM)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_DM = ss$
          tprint_DM =  t$
          tete_rev_DM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_DM = x$
          yprint_DM = y$
          zprint_DM = z$

          xrprint_DM = xr$
          yrprint_DM = yr$
          zrprint_DM = zr$

          iprint_DM = i$
          jprint_DM = j$
          kprint_DM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_DM = y$*sin(tourne) + x$*cos(tourne)
          yprint_DM = y$*cos(tourne) - x$*sin(tourne)
          zprint_DM = z$

          xrprint_DM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_DM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_DM = zr$

          iprint_DM = j$*sin(tourne) + i$*cos(tourne)
          jprint_DM = j$*cos(tourne) - i$*sin(tourne)
          kprint_DM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_DM = tox4$
          toy4print_DM = toy4$
          toz4print_DM = toz4$


          mr2print_DM = mr2$
          zsecuprint = zsecu_DM
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_DM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_DM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_DM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_DM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_DM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_DM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_DM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_DM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_DM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_DM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#endregion

#region   PG9 #OK
#region pg9_5x  
pg9_5x_AG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_AG = sqrt((old_x_5x_AG - x$)^2 + (old_y_5x_AG - y$)^2 + (old_z_5x_AG - z$)^2)
                long_p23_AG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_AG = sqrt((old_x_5x_AG - nextx$)^2 + (old_y_5x_AG - nexty$)^2 + (old_z_5x_AG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_AG <> 0 & long_p23_AG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AG = (long_p23_AG^2 + long_p12_AG^2 - long_p13_AG^2)/(2*long_p12_AG*long_p23_AG)
                !cosangle_AG#, e$
                if cosangle_AG <= 1 & cosangle_AG >= -1,
                [
                ang5x_AG = acos(cosangle_AG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AG, *mr7$, e$
                if ang5x_AG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_BG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_BG = sqrt((old_x_5x_BG - x$)^2 + (old_y_5x_BG - y$)^2 + (old_z_5x_BG - z$)^2)
                long_p23_BG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_BG = sqrt((old_x_5x_BG - nextx$)^2 + (old_y_5x_BG - nexty$)^2 + (old_z_5x_BG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_BG <> 0 & long_p23_BG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BG = (long_p23_BG^2 + long_p12_BG^2 - long_p13_BG^2)/(2*long_p12_BG*long_p23_BG)
                !cosangle_BG
                if cosangle_BG <= 1 & cosangle_BG >= -1,
                [
                ang5x_BG = acos(cosangle_BG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_BG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_CG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_CG = sqrt((old_x_5x_CG - x$)^2 + (old_y_5x_CG - y$)^2 + (old_z_5x_CG - z$)^2)
                long_p23_CG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_CG = sqrt((old_x_5x_CG - nextx$)^2 + (old_y_5x_CG - nexty$)^2 + (old_z_5x_CG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_CG <> 0 & long_p23_CG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CG = (long_p23_CG^2 + long_p12_CG^2 - long_p13_CG^2)/(2*long_p12_CG*long_p23_CG)
                !cosangle_CG
                if cosangle_CG <= 1 & cosangle_CG >= -1,
                [
                ang5x_CG = acos(cosangle_CG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_CG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_DG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_DG = sqrt((old_x_5x_DG - x$)^2 + (old_y_5x_DG - y$)^2 + (old_z_5x_DG - z$)^2)
                long_p23_DG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_DG = sqrt((old_x_5x_DG - nextx$)^2 + (old_y_5x_DG - nexty$)^2 + (old_z_5x_DG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_DG <> 0 & long_p23_DG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DG = (long_p23_DG^2 + long_p12_DG^2 - long_p13_DG^2)/(2*long_p12_DG*long_p23_DG)
                !cosangle_DG
                if cosangle_DG <= 1 & cosangle_DG >= -1,
                [
                ang5x_DG = acos(cosangle_DG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_DG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_AM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_AM = sqrt((old_x_5x_AM - x$)^2 + (old_y_5x_AM - y$)^2 + (old_z_5x_AM - z$)^2)
                long_p23_AM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_AM = sqrt((old_x_5x_AM - nextx$)^2 + (old_y_5x_AM - nexty$)^2 + (old_z_5x_AM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_AM <> 0 & long_p23_AM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AM = (long_p23_AM^2 + long_p12_AM^2 - long_p13_AM^2)/(2*long_p12_AM*long_p23_AM)
                !cosangle_AM#, e$
                if cosangle_AM <= 1 & cosangle_AM >= -1,
                [
                ang5x_AM = acos(cosangle_AM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AM, *mr7$, e$
                if ang5x_AM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_BM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_BM = sqrt((old_x_5x_BM - x$)^2 + (old_y_5x_BM - y$)^2 + (old_z_5x_BM - z$)^2)
                long_p23_BM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_BM = sqrt((old_x_5x_BM - nextx$)^2 + (old_y_5x_BM - nexty$)^2 + (old_z_5x_BM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_BM <> 0 & long_p23_BM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BM = (long_p23_BM^2 + long_p12_BM^2 - long_p13_BM^2)/(2*long_p12_BM*long_p23_BM)
                !cosangle_BM
                if cosangle_BM <= 1 & cosangle_BM >= -1,
                [
                ang5x_BM = acos(cosangle_BM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_BM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_CM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_CM = sqrt((old_x_5x_CM - x$)^2 + (old_y_5x_CM - y$)^2 + (old_z_5x_CM - z$)^2)
                long_p23_CM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_CM = sqrt((old_x_5x_CM - nextx$)^2 + (old_y_5x_CM - nexty$)^2 + (old_z_5x_CM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_CM <> 0 & long_p23_CM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CM = (long_p23_CM^2 + long_p12_CM^2 - long_p13_CM^2)/(2*long_p12_CM*long_p23_CM)
                !cosangle_CM
                if cosangle_CM <= 1 & cosangle_CM >= -1,
                [
                ang5x_CM = acos(cosangle_CM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_CM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_DM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_DM = sqrt((old_x_5x_DM - x$)^2 + (old_y_5x_DM - y$)^2 + (old_z_5x_DM - z$)^2)
                long_p23_DM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_DM = sqrt((old_x_5x_DM - nextx$)^2 + (old_y_5x_DM - nexty$)^2 + (old_z_5x_DM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_DM <> 0 & long_p23_DM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DM = (long_p23_DM^2 + long_p12_DM^2 - long_p13_DM^2)/(2*long_p12_DM*long_p23_DM)
                !cosangle_DM
                if cosangle_DM <= 1 & cosangle_DM >= -1,
                [
                ang5x_DM = acos(cosangle_DM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_DM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
#endregion      
#region pg9
pg9_AG           #ajout du code G9 en 2d

                long_p12_AG = sqrt((old_x_AG - x$)^2 + (old_y_AG - y$)^2)
                long_p23_AG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_AG = sqrt((old_x_AG - nextx$)^2 + (old_y_AG - nexty$)^2)

                if long_p12_AG <> 0 & long_p23_AG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AG = (long_p23_AG^2 + long_p12_AG^2 - long_p13_AG^2)/(2*long_p12_AG*long_p23_AG)
                !cosangle_AG
                if cosangle_AG <= 1 & cosangle_AG >= -1,
                [
                ang5x_AG = acos(cosangle_AG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AG, *mr7$, e$
                if ang5x_AG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_BG           #ajout du code G9 en 2d

                long_p12_BG = sqrt((old_x_BG - x$)^2 + (old_y_BG - y$)^2)
                long_p23_BG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_BG = sqrt((old_x_BG - nextx$)^2 + (old_y_BG - nexty$)^2)

                if long_p12_BG <> 0 & long_p23_BG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BG = (long_p23_BG^2 + long_p12_BG^2 - long_p13_BG^2)/(2*long_p12_BG*long_p23_BG)
                !cosangle_BG
                if cosangle_BG <= 1 & cosangle_BG >= -1,
                [
                ang5x_BG = acos(cosangle_BG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_BG, *mr7$, e$
                if ang5x_BG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_CG           #ajout du code G9 en 2d

                long_p12_CG = sqrt((old_x_CG - x$)^2 + (old_y_CG - y$)^2)
                long_p23_CG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_CG = sqrt((old_x_CG - nextx$)^2 + (old_y_CG - nexty$)^2)

                if long_p12_CG <> 0 & long_p23_CG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CG = (long_p23_CG^2 + long_p12_CG^2 - long_p13_CG^2)/(2*long_p12_CG*long_p23_CG)
                !cosangle_CG
                if cosangle_CG <= 1 & cosangle_CG >= -1,
                [
                ang5x_CG = acos(cosangle_CG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_CG, *mr7$, e$
                if ang5x_CG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_DG           #ajout du code G9 en 2d

                long_p12_DG = sqrt((old_x_DG - x$)^2 + (old_y_DG - y$)^2)
                long_p23_DG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_DG = sqrt((old_x_DG - nextx$)^2 + (old_y_DG - nexty$)^2)

                if long_p12_DG <> 0 & long_p23_DG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DG = (long_p23_DG^2 + long_p12_DG^2 - long_p13_DG^2)/(2*long_p12_DG*long_p23_DG)
                !cosangle_DG
                if cosangle_DG <= 1 & cosangle_DG >= -1,
                [
                ang5x_DG = acos(cosangle_DG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_DG, *mr7$, e$
                if ang5x_DG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_AM           #ajout du code G9 en 2d

                long_p12_AM = sqrt((old_x_AM - x$)^2 + (old_y_AM - y$)^2)
                long_p23_AM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_AM = sqrt((old_x_AM - nextx$)^2 + (old_y_AM - nexty$)^2)

                if long_p12_AM <> 0 & long_p23_AM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AM = (long_p23_AM^2 + long_p12_AM^2 - long_p13_AM^2)/(2*long_p12_AM*long_p23_AM)
                !cosangle_AM
                if cosangle_AM <= 1 & cosangle_AM >= -1,
                [
                ang5x_AM = acos(cosangle_AM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AM, *mr7$, e$
                if ang5x_AM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_BM           #ajout du code G9 en 2d

                long_p12_BM = sqrt((old_x_BM - x$)^2 + (old_y_BM - y$)^2)
                long_p23_BM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_BM = sqrt((old_x_BM - nextx$)^2 + (old_y_BM - nexty$)^2)

                if long_p12_BM <> 0 & long_p23_BM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BM = (long_p23_BM^2 + long_p12_BM^2 - long_p13_BM^2)/(2*long_p12_BM*long_p23_BM)
                !cosangle_BM
                if cosangle_BM <= 1 & cosangle_BM >= -1,
                [
                ang5x_BM = acos(cosangle_BM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_BM, *mr7$, e$
                if ang5x_BM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_CM           #ajout du code G9 en 2d

                long_p12_CM = sqrt((old_x_CM - x$)^2 + (old_y_CM - y$)^2)
                long_p23_CM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_CM = sqrt((old_x_CM - nextx$)^2 + (old_y_CM - nexty$)^2)

                if long_p12_CM <> 0 & long_p23_CM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CM = (long_p23_CM^2 + long_p12_CM^2 - long_p13_CM^2)/(2*long_p12_CM*long_p23_CM)
                !cosangle_CM
                if cosangle_CM <= 1 & cosangle_CM >= -1,
                [
                ang5x_CM = acos(cosangle_CM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_CM, *mr7$, e$
                if ang5x_CM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_DM           #ajout du code G9 en 2d

                long_p12_DM = sqrt((old_x_DM - x$)^2 + (old_y_DM - y$)^2)
                long_p23_DM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_DM = sqrt((old_x_DM - nextx$)^2 + (old_y_DM - nexty$)^2)

                if long_p12_DM <> 0 & long_p23_DM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DM = (long_p23_DM^2 + long_p12_DM^2 - long_p13_DM^2)/(2*long_p12_DM*long_p23_DM)
                !cosangle_DM
                if cosangle_DM <= 1 & cosangle_DM >= -1,
                [
                ang5x_DM = acos(cosangle_DM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_DM, *mr7$, e$
                if ang5x_DM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
#endregion              
#endregion

#region   COMMMENTAIRES, PFR, PMODAL, COMPTEUR #OK
#region pcomment_descripteur

snumprog_AG : ""
fmt "num de prog" 4 num_prog_AG
pcomment_descripteur

           if gcode$ = 1054,    [
                                if compteur_descrip = 15, sprog_complet_AG = scomm$
                                if compteur_descrip = 16, sprog_complet_BG = scomm$
                                if compteur_descrip = 17, sprog_complet_CG = scomm$
                                if compteur_descrip = 18, sprog_complet_DG = scomm$
                                if compteur_descrip = 20, sprog_concat_AM = scomm$
                                if compteur_descrip = 21, sprog_concat_BM = scomm$
                                if compteur_descrip = 22, sprog_concat_CM = scomm$
                                if compteur_descrip = 23, sprog_concat_DM = scomm$
                                if compteur_descrip = 30, snumprog_AG = scomm$
                                if compteur_descrip = 32, SDEC_X_AG = scomm$
                                if compteur_descrip = 35, SDEC_Y_AG = scomm$
                                if compteur_descrip = 38, SDEC_Z_AG = scomm$
                                if compteur_descrip = 49, SDEC_X_BG = scomm$
                                if compteur_descrip = 52, SDEC_Y_BG = scomm$
                                if compteur_descrip = 55, SDEC_Z_BG = scomm$
                                if compteur_descrip = 66, SDEC_X_CG = scomm$
                                if compteur_descrip = 69, SDEC_Y_CG = scomm$
                                if compteur_descrip = 72, SDEC_Z_CG = scomm$
                                if compteur_descrip = 83, SDEC_X_DG = scomm$
                                if compteur_descrip = 86, SDEC_Y_DG = scomm$
                                if compteur_descrip = 89, SDEC_Z_DG = scomm$
                                if compteur_descrip = 73, SPOURCENTAGE_AVANCE_CG = scomm$
                                if compteur_descrip = 74, SCLOCHE_ACTIVE_CG = scomm$
                                if compteur_descrip = 90, SPOURCENTAGE_AVANCE_DG = scomm$
                                if compteur_descrip = 91, SCLOCHE_ACTIVE_DG = scomm$
                                if compteur_descrip = 98, sdim_outillage = scomm$
                                if compteur_descrip = 102, susure_outil_1 = scomm$
                                if compteur_descrip = 103, susure_outil_2 = scomm$
                                if compteur_descrip = 104, susure_outil_3 = scomm$
                                if compteur_descrip = 105, susure_outil_4 = scomm$
                                if compteur_descrip = 106, susure_outil_5 = scomm$
                                if compteur_descrip = 107, susure_outil_6 = scomm$
                                if compteur_descrip = 108, susure_outil_7 = scomm$
                                if compteur_descrip = 109, susure_outil_8 = scomm$
                                if compteur_descrip = 110, susure_outil_9 = scomm$
                                if compteur_descrip = 111, susure_outil_10 = scomm$
                                if compteur_descrip = 112, susure_outil_11 = scomm$
                                if compteur_descrip = 113, susure_outil_12 = scomm$
                                if compteur_descrip = 114, susure_outil_13 = scomm$
                                if compteur_descrip = 115, susure_outil_14 = scomm$
                                if compteur_descrip = 116, susure_outil_15 = scomm$
                                if compteur_descrip = 117, susure_outil_16 = scomm$
                                if compteur_descrip = 118, susure_outil_17 = scomm$
                                if compteur_descrip = 119, susure_outil_18 = scomm$
                                if compteur_descrip = 120, susure_outil_19 = scomm$
                                if compteur_descrip = 121, susure_outil_20 = scomm$
                                if compteur_descrip = 122, susure_outil_21 = scomm$
                                if compteur_descrip = 123, susure_outil_22 = scomm$
                                if compteur_descrip = 124, susure_outil_23 = scomm$
                                if compteur_descrip = 125, susure_outil_24 = scomm$
                                if compteur_descrip = 126, susure_outil_25 = scomm$
                                if compteur_descrip = 127, susure_outil_26 = scomm$
                                if compteur_descrip = 128, susure_outil_27 = scomm$
                                if compteur_descrip = 129, susure_outil_28 = scomm$
                                if compteur_descrip = 130, susure_outil_29 = scomm$
                                if compteur_descrip = 131, susure_outil_30 = scomm$

                                compteur_descrip = compteur_descrip + 1

                                DEC_X_AG = rpar(SDEC_X_AG,1)
                                DEC_Y_AG = rpar(SDEC_Y_AG,1)
                                DEC_Z_AG = rpar(SDEC_Z_AG,1)

                                DEC_X_BG = rpar(SDEC_X_BG,1)
                                DEC_Y_BG = rpar(SDEC_Y_BG,1)
                                DEC_Z_BG = rpar(SDEC_Z_BG,1)

                                DEC_X_CG = rpar(SDEC_X_CG,1)
                                DEC_Y_CG = rpar(SDEC_Y_CG,1)
                                DEC_Z_CG = rpar(SDEC_Z_CG,1)

                                DEC_X_DG = rpar(SDEC_X_DG,1)
                                DEC_Y_DG = rpar(SDEC_Y_DG,1)
                                DEC_Z_DG = rpar(SDEC_Z_DG,1)

                                DEC_X_AM = rpar(SDEC_X_AG,1)
                                DEC_Y_AM = rpar(SDEC_Y_AG,1)
                                DEC_Z_AM = rpar(SDEC_Z_AG,1)

                                DEC_X_BM = rpar(SDEC_X_BG,1)
                                DEC_Y_BM = rpar(SDEC_Y_BG,1)
                                DEC_Z_BM = rpar(SDEC_Z_BG,1)

                                DEC_X_CM = rpar(SDEC_X_CG,1)
                                DEC_Y_CM = rpar(SDEC_Y_CG,1)
                                DEC_Z_CM = rpar(SDEC_Z_CG,1)

                                DEC_X_DM = rpar(SDEC_X_DG,1)
                                DEC_Y_DM = rpar(SDEC_Y_DG,1)
                                DEC_Z_DM = rpar(SDEC_Z_DG,1)

                                SPOURCENTAGE_AVANCE_CG = brksps(27,SPOURCENTAGE_AVANCE_CG)
                                SPOURCENTAGE_AVANCE_DG = brksps(27,SPOURCENTAGE_AVANCE_DG)
                                POURCENTAGE_AVANCE_CG = rpar(SPOURCENTAGE_AVANCE_CG,1)
                                POURCENTAGE_AVANCE_CM = rpar(SPOURCENTAGE_AVANCE_CG,1)
                                POURCENTAGE_AVANCE_DG = rpar(SPOURCENTAGE_AVANCE_DG,1)
                                POURCENTAGE_AVANCE_DM = rpar(SPOURCENTAGE_AVANCE_DG,1)
                                ]

#region pvoirdescrip
pvoirdescrip

                                "toto", *SCLOCHE_ACTIVE_CG, e$

                                SDEC_X_AG, e$
                                SDEC_Y_AG, e$
                                SDEC_Z_AG, e$

                                SDEC_X_BG, e$
                                SDEC_Y_BG, e$
                                SDEC_Z_BG, e$

                                SDEC_X_CG, e$
                                SDEC_Y_CG, e$
                                SDEC_Z_CG, e$

                                DEC_X_AG, e$
                                DEC_Y_AG, e$
                                DEC_Z_AG, e$

                                DEC_X_BG, e$
                                DEC_Y_BG, e$
                                DEC_Z_BG, e$

                                DEC_X_CG, e$
                                DEC_Y_CG, e$
                                DEC_Z_CG, e$

                                DEC_X_AM, e$
                                DEC_Y_AM, e$
                                DEC_Z_AM, e$

                                DEC_X_BM, e$
                                DEC_Y_BM, e$
                                DEC_Z_BM, e$

                                DEC_X_CM, e$
                                DEC_Y_CM, e$
                                DEC_Z_CM, e$

                                sprog_complet_AG, e$
                                sprog_complet_BG, e$
                                sprog_complet_CG, e$

                                sprog_concat_AM, e$
                                sprog_concat_BM, e$
                                sprog_concat_CM, e$

                                prog_AG, e$
                                prog_BG, e$
                                prog_CG, e$
                                prog_AM, e$
                                prog_BM, e$
                                prog_CM, e$

#endregion                              
#endregion
#region PCOMMENT
pcomment$
                            if debut_pp = 0, pcomment_descripteur
							pchange_AG
                            pcomment_AG
							pchange_BG
                            pcomment_BG
							pchange_CG
                            pcomment_CG
							pchange_DG
                            pcomment_DG
							pchange_AM
                            pcomment_AM
							pchange_BM
                            pcomment_BM
							pchange_CM
                            pcomment_CM
							pchange_DM
                            pcomment_DM
							pchange_AG
pcomment_AG
           if gcode$ = 1005, strcom_AG = strparo + scomm$ + strparf, pnumligne, strcom_AG, e$
           if gcode$ = 1006, strcom_AG = scomm$, pnumligne, strcom_AG, e$
           if gcode$ = 1007, strcom_AG = strparodeux + scomm$ + strparf, pnumligne, strcom_AG, e$
           if gcode$ = 1008, strcom_AG = strparo + scomm$ + strparf, pnumligne, strcom_AG, e$
pcomment_BG

           if gcode$ = 1005, strcom_BG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_BG, e$
           if gcode$ = 1006, strcom_BG = scomm$, pnumligne, strcom_BG, e$
           if gcode$ = 1007, strcom_BG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_BG, e$
           if gcode$ = 1008, strcom_BG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_BG, e$
pcomment_CG
           if gcode$ = 1005, strcom_CG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_CG, e$
           if gcode$ = 1006, strcom_CG = scomm$, pnumligne, strcom_CG, e$
           if gcode$ = 1007, strcom_CG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_CG, e$
           if gcode$ = 1008, strcom_CG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_CG, e$
pcomment_DG
           if gcode$ = 1005, strcom_DG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_DG, e$
           if gcode$ = 1006, strcom_DG = scomm$, pnumligne, strcom_DG, e$
           if gcode$ = 1007, strcom_DG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_DG, e$
           if gcode$ = 1008, strcom_DG = strmsg + sentre_cote + scomm$ + sentre_cote + strparf, pnumligne, strcom_DG, e$
pcomment_AM
           if gcode$ = 1005, strcom_AM = strparo + scomm$ + strparf#enlevé pour concat, pnumligne, strcom_AM, e$
           if gcode$ = 1006, strcom_AM = scomm$#enlevé pour concat, pnumligne, strcom_AM, e$
           if gcode$ = 1007, strcom_AM = strparodeux + scomm$ + strparf#enlevé pour concat, pnumligne, strcom_AM, e$
           if gcode$ = 1008, strcom_AM = strparo + scomm$ + strparf#enlevé pour concat, pnumligne, strcom_AM, e$
pcomment_BM
           if gcode$ = 1005, strcom_BM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_BM, e$
           if gcode$ = 1006, strcom_BM = scomm$#enlevé pour concat, pnumligne, strcom_BM, e$
           if gcode$ = 1007, strcom_BM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_BM, e$
           if gcode$ = 1008, strcom_BM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_BM, e$
pcomment_CM
           if gcode$ = 1005, strcom_CM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_CM, e$
           if gcode$ = 1006, strcom_CM = scomm$#enlevé pour concat, pnumligne, strcom_CM, e$
           if gcode$ = 1007, strcom_CM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_CM, e$
           if gcode$ = 1008, strcom_CM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_CM, e$
pcomment_DM
           if gcode$ = 1005, strcom_DM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_DM, e$
           if gcode$ = 1006, strcom_DM = scomm$#enlevé pour concat, pnumligne, strcom_DM, e$
           if gcode$ = 1007, strcom_DM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_DM, e$
           if gcode$ = 1008, strcom_DM = strmsg + sentre_cote + scomm$ + sentre_cote + strparf#enlevé pour concat, pnumligne, strcom_DM, e$
#endregion   
#region strings multi comment
strcom_AG : ""
strcom_BG : ""
strcom_CG : ""
strcom_DG : ""
strcom_AM : ""
strcom_BM : ""
strcom_CM : ""
strcom_DM : ""
strparo : "("
strparf : ")"
strparodeux : "(2"
strmsg : "MSG("
strcroch : ""
#endregion         
#region PFR

pfr_AG        # avance
            if fr$ >= 0, *fr$

pfr_BG        # avance
            if fr$ >= 0, *fr$
            if fr$ >= 0, avance_BG = fr$

pfr_CG        # avance
            if gfr_CG = 1, fr_CG = fr$/POURCENTAGE_AVANCE_CG
            else, fr_CG = fr$*POURCENTAGE_AVANCE_CG
            if fr$ >= 0, *fr_CG
            if fr$ >= 0, avance_CG = fr_CG

pfr_DG        # avance
            if gfr_DG = 1, fr_DG = fr$/POURCENTAGE_AVANCE_DG
            else, fr_DG = fr$*POURCENTAGE_AVANCE_DG
            if fr$ >= 0, *fr_DG
            if fr$ >= 0, avance_DG = fr_DG

pfr_AM        # avance
            fr_AM = fr$	
            if fr_AM = av_plonge, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr_AM)
			if fr_AM = av_travail, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr_AM)	
            if fr$ >= 0, *fr_AM
			
pfr_BM        # avance
            fr_BM = fr$
            if fr_BM = av_plonge, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr_BM)
			if fr_BM = av_travail, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr_BM)
            if fr$ >= 0, *fr_BM
            if fr$ >= 0, avance_BM = fr$

fmt 4 av_plonge_CM
fmt 4 av_travail_CM
fmt 4 av_plonge_DM
fmt 4 av_travail_DM

fmt 10 av_plonge_5x_AM
fmt 10 av_travail_5x_AM
fmt 10 av_plonge_5x_BM
fmt 10 av_travail_5x_BM
fmt 10 av_plonge_5x_CM
fmt 10 av_travail_5x_CM
fmt 10 av_plonge_5x_DM
fmt 10 av_travail_5x_DM
pfr_CM        # avance
            if gfr_CM = 1,	[
							fr_CM = fr$/POURCENTAGE_AVANCE_CM
							av_travail_CM = av_travail/POURCENTAGE_AVANCE_CM
							av_plonge_CM = av_plonge/POURCENTAGE_AVANCE_CM	
							]
            else,	[
					fr_CM = fr$*POURCENTAGE_AVANCE_CM
					av_travail_CM = av_travail*POURCENTAGE_AVANCE_CM
					av_plonge_CM = av_plonge*POURCENTAGE_AVANCE_CM	
					]
            if fr_CM = av_plonge_CM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr_CM)
			if fr_CM = av_travail_CM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr_CM)		
            if fr$ >= 0, *fr_CM
            if fr$ >= 0, avance_CM = fr$

pfr_DM        # avance
            if gfr_DM = 1,	[
							fr_DM = fr$/POURCENTAGE_AVANCE_DM
							av_travail_DM = av_travail/POURCENTAGE_AVANCE_DM
							av_plonge_DM = av_plonge/POURCENTAGE_AVANCE_DM	
							]
            else,	[
					fr_DM = fr$*POURCENTAGE_AVANCE_DM
					av_travail_DM = av_travail*POURCENTAGE_AVANCE_DM
					av_plonge_DM = av_plonge*POURCENTAGE_AVANCE_DM	
					]
            if fr_DM = av_plonge_DM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr_DM)	
			if fr_DM = av_travail_DM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr_DM)	
            if fr$ >= 0, *fr_DM
            if fr$ >= 0, avance_DM = fr$
#endregion         
#region PFR5AXE

pfr5axe_AG  # avance en 3
           if fr5axe_AG >= 0, *fr5axe_AG

pfr5axe_BG  # avance en 3
           if fr5axe_BG >= 0, *fr5axe_BG

pfr5axe_CG  # avance en 3
           if fr5axe_CG >= 0, *fr5axe_CG

pfr5axe_DG  # avance en 3
           if fr5axe_DG >= 0, *fr5axe_DG

pfr5axe_AM  # avance en 3
           if fr5axe_AM >= 0, *fr5axe_AM

pfr5axe_BM  # avance en 3
           if fr5axe_BM >= 0, *fr5axe_BM

pfr5axe_CM  # avance en 3
           if fr5axe_CM >= 0, *fr5axe_CM

pfr5axe_DM  # avance en 3
           if fr5axe_DM >= 0, *fr5axe_DM
#endregion
#region PDMODALXYZ

pdmodalxyz_AG   # demodalise temporairement xyz
        vieuxx = xprint_AG
        vieuxy = yprint_AG
        vieuxz = zprint_AG
        @vieuxx, @vieuxy, @vieuxz
        xprint_AG = 999999
        yprint_AG = 999999
        zprint_AG = 999999
        !xprint_AG,!yprint_AG,!zprint_AG
        xprint_AG = vieuxx
        yprint_AG = vieuxy
        zprint_AG = vieuxz
         @xprint_AG,@yprint_AG,@zprint_AG

pdmodalxyz_BG   # demodalise temporairement xyz
        vieuxx = xprint_BG
        vieuxy = yprint_BG
        vieuxz = zprint_BG
        @vieuxx, @vieuxy, @vieuxz
        xprint_BG = 999999
        yprint_BG = 999999
        zprint_BG = 999999
        !xprint_BG,!yprint_BG,!zprint_BG
        xprint_BG = vieuxx
        yprint_BG = vieuxy
        zprint_BG = vieuxz
         @xprint_BG,@yprint_BG,@zprint_BG

pdmodalxyz_CG   # demodalise temporairement xyz
        vieuxx = xprint_CG
        vieuxy = yprint_CG
        vieuxz = zprint_CG
        @vieuxx, @vieuxy, @vieuxz
        xprint_CG = 999999
        yprint_CG = 999999
        zprint_CG = 999999
        !xprint_CG,!yprint_CG,!zprint_CG
        xprint_CG = vieuxx
        yprint_CG = vieuxy
        zprint_CG = vieuxz
         @xprint_CG,@yprint_CG,@zprint_CG
pdmodalxyz_DG   # demodalise temporairement xyz
        vieuxx = xprint_DG
        vieuxy = yprint_DG
        vieuxz = zprint_DG
        @vieuxx, @vieuxy, @vieuxz
        xprint_DG = 999999
        yprint_DG = 999999
        zprint_DG = 999999
        !xprint_DG,!yprint_DG,!zprint_DG
        xprint_DG = vieuxx
        yprint_DG = vieuxy
        zprint_DG = vieuxz
         @xprint_DG,@yprint_DG,@zprint_DG
pdmodalxyz_AM   # demodalise temporairement xyz
        vieuxx = xprint_AM
        vieuxy = yprint_AM
        vieuxz = zprint_AM
        @vieuxx, @vieuxy, @vieuxz
        xprint_AM = 999999
        yprint_AM = 999999
        zprint_AM = 999999
        !xprint_AM,!yprint_AM,!zprint_AM
        xprint_AM = vieuxx
        yprint_AM = vieuxy
        zprint_AM = vieuxz
         @xprint_AM,@yprint_AM,@zprint_AM

pdmodalxyz_BM   # demodalise temporairement xyz
        vieuxx = xprint_BM
        vieuxy = yprint_BM
        vieuxz = zprint_BM
        @vieuxx, @vieuxy, @vieuxz
        xprint_BM = 999999
        yprint_BM = 999999
        zprint_BM = 999999
        !xprint_BM,!yprint_BM,!zprint_BM
        xprint_BM = vieuxx
        yprint_BM = vieuxy
        zprint_BM = vieuxz
         @xprint_BM,@yprint_BM,@zprint_BM

pdmodalxyz_CM   # demodalise temporairement xyz
        vieuxx = xprint_CM
        vieuxy = yprint_CM
        vieuxz = zprint_CM
        @vieuxx, @vieuxy, @vieuxz
        xprint_CM = 999999
        yprint_CM = 999999
        zprint_CM = 999999
        !xprint_CM,!yprint_CM,!zprint_CM
        xprint_CM = vieuxx
        yprint_CM = vieuxy
        zprint_CM = vieuxz
         @xprint_CM,@yprint_CM,@zprint_CM
pdmodalxyz_DM   # demodalise temporairement xyz
        vieuxx = xprint_DM
        vieuxy = yprint_DM
        vieuxz = zprint_DM
        @vieuxx, @vieuxy, @vieuxz
        xprint_DM = 999999
        yprint_DM = 999999
        zprint_DM = 999999
        !xprint_DM,!yprint_DM,!zprint_DM
        xprint_DM = vieuxx
        yprint_DM = vieuxy
        zprint_DM = vieuxz
         @xprint_DM,@yprint_DM,@zprint_DM
#endregion
#region PESSAICOMPTEUR

pessaicompteur_AG
        difaxecpos_AG = axeCpos_AG - oldreel_axeCpos_AG
        if difaxecpos_AG < -180,comptour_AG= comptour_AG + 360
        if difaxecpos_AG > 180,  comptour_AG = comptour_AG - 360
        naxecpos_AG = axeCpos_AG + comptour_AG
        @maxi_c_AG,@mini_c_AG
        if naxecpos_AG < mini_c_AG, comptour_AG = comptour_AG + 360
        if naxecpos_AG > maxi_c_AG, comptour_AG = comptour_AG - 360
        axeCpos_AG = axeCpos_AG + comptour_AG

pessaicompteur_BG
        difaxecpos_BG = axeCpos_BG - oldreel_axeCpos_BG
        if difaxecpos_BG <   -180,comptour_BG= comptour_BG + 360
        if difaxecpos_BG > 180,  comptour_BG = comptour_BG - 360
        naxecpos_BG = axeCpos_BG + comptour_BG
        @maxi_c_BG,@mini_c_BG
        if naxecpos_BG < mini_c_BG, comptour_BG = comptour_BG + 360
        if naxecpos_BG > maxi_c_BG, comptour_BG = comptour_BG - 360
        axeCpos_BG = axeCpos_BG + comptour_BG

pessaicompteur_CG
        difaxecpos_CG = axeCpos_CG - oldreel_axeCpos_CG
        if difaxecpos_CG <   -180,comptour_CG= comptour_CG + 360
        if difaxecpos_CG > 180,  comptour_CG = comptour_CG - 360
        naxecpos_CG = axeCpos_CG + comptour_CG
        @maxi_c_CG,@mini_c_CG
        if naxecpos_CG < mini_c_CG, comptour_CG = comptour_CG + 360
        if naxecpos_CG > maxi_c_CG, comptour_CG = comptour_CG - 360
        axeCpos_CG = axeCpos_CG + comptour_CG

pessaicompteur_DG
        difaxecpos_DG = axeCpos_DG - oldreel_axeCpos_DG
        if difaxecpos_DG <   -180,comptour_DG= comptour_DG + 360
        if difaxecpos_DG > 180,  comptour_DG = comptour_DG - 360
        naxecpos_DG = axeCpos_DG + comptour_DG
        @maxi_c_DG,@mini_c_DG
        if naxecpos_DG < mini_c_DG, comptour_DG = comptour_DG + 360
        if naxecpos_DG > maxi_c_DG, comptour_DG = comptour_DG - 360
        axeCpos_DG = axeCpos_DG + comptour_DG

pessaicompteur_AM
        difaxecpos_AM = axeCpos_AM - oldreel_axeCpos_AM
        if difaxecpos_AM < -180,comptour_AM= comptour_AM + 360
        if difaxecpos_AM > 180,  comptour_AM = comptour_AM - 360
        naxecpos_AM = axeCpos_AM + comptour_AM
        @maxi_c_AM,@mini_c_AM
        if naxecpos_AM < mini_c_AM, comptour_AM = comptour_AM + 360
        if naxecpos_AM > maxi_c_AM, comptour_AM = comptour_AM - 360
        axeCpos_AM = axeCpos_AM + comptour_AM

pessaicompteur_BM
        difaxecpos_BM = axeCpos_BM - oldreel_axeCpos_BM
        if difaxecpos_BM <   -180,comptour_BM= comptour_BM + 360
        if difaxecpos_BM > 180,  comptour_BM = comptour_BM - 360
        naxecpos_BM = axeCpos_BM + comptour_BM
        @maxi_c_BM,@mini_c_BM
        if naxecpos_BM < mini_c_BM, comptour_BM = comptour_BM + 360
        if naxecpos_BM > maxi_c_BM, comptour_BM = comptour_BM - 360
        axeCpos_BM = axeCpos_BM + comptour_BM

pessaicompteur_CM
        difaxecpos_CM = axeCpos_CM - oldreel_axeCpos_CM
        if difaxecpos_CM <   -180,comptour_CM= comptour_CM + 360
        if difaxecpos_CM > 180,  comptour_CM = comptour_CM - 360
        naxecpos_CM = axeCpos_CM + comptour_CM
        @maxi_c_CM,@mini_c_CM
        if naxecpos_CM < mini_c_CM, comptour_CM = comptour_CM + 360
        if naxecpos_CM > maxi_c_CM, comptour_CM = comptour_CM - 360
        axeCpos_CM = axeCpos_CM + comptour_CM

pessaicompteur_DM
        difaxecpos_DM = axeCpos_DM - oldreel_axeCpos_DM
        if difaxecpos_DM <   -180,comptour_DM= comptour_DM + 360
        if difaxecpos_DM > 180,  comptour_DM = comptour_DM - 360
        naxecpos_DM = axeCpos_DM + comptour_DM
        @maxi_c_DM,@mini_c_DM
        if naxecpos_DM < mini_c_DM, comptour_DM = comptour_DM + 360
        if naxecpos_DM > maxi_c_DM, comptour_DM = comptour_DM - 360
        axeCpos_DM = axeCpos_DM + comptour_DM
#endregion
prot0$
prot$
#endregion

#region   CALCUL PLANS #OK
#region panul_plan_inc

panul_plan_inc_BG   # annulation plan incliner
                    pnumligne, "TRANS", e$
                    pnumligne, "ROT", e$
panul_plan_inc_CG   # annulation plan incliner
                    if blocaxe_CG = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CG = 0
                    if cycle_800 = 1, pnumligne, "CYCLE800()", e$
                    else,   [
                            pnumligne, "TRANS", e$
                            pnumligne, "ROT", e$
                            ]
panul_plan_inc_DG   # annulation plan incliner
                    if blocaxe_DG = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_DG = 0
                    if cycle_800 = 1, pnumligne, "CYCLE800()", e$
                    else,   [
                            pnumligne, "TRANS", e$
                            pnumligne, "ROT", e$
                            ]
panul_plan_inc_BM   # annulation plan incliner
                    pnumligne, "TRANS", e$
                    pnumligne, "ROT", e$
panul_plan_inc_CM   # annulation plan incliner
                    if blocaxe_CM = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CM = 0
                    if cycle_800 = 1, pnumligne, "CYCLE800()", e$
                    else,   [
                            pnumligne, "TRANS", e$
                            pnumligne, "ROT", e$
                            ]
panul_plan_inc_DM   # annulation plan incliner
                    if blocaxe_DM = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_DM = 0
                    if cycle_800 = 1, pnumligne, "CYCLE800()", e$
                    else,   [
                            pnumligne, "TRANS", e$
                            pnumligne, "ROT", e$
                            ]
#endregion
#region pafichecala

pafichecala_AG   # routine pour trouver bonne angle a
                axeApos_AG = atan2(new_m8,m9print)
                "voir axeC_AG solution1=",*axeApos_AG, e$
                axeApos_AG = atan2(-new_m8,m9print)
                "voir axeC_AG solution2=",*axeApos_AG, e$
                axeApos_AG = atan2(new_m8,-m9print)
                "voir axeC_AG solution3=",*axeApos_AG, e$
                axeApos_AG = atan2(-new_m8,-m9print)
                "voir axeC_AG solution4=",*axeApos_AG, e$
                axeApos_AG = atan2(m9print,new_m8)
                "voir axeC_AG solution5=",*axeApos_AG, e$
                axeApos_AG = atan2(-m9print,new_m8)
                "voir axeC_AG solution6=",*axeApos_AG, e$
                axeApos_AG = atan2(m9print,-new_m8)
                "voir axeC_AG solution7=",*axeApos_AG, e$
                axeApos_AG = atan2(-m9print,-new_m8)
                "voir axeC_AG solution8=",*axeApos_AG, e$

pafichecala_BG   # routine pour trouver bonne angle a
                axeApos_BG = atan2(new_m8,m9print)
                "voir axeC_BG solution1=",*axeApos_BG, e$
                axeApos_BG = atan2(-new_m8,m9print)
                "voir axeC_BG solution2=",*axeApos_BG, e$
                axeApos_BG = atan2(new_m8,-m9print)
                "voir axeC_BG solution3=",*axeApos_BG, e$
                axeApos_BG = atan2(-new_m8,-m9print)
                "voir axeC_BG solution4=",*axeApos_BG, e$
                axeApos_BG = atan2(m9print,new_m8)
                "voir axeC_BG solution5=",*axeApos_BG, e$
                axeApos_BG = atan2(-m9print,new_m8)
                "voir axeC_BG solution6=",*axeApos_BG, e$
                axeApos_BG = atan2(m9print,-new_m8)
                "voir axeC_BG solution7=",*axeApos_BG, e$
                axeApos_BG = atan2(-m9print,-new_m8)
                "voir axeC_BG solution8=",*axeApos_BG, e$

pafichecala_CG   # routine pour trouver bonne angle a
                axeApos_CG = atan2(new_m8,m9print)
                "voir axeC_CG solution1=",*axeApos_CG, e$
                axeApos_CG = atan2(-new_m8,m9print)
                "voir axeC_CG solution2=",*axeApos_CG, e$
                axeApos_CG = atan2(new_m8,-m9print)
                "voir axeC_CG solution3=",*axeApos_CG, e$
                axeApos_CG = atan2(-new_m8,-m9print)
                "voir axeC_CG solution4=",*axeApos_CG, e$
                axeApos_CG = atan2(m9print,new_m8)
                "voir axeC_CG solution5=",*axeApos_CG, e$
                axeApos_CG = atan2(-m9print,new_m8)
                "voir axeC_CG solution6=",*axeApos_CG, e$
                axeApos_CG = atan2(m9print,-new_m8)
                "voir axeC_CG solution7=",*axeApos_CG, e$
                axeApos_CG = atan2(-m9print,-new_m8)
                "voir axeC_CG solution8=",*axeApos_CG, e$

pafichecala_DG   # routine pour trouver bonne angle a
                axeApos_DG = atan2(new_m8,m9print)
                "voir axeC_DG solution1=",*axeApos_DG, e$
                axeApos_DG = atan2(-new_m8,m9print)
                "voir axeC_DG solution2=",*axeApos_DG, e$
                axeApos_DG = atan2(new_m8,-m9print)
                "voir axeC_DG solution3=",*axeApos_DG, e$
                axeApos_DG = atan2(-new_m8,-m9print)
                "voir axeC_DG solution4=",*axeApos_DG, e$
                axeApos_DG = atan2(m9print,new_m8)
                "voir axeC_DG solution5=",*axeApos_DG, e$
                axeApos_DG = atan2(-m9print,new_m8)
                "voir axeC_DG solution6=",*axeApos_DG, e$
                axeApos_DG = atan2(m9print,-new_m8)
                "voir axeC_DG solution7=",*axeApos_DG, e$
                axeApos_DG = atan2(-m9print,-new_m8)
                "voir axeC_DG solution8=",*axeApos_DG, e$

pafichecala_AM   # routine pour trouver bonne angle a
                axeApos_AM = atan2(new_m8,m9print)
                "voir axeC_AM solution1=",*axeApos_AM, e$
                axeApos_AM = atan2(-new_m8,m9print)
                "voir axeC_AM solution2=",*axeApos_AM, e$
                axeApos_AM = atan2(new_m8,-m9print)
                "voir axeC_AM solution3=",*axeApos_AM, e$
                axeApos_AM = atan2(-new_m8,-m9print)
                "voir axeC_AM solution4=",*axeApos_AM, e$
                axeApos_AM = atan2(m9print,new_m8)
                "voir axeC_AM solution5=",*axeApos_AM, e$
                axeApos_AM = atan2(-m9print,new_m8)
                "voir axeC_AM solution6=",*axeApos_AM, e$
                axeApos_AM = atan2(m9print,-new_m8)
                "voir axeC_AM solution7=",*axeApos_AM, e$
                axeApos_AM = atan2(-m9print,-new_m8)
                "voir axeC_AM solution8=",*axeApos_AM, e$

pafichecala_BM   # routine pour trouver bonne angle a
                axeApos_BM = atan2(new_m8,m9print)
                "voir axeC_BM solution1=",*axeApos_BM, e$
                axeApos_BM = atan2(-new_m8,m9print)
                "voir axeC_BM solution2=",*axeApos_BM, e$
                axeApos_BM = atan2(new_m8,-m9print)
                "voir axeC_BM solution3=",*axeApos_BM, e$
                axeApos_BM = atan2(-new_m8,-m9print)
                "voir axeC_BM solution4=",*axeApos_BM, e$
                axeApos_BM = atan2(m9print,new_m8)
                "voir axeC_BM solution5=",*axeApos_BM, e$
                axeApos_BM = atan2(-m9print,new_m8)
                "voir axeC_BM solution6=",*axeApos_BM, e$
                axeApos_BM = atan2(m9print,-new_m8)
                "voir axeC_BM solution7=",*axeApos_BM, e$
                axeApos_BM = atan2(-m9print,-new_m8)
                "voir axeC_BM solution8=",*axeApos_BM, e$

pafichecala_CM   # routine pour trouver bonne angle a
                axeApos_CM = atan2(new_m8,m9print)
                "voir axeC_CM solution1=",*axeApos_CM, e$
                axeApos_CM = atan2(-new_m8,m9print)
                "voir axeC_CM solution2=",*axeApos_CM, e$
                axeApos_CM = atan2(new_m8,-m9print)
                "voir axeC_CM solution3=",*axeApos_CM, e$
                axeApos_CM = atan2(-new_m8,-m9print)
                "voir axeC_CM solution4=",*axeApos_CM, e$
                axeApos_CM = atan2(m9print,new_m8)
                "voir axeC_CM solution5=",*axeApos_CM, e$
                axeApos_CM = atan2(-m9print,new_m8)
                "voir axeC_CM solution6=",*axeApos_CM, e$
                axeApos_CM = atan2(m9print,-new_m8)
                "voir axeC_CM solution7=",*axeApos_CM, e$
                axeApos_CM = atan2(-m9print,-new_m8)
                "voir axeC_CM solution8=",*axeApos_CM, e$

pafichecala_DM   # routine pour trouver bonne angle a
                axeApos_DM = atan2(new_m8,m9print)
                "voir axeC_DM solution1=",*axeApos_DM, e$
                axeApos_DM = atan2(-new_m8,m9print)
                "voir axeC_DM solution2=",*axeApos_DM, e$
                axeApos_DM = atan2(new_m8,-m9print)
                "voir axeC_DM solution3=",*axeApos_DM, e$
                axeApos_DM = atan2(-new_m8,-m9print)
                "voir axeC_DM solution4=",*axeApos_DM, e$
                axeApos_DM = atan2(m9print,new_m8)
                "voir axeC_DM solution5=",*axeApos_DM, e$
                axeApos_DM = atan2(-m9print,new_m8)
                "voir axeC_DM solution6=",*axeApos_DM, e$
                axeApos_DM = atan2(m9print,-new_m8)
                "voir axeC_DM solution7=",*axeApos_DM, e$
                axeApos_DM = atan2(-m9print,-new_m8)
                "voir axeC_DM solution8=",*axeApos_DM, e$
#endregion  
#region pafichecalc

pafichecalc_AG   # routine pour trouver bonne angle c
                " voir solution de base = ",axeCpos_AG, e$
                "-----------------------", e$
                axeCpos_AG = atan2(m7print,m8print)
                "voir axeC_AG solution1=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m7print,-m8print)
                "voir axeC_AG solution2=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m7print,m8print)
                "voir axeC_AG solution3=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m7print,-m8print)
                "voir axeC_AG solution4=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m8print,m7print)
                "voir axeC_AG solution5=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m8print,m7print)
                "voir axeC_AG solution6=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m8print,-m7print)
                "voir axeC_AG solution7=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m8print,-m7print)
                "voir axeC_AG solution8=",*axeCpos_AG, e$
                "-----------------------", e$
pafichecalc_BG   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_BG, e$
                "-----------------------", e$

                axeCpos_BG = atan2(m7print,m8print)
                "voir axeC_BG solution1=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m7print,-m8print)
                "voir axeC_BG solution2=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m7print,m8print)
                "voir axeC_BG solution3=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m7print,-m8print)
                "voir axeC_BG solution4=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m8print,m7print)
                "voir axeC_BG solution5=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m8print,m7print)
                "voir axeC_BG solution6=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m8print,-m7print)
                "voir axeC_BG solution7=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m8print,-m7print)
                "voir axeC_BG solution8=",*axeCpos_BG, e$
                "-----------------------", e$
pafichecalc_CG   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_CG, e$
                "-----------------------", e$

                axeCpos_CG = atan2(m7print,m8print)
                "voir axeC_CG solution1=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m7print,-m8print)
                "voir axeC_CG solution2=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m7print,m8print)
                "voir axeC_CG solution3=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m7print,-m8print)
                "voir axeC_CG solution4=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m8print,m7print)
                "voir axeC_CG solution5=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m8print,m7print)
                "voir axeC_CG solution6=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m8print,-m7print)
                "voir axeC_CG solution7=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m8print,-m7print)
                "voir axeC_CG solution8=",*axeCpos_CG, e$
                "-----------------------", e$

pafichecalc_DG   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_DG, e$
                "-----------------------", e$

                axeCpos_DG = atan2(m7print,m8print)
                "voir axeC_DG solution1=",*axeCpos_DG, e$
                axeCpos_DG = atan2(m7print,-m8print)
                "voir axeC_DG solution2=",*axeCpos_DG, e$
                axeCpos_DG = atan2(-m7print,m8print)
                "voir axeC_DG solution3=",*axeCpos_DG, e$
                axeCpos_DG = atan2(-m7print,-m8print)
                "voir axeC_DG solution4=",*axeCpos_DG, e$
                axeCpos_DG = atan2(m8print,m7print)
                "voir axeC_DG solution5=",*axeCpos_DG, e$
                axeCpos_DG = atan2(-m8print,m7print)
                "voir axeC_DG solution6=",*axeCpos_DG, e$
                axeCpos_DG = atan2(m8print,-m7print)
                "voir axeC_DG solution7=",*axeCpos_DG, e$
                axeCpos_DG = atan2(-m8print,-m7print)
                "voir axeC_DG solution8=",*axeCpos_DG, e$
                "-----------------------", e$

pafichecalc_AM   # routine pour trouver bonne angle c
                " voir solution de base = ",axeCpos_AM, e$
                "-----------------------", e$
                axeCpos_AM = atan2(m7print,m8print)
                "voir axeC_AM solution1=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m7print,-m8print)
                "voir axeC_AM solution2=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m7print,m8print)
                "voir axeC_AM solution3=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m7print,-m8print)
                "voir axeC_AM solution4=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m8print,m7print)
                "voir axeC_AM solution5=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m8print,m7print)
                "voir axeC_AM solution6=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m8print,-m7print)
                "voir axeC_AM solution7=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m8print,-m7print)
                "voir axeC_AM solution8=",*axeCpos_AM, e$
                "-----------------------", e$
pafichecalc_BM   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_BM, e$
                "-----------------------", e$

                axeCpos_BM = atan2(m7print,m8print)
                "voir axeC_BM solution1=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m7print,-m8print)
                "voir axeC_BM solution2=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m7print,m8print)
                "voir axeC_BM solution3=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m7print,-m8print)
                "voir axeC_BM solution4=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m8print,m7print)
                "voir axeC_BM solution5=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m8print,m7print)
                "voir axeC_BM solution6=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m8print,-m7print)
                "voir axeC_BM solution7=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m8print,-m7print)
                "voir axeC_BM solution8=",*axeCpos_BM, e$
                "-----------------------", e$
pafichecalc_CM   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_CM, e$
                "-----------------------", e$

                axeCpos_CM = atan2(m7print,m8print)
                "voir axeC_CM solution1=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m7print,-m8print)
                "voir axeC_CM solution2=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m7print,m8print)
                "voir axeC_CM solution3=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m7print,-m8print)
                "voir axeC_CM solution4=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m8print,m7print)
                "voir axeC_CM solution5=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m8print,m7print)
                "voir axeC_CM solution6=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m8print,-m7print)
                "voir axeC_CM solution7=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m8print,-m7print)
                "voir axeC_CM solution8=",*axeCpos_CM, e$
                "-----------------------", e$
pafichecalc_DM   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_DM, e$
                "-----------------------", e$

                axeCpos_DM = atan2(m7print,m8print)
                "voir axeC_DM solution1=",*axeCpos_DM, e$
                axeCpos_DM = atan2(m7print,-m8print)
                "voir axeC_DM solution2=",*axeCpos_DM, e$
                axeCpos_DM = atan2(-m7print,m8print)
                "voir axeC_DM solution3=",*axeCpos_DM, e$
                axeCpos_DM = atan2(-m7print,-m8print)
                "voir axeC_DM solution4=",*axeCpos_DM, e$
                axeCpos_DM = atan2(m8print,m7print)
                "voir axeC_DM solution5=",*axeCpos_DM, e$
                axeCpos_DM = atan2(-m8print,m7print)
                "voir axeC_DM solution6=",*axeCpos_DM, e$
                axeCpos_DM = atan2(m8print,-m7print)
                "voir axeC_DM solution7=",*axeCpos_DM, e$
                axeCpos_DM = atan2(-m8print,-m7print)
                "voir axeC_DM solution8=",*axeCpos_DM, e$
                "-----------------------", e$
#endregion
#region prot1

prot1_AG        # Calcul des angles
                # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
                #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_AG, @maxi_a_AG, @mini_c_AG, @maxi_c_AG, @nbt_AG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_AG = atan2(m2print,m1print) 
                #"voir axeC_AG solution old=",*axeCpos_AG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_AG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_AG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0,axeCpos_AG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_AG = 0
                ]
                reel_axeCpos_AG = axeCpos_AG
                new_m8 = m8print * cos(axeCpos_AG) - m7print * sin(axeCpos_AG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0, axeApos_AG = atan2(-new_m8,-m9print) # pafichecala_AG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_AG = 90 # pas d'angle sur a
                else,  axeApos_AG = atan2(m9print,new_m8)
                ]
               !axeApos_AG
               if axeApos_AG > 270, axeApos_AG = axeApos_AG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_AG = axeApos_AG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_AG = axeCpos_AG

               axeApos1_AG = axeApos_AG
               if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
               if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AG = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_AG = 1,
               [
                axeApos1_AG = axeApos1_AG *  -1
                if axeCpos1_AG >= 180, axeCpos1_AG = axeCpos1_AG - 180
                else, axeCpos1_AG = axeCpos1_AG + 180
               ]
               if mi1_C_base_AG =  2, axeCpos1_AG = axeCpos1_AG - 360
               !axeApos_AG, !new_m8, !axeCpos_AG         #actualise les variable
               if axeApos_AG > maxi_a_AG | axeApos_AG < mini_a_AG, psortie10_AG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a       

prot1_BG     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_BG, @maxi_a_BG, @mini_c_BG, @maxi_c_BG, @nbt_BG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_BG = atan2(m2print,m1print) 
                #"voir axeC_BG solution old=",*axeCpos_BG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_BG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_BG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_BG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_BG = 0
                ]
                reel_axeCpos_BG = axeCpos_BG
                new_m8 = m8print * cos(axeCpos_BG) - m7print * sin(axeCpos_BG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_BG = atan2(-new_m8,-m9print) # pafichecala_BG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_BG = 90 # pas d'angle sur a
                else,  axeApos_BG = atan2(m9print,new_m8)
                ]
               !axeApos_BG
               if axeApos_BG > 270, axeApos_BG = axeApos_BG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_BG = axeApos_BG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_BG = axeCpos_BG
               axeApos1_BG = axeApos_BG
               if tete_rev_ang_droite = 1, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_BG = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_BG = 1,
               [
                axeApos1_BG = axeApos1_BG *  -1
                if axeCpos1_BG >= 180, axeCpos1_BG = axeCpos1_BG - 180
                else, axeCpos1_BG = axeCpos1_BG + 180
               ]
               if mi1_C_base_BG =  2, axeCpos1_BG = axeCpos1_BG - 360
               !axeApos_BG, !new_m8, !axeCpos_BG         #actualise les variable
               if axeApos_BG > maxi_a_BG | axeApos_BG < mini_a_BG, psortie10_BG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 

prot1_CG     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_CG, @maxi_a_CG, @mini_c_CG, @maxi_c_CG, @nbt_CG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_CG = atan2(m2print,m1print) 
                #"voir axeC_CG solution old=",*axeCpos_CG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_CG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_CG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_CG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CG = 0
                ]
                reel_axeCpos_CG = axeCpos_CG
                new_m8 = m8print * cos(axeCpos_CG) - m7print * sin(axeCpos_CG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_CG = atan2(-new_m8,-m9print) # pafichecala_CG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_CG = 90 # pas d'angle sur a
                else,  axeApos_CG = atan2(m9print,new_m8)
                ]
               !axeApos_CG
               if axeApos_CG > 270, axeApos_CG = axeApos_CG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_CG = axeApos_CG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_CG = axeCpos_CG - 90
               axeApos1_CG = axeApos_CG
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CG = 0, axeCpos1_CG = 0
               if tete_rev_ang_droite = 1, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_CG = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_CG = 1,
               [
                axeApos1_CG = axeApos1_CG *  -1
                if axeCpos1_CG >= 180, axeCpos1_CG = axeCpos1_CG - 180
                else, axeCpos1_CG = axeCpos1_CG + 180
               ]
               if mi1_C_base_CG =  2, axeCpos1_CG = axeCpos1_CG - 360
               !axeApos_CG, !new_m8, !axeCpos_CG         #actualise les variable
               if axeApos_CG > maxi_a_CG | axeApos_CG < mini_a_CG, psortie10_CG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 

prot1_DG     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_DG, @maxi_a_DG, @mini_c_DG, @maxi_c_DG, @nbt_DG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_DG = atan2(m2print,m1print) 
                #"voir axeC_DG solution old=",*axeCpos_DG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_DG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_DG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_DG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_DG = 0
                ]
                reel_axeCpos_DG = axeCpos_DG
                new_m8 = m8print * cos(axeCpos_DG) - m7print * sin(axeCpos_DG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_DG = atan2(-new_m8,-m9print) # pafichecala_DG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_DG = 90 # pas d'angle sur a
                else,  axeApos_DG = atan2(m9print,new_m8)
                ]
               !axeApos_DG
               if axeApos_DG > 270, axeApos_DG = axeApos_DG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_DG = axeApos_DG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_DG = axeCpos_DG - 90
               axeApos1_DG = axeApos_DG
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_DG = 0, axeCpos1_DG = 0
               if tete_rev_ang_droite = 1, invers_DG = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_DG = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_DG = 1,
               [
                axeApos1_DG = axeApos1_DG *  -1
                if axeCpos1_DG >= 180, axeCpos1_DG = axeCpos1_DG - 180
                else, axeCpos1_DG = axeCpos1_DG + 180
               ]
               if mi1_C_base_DG =  2, axeCpos1_DG = axeCpos1_DG - 360
               !axeApos_DG, !new_m8, !axeCpos_DG         #actualise les variable
               if axeApos_DG > maxi_a_DG | axeApos_DG < mini_a_DG, psortie10_DG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_DG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_DG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a              
prot1_AM        # Calcul des angles
                # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
                #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_AM, @maxi_a_AM, @mini_c_AM, @maxi_c_AM, @nbt_AG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_AM = atan2(m2print,m1print) 
                #"voir axeC_AM solution old=",*axeCpos_AM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_AM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_AM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0,axeCpos_AM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_AM = 0
                ]
                reel_axeCpos_AM = axeCpos_AM
                new_m8 = m8print * cos(axeCpos_AM) - m7print * sin(axeCpos_AM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0, axeApos_AM = atan2(-new_m8,-m9print) # pafichecala_AM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_AM = 90 # pas d'angle sur a
                else,  axeApos_AM = atan2(m9print,new_m8)
                ]
               !axeApos_AM
               if axeApos_AM > 270, axeApos_AM = axeApos_AM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_AM = axeApos_AM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_AM = axeCpos_AM
               axeApos1_AM = axeApos_AM

               if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
               if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AM = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_AM = 1,
               [
                axeApos1_AM = axeApos1_AM *  -1
                if axeCpos1_AM >= 180, axeCpos1_AM = axeCpos1_AM - 180
                else, axeCpos1_AM = axeCpos1_AM + 180
               ]
               if mi1_C_base_AM =  2, axeCpos1_AM = axeCpos1_AM - 360
               !axeApos_AM, !new_m8, !axeCpos_AM         #actualise les variable
               if axeApos_AM > maxi_a_AM | axeApos_AM < mini_a_AM, psortie10_AM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a       

prot1_BM     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_BM, @maxi_a_BM, @mini_c_BM, @maxi_c_BM, @nbt_BG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_BM = atan2(m2print,m1print) 
                #"voir axeC_BM solution old=",*axeCpos_BM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_BM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_BM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_BM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_BM = 0
                ]
                reel_axeCpos_BM = axeCpos_BM
                new_m8 = m8print * cos(axeCpos_BM) - m7print * sin(axeCpos_BM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_BM = atan2(-new_m8,-m9print) # pafichecala_BM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_BM = 90 # pas d'angle sur a
                else,  axeApos_BM = atan2(m9print,new_m8)
                ]
               !axeApos_BM
               if axeApos_BM > 270, axeApos_BM = axeApos_BM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_BM = axeApos_BM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_BM = axeCpos_BM
               axeApos1_BM = axeApos_BM
               if tete_rev_ang_droite = 1, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_BM = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_BM = 1,
               [
                axeApos1_BM = axeApos1_BM *  -1
                if axeCpos1_BM >= 180, axeCpos1_BM = axeCpos1_BM - 180
                else, axeCpos1_BM = axeCpos1_BM + 180
               ]
               if mi1_C_base_BM =  2, axeCpos1_BM = axeCpos1_BM - 360
               !axeApos_BM, !new_m8, !axeCpos_BM         #actualise les variable
               if axeApos_BM > maxi_a_BM | axeApos_BM < mini_a_BM, psortie10_BM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 

prot1_CM     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_CM, @maxi_a_CM, @mini_c_CM, @maxi_c_CM, @nbt_CG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_CM = atan2(m2print,m1print) 
                #"voir axeC_CM solution old=",*axeCpos_CM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_CM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_CM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_CM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CM = 0
                ]
                reel_axeCpos_CM = axeCpos_CM
                new_m8 = m8print * cos(axeCpos_CM) - m7print * sin(axeCpos_CM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_CM = atan2(-new_m8,-m9print) # pafichecala_CM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_CM = 90 # pas d'angle sur a
                else,  axeApos_CM = atan2(m9print,new_m8)
                ]
               !axeApos_CM
               if axeApos_CM > 270, axeApos_CM = axeApos_CM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_CM = axeApos_CM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_CM = axeCpos_CM - 90
               axeApos1_CM = axeApos_CM
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CM = 0, axeCpos1_CM = 0
               if tete_rev_ang_droite = 1, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_CM = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_CM = 1,
               [
                axeApos1_CM = axeApos1_CM *  -1
                if axeCpos1_CM >= 180, axeCpos1_CM = axeCpos1_CM - 180
                else, axeCpos1_CM = axeCpos1_CM + 180
               ]
               if mi1_C_base_CM =  2, axeCpos1_CM = axeCpos1_CM - 360
               !axeApos_CM, !new_m8, !axeCpos_CM         #actualise les variable
               if axeApos_CM > maxi_a_CM | axeApos_CM < mini_a_CM, psortie10_CM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a

prot1_DM     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_DM, @maxi_a_DM, @mini_c_DM, @maxi_c_DM, @nbt_CG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_DM = atan2(m2print,m1print) 
                #"voir axeC_DM solution old=",*axeCpos_DM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_DM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_DM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_DM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_DM = 0
                ]
                reel_axeCpos_DM = axeCpos_DM
                new_m8 = m8print * cos(axeCpos_DM) - m7print * sin(axeCpos_DM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_DM = atan2(-new_m8,-m9print) # pafichecala_DM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_DM = 90 # pas d'angle sur a
                else,  axeApos_DM = atan2(m9print,new_m8)
                ]
               !axeApos_DM
               if axeApos_DM > 270, axeApos_DM = axeApos_DM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_DM = axeApos_DM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_DM = axeCpos_DM - 90
               axeApos1_DM = axeApos_DM
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_DM = 0, axeCpos1_DM = 0
               if tete_rev_ang_droite = 1, invers_DM = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers_DM = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers_DM = 1,
               [
                axeApos1_DM = axeApos1_DM *  -1
                if axeCpos1_DM >= 180, axeCpos1_DM = axeCpos1_DM - 180
                else, axeCpos1_DM = axeCpos1_DM + 180
               ]
               if mi1_C_base_DM =  2, axeCpos1_DM = axeCpos1_DM - 360
               !axeApos_DM, !new_m8, !axeCpos_DM         #actualise les variable
               if axeApos_DM > maxi_a_DM | axeApos_DM < mini_a_DM, psortie10_DM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_DM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_DM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a              
#endregion
pmiscparam$
#region pcalxyz3d_renvoi

pcalxyz3d_renvoi_AG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_AG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_AG) - m7$ * sin(axeCpos_AG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_AG = atan2(m9$,new_m8)
        if axeApos_AG > 270, axeApos_AG = axeApos_AG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_AG = axeApos_AG - 90
        axeacal = (90 - axeApos_AG)
        axeccal = axeCpos_AG + 270
        #"voir les rapide", *xprint_AG, *yprint_AG, *zprint_AG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_AG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_AG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]


        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AG",*z1_AG,e

        x3dprint_AG = x1 + tox4print_AG
        y3dprint_AG = y2 + toy4print_AG
        z3dprint_AG = z1_AG + toz4print_AG

        prot1_AG   # remise a jour des angles

pcalxyz3d_renvoi_BG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_BG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_BG) - m7$ * sin(axeCpos_BG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_BG = atan2(m9$,new_m8)
        if axeApos_BG > 270, axeApos_BG = axeApos_BG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_BG = axeApos_BG - 90
        axeacal = (90 - axeApos_BG)
        axeccal = axeCpos_BG + 270
        #"voir les rapide", *xprint_BG, *yprint_BG, *zprint_BG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_BG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_BG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_BG = x1 + tox4print_BG
        y3dprint_BG = y2 + toy4print_BG
        z3dprint_BG = z1_BG + toz4print_BG

        prot1_BG   # remise a jour des angles 

pcalxyz3d_renvoi_CG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_CG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_CG) - m7$ * sin(axeCpos_CG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_CG = atan2(m9$,new_m8)
        if axeApos_CG > 270, axeApos_CG = axeApos_CG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_CG = axeApos_CG - 90
        axeacal = (90 - axeApos_CG)
        axeccal = axeCpos_CG + 270
        #"voir les rapide", *xprint_CG, *yprint_CG, *zprint_CG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_CG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_CG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_CG = x1 + tox4print_CG
        y3dprint_CG = y2 + toy4print_CG
        z3dprint_CG = z1_CG + toz4print_CG

        prot1_CG   # remise a jour des angles 

pcalxyz3d_renvoi_DG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_DG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_DG) - m7$ * sin(axeCpos_DG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_DG = atan2(m9$,new_m8)
        if axeApos_DG > 270, axeApos_DG = axeApos_DG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_DG = axeApos_DG - 90
        axeacal = (90 - axeApos_DG)
        axeccal = axeCpos_DG + 270
        #"voir les rapide", *xprint_DG, *yprint_DG, *zprint_DG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_DG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_DG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_DG = x1 + tox4print_DG
        y3dprint_DG = y2 + toy4print_DG
        z3dprint_DG = z1_DG + toz4print_DG

        prot1_DG   # remise a jour des angles 

pcalxyz3d_renvoi_AM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_AM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_AM) - m7$ * sin(axeCpos_AM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_AM = atan2(m9$,new_m8)
        if axeApos_AM > 270, axeApos_AM = axeApos_AM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_AM = axeApos_AM - 90
        axeacal = (90 - axeApos_AM)
        axeccal = axeCpos_AM + 270
        #"voir les rapide", *xprint_AM, *yprint_AM, *zprint_AM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_AM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_AM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]


        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AM",*z1_AM,e

        x3dprint_AM = x1 + tox4print_AM
        y3dprint_AM = y2 + toy4print_AM
        z3dprint_AM = z1_AM + toz4print_AM

        prot1_AM   # remise a jour des angles

pcalxyz3d_renvoi_BM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_BM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_BM) - m7$ * sin(axeCpos_BM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_BM = atan2(m9$,new_m8)
        if axeApos_BM > 270, axeApos_BM = axeApos_BM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_BM = axeApos_BM - 90
        axeacal = (90 - axeApos_BM)
        axeccal = axeCpos_BM + 270
        #"voir les rapide", *xprint_BM, *yprint_BM, *zprint_BM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_BM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_BM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_BM = x1 + tox4print_BM
        y3dprint_BM = y2 + toy4print_BM
        z3dprint_BM = z1_BM + toz4print_BM

        prot1_BM   # remise a jour des angles 

pcalxyz3d_renvoi_CM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_CM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_CM) - m7$ * sin(axeCpos_CM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_CM = atan2(m9$,new_m8)
        if axeApos_CM > 270, axeApos_CM = axeApos_CM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_CM = axeApos_CM - 90
        axeacal = (90 - axeApos_CM)
        axeccal = axeCpos_CM + 270
        #"voir les rapide", *xprint_CM, *yprint_CM, *zprint_CM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_CM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_CM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_CM = x1 + tox4print_CM
        y3dprint_CM = y2 + toy4print_CM
        z3dprint_CM = z1_CM + toz4print_CM

        prot1_CM   # remise a jour des angles

pcalxyz3d_renvoi_DM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_DM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_DM) - m7$ * sin(axeCpos_DM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_DM = atan2(m9$,new_m8)
        if axeApos_DM > 270, axeApos_DM = axeApos_DM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_DM = axeApos_DM - 90
        axeacal = (90 - axeApos_DM)
        axeccal = axeCpos_DM + 270
        #"voir les rapide", *xprint_DM, *yprint_DM, *zprint_DM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_DM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_DM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_DM = x1 + tox4print_DM
        y3dprint_DM = y2 + toy4print_DM
        z3dprint_DM = z1_DM + toz4print_DM

        prot1_DM   # remise a jour des angles       
#endregion
#region pcalxyz3d_normal

pcalxyz3d_normal_AG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_AG)
        axeccal = axeCpos_AG + 270
        #"voir les rapide", *xprint_AG, *yprint_AG, *zprint_AG, e$
        y1 =   zrprint_AG * cos(axeacal) - yrprint_AG * sin(axeacal)
        z1_AG =   zrprint_AG * sin(axeacal) + yrprint_AG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_AG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_AG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AG",*z1_AG,e

        x3dprint_AG = x1 + tox4print_AG
        y3dprint_AG = y2 + toy4print_AG
        z3dprint_AG = z1_AG + toz4print_AG

pcalxyz3d_normal_BG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_BG)
        axeccal = axeCpos_BG + 270
        #"voir les rapide", *xprint_BG, *yprint_BG, *zprint_BG, e$
        y1 =   zrprint_BG * cos(axeacal) - yrprint_BG * sin(axeacal)
        z1_BG =   zrprint_BG * sin(axeacal) + yrprint_BG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_BG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_BG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_BG",*z1_BG,e

        x3dprint_BG = x1 + tox4print_BG
        y3dprint_BG = y2 + toy4print_BG
        z3dprint_BG = z1_BG + toz4print_BG

pcalxyz3d_normal_CG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_CG)
        axeccal = axeCpos_CG + 270
        #"voir les rapide", *xprint_CG, *yprint_CG, *zprint_CG, e$
        y1 =   zrprint_CG * cos(axeacal) - yrprint_CG * sin(axeacal)
        z1_CG =   zrprint_CG * sin(axeacal) + yrprint_CG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_CG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_CG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_CG",*z1_CG,e

        x3dprint_CG = x1 + tox4print_CG
        y3dprint_CG = y2 + toy4print_CG
        z3dprint_CG = z1_CG + toz4print_CG

pcalxyz3d_normal_DG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_DG)
        axeccal = axeCpos_DG + 270
        #"voir les rapide", *xprint_DG, *yprint_DG, *zprint_DG, e$
        y1 =   zrprint_DG * cos(axeacal) - yrprint_DG * sin(axeacal)
        z1_DG =   zrprint_DG * sin(axeacal) + yrprint_DG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_DG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_DG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_DG",*z1_DG,e

        x3dprint_DG = x1 + tox4print_DG
        y3dprint_DG = y2 + toy4print_DG
        z3dprint_DG = z1_DG + toz4print_DG

pcalxyz3d_normal_AM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_AM)
        axeccal = axeCpos_AM + 270
        #"voir les rapide", *xprint_AM, *yprint_AM, *zprint_AM, e$
        y1 =   zrprint_AM * cos(axeacal) - yrprint_AM * sin(axeacal)
        z1_AM =   zrprint_AM * sin(axeacal) + yrprint_AM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_AM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_AM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AM",*z1_AM,e

        x3dprint_AM = x1 + tox4print_AM
        y3dprint_AM = y2 + toy4print_AM
        z3dprint_AM = z1_AM + toz4print_AM

pcalxyz3d_normal_BM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_BM)
        axeccal = axeCpos_BM + 270
        #"voir les rapide", *xprint_BM, *yprint_BM, *zprint_BM, e$
        y1 =   zrprint_BM * cos(axeacal) - yrprint_BM * sin(axeacal)
        z1_BM =   zrprint_BM * sin(axeacal) + yrprint_BM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_BM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_BM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_BM",*z1_BM,e

        x3dprint_BM = x1 + tox4print_BM
        y3dprint_BM = y2 + toy4print_BM
        z3dprint_BM = z1_BM + toz4print_BM

pcalxyz3d_normal_CM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_CM)
        axeccal = axeCpos_CM + 270
        #"voir les rapide", *xprint_CM, *yprint_CM, *zprint_CM, e$
        y1 =   zrprint_CM * cos(axeacal) - yrprint_CM * sin(axeacal)
        z1_CM =   zrprint_CM * sin(axeacal) + yrprint_CM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_CM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_CM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_CM",*z1_CM,e

        x3dprint_CM = x1 + tox4print_CM
        y3dprint_CM = y2 + toy4print_CM
        z3dprint_CM = z1_CM + toz4print_CM

pcalxyz3d_normal_DM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_DM)
        axeccal = axeCpos_DM + 270
        #"voir les rapide", *xprint_DM, *yprint_DM, *zprint_DM, e$
        y1 =   zrprint_DM * cos(axeacal) - yrprint_DM * sin(axeacal)
        z1_DM =   zrprint_DM * sin(axeacal) + yrprint_DM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_DM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_DM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_DM",*z1_DM,e

        x3dprint_DM = x1 + tox4print_DM
        y3dprint_DM = y2 + toy4print_DM
        z3dprint_DM = z1_DM + toz4print_DM
#endregion
#region pcalxyz3d

pcalxyz3d_AG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_AG = 1, pcalxyz3d_renvoi_AG
        else, pcalxyz3d_normal_AG

pcalxyz3d_BG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_BG = 1, pcalxyz3d_renvoi_BG
        else, pcalxyz3d_normal_BG

pcalxyz3d_CG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_CG = 1, pcalxyz3d_renvoi_CG
        else, pcalxyz3d_normal_CG

pcalxyz3d_DG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_DG = 1, pcalxyz3d_renvoi_DG
        else, pcalxyz3d_normal_DG

pcalxyz3d_AM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_AM = 1, pcalxyz3d_renvoi_AM
        else, pcalxyz3d_normal_AM

pcalxyz3d_BM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_BM = 1, pcalxyz3d_renvoi_BM
        else, pcalxyz3d_normal_BM

pcalxyz3d_CM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_CM = 1, pcalxyz3d_renvoi_CM
        else, pcalxyz3d_normal_CM

pcalxyz3d_DM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_DM = 1, pcalxyz3d_renvoi_DM
        else, pcalxyz3d_normal_DM
#endregion
#region prot2

prot2_AG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_AG
            # if mr2 < z1_AG, n, pgcode_AG, z1_AG #    masque pour test
            if mr2print_AG < z3dprint_AG & mr2print_AG <>   -1,pnumligne, pgcode_AG, z3dprint_AG, e$
            if nextop$ <> 11, pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if nextop$ <> 11, pnumligne, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,axeCpos1_AG, axeApos1_AG, e$
            if nextop$ <> 11, pnumligne, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
            #else, n, pgcode_force_AG, *x1,*y2,e
            if axeCpos1_AG <> 0 | axeApos1_AG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_AG = 9999, zprint_AG = zrprint_AG
            if nextop$ <> 11, pnumligne, pgcode_force_AG,xrprint_AG,yrprint_AG,zrprint_AG, e$
            old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AG = toy4print_AG
            old_toz4_AG = toz4print_AG
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG

prot2_BG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_BG
            # if mr2 < z1_BG, n, pgcode_BG, z1_BG #    masque pour test
            if mr2print_BG < z3dprint_BG & mr2print_BG <>   -1,pnumligne, pgcode_BG, z3dprint_BG, e$
            if nextop$ <> 11, panul_plan_inc_BG
            if nextop$ <> 11, pnumligne, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,axeCpos1_BG, axeApos1_BG, e$
            if nextop$ <> 11, pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$
            #else, n, pgcode_force_BG, *x1,*y2,e
            if axeCpos1_BG <> 0 | axeApos1_BG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_BG = 9999, zprint_BG = zrprint_BG
            if nextop$ <> 11, pnumligne, pgcode_force_BG,xrprint_BG,yrprint_BG,zrprint_BG, e$
            old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BG = toy4print_BG
            old_toz4_BG = toz4print_BG
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG

prot2_CG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_CG
            # if mr2 < z1_CG, n, pgcode_CG, z1_CG #    masque pour test
            if mr2print_CG < z3dprint_CG & mr2print_CG <>   -1,pnumligne, pgcode_CG, z3dprint_CG, e$
            if nextop$ <> 11, panul_plan_inc_CG
            if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
            if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
            if nextop$ <> 11, pnumligne, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,axeCpos1_CG, axeApos1_CG, e$
            if nextop$ <> 11, [
                              if cycle_800 = 1, [
                                                spaces$ = 0
                                                axeApos_cycle800_CG = axeApos_CG
                                                axeCpos_cycle800_CG = axeCpos_CG
                                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                                spaces$ = 1
                                                ]
                              else, pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$
                              ]
            if nextop$ <> 11, pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
            #else, n, pgcode_force_CG, *x1,*y2,e
            if axeCpos1_CG <> 0 | axeApos1_CG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_CG = 9999, zprint_CG = zrprint_CG
            if nextop$ <> 11, pnumligne, pgcode_force_CG,xrprint_CG,yrprint_CG,zrprint_CG, e$
            old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CG = toy4print_CG
            old_toz4_CG = toz4print_CG
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG

prot2_DG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_DG
            # if mr2 < z1_DG, n, pgcode_DG, z1_DG #    masque pour test
            if mr2print_DG < z3dprint_DG & mr2print_DG <>   -1,pnumligne, pgcode_DG, z3dprint_DG, e$
            if nextop$ <> 11, panul_plan_inc_DG
            if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
            if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
            if nextop$ <> 11, pnumligne, pgcode_force_DG, *x3dprint_DG,*y3dprint_DG,axeCpos1_DG, axeApos1_DG, e$
            if nextop$ <> 11, [
                              if cycle_800 = 1, [
                                                spaces$ = 0
                                                axeApos_cycle800_DG = axeApos_DG
                                                axeCpos_cycle800_DG = axeCpos_DG
                                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                                spaces$ = 1
                                                ]
                              else, pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$
                              ]
            if nextop$ <> 11, pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DG = 1
            #else, n, pgcode_force_DG, *x1,*y2,e
            if axeCpos1_DG <> 0 | axeApos1_DG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_DG = 9999, zprint_DG = zrprint_DG
            if nextop$ <> 11, pnumligne, pgcode_force_DG,xrprint_DG,yrprint_DG,zrprint_DG, e$
            old_tox4_DG = tox4print_DG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_DG = toy4print_DG
            old_toz4_DG = toz4print_DG
            old_axeCpos_DG = axeCpos_DG
            old_axeApos_DG = axeApos_DG
            oldreel_axeCpos_DG = reel_axeCpos_DG

prot2_AM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_AM
            # if mr2 < z1_AM, n, pgcode_AM, z1_AM #    masque pour test
            if mr2print_AM < z3dprint_AM & mr2print_AM <>   -1,pnumligne, pgcode_AM, z3dprint_AM, e$
            if nextop$ <> 11, pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if nextop$ <> 11, pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
            if nextop$ <> 11, pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
            #else, n, pgcode_force_AM, *x1,*y2,e
            if axeCpos1_AM <> 0 | axeApos1_AM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_AM = 9999, zprint_AM = zrprint_AM
            if nextop$ <> 11, pnumligne, pgcode_force_AM,xrprint_AM,yrprint_AM,zrprint_AM, e$
            old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AM = toy4print_AM
            old_toz4_AM = toz4print_AM
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM

prot2_BM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_BM
            # if mr2 < z1_BM, n, pgcode_BM, z1_BM #    masque pour test
            if mr2print_BM < z3dprint_BM & mr2print_BM <>   -1,pnumligne, pgcode_BM, z3dprint_BM, e$
            if nextop$ <> 11, panul_plan_inc_BM
            if nextop$ <> 11, pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
            if nextop$ <> 11, pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
            #else, n, pgcode_force_BM, *x1,*y2,e
            if axeCpos1_BM <> 0 | axeApos1_BM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_BM = 9999, zprint_BM = zrprint_BM
            if nextop$ <> 11, pnumligne, pgcode_force_BM,xrprint_BM,yrprint_BM,zrprint_BM, e$
            old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BM = toy4print_BM
            old_toz4_BM = toz4print_BM
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM

prot2_CM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_CM
            # if mr2 < z1_CM, n, pgcode_CM, z1_CM #    masque pour test
            if mr2print_CM < z3dprint_CM & mr2print_CM <>   -1,pnumligne, pgcode_CM, z3dprint_CM, e$
            if nextop$ <> 11, panul_plan_inc_CM
            if nextop$ <> 11, pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
            if nextop$ <> 11, [
                              if cycle_800 = 1, [
                                                spaces$ = 0
                                                axeApos_cycle800_CM = axeApos_CM
                                                axeCpos_cycle800_CM = axeCpos_CM
                                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                                spaces$ = 1
                                                ]
                              else, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
                              ]
            if nextop$ <> 11, pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
            #else, n, pgcode_force_CM, *x1,*y2,e
            if axeCpos1_CM <> 0 | axeApos1_CM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_CM = 9999, zprint_CM = zrprint_CM
            if nextop$ <> 11, pnumligne, pgcode_force_CM,xrprint_CM,yrprint_CM,zrprint_CM, e$
            old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CM = toy4print_CM
            old_toz4_CM = toz4print_CM
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM

prot2_DM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_DM
            # if mr2 < z1_DM, n, pgcode_DM, z1_DM #    masque pour test
            if mr2print_DM < z3dprint_DM & mr2print_DM <>   -1,pnumligne, pgcode_DM, z3dprint_DM, e$
            if nextop$ <> 11, panul_plan_inc_DM
            if nextop$ <> 11, pnumligne, pgcode_force_DM, *x3dprint_DM,*y3dprint_DM,axeCpos1_DM, axeApos1_DM, e$
            if nextop$ <> 11, [
                              if cycle_800 = 1, [
                                                spaces$ = 0
                                                axeApos_cycle800_DM = axeApos_DM
                                                axeCpos_cycle800_DM = axeCpos_DM
                                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                                spaces$ = 1
                                                ]
                              else, pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$
                              ]
            if nextop$ <> 11, pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DM = 1
            #else, n, pgcode_force_DM, *x1,*y2,e
            if axeCpos1_DM <> 0 | axeApos1_DM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_DM = 9999, zprint_DM = zrprint_DM
            if nextop$ <> 11, pnumligne, pgcode_force_DM,xrprint_DM,yrprint_DM,zrprint_DM, e$
            old_tox4_DM = tox4print_DM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_DM = toy4print_DM
            old_toz4_DM = toz4print_DM
            old_axeCpos_DM = axeCpos_DM
            old_axeApos_DM = axeApos_DM
            oldreel_axeCpos_DM = reel_axeCpos_DM
#endregion
#region prot3

prot3_AG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
             if mr2print_AG = 0, mr2print_AG =zsecuprint
         pcalxyz3d_AG
         if mr2print_AG < z3dprint_AG & mr2print_AG <>   -1,pnumligne, pgcode_AG, z3dprint_AG, e$
         if mr2print_AG >= z3dprint_AG & mr2print_AG <>   -1,pnumligne,pgcode_AG, mr2print_AG, e$
             if mr2print_AG <>   -1,pnumligne,pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,axeCpos1_AG, axeApos1_AG, e$
             else, pnumligne, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*z3dprint_AG,axeCpos1_AG, axeApos1_AG, e$

             pnumligne, "G151", axeCpos_AG, axeApos_AG,  tox4print_AG, toy4print_AG, toz4print_AG, e$
             if opcode$ = 3, pnumligne, pgcode_AG, xrprint_AG,yrprint_AG,zrprint_AG, e$
        #     else , n, pgcode_AG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AG = toy4print_AG
           old_toz4_AG = toz4print_AG
           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

prot3_BG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_BG
             if mr2print_BG = 0, mr2print_BG =zsecuprint
         pcalxyz3d_BG
         if mr2print_BG < z3dprint_BG & mr2print_BG <>   -1,pnumligne, pgcode_BG, z3dprint_BG, e$
         if mr2print_BG >= z3dprint_BG & mr2print_BG <>   -1,pnumligne,pgcode_BG, mr2print_BG, e$
             if mr2print_BG <>   -1,pnumligne,pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,axeCpos1_BG, axeApos1_BG, e$
             else, pnumligne, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*z3dprint_BG,axeCpos1_BG, axeApos1_BG, e$

             pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$
             if opcode$ = 3, pnumligne, pgcode_BG, xrprint_BG,yrprint_BG,zrprint_BG, e$
        #     else , n, pgcode_BG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BG = toy4print_BG
           old_toz4_BG = toz4print_BG
           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

prot3_CG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_CG
             if mr2print_CG = 0, mr2print_CG =zsecuprint
         pcalxyz3d_CG
         if mr2print_CG < z3dprint_CG & mr2print_CG <>   -1,pnumligne, pgcode_CG, z3dprint_CG, e$
         if mr2print_CG >= z3dprint_CG & mr2print_CG <>   -1,pnumligne,pgcode_CG, mr2print_CG, e$
         if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
         if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
             if mr2print_CG <>   -1,    [
                                        if garage_CG <> 0, pnumligne, pgcode_force_CG, *axeCpos1_CG, e$
                                        pnumligne,pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,axeCpos1_CG, axeApos1_CG, e$
                                        ]
             else, pnumligne, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*z3dprint_CG,axeCpos1_CG, axeApos1_CG, e$

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CG = axeApos_CG
                                axeCpos_cycle800_CG = axeCpos_CG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$

             pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
             if opcode$ = 3, pnumligne, pgcode_CG, xrprint_CG,yrprint_CG,zrprint_CG, e$
        #     else , n, pgcode_CG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CG = toy4print_CG
           old_toz4_CG = toz4print_CG
           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

prot3_DG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_DG
             if mr2print_DG = 0, mr2print_DG =zsecuprint
         pcalxyz3d_DG
         if mr2print_DG < z3dprint_DG & mr2print_DG <>   -1,pnumligne, pgcode_DG, z3dprint_DG, e$
         if mr2print_DG >= z3dprint_DG & mr2print_DG <>   -1,pnumligne,pgcode_DG, mr2print_DG, e$
         if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
         if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
             if mr2print_DG <>   -1,    [
                                        if garage_DG <> 0, pnumligne, pgcode_force_DG, *axeCpos1_DG, e$
                                        pnumligne,pgcode_force_DG, *x3dprint_DG,*y3dprint_DG,axeCpos1_DG, axeApos1_DG, e$
                                        ]
             else, pnumligne, pgcode_force_DG, *x3dprint_DG,*y3dprint_DG,*z3dprint_DG,axeCpos1_DG, axeApos1_DG, e$

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DG = axeApos_DG
                                axeCpos_cycle800_DG = axeCpos_DG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$

             pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DG = 1
             if opcode$ = 3, pnumligne, pgcode_DG, xrprint_DG,yrprint_DG,zrprint_DG, e$
        #     else , n, pgcode_DG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_DG = tox4print_DG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_DG = toy4print_DG
           old_toz4_DG = toz4print_DG
           old_axeCpos_DG = axeCpos_DG
           old_axeApos_DG = axeApos_DG
           oldreel_axeCpos_DG = reel_axeCpos_DG

prot3_AM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
             if mr2print_AM = 0, mr2print_AM =zsecuprint
         pcalxyz3d_AM
         if mr2print_AM < z3dprint_AM & mr2print_AM <>   -1,pnumligne, pgcode_AM, z3dprint_AM, e$
         if mr2print_AM >= z3dprint_AM & mr2print_AM <>   -1,pnumligne,pgcode_AM, mr2print_AM, e$
             if mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
             else, pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,*z3dprint_AM,axeCpos1_AM, axeApos1_AM, e$

             pnumligne, "G151", axeCpos_AM, axeApos_AM,  tox4print_AM, toy4print_AM, toz4print_AM, e$
             if opcode$ = 3, pnumligne, pgcode_AM, xrprint_AM,yrprint_AM,zrprint_AM, e$
        #     else , n, pgcode_AM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AM = toy4print_AM
           old_toz4_AM = toz4print_AM
           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

prot3_BM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_BM
             if mr2print_BM = 0, mr2print_BM =zsecuprint
         pcalxyz3d_BM
         if mr2print_BM < z3dprint_BM & mr2print_BM <>   -1,pnumligne, pgcode_BM, z3dprint_BM, e$
         if mr2print_BM >= z3dprint_BM & mr2print_BM <>   -1,pnumligne,pgcode_BM, mr2print_BM, e$
             if mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
             else, pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,*z3dprint_BM,axeCpos1_BM, axeApos1_BM, e$

             pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
             if opcode$ = 3, pnumligne, pgcode_BM, xrprint_BM,yrprint_BM,zrprint_BM, e$
        #     else , n, pgcode_BM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BM = toy4print_BM
           old_toz4_BM = toz4print_BM
           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

prot3_CM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_CM
             if mr2print_CM = 0, mr2print_CM =zsecuprint
         pcalxyz3d_CM
         if mr2print_CM < z3dprint_CM & mr2print_CM <>   -1,pnumligne, pgcode_CM, z3dprint_CM, e$
         if mr2print_CM >= z3dprint_CM & mr2print_CM <>   -1,pnumligne,pgcode_CM, mr2print_CM, e$
             if mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
             else, pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,*z3dprint_CM,axeCpos1_CM, axeApos1_CM, e$

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CM = axeApos_CM
                                axeCpos_cycle800_CM = axeCpos_CM
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
             else, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$


             pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
             if opcode$ = 3, pnumligne, pgcode_CM, xrprint_CM,yrprint_CM,zrprint_CM, e$
        #     else , n, pgcode_CM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CM = toy4print_CM
           old_toz4_CM = toz4print_CM
           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM

prot3_DM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_DM
             if mr2print_DM = 0, mr2print_DM =zsecuprint
         pcalxyz3d_DM
         if mr2print_DM < z3dprint_DM & mr2print_DM <>   -1,pnumligne, pgcode_DM, z3dprint_DM, e$
         if mr2print_DM >= z3dprint_DM & mr2print_DM <>   -1,pnumligne,pgcode_DM, mr2print_DM, e$
             if mr2print_DM <>   -1,pnumligne,pgcode_force_DM, *x3dprint_DM,*y3dprint_DM,axeCpos1_DM, axeApos1_DM, e$
             else, pnumligne, pgcode_force_DM, *x3dprint_DM,*y3dprint_DM,*z3dprint_DM,axeCpos1_DM, axeApos1_DM, e$

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DM = axeApos_DM
                                axeCpos_cycle800_DM = axeCpos_DM
                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
             else, pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$


             pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DM = 1
             if opcode$ = 3, pnumligne, pgcode_DM, xrprint_DM,yrprint_DM,zrprint_DM, e$
        #     else , n, pgcode_DM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_DM = tox4print_DM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_DM = toy4print_DM
           old_toz4_DM = toz4print_DM
           old_axeCpos_DM = axeCpos_DM
           old_axeApos_DM = axeApos_DM
           oldreel_axeCpos_DM = reel_axeCpos_DM
#endregion
#endregion

#region   PSOF PHEADER OPTIONS #OK
#region premx

premx_AG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_AG, *mr1 ,e
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
            if mr2print_AG = 0, mr2print_AG =zsecuprint
            if mr2print_AG <>   -1,pnumligne,pgcode_AG, mr2print_AG,e$
            axeCpos_AG = 0
            axeApos_AG = 0
            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG


premx_BG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_BG, *mr1 ,e
            panul_plan_inc_BG
            if mr2print_BG = 0, mr2print_BG =zsecuprint
            if mr2print_BG <>   -1,pnumligne,pgcode_BG, mr2print_BG,e$
            axeCpos_BG = 0
            axeApos_BG = 0
            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG


premx_CG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_CG, *mr1 ,e
            panul_plan_inc_CG
            if mr2print_CG = 0, mr2print_CG =zsecuprint

            pgestionduB_cloche_CG
            #"voir",  *axeA_cloche_CG, e$
            if axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG
            if mr2print_CG <> -1 & axeA_cloche_CG = 0, pnumligne, pgcode_CG, mr2print_CG, e$
            if mr2print_CG <> -1 & axeA_cloche_CG <> 0, pnumligne, pgcode_CG, mr2print_CG, *axeA_cloche_CG, e$

            flagmr2_CG = 1
            axeCpos_CG = 0
            axeApos_CG = 0
            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

premx_DG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_DG, *mr1 ,e
            panul_plan_inc_DG
            if mr2print_DG = 0, mr2print_DG =zsecuprint

            pgestionduB_cloche_DG
            #"voir",  *axeA_cloche_DG, e$
            if axeA_cloche_DG <> 0 & mr2print_DG = -1, psortie_cloche_DG
            if mr2print_DG <> -1 & axeA_cloche_DG = 0, pnumligne, pgcode_DG, mr2print_DG, e$
            if mr2print_DG <> -1 & axeA_cloche_DG <> 0, pnumligne, pgcode_DG, mr2print_DG, *axeA_cloche_DG, e$

            flagmr2_DG = 1
            axeCpos_DG = 0
            axeApos_DG = 0
            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG

premx_AM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_AM, *mr1 ,e
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
            if mr2print_AM = 0, mr2print_AM =zsecuprint
            if mr2print_AM <>   -1,pnumligne,pgcode_AM, mr2print_AM,e$
            axeCpos_AM = 0
            axeApos_AM = 0
            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM


premx_BM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_BM, *mr1 ,e
            panul_plan_inc_BM
            if mr2print_BM = 0, mr2print_BM =zsecuprint
            if mr2print_BM <>   -1,pnumligne,pgcode_BM, mr2print_BM,e$
            axeCpos_BM = 0
            axeApos_BM = 0
            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM


premx_CM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_CM, *mr1 ,e
            panul_plan_inc_CM
            if mr2print_CM = 0, mr2print_CM =zsecuprint

            pgestionduB_cloche_CM
            #"voir",  *axeA_cloche_CM, e$
            if axeA_cloche_CM <> 0 & mr2print_CM = -1, #psortie_cloche_CM
            if mr2print_CM <> -1 & axeA_cloche_CM = 0, pnumligne, pgcode_CM, mr2print_CM, e$
            if mr2print_CM <> -1 & axeA_cloche_CM <> 0, pnumligne, pgcode_CM, mr2print_CM, e$#*axeA_cloche_CM, e$

            flagmr2_CM = 1
            axeCpos_CM = 0
            axeApos_CM = 0
            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

premx_DM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_DM, *mr1 ,e
            panul_plan_inc_DM
            if mr2print_DM = 0, mr2print_DM =zsecuprint

            pgestionduB_cloche_DM
            #"voir",  *axeA_cloche_DM, e$
            if axeA_cloche_DM <> 0 & mr2print_DM = -1, #psortie_cloche_DM
            if mr2print_DM <> -1 & axeA_cloche_DM = 0, pnumligne, pgcode_DM, mr2print_DM, e$
            if mr2print_DM <> -1 & axeA_cloche_DM <> 0, pnumligne, pgcode_DM, mr2print_DM, e$#*axeA_cloche_DM, e$

            flagmr2_DM = 1
            axeCpos_DM = 0
            axeApos_DM = 0
            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM
#endregion          
#region pcord

pcord_AG     # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_BG      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_CG      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_DG      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_AM     # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_BM      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_CM      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_DM      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

#endregion
#region plubrifon_old

plubrifon_old_BG
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_CG
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_DG
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_BM
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_CM
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_DM
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

#endregion
#region pcontrol_lubrif

pcontrol_lubrif_BG  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_CG  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_DG  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

pcontrol_lubrif_BM  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_CM  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_DM  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

#endregion
#region plubrifon

plubrifon_AG
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7"
           if lubrif = 2, pnumligne, "M150"
           if lubrif = 3, pnumligne, "M150", e$, pnumligne, "M7"
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_BG   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur200_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                subout$ = 3
                                erreur_BG = 1
                                #exitpost$ # abandonner 
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_BG <> 9 ,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur203_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                subout$ = 3
                                erreur_BG = 1
                                #exitpost$ # abandonner
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_CG   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur200_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_CG <> 9 ,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur203_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_DG   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur200_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_DG <> 9 ,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur203_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_AM
           lubrif = coolant$
           if lubrif = 1, pnumligne, "M7"
           if lubrif = 2, pnumligne, "M150"
           if lubrif = 3, pnumligne, "M150", e$, pnumligne, "M7"
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_BM   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur200_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                subout$ = 3
                                erreur_BM = 1
                                #exitpost$ # abandonner 
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_BM <> 9 ,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur203_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                subout$ = 3
                                erreur_BM = 1
                                #exitpost$ # abandonner
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_CM   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur200_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_CM <> 9 ,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur203_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_DM   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur200_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_DM <> 9 ,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur203_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

#endregion
#region plubrifoff

plubrifoff_AG
           if lub = 1, pnumligne, "M9", e$ , pnumligne, "M151"

plubrifoff_BG
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_CG
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_DG
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_AM
           if lub = 1, pnumligne, "M9", e$ , pnumligne, "M151"

plubrifoff_BM
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_CM
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_DM
           if lub <> 0, pnumligne, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0
#endregion
#region ptempo

ptempo_BG      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M151; ARRET ASPI", e$
            tempo_BG = mi10$ / 10
            pnumligne,tempo_BG,e$

ptempo_CG      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M302 ; ARRET ASPI 1", e$
            if mi10$ < -1, pnumligne, "M304 ; ARRET ASPI 2", e$
            tempo_CG = mi10$ / 10
            pnumligne,tempo_CG,e$

ptempo_DG      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M302 ; ARRET ASPI 1", e$
            if mi10$ < -1, pnumligne, "M304 ; ARRET ASPI 2", e$
            tempo_DG = mi10$ / 10
            pnumligne,tempo_DG,e$

ptempo_BM      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M151; ARRET ASPI", e$
            tempo_BM = mi10$ / 10
            pnumligne,tempo_BM,e$

ptempo_CM      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M302 ; ARRET ASPI 1", e$
            if mi10$ < -1, pnumligne, "M304 ; ARRET ASPI 2", e$
            tempo_CM = mi10$ / 10
            pnumligne,tempo_CM,e$

ptempo_DM      # tempo suivant mi10$
            if mi10$ < -1, pnumligne, "M302 ; ARRET ASPI 1", e$
            if mi10$ < -1, pnumligne, "M304 ; ARRET ASPI 2", e$
            tempo_DM = mi10$ / 10
            pnumligne,tempo_DM,e$

#endregion
#region parretprog

parretprog_AG   # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 (ARRET BROCHE)",e$
        pnumligne,"G151 S0",e$
        pnumligne,"G0 G52 Z-150",e$
        if mi10$ = -1, pnumligne,"M151",e$
        pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_AG = 1) | (prog_AM = 1) , q10
            #pnumligne,"$", smesage_AG,e$
            if prog_AG = 1, q10
            pnumligne,"$", smesage,e$
            ]
        pcantext_AG
        pnumligne,"M0",e$
        if oldstation_AG <> 0 & oldstation_AG = mi4_AG, pnumligne, *spdlon_AG, "M40", ssprint_AG,e$
        else,
        [
        if mi4_AG  <= 0 | mi4_AG > 6, pnumligne, *spdlon_AG, "M40", ssprint_AG,e$
        ]
            if mr2print_AG <= 0, mr2print_AG =zsecuprint
            prvmr2_AG = mr2print_AG

parretprog_BG    # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BG
        plubrifoff_BG
        if mi10$ = -1, pnumligne, "M151; ARRET ASPI", e$
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_BG = 1) | (prog_BM = 1), q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BG
        pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        pnumligne, "TRAORI(1)", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        pnumligne, *spdlon_BG, ssprint_BG,e$

parretprog_CG    # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CG
        plubrifoff_CG
        if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        pgarage_CG
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_CG = 1) | (prog_CM = 1), q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CG
        pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        pnumligne, "TRAORI(1)", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        pnumligne, *spdlon_CG, ssprint_CG,e$

parretprog_DG    # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_DG
        plubrifoff_DG
        if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        pgarage_DG
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_DG = 1) | (prog_CM = 1), q12
            #pnumligne,"MSG(",34, smesage_DG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_DG
        pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        pnumligne, "TRAORI(1)", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        pnumligne, *spdlon_DG, ssprint_DG,e$

parretprog_AM   # arret machine programmer avant op quand mi10 = 1
        #enlevé pour concat#pnumligne,"M5 (ARRET BROCHE)",e$
        #enlevé pour concat#pnumligne,"G151 S0",e$
        #enlevé pour concat#pnumligne,"G0 G52 Z-150",e$
        #enlevé pour concat#if mi10$ = -1, pnumligne,"M151",e$
        #enlevé pour concat#pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q10
            #pnumligne,"$", smesage_AG,e$
            pnumligne,"$", smesage,e$
            ]
        pcantext_AM
        #enlevé pour concat#pnumligne,"M0",e$
        #enlevé pour concat#if oldstation_AM <> 0 & oldstation_AM = mi4_AM, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
        #enlevé pour concat#else,
        #enlevé pour concat#[
        #enlevé pour concat#if mi4_AM  <= 0 | mi4_AM > 6, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
        #enlevé pour concat#]
            if mr2print_AM <= 0, mr2print_AM =zsecuprint
            prvmr2_AM = mr2print_AM

parretprog_BM    # arret machine programmer avant op quand mi10 = 1
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_BM
        #enlevé pour concat#plubrifoff_BM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M151; ARRET ASPI", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BM
        #enlevé pour concat#pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        #enlevé pour concat#pnumligne, "TRAORI(1)", e$
        #enlevé pour concat#pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        #enlevé pour concat#pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        #enlevé pour concat#pnumligne, *spdlon_BM, ssprint_BM,e$

parretprog_CM    # arret machine programmer avant op quand mi10 = 1
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_CM
        #enlevé pour concat#plubrifoff_CM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CM
        #enlevé pour concat#pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        #enlevé pour concat#pnumligne, "TRAORI(1)", e$
        #enlevé pour concat#pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        #enlevé pour concat#pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        #enlevé pour concat#pnumligne, *spdlon_CM, ssprint_CM,e$

parretprog_DM    # arret machine programmer avant op quand mi10 = 1
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_DM
        #enlevé pour concat#plubrifoff_DM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_DM
        #enlevé pour concat#pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        #enlevé pour concat#pnumligne, "TRAORI(1)", e$
        #enlevé pour concat#pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        #enlevé pour concat#pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        #enlevé pour concat#pnumligne, *spdlon_DM, ssprint_DM,e$
#endregion
#region parretprog2

parretprog2_AG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 (ARRET BROCHE)",e$
        pnumligne,"G151 S0",e$
        if mi10$ = -1, pnumligne,"M151",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_AG = 1) | (prog_AM = 1), q10
            #pnumligne,"$", smesage_AG,e$
            if prog_AG = 1, q10
            pnumligne,"$", smesage,e$
            ]
        pcantext_AG
        pnumligne,"M0",e$

parretprog2_BG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BG
        plubrifoff_BG
        if mi10$ = -1, pnumligne, "M151; ARRET ASPI", e$
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_BG = 1) | (prog_BM = 1), q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BG
        pnumligne, "M0", e$

parretprog2_CG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CG
        plubrifoff_CG
        if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        pgarage_CG
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_CG = 1) | (prog_CM = 1), q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CG
        pnumligne, "M0", e$

parretprog2_DG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_DG
        plubrifoff_DG
        if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        pgarage_DG
        pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_DG = 1) | (prog_CM = 1), q12
            #pnumligne,"MSG(",34, smesage_DG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_DG
        pnumligne, "M0", e$

parretprog2_AM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        #enlevé pour concat#pnumligne,"M5 (ARRET BROCHE)",e$
        #enlevé pour concat#pnumligne,"G151 S0",e$
        #enlevé pour concat#pnumligne,"G0 G52 Z-150",e$
        #enlevé pour concat#if mi10$ = -1, pnumligne,"M151",e$
        #enlevé pour concat#pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q10
            #pnumligne,"$", smesage_AG,e$
            pnumligne,"$", smesage,e$
            ]
        pcantext_AM
        #enlevé pour concat#pnumligne,"M0",e$

parretprog2_BM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_BM
        #enlevé pour concat#plubrifoff_BM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M151; ARRET ASPI", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BM
        #enlevé pour concat#pnumligne, "M0", e$

parretprog2_CM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_CM
        #enlevé pour concat#plubrifoff_CM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CM
        #pnumligne, "M0", e$

parretprog2_DM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        #enlevé pour concat#pnumligne,"M5 ;(ARRET BROCHE)",e$
        #enlevé pour concat#panul_plan_inc_DM
        #enlevé pour concat#plubrifoff_DM
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concat#if mi10$ = -1, pnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_DM
        #enlevé pour concat#pnumligne, "M0", e$

#endregion
#region pprep
pprep$
        #err_file$ = 4
        seqno$ = 5
        seqinc$ = 5
        n$ = 5
        clearaux$
        clearext$
        clearlcc$
        newaux$
        ecrigeneral_AG = 0
        ecrigeneral_BG = 0
        ecrigeneral_CG = 0
        ecrigeneral_DG = 0

#endregion
#region ppost
ppost$
        spathnc$ = sentre_cote + spathnc$ + sentre_cote
        result = launch(sdpdir, spathnc$)
#endregion
#region pheader
pheader$
                comment$
                debut_pp = 1
                pgestion_prog
                pgestion_valeur_C_CLOCHE_CG
                pgestion_valeur_C_CLOCHE_DG
                pgestion_rep  # on part cree les repertoires machines
                q3
                subout$=0   # on ecrit dans le fichier de synthese

                 "*******************************************************************", e$
                 "SYNTHESE DES PROGRAMMES GENERES POUR LE DESSIN", smcname$,e$    # FICAM
                 "*******************************************************************", e$
                 "Généré le ", date$, " A ", time$, "par", snomprog, e$     # date du traitement post-pro
                 " ", e$
                 "***********************************", e$
                 "PROGRAMME SORTIE POUR LES MACHINES:" e$              # nom de la machine   
                 "***********************************", e$
                 if (prog_AG = 1) | (prog_AM = 1), " - ",smachine_AG, e$
                 if (prog_BG = 1) | (prog_BM = 1), " - ",smachine_BG, e$
                 if (prog_CG = 1) | (prog_CM = 1), " - ",smachine_CG, e$
                 if (prog_DG = 1) | (prog_DM = 1), " - ",smachine_DG, e$
                 " ", e$
                 "**************************", e$
                 "LISTE DES OUTILS UTILISER:", e$
                 "**************************", e$
                 #pvoirdescrip
                 subout$=1

                pdecomposition_mi5
                pchange_AG
                pheader_AG

                pchange_BG
                pheader_BG

                pchange_CG
                pheader_CG

                pchange_DG
                pheader_DG

                pcont_garage_AM
                pchange_AM
                pheader_AM

                pcont_garage_BM
                pchange_BM
                pheader_BM

				pcont_garage_CM
                pchange_CM
                pheader_CM

                pcont_garage_DM
                pchange_DM
                pheader_DM

                old_numprg_garage_AM = numprg_garage_AM
                old_numprg_garage_BM = numprg_garage_BM
                old_numprg_garage_CM = numprg_garage_CM
                old_numprg_garage_DM = numprg_garage_DM
                old_progno_AM = numprg_concat_AM
                old_progno_BM = numprg_concat_BM
                old_progno_CM = numprg_concat_CM
                old_progno_DM = numprg_concat_DM
pheader_AG     # Entete
        if progno$ = 0, progno$ = 8999
        ppr = mi5_AG
        !ppr
        if trans_num_prg <> 0, mr1_AG = trans_num_prg
        else, mr1_AG = mr1$
        if (mr1_AG <> 0) & (mr1_AG > 0) & (mr1_AG < 9000), mr1_AG, e$
        else, psortie_num_prog_AG
        if ppr = 1, pnumligne,"G77 H9001.",e$,pnumligne,"E10000=1",e$
        if ppr = 2, pnumligne,"G77 H9002.",e$,pnumligne,"E10001=1",e$
        if ppr = 3, pnumligne,"G77 H9001. N55N65",e$,pnumligne,"G77 H9999",e$,pnumligne,"E10001=1 E10000=1",e$
        @gfr_AG
        "(STELIA COMPOSITES)",e$
        "(CRENEAU 5 AXES STC9101)",e$
        "(ETABLI LE ",date$," A ",time$, " H)",e$
        "(PROG PAR ",snomprog, ")",e$
        #"$ PIECE:", srefpiec,e$

pheader_BG     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_BG
        pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        pnumligne,";(",34,"CRENEAU 5 AXES STC9103",34,")",e$
        pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$
        #pnumligne,";(",34,"PIECE:", srefpiec,34,")",e$

pheader_CG     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_CG
        pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        pnumligne,";(",34,"CRENEAU 5 AXES STC9110",34,")",e$
        pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$
        #pnumligne,";(",34,"PIECE:", srefpiec,34,")",e$

pheader_DG     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_DG
        pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        pnumligne,";(",34,"CRENEAU 5 AXES STEMA01",34,")",e$
        pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$
        #pnumligne,";(",34,"PIECE:", srefpiec,34,")",e$

pheader_AM     # Entete
        if progno$ = 0, progno$ = 8999
        ppr = mi5_AM
        !ppr
        #enlevé pour concat#*progno$,e$
        #enlevé pour concat#if ppr = 1, pnumligne,"G77 H9001.",e$,pnumligne,"E10000=1",e$
        #enlevé pour concat#if ppr = 2, pnumligne,"G77 H9002.",e$,pnumligne,"E10001=1",e$
        #enlevé pour concat#if ppr = 3, pnumligne,"G77 H9001. N55N65",e$,pnumligne,"G77 H9999",e$,pnumligne,"E10001=1 E10000=1",e$
        @gfr_AM
        #enlevé pour concat#"(STELIA COMPOSITES)",e$
        #enlevé pour concat#"(CRENEAU 5 AXES STC9101)",e$
        #enlevé pour concat#"(ETABLI LE ",date$," A ",time$, " H)",e$
        #enlevé pour concat#"(PROG PAR ",snomprog, ")",e$ #enlevé pour concat


pheader_BM     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_BM
        #enlevé pour concat#pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"CRENEAU 5 AXES STC9103",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$


pheader_CM     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_CM
        #enlevé pour concat#pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"CRENEAU 5 AXES STC9110",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$

pheader_DM     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_DM
        #enlevé pour concat#pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"CRENEAU 5 AXES STC9110",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$        

#endregion
#region pcycle832

pcycle832_BG   # gestion du cycle 832 lissage 
        if (mi8_BG > 0) & (mi8_BG <> 9) & mi8_BG <> oldmi8_BG,
                    [
                    if mi8_BG = 1, pnumligne, scycle832_a, e$
                    if mi8_BG = 2, pnumligne, scycle832_b, e$
                    if mi8_BG = 3, pnumligne, scycle832_c, e$
                    if mi8_BG = 4, pnumligne, scycle832_d, e$
                    if mi8_BG = 5, pnumligne, scycle832_e, e$
                    if mi8_BG = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_BG <= 0) | (mi8_BG = 9)) & mi8_BG <> oldmi8_BG, pnumligne, scycle832_anul, e$
        oldmi8_BG = mi8_BG

pcycle832_CG   # gestion du cycle 832 lissage 
        if (mi8_CG > 0) & (mi8_CG <> 9) & mi8_CG <> oldmi8_CG,
                    [
                    if mi8_CG = 1, pnumligne, scycle832_a, e$
                    if mi8_CG = 2, pnumligne, scycle832_b, e$
                    if mi8_CG = 3, pnumligne, scycle832_c, e$
                    if mi8_CG = 4, pnumligne, scycle832_d, e$
                    if mi8_CG = 5, pnumligne, scycle832_e, e$
                    if mi8_CG = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_CG <= 0) | (mi8_CG = 9)) & mi8_CG <> oldmi8_CG, pnumligne, scycle832_anul, e$
        oldmi8_CG = mi8_CG

pcycle832_DG   # gestion du cycle 832 lissage 
        if (mi8_DG > 0) & (mi8_DG <> 9) & mi8_DG <> oldmi8_DG,
                    [
                    if mi8_DG = 1, pnumligne, scycle832_a, e$
                    if mi8_DG = 2, pnumligne, scycle832_b, e$
                    if mi8_DG = 3, pnumligne, scycle832_c, e$
                    if mi8_DG = 4, pnumligne, scycle832_d, e$
                    if mi8_DG = 5, pnumligne, scycle832_e, e$
                    if mi8_DG = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_DG <= 0) | (mi8_DG = 9)) & mi8_DG <> oldmi8_DG, pnumligne, scycle832_anul, e$
        oldmi8_DG = mi8_DG

pcycle832_BM   # gestion du cycle 832 lissage 
        if (mi8_BM > 0) & (mi8_BM <> 9) & mi8_BM <> oldmi8_BM,
                    [
                    if mi8_BM = 1, pnumligne, scycle832_a, e$
                    if mi8_BM = 2, pnumligne, scycle832_b, e$
                    if mi8_BM = 3, pnumligne, scycle832_c, e$
                    if mi8_BM = 4, pnumligne, scycle832_d, e$
                    if mi8_BM = 5, pnumligne, scycle832_e, e$
                    if mi8_BM = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_BM <= 0) | (mi8_BM = 9)) & mi8_BM <> oldmi8_BM, pnumligne, scycle832_anul, e$
        oldmi8_BM = mi8_BM

pcycle832_CM   # gestion du cycle 832 lissage 
        if (mi8_CM > 0) & (mi8_CM <> 9) & mi8_CM <> oldmi8_CM,
                    [
                    if mi8_CM = 1, pnumligne, scycle832_a, e$
                    if mi8_CM = 2, pnumligne, scycle832_b, e$
                    if mi8_CM = 3, pnumligne, scycle832_c, e$
                    if mi8_CM = 4, pnumligne, scycle832_d, e$
                    if mi8_CM = 5, pnumligne, scycle832_e, e$
                    if mi8_CM = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_CM <= 0) | (mi8_CM = 9)) & mi8_CM <> oldmi8_CM, pnumligne, scycle832_anul, e$
        oldmi8_CM = mi8_CM

pcycle832_DM   # gestion du cycle 832 lissage 
        if (mi8_DM > 0) & (mi8_DM <> 9) & mi8_DM <> oldmi8_DM,
                    [
                    if mi8_DM = 1, pnumligne, scycle832_a, e$
                    if mi8_DM = 2, pnumligne, scycle832_b, e$
                    if mi8_DM = 3, pnumligne, scycle832_c, e$
                    if mi8_DM = 4, pnumligne, scycle832_d, e$
                    if mi8_DM = 5, pnumligne, scycle832_e, e$
                    if mi8_DM = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_DM <= 0) | (mi8_DM = 9)) & mi8_DM <> oldmi8_DM, pnumligne, scycle832_anul, e$
        oldmi8_DM = mi8_DM
#endregion
#region ptestrenvoi_angle
fmt "outil=" 2 outil_complet
fmt "Num RA=" 4 num_ra
fmt "Num outil=" 4 num_outil

ptestrenvoi_angle_BG  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_BG = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_BG=",  tprint2_BG, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BG,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_BG > 0,psortie3_BG
                                            if coolant$ > 0, psortie4_BG
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BG,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_BG > 0,psortie3_BG
                                            if coolant$ > 0, psortie4_BG
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_CG  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_CG = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_CG=",  tprint2_CG, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CG,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_CG > 0,psortie3_CG
                                            if coolant$ > 0, psortie4_CG
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CG,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_CG > 0,psortie3_CG
                                            if coolant$ > 0, psortie4_CG
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_DG  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_DG = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_DG=",  tprint2_DG, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_DG,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_DG > 0,psortie3_DG
                                            if coolant$ > 0, psortie4_DG
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_DG,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_DG > 0,psortie3_DG
                                            if coolant$ > 0, psortie4_DG
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_BM  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_BM = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_BM=",  tprint2_BM, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BM,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_BM > 0,psortie3_BM
                                            if coolant$ > 0, psortie4_BM
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BM,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_BM > 0,psortie3_BM
                                            if coolant$ > 0, psortie4_BM
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_CM  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_CM = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_CM=",  tprint2_CM, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CM,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_CM > 0,psortie3_CM
                                            if coolant$ > 0, psortie4_CM
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CM,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_CM > 0,psortie3_CM
                                            if coolant$ > 0, psortie4_CM
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_DM  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_DM = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_DM=",  tprint2_DM, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_DM,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_DM > 0,psortie3_DM
                                            if coolant$ > 0, psortie4_DM
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_DM,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_DM > 0,psortie3_DM
                                            if coolant$ > 0, psortie4_DM
                                            ]
                    else, tete_rev_ang_gauche = 0
#endregion
#region ptestcloche

ptestcloche_BG # test si num de cloche possible
                if mi4_BG <> 1 & mi4_BG <> 2 & mi4_BG <> 3 & mi4_BG <> 4 & mi4_BG <> 11 & mi4_BG <> 12 & mi4_BG <> 13 & mi4_BG <> 14 & mi4_BG <> 21 & mi4_BG <> 22 & mi4_BG <> 23 & mi4_BG <> 24 & mi4_BG > 0   , mi4_BG = 0

ptestcloche_CG # test si num de cloche possible
                if mi4_CG <> 1 & mi4_CG <> 2 & mi4_CG <> 3 & mi4_CG <> 4 & mi4_CG <> 11 & mi4_CG <> 12 & mi4_CG <> 13 & mi4_CG <> 14 & mi4_CG <> 21 & mi4_CG <> 22 & mi4_CG <> 23 & mi4_CG <> 24 & mi4_CG > 0   , mi4_CG = 0

ptestcloche_DG # test si num de cloche possible
                if mi4_DG <> 1 & mi4_DG <> 2 & mi4_DG <> 3 & mi4_DG <> 4 & mi4_DG <> 11 & mi4_DG <> 12 & mi4_DG <> 13 & mi4_DG <> 14 & mi4_DG <> 21 & mi4_DG <> 22 & mi4_DG <> 23 & mi4_DG <> 24 & mi4_DG > 0   , mi4_DG = 0

ptestcloche_BM # test si num de cloche possible
                if mi4_BM <> 1 & mi4_BM <> 2 & mi4_BM <> 3 & mi4_BM <> 4 & mi4_BM <> 11 & mi4_BM <> 12 & mi4_BM <> 13 & mi4_BM <> 14 & mi4_BM <> 21 & mi4_BM <> 22 & mi4_BM <> 23 & mi4_BM <> 24 & mi4_BM > 0   , mi4_BM = 0

ptestcloche_CM # test si num de cloche possible
                if mi4_CM <> 1 & mi4_CM <> 2 & mi4_CM <> 3 & mi4_CM <> 4 & mi4_CM <> 11 & mi4_CM <> 12 & mi4_CM <> 13 & mi4_CM <> 14 & mi4_CM <> 21 & mi4_CM <> 22 & mi4_CM <> 23 & mi4_CM <> 24 & mi4_CM > 0   , mi4_CM = 0

ptestcloche_DM # test si num de cloche possible
                if mi4_DM <> 1 & mi4_DM <> 2 & mi4_DM <> 3 & mi4_DM <> 4 & mi4_DM <> 11 & mi4_DM <> 12 & mi4_DM <> 13 & mi4_DM <> 14 & mi4_DM <> 21 & mi4_DM <> 22 & mi4_DM <> 23 & mi4_DM <> 24 & mi4_DM > 0   , mi4_DM = 0
#endregion
#region ptlngno

ptlngno_AG      # gestion des cloches
          if mi4_AG = 9, pnumligne, "( PAS DE CLOCHE )",e$
          if mi4_AG = 0 ,pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$

          if t$ < 16,[
          if mi4_AG = 1 , pnumligne, "M171", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if mi4_AG = 2 , pnumligne, "M172", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if mi4_AG = 3 , pnumligne, "M173", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if mi4_AG = 4 , pnumligne, "M174", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if mi4_AG = 5 , pnumligne, "M175", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if mi4_AG = 6 , pnumligne, "M176", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AG, "M40", ssprint_AG, e$
          if (mi4_AG > 6) & (mi4_AG <> 9), "( CLOCHE NON VALIDE )",e$
          ]
          else, pnumligne, "( PAS DE CLOCHE )",e$

ptlngno_BG      # gestion des cloches
          if (mi4_BG = 0) | (mi4_BG = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_BG = 9 , pnumligne, "M151 ; ARRET ASPI", e$
          else, pnumligne, "M150 ; MARCHE ASPI ", e$

ptlngno_CG      # gestion des cloches
          if (mi4_CG = 0) | (mi4_CG = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_CG = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
          else, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$

ptlngno_DG      # gestion des cloches
          if (mi4_DG = 0) | (mi4_DG = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_DG = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
          else, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$

ptlngno_AM      # gestion des cloches
          if mi4_AM = 9, pnumligne, "( PAS DE CLOCHE )",e$
          if mi4_AM = 0 ,pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$

          if t$ < 16,[
          if mi4_AM = 1 , pnumligne, "M171", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 2 , pnumligne, "M172", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 3 , pnumligne, "M173", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 4 , pnumligne, "M174", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 5 , pnumligne, "M175", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 6 , pnumligne, "M176", e$, pnumligne, "M150", e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if (mi4_AM > 6) & (mi4_AM <> 9), "( CLOCHE NON VALIDE )",e$
          ]
          else, pnumligne, "( PAS DE CLOCHE )",e$

ptlngno_BM      # gestion des cloches
          if (mi4_BM = 0) | (mi4_BM = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_BM = 9 , pnumligne, "M151 ; ARRET ASPI", e$
          else, pnumligne, "M150 ; MARCHE ASPI ", e$

ptlngno_CM      # gestion des cloches
          if (mi4_CM = 0) | (mi4_CM = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_CM = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
          else, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$

ptlngno_DM      # gestion des cloches
          if (mi4_DM = 0) | (mi4_DM = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_DM = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
          else, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$

#endregion
#region ptlngno2

ptlngno2_AG   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          pnumligne, "G151 S0", e$
          pnumligne, "M9", e$
          pnumligne, "M151", e$
          pnumligne, "M5", e$
          pnumligne, "M170", e$
          ptlngno_AG
          if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)),pnumligne, *spdlon_AG, "M40", ssprint_AG,e$

ptlngno2_BG   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          panul_plan_inc_BG
          plubrifoff_BG
          pnumligne, "M151; ARRET ASPI", e$
          pnumligne, "M5 ; ARRET BROCHE", e$
          pappeloutil_BG
          ptlngno_BG
          pnumligne, *spdlon_BG,  ssprint_BG,e$
          pcycle832_BG
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$

ptlngno2_CG   # gestion cloche quand pas de nouvel outil
            if (mi4_CG > 0) & (mi4_CG <> 9), pnumligne, "STOPRE", e$, pnumligne, "M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, "STOPRE", e$, pnumligne, "M68 ; OUVERTURE CLOCHE", e$

ptlngno2_DG   # gestion cloche quand pas de nouvel outil
            if (mi4_DG > 0) & (mi4_DG <> 9), pnumligne, "STOPRE", e$, pnumligne, "M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, "STOPRE", e$, pnumligne, "M68 ; OUVERTURE CLOCHE", e$

ptlngno2_AM   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          pnumligne, "G151 S0", e$
          pnumligne, "M9", e$
          pnumligne, "M151", e$
          pnumligne, "M5", e$
          pnumligne, "M170", e$
          ptlngno_AM
          if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)),pnumligne, *spdlon_AM, "M40", ssprint_AM,e$


ptlngno2_BM   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          panul_plan_inc_BM
          plubrifoff_BM
          pnumligne, "M151; ARRET ASPI", e$
          pnumligne, "M5 ; ARRET BROCHE", e$
          pappeloutil_BM
          ptlngno_BM
          pnumligne, *spdlon_BM,  ssprint_BM,e$
          pcycle832_BM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$

ptlngno2_CM   # gestion cloche quand pas de nouvel outil
            spaces$ = 1
			if (mi4_CM > 0) & (mi4_CM <> 9), pnumligne, "STOPRE", e$, pnumligne, "M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, "STOPRE", e$, pnumligne, "M68 ; OUVERTURE CLOCHE", e$

ptlngno2_DM   # gestion cloche quand pas de nouvel outil
            spaces$ = 1
			if (mi4_DM > 0) & (mi4_DM <> 9), pnumligne, "STOPRE", e$, pnumligne, "M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, "STOPRE", e$, pnumligne, "M68 ; OUVERTURE CLOCHE", e$
#endregion
#region psof0
psof0$
            pchange_AG
            psof0_AG

            pchange_AM
            psof0_AM

            pchange_BG
            psof0_BG

            pchange_BM
            psof0_BM

            pchange_CG
            psof0_CG

            pchange_CM
            psof0_CM

            pchange_DG
            psof0_DG

            pchange_DM
            psof0_DM

psof0_AG      # Debut si pas d'outil
            psof$

psof0_BG       # Debut si pas d'outil
            psof$

psof0_CG       # Debut si pas d'outil
            psof$

psof0_DG       # Debut si pas d'outil
            psof$

psof0_AM      # Debut si pas d'outil
            psof$

psof0_BM       # Debut si pas d'outil
            psof$

psof0_CM       # Debut si pas d'outil
            psof$

psof0_DM       # Debut si pas d'outil
            psof$
#endregion
#region pugv

pugv_AG    # activation ou non du mode UGV
            if mi8_AG =  9,pnumligne, "M126", e$
            else, pnumligne, "M125", e$
pugv_AM    # activation ou non du mode UGV
            if mi8_AM =  9,pnumligne, "M126", e$
            else, pnumligne, "M125", e$
#endregion
#region pstring
fmt "valeur de string" 1 valstring

pstring_AG    # valeur de la string
             if valstring = 1, pnumligne, stringtxt1_AG, e$
             if valstring = 2, pnumligne, stringtxt2_AG, e$
             if valstring = 3, pnumligne, stringtxt3_AG, e$
             if valstring = 4, pnumligne, stringtxt4_AG, e$
             if valstring = 5, pnumligne, stringtxt5_AG, e$
             if valstring = 6, pnumligne, stringtxt6_AG, e$
             if valstring = 7, pnumligne, stringtxt7_AG, e$
             if valstring = 8, pnumligne, stringtxt8_AG, e$
             if valstring = 9, pnumligne, stringtxt9_AG, e$
             if valstring = 10, pnumligne, stringtxt10_AG, e$

pstring_BG    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_BG,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_BG,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_BG,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_BG,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_BG,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_BG,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_BG,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_BG,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_BG,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_BG,34,")", e$
             #spaces$ = 0

pstring_CG    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_CG,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_CG,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_CG,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_CG,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_CG,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_CG,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_CG,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_CG,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_CG,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_CG,34,")", e$
             #spaces$ = 0   

pstring_DG    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_DG,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_DG,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_DG,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_DG,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_DG,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_DG,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_DG,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_DG,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_DG,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_DG,34,")", e$
             #spaces$ = 0   

pstring_AM    # valeur de la string
             if valstring = 1, pnumligne, stringtxt1_AM, e$
             if valstring = 2, pnumligne, stringtxt2_AM, e$
             if valstring = 3, pnumligne, stringtxt3_AM, e$
             if valstring = 4, pnumligne, stringtxt4_AM, e$
             if valstring = 5, pnumligne, stringtxt5_AM, e$
             if valstring = 6, pnumligne, stringtxt6_AM, e$
             if valstring = 7, pnumligne, stringtxt7_AM, e$
             if valstring = 8, pnumligne, stringtxt8_AM, e$
             if valstring = 9, pnumligne, stringtxt9_AM, e$
             if valstring = 10, pnumligne, stringtxt10_AM, e$

pstring_BM    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_BM,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_BM,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_BM,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_BM,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_BM,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_BM,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_BM,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_BM,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_BM,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_BM,34,")", e$
             #spaces$ = 0

pstring_CM    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_CM,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_CM,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_CM,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_CM,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_CM,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_CM,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_CM,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_CM,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_CM,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_CM,34,")", e$
             #spaces$ = 0 

pstring_DM    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_DM,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_DM,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_DM,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_DM,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_DM,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_DM,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_DM,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_DM,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_DM,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_DM,34,")", e$
             #spaces$ = 0            

#endregion
#region pcantext

pcantext_AG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_AG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_AG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_AG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_AG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_AG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_AG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_AG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_AG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_AG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_AG
             ]

pcantext_BG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_BG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_BG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_BG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_BG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_BG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_BG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_BG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_BG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_BG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_BG
             ]

pcantext_CG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_CG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_CG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_CG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_CG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_CG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_CG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_CG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_CG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_CG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_CG
             ]

pcantext_DG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_DG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_DG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_DG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_DG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_DG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_DG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_DG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_DG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_DG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_DG
             ]

pcantext_AM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_AM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_AM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_AM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_AM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_AM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_AM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_AM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_AM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_AM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_AM
             ]

pcantext_BM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_BM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_BM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_BM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_BM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_BM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_BM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_BM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_BM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_BM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_BM
             ]

pcantext_CM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_CM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_CM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_CM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_CM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_CM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_CM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_CM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_CM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_CM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_CM
             ]

pcantext_DM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_DM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_DM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_DM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_DM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_DM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_DM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_DM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_DM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_DM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_DM
             ]
#endregion
#region pappeloutil
smoins : "-"
stringdebut : ""
stringfin : ""
fmt "Nb=" 4 long_string

fmt "" 15 var_1
fmt "" 15 var_2
fmt "" 15 var_3
fmt "" 15 var_4
fmt "" 15 var_5
fmt "" 15 var_6
fmt "" 15 var_7

var_1 : 0
var_2 : 0
var_3 : 0
var_4 : 0
var_5 : 0
var_6 : 0
var_7 : 0

fmt "" 2 longeur_outil
fmt "" 2 rayon_outil
fmt "" 2 dec_rayon
fmt "" 2 rayon_coin_outil
fmt "Nb" 4 nb_digit_outil

fmt "" 3 vartool_1
fmt "" 3 vartool_2

vartool_1 : 0
vartool_2 : 0

svartool_1 : ""

pappeloutil_BG
            pdecomposition_mi4
            if strtool$ = spalpeur_BG,
            [
             pnumligne, " T1=",34,strtool$,34, e$  # choix de l'outil
             pnumligne, " T2=0",e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_BG = 0

            if opcode$ <> 3, psortie7_BG
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_BG = 1, [
            subout$ = 4
            serreur_visu_BG = serreurnomoutil_BG + no2str(numop_BG)
            *serreur_visu_BG, e$
            result = mprint(serreur_visu_BG)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_BG = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            pnumligne, " T1=",34,soutil,34, e$  # choix de l'outil
            if (mi4_BG > 0) & (mi4_BG <> 9), pnumligne, " T2=",34,"CLOCHE", *mi4_BG,34,e$
            else, pnumligne, " T2=0",e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                    pnumligne," BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")", e$
                                    spaces$ = 1
                                    ]
                    ]
            ]

pappeloutil_CG

            if strtool$ = spalpeur_CG,
            [
             spaces$ = 1, pnumligne, *tprint_CG, e$, spaces$ = 0
             pnumligne, "STOPRE", e$
             pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_CG = 0

            if opcode$ <> 3, psortie7_CG
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_CG = 1, [
            subout$ = 4
            serreur_visu_CG = serreurnomoutil_CG + no2str(numop_CG)
            *serreur_visu_CG, e$
            result = mprint(serreur_visu_CG)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_CG = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, pnumligne, *tprint_CG, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            spaces$ = 0
            if (mi4_CG > 0) & (mi4_CG <> 9), pnumligne, " STOPRE", e$, pnumligne, " M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, " STOPRE", e$, pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        LONG_MAX_CG = var_2 + var_3
                        LONG_MIN_CG = var_2 - var_3
                        pnumligne, *LONG_MAX_CG, e$
                        pnumligne, *LONG_MIN_CG, e$
                        pnumligne, "TEST_LONG", e$
                    ]
            ]

pappeloutil_DG

            if strtool$ = spalpeur_DG,
            [
             spaces$ = 1, pnumligne, *tprint_DG, e$, spaces$ = 0
             pnumligne, "STOPRE", e$
             pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_DG = 0

            if opcode$ <> 3, psortie7_DG
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_DG = 1, [
            subout$ = 4
            serreur_visu_DG = serreurnomoutil_DG + no2str(numop_DG)
            *serreur_visu_DG, e$
            result = mprint(serreur_visu_DG)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_DG = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, pnumligne, *tprint_DG, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            spaces$ = 0
            if (mi4_DG > 0) & (mi4_DG <> 9), pnumligne, " STOPRE", e$, pnumligne, " M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, " STOPRE", e$, pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        LONG_MAX_DG = var_2 + var_3
                        LONG_MIN_DG = var_2 - var_3
                        pnumligne, *LONG_MAX_DG, e$
                        pnumligne, *LONG_MIN_DG, e$
                        pnumligne, "TEST_LONG", e$
                    ]
            ]

pappeloutil_BM
            pchange_BM
			pdecomposition_mi4
            if strtool$ = spalpeur_BM,
            [
             pnumligne, " T1=",34,strtool$,34, e$  # choix de l'outil
             pnumligne, " T2=0",e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_BM = 0

            if opcode$ <> 3, psortie7_BM
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_BM = 1, [
            subout$ = 4
            serreur_visu_BM = serreurnomoutil_BM + no2str(numop_BM)
            *serreur_visu_BM, e$
            result = mprint(serreur_visu_BM)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_BM = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            pnumligne, " T1=",34,soutil,34, e$  # choix de l'outil
            if (mi4_BM > 0) & (mi4_BM <> 9), pnumligne, " T2=",34,"CLOCHE", *mi4_BM,34,e$
            else, pnumligne, " T2=0",e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                    pnumligne," BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")", e$
                                    spaces$ = 1
                                    ]
                    ]
            ]

pappeloutil_CM
			pchange_CM
            if strtool$ = spalpeur_CM,
            [
             spaces$ = 1, pnumligne, *tprint_CM, e$, spaces$ = 0
             pnumligne, "STOPRE", e$
             pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_CM = 0

            if opcode$ <> 3, psortie7_CM
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_CM = 1, [
            subout$ = 4
            serreur_visu_CM = serreurnomoutil_CM + no2str(numop_CM)
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_CM = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, pnumligne, *tprint_CM, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            spaces$ = 0
            if (mi4_CM > 0) & (mi4_CM <> 9), pnumligne, " STOPRE", e$, pnumligne, " M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, " STOPRE", e$, pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        LONG_MAX_CM = var_2 + var_3
                        LONG_MIN_CM = var_2 - var_3
                        pnumligne, *LONG_MAX_CM, e$
                        pnumligne, *LONG_MIN_CM, e$
                        pnumligne, "TEST_LONG", e$
                    ]
            ]

pappeloutil_DM
			pchange_DM
            if strtool$ = spalpeur_DM,
            [
             spaces$ = 1, pnumligne, *tprint_DM, e$, spaces$ = 0
             pnumligne, "STOPRE", e$
             pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_DM = 0

            if opcode$ <> 3, psortie7_DM
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            if prog_DM = 1, [
            subout$ = 4
            serreur_visu_DM = serreurnomoutil_DM + no2str(numop_DM)
            *serreur_visu_DM, e$
            result = mprint(serreur_visu_DM)
            #exitpost$ # abandonner
            subout$ = 3
            erreur_DM = 1
                            ]
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, pnumligne, *tprint_DM, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            spaces$ = 0
            if (mi4_DM > 0) & (mi4_DM <> 9), pnumligne, " STOPRE", e$, pnumligne, " M69 ; FERMETURE CLOCHE", e$
            else, pnumligne, " STOPRE", e$, pnumligne, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
                        LONG_MAX_DM = var_2 + var_3
                        LONG_MIN_DM = var_2 - var_3
                        pnumligne, *LONG_MAX_DM, e$
                        pnumligne, *LONG_MIN_DM, e$
                        pnumligne, "TEST_LONG", e$
                    ]
            ]

#endregion
#region sous programme

psub_call_s$

psub_st_s$

psub_end_s$

psub_call_mm$

psub_call_m$

psub_end_m_r$

psub_st_m$

#endregion
#region ptrans_option

fmt 17 transform_AG
fmt 17 transform_BG
fmt 17 transform_CG
fmt 17 transform_DG
fmt 17 transform_AM
fmt 17 transform_BM
fmt 17 transform_CM
fmt 17 transform_DM
transform_AG : -1
transform_BG : -1
transform_CG : -1
transform_DG : -1
transform_AM : -1
transform_BM : -1
transform_CM : -1
transform_DM : -1

ptrans_option_AG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_AG = 0
                    mi2_A_base_AG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_AG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_AG
                    transform_AG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_AG = mi1_trans_AG, mi2_A_base_AG = mi2_trans_AG
                    if sub_trnstyp$ = 0, mi1_C_base_AG = mi1_mirro_AG, mi2_A_base_AG = mi2_mirro_AG
                    if sub_trnstyp$ = 1, mi1_C_base_AG = mi1_rotat_AG, mi2_A_base_AG = mi2_rotat_AG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_AG = 0
                    mi1_C_base_AG = mi1_trans_AG
                    mi2_A_base_AG = mi2_trans_AG
                    ]
                    #"voir",  *mi1_C_base_AG, *mi2_A_base_AG, e$

                    old_sub_trnstyp_AG = sub_trnstyp$
                    old_sub_totl_no_AG = sub_totl_no$
ptrans_option_BG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_BG = 0
                    mi2_A_base_BG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_BG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_BG
                    transform_BG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_BG = mi1_trans_BG, mi2_A_base_BG = mi2_trans_BG
                    if sub_trnstyp$ = 0, mi1_C_base_BG = mi1_mirro_BG, mi2_A_base_BG = mi2_mirro_BG
                    if sub_trnstyp$ = 1, mi1_C_base_BG = mi1_rotat_BG, mi2_A_base_BG = mi2_rotat_BG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_BG = 0
                    mi1_C_base_BG = mi1_trans_BG
                    mi2_A_base_BG = mi2_trans_BG
                    ]

                    #"voir",  *mi1_C_base_BG, *mi2_A_base_BG, e$

                    old_sub_trnstyp_BG = sub_trnstyp$
                    old_sub_totl_no_BG = sub_totl_no$
ptrans_option_CG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_CG = 0
                    mi2_A_base_CG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_CG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_CG
                    transform_CG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_CG = mi1_trans_CG, mi2_A_base_CG = mi2_trans_CG
                    if sub_trnstyp$ = 0, mi1_C_base_CG = mi1_mirro_CG, mi2_A_base_CG = mi2_mirro_CG
                    if sub_trnstyp$ = 1, mi1_C_base_CG = mi1_rotat_CG, mi2_A_base_CG = mi2_rotat_CG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_CG = 0
                    mi1_C_base_CG = mi1_trans_CG
                    mi2_A_base_CG = mi2_trans_CG
                    ]

                    #"voir",  *mi1_C_base_CG, *mi2_A_base_CG, e$

                    old_sub_trnstyp_CG = sub_trnstyp$
                    old_sub_totl_no_CG = sub_totl_no$

ptrans_option_DG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_DG = 0
                    mi2_A_base_DG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_DG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_DG
                    transform_DG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_DG = mi1_trans_DG, mi2_A_base_DG = mi2_trans_DG
                    if sub_trnstyp$ = 0, mi1_C_base_DG = mi1_mirro_DG, mi2_A_base_DG = mi2_mirro_DG
                    if sub_trnstyp$ = 1, mi1_C_base_DG = mi1_rotat_DG, mi2_A_base_DG = mi2_rotat_DG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_DG = 0
                    mi1_C_base_DG = mi1_trans_DG
                    mi2_A_base_DG = mi2_trans_DG
                    ]

                    #"voir",  *mi1_C_base_DG, *mi2_A_base_DG, e$

                    old_sub_trnstyp_DG = sub_trnstyp$
                    old_sub_totl_no_DG = sub_totl_no$

ptrans_option_AM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_AM = 0
                    mi2_A_base_AM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_AM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_AM
                    transform_AM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_AM = mi1_trans_AM, mi2_A_base_AM = mi2_trans_AM
                    if sub_trnstyp$ = 0, mi1_C_base_AM = mi1_mirro_AM, mi2_A_base_AM = mi2_mirro_AM
                    if sub_trnstyp$ = 1, mi1_C_base_AM = mi1_rotat_AM, mi2_A_base_AM = mi2_rotat_AM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_AM = 0
                    mi1_C_base_AM = mi1_trans_AM
                    mi2_A_base_AM = mi2_trans_AM
                    ]

                    #"voir",  *mi1_C_base_AM, *mi2_A_base_AM, e$

                    old_sub_trnstyp_AM = sub_trnstyp$
                    old_sub_totl_no_AM = sub_totl_no$
ptrans_option_BM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_BM = 0
                    mi2_A_base_BM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_BM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_BM
                    transform_BM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_BM = mi1_trans_BM, mi2_A_base_BM = mi2_trans_BM
                    if sub_trnstyp$ = 0, mi1_C_base_BM = mi1_mirro_BM, mi2_A_base_BM = mi2_mirro_BM
                    if sub_trnstyp$ = 1, mi1_C_base_BM = mi1_rotat_BM, mi2_A_base_BM = mi2_rotat_BM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_BM = 0
                    mi1_C_base_BM = mi1_trans_BM
                    mi2_A_base_BM = mi2_trans_BM
                    ]

                    #"voir",  *mi1_C_base_BM, *mi2_A_base_BM, e$

                    old_sub_trnstyp_BM = sub_trnstyp$
                    old_sub_totl_no_BM = sub_totl_no$
ptrans_option_CM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_CM = 0
                    mi2_A_base_CM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_CM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_CM
                    transform_CM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_CM = mi1_trans_CM, mi2_A_base_CM = mi2_trans_CM
                    if sub_trnstyp$ = 0, mi1_C_base_CM = mi1_mirro_CM, mi2_A_base_CM = mi2_mirro_CM
                    if sub_trnstyp$ = 1, mi1_C_base_CM = mi1_rotat_CM, mi2_A_base_CM = mi2_rotat_CM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_CM = 0
                    mi1_C_base_CM = mi1_trans_CM
                    mi2_A_base_CM = mi2_trans_CM
                    ]

                    #"voir",  *mi1_C_base_CM, *mi2_A_base_CM, e$

                    old_sub_trnstyp_CM = sub_trnstyp$
                    old_sub_totl_no_CM = sub_totl_no$

ptrans_option_DM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_DM = 0
                    mi2_A_base_DM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_DM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_DM
                    transform_DM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_DM = mi1_trans_DM, mi2_A_base_DM = mi2_trans_DM
                    if sub_trnstyp$ = 0, mi1_C_base_DM = mi1_mirro_DM, mi2_A_base_DM = mi2_mirro_DM
                    if sub_trnstyp$ = 1, mi1_C_base_DM = mi1_rotat_DM, mi2_A_base_DM = mi2_rotat_DM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
                    transform_DM = 0
                    mi1_C_base_DM = mi1_trans_DM
                    mi2_A_base_DM = mi2_trans_DM
                    ]

                    #"voir",  *mi1_C_base_DM, *mi2_A_base_DM, e$

                    old_sub_trnstyp_DM = sub_trnstyp$
                    old_sub_totl_no_DM = sub_totl_no$
#endregion
#region psof
psof$
            if compteur_descrip = 0,    psortie_descripteur
            if compteur_descrip < 98, psortie_descripteur_erreur2
            if snumprog_AG <> "DEC X", psortie_descripteur_erreur
            if (DEC_X_AG = 0) & (DEC_Y_AG = 0) & (DEC_Z_AG = 0), psortie_dec_AG
            if (DEC_X_BG = 0) & (DEC_Y_BG = 0) & (DEC_Z_BG = 0), psortie_dec_BG
            if (DEC_X_CG = 0) & (DEC_Y_CG = 0) & (DEC_Z_CG = 0), psortie_dec_CG
            if (DEC_X_DG = 0) & (DEC_Y_DG = 0) & (DEC_Z_DG = 0), psortie_dec_DG

            if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")), [
                                                                                            if opcode$ >= 16, psortieplan5X
                                                                                            ]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            psof_AG

            pchange_AM
            psof_AM

            pchange_BG
            psof_BG

            pchange_BM
            psof_BM

            pchange_CG
            psof_CG

            pchange_CM
            psof_CM

            pchange_DG
            psof_DG

            pchange_DM
            psof_DM

fmt 2 numpp
psof_AG        # Debut si outil

        pnumop_AG

        rayon_outil = tldia$/2
        longeur_outil = paramT3 + paramT7
        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        if stl_mfg_com = svide, psortietest_outil

        if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
        if mr2$ = -1, psortie13_AG
            if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
            ptrans_option_AG  # mise a jour des variable mi1 et mi2 
            #" voir operation_AG ", *op_id$, *xform_op_id$, *sub_trnstyp$, e$
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pcantext_AG
            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AG
          gcode$ = 0
          spaces$ = 1
          pnumligne, "(USINAGE AVEC OUTIL", t$, ")", e$
          pnumligne, "G90 G17 G40 G80 G0 G94",e$
          mr8_AG = DEC_X_AG + mr8$
          mr9_AG = DEC_Y_AG + mr9$
          mr10_AG = DEC_Z_AG + mr10$
          pnumligne, "E60001=", *mr8_AG ,e$
          pnumligne, "E61001=", *mr9_AG ,e$
          pnumligne, "E62001=", *mr10_AG ,e$
          pnumligne, "E64001=E61001",e$
            cycle_heli_spiral_AG = 0
        vale84_AG =   -2022875+(mr3$ * 1000)
        if mr3$ <= 0 | mr3$ > 1892.875 , vale84_AG =   -130000
        if mr3$ > 0 & mr3$ < 1233.432 , vale84_AG =   -691000
          pnumligne, *vale84_AG,e$
          prvop_id_AG = op_id$
          #n, "G0 G52 Z-130"
          pnumligne, "M9",e$
          pnumligne, "M5",e$
          pnumligne, "M151",e$
          e53_AG = 53000 + tlngno$
          if mi4_AG >= 1 & mi4_AG <=6,
          [
          pnumligne, tlngno$,e$
          spaces$ = 0
          @e53_AG
          pnumligne," ", e53_AG,"=0",e$
          nplus_AG = n_AG + ( 5 * seqinc$)
          spaces$ = 0
          e40 = tprint_AG
           pnumligne," G79 E40000=", e40," ", *nplus_AG,e$
          spaces$ = 1
          ]
          pnumligne, "M170",e$
          if t$ > 16 & t$ < 20 | t$ > 29 ,  [
                                            if prog_AG = 1, q1
                                            ]
          if t$ < 16 , station_tool = 1
          if t$ > 20 , station_tool = 2
         # if t$ > 20 & station_tool = 2, pnumligne, "M6 T0",e$# depose outil 
          if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
          if t$ = tete_rev_ang_12 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
          if t$ = tete_rev_ang_21 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
          if t$ = tete_rev_ang_22 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
          pnumligne, "M6", *tprint_AG, *tlngno$,e$
          ptlngno_AG
          spaces$ = 0
          mr4_AG = mr4$
          pnumligne," ", e53_AG,"=", *mr4_AG,e$
          spaces$ = 1
          if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)) | t$ > 16, pnumligne, *spdlon_AG, "M40", ssprint_AG,e$
              old_ss = ssprint_AG
            plubrifon_AG,e$
            numpp = 1
            comment$
            pnumligne, strcom_AG, e$
            if mi2_A_base_AG = 0, invers_AG = 0
            if mi2_A_base_AG = 2, invers_AG = 1

            if opcode$ = 16, pchange_AM, psof_AM
            prot1_AG
            pprint_AG
           if mr2print_AG = 0, mr2print_AG =zsecuprint
                prvmr2_AG = mr2print_AG
                pcalxyz3d_AG
           if  mr2print_AG <> -1,pnumligne,pgcode_force_AG, *mr2print_AG ,e$
             else, pnumligne, pgcode_force_AG,*z1_AG,e$
          spaces$ = 0
           spaces$ = 1

           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_AG
           old_x_AG=xrprint_AG
           old_y_AG=yrprint_AG
           old_z_AG=zrprint_AG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_AG = mi4_AG
       frbase_AG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       pugv_AG
       changop_AG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_BG        # Debut si outil
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_BG
            if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
            if mr2$ = -1, psortie13_BG
            ptrans_option_BG  # mise a jour des variable mi1 et mi2 
            pcantext_BG
            if oscilliation = 1 & mi7$ <> 0, psortie12_BG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BG
            ptestcloche_BG
          gcode$ = 0
          spaces$ = 0
          pnumligne, " CRENO_START", e$
          mr8_BG = DEC_X_BG + mr8$
          mr9_BG = DEC_Y_BG + mr9$
          mr10_BG = DEC_Z_BG + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          pnumligne, " $P_UIFR[1]=CTRANS(",mr8_BG,","mr9_BG,","mr10_BG,",A,0.,C,0.)",e$
          pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_BG = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          pnumligne, "ROT ; RAZ ROTATION ", e$
          pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          pnumligne, "M5 ; ARRET BROCHE",e$
          pnumligne, "M151 ; ARRET ASPI",e$
          tlngno$ = 1
          ptestrenvoi_angle_BG
          spaces$ = 0
          pappeloutil_BG
          mr4_BG = mr4$
          if mr4$ > 0, pnumligne, mr4_BG, e$
          ptlngno_BG
          spaces$ = 1
          pnumligne, *spdlon_BG, ssprint_BG,e$
          old_ss = ssprint_BG
          plubrifon_BG
          numpp = 2
          comment$
          pnumligne, strcom_BG, e$
          if mi2_A_base_BG = 0, invers_BG = 0
          if mi2_A_base_BG = 2, invers_BG = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_BG
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            if mi9$ = -1, pnumligne, "M210", e$
            else, pnumligne, "M211", e$
            if opcode$ = 16, pchange_BM, psof_BM
            prot1_BG
            pprint_BG
            if mr2print_BG = 0, mr2print_BG =zsecuprint
            prvmr2_BG = mr2print_BG
            pcalxyz3d_BG
            if  mr2print_BG <>   -1,pnumligne,pgcode_force_BG, *mr2print_BG ,e$
            else, pnumligne, pgcode_force_BG,*z1_BG,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_BG
           old_x_BG=xrprint_BG
           old_y_BG=yrprint_BG
           old_z_BG=zrprint_BG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_BG = mi4_BG
       frbase_BG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_BG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_CG        # Debut si outil
            garage_CG = 0
            flagmr2_CG = 0
            old_opcode_cloche_CG = opcode$
            POURCENTAGE_AVANCE_CG = (POURCENTAGE_AVANCE_CG/100)
            if POURCENTAGE_AVANCE_CG = 0, POURCENTAGE_AVANCE_CG = 1

            #if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
            #else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG

            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_CG
            if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
            if mr2$ = -1, psortie13_CG
            ptrans_option_CG  # mise a jour des variable mi1 et mi2 
            pcantext_CG
            if oscilliation = 1 & mi7$ <> 0, psortie12_CG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CG
            ptestcloche_CG
          gcode$ = 0
          spaces$ = 0
          pnumligne, " CMS_START", e$
          mr8_CG = DEC_X_CG + mr8$
          mr9_CG = DEC_Y_CG + mr9$
          mr10_CG = DEC_Z_CG + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          pnumligne, " $P_UIFR[1]=CTRANS(",mr8_CG,","mr9_CG,","mr10_CG,",B,0.,C,0.)",e$
          pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_CG = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          if cycle_800 = 1, pnumligne, "CYCLE800()", e$
          else, [
                pnumligne, "TRANS ; RAZ TRANSLATION ", e$
                pnumligne, "ROT ; RAZ ROTATION ", e$
                ]
          pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          pnumligne, "M5 ; ARRET BROCHE",e$
          pnumligne, "M302 ; ARRET ASPI 1", e$
          pnumligne, "M304 ; ARRET ASPI 2", e$
          tlngno$ = 1
          ptestrenvoi_angle_CG
          spaces$ = 0
          pappeloutil_CG
          mr4_CG = mr4$
          if mr4$ > 0, pnumligne, mr4_CG, e$, pnumligne, "USURE", e$ 
          ptlngno_CG
          spaces$ = 1
          pnumligne, *spdlon_CG, ssprint_CG,e$
          old_ss = ssprint_CG
          plubrifon_CG
          numpp = 3
          comment$
          pnumligne, strcom_CG, e$
          if mi2_A_base_CG = 0, invers_CG = 0
          if mi2_A_base_CG = 2, invers_CG = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_CG
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, pnumligne, "M210", e$
            #else, pnumligne, "M211", e$
            if opcode$ = 16, pchange_CM, psof_CM
            prot1_CG
            pprint_CG
            if mr2print_CG = 0, mr2print_CG =zsecuprint
            prvmr2_CG = mr2print_CG
            pcalxyz3d_CG
            if  mr2print_CG <>   -1,pnumligne,pgcode_force_CG, *mr2print_CG ,e$
            else, pnumligne, pgcode_force_CG,*z1_CG,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_CG
           old_x_CG=xrprint_CG
           old_y_CG=yrprint_CG
           old_z_CG=zrprint_CG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_CG = mi4_CG
       frbase_CG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_CG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_DG        # Debut si outil
            garage_DG = 0
            flagmr2_DG = 0
            old_opcode_cloche_DG = opcode$
            POURCENTAGE_AVANCE_DG = (POURCENTAGE_AVANCE_DG/100)
            if POURCENTAGE_AVANCE_DG = 0, POURCENTAGE_AVANCE_DG = 1

            #if (mi4_DG > 0) & (mi4_DG <> 9), mini_c_DG = mini_c_avec_cloche_DG, maxi_c_DG = maxi_c_avec_cloche_DG
            #else, mini_c_DG = mini_c_sans_cloche_DG, maxi_c_DG = maxi_c_sans_cloche_DG

            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_DG
            if (mr2$ = 0) | (mr2$ = 1), psortie15_DG
            if mr2$ = -1, psortie13_DG
            ptrans_option_DG  # mise a jour des variable mi1 et mi2 
            pcantext_DG
            if oscilliation = 1 & mi7$ <> 0, psortie12_DG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DG
            if opcode$ = 16, drill5axes_DG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_DG
            ptestcloche_DG
          gcode$ = 0
          spaces$ = 0
          pnumligne, " CMS_START", e$
          mr8_DG = DEC_X_DG + mr8$
          mr9_DG = DEC_Y_DG + mr9$
          mr10_DG = DEC_Z_DG + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          pnumligne, " $P_UIFR[1]=CTRANS(",mr8_DG,","mr9_DG,","mr10_DG,",B,0.,C,0.)",e$
          pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_DG = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          if cycle_800 = 1, pnumligne, "CYCLE800()", e$
          else, [
                pnumligne, "TRANS ; RAZ TRANSLATION ", e$
                pnumligne, "ROT ; RAZ ROTATION ", e$
                ]
          pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          pnumligne, "M5 ; ARRET BROCHE",e$
          pnumligne, "M302 ; ARRET ASPI 1", e$
          pnumligne, "M304 ; ARRET ASPI 2", e$
          tlngno$ = 1
          ptestrenvoi_angle_DG
          spaces$ = 0
          pappeloutil_DG
          mr4_DG = mr4$
          if mr4$ > 0, pnumligne, mr4_DG, e$, pnumligne, "USURE", e$ 
          ptlngno_DG
          spaces$ = 1
          pnumligne, *spdlon_DG, ssprint_DG,e$
          old_ss = ssprint_DG
          plubrifon_DG
          numpp = 3
          comment$
          pnumligne, strcom_DG, e$
          if mi2_A_base_DG = 0, invers_DG = 0
          if mi2_A_base_DG = 2, invers_DG = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_DG
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, pnumligne, "M210", e$
            #else, pnumligne, "M211", e$
            if opcode$ = 16, pchange_DM, psof_DM
            prot1_DG
            pprint_DG
            if mr2print_DG = 0, mr2print_DG =zsecuprint
            prvmr2_DG = mr2print_DG
            pcalxyz3d_DG
            if  mr2print_DG <>   -1,pnumligne,pgcode_force_DG, *mr2print_DG ,e$
            else, pnumligne, pgcode_force_DG,*z1_DG,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_DG
           old_x_DG=xrprint_DG
           old_y_DG=yrprint_DG
           old_z_DG=zrprint_DG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_DG = mi4_DG
       frbase_DG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_DG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_AM        # Debut si outil
        pnumop_AM
        if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
        if mr2$ = -1, psortie13_AM
            if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
            ptrans_option_AM  # mise a jour des variable mi1 et mi2 
            #" voir operation_AM ", *op_id$, *xform_op_id$, *sub_trnstyp$, e$
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pcantext_AM
            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AM
          gcode$ = 0
          #enlevé pour concat#pnumligne, "(USINAGE AVEC OUTIL", t$, ")", e$
          #enlevé pour concat#pnumligne, "G90 G17 G40 G80 G0 G94",e$
          mr8_AM = DEC_X_AM + mr8$
          mr9_AM = DEC_Y_AM + mr9$
          mr10_AM = DEC_Z_AM + mr10$
          #enlevé pour concat#pnumligne, "E60001=", *mr8_AM ,e$
          #enlevé pour concat#pnumligne, "E61001=", *mr9_AM ,e$
          #enlevé pour concat#pnumligne, "E62001=", *mr10_AM ,e$
          #enlevé pour concat#pnumligne, "E64001=E61001",e$
            cycle_heli_spiral_AM = 0
        vale84_AM =   -2022875+(mr3$ * 1000)
        if mr3$ <= 0 | mr3$ > 1892.875 , vale84_AM =   -130000
        if mr3$ > 0 & mr3$ < 1233.432 , vale84_AM =   -691000
          #enlevé pour concat#pnumligne, *vale84_AM,e$
          prvop_id_AM = op_id$
          #n, "G0 G52 Z-130"
          #enlevé pour concat#pnumligne, SARRET_LUB,e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          e53_AM = 53000 + tlngno$
          #e53_AM = tlngno$
          if mi4_AM >= 1 & mi4_AM <=6,
          [
          tlngno_AM = tlngno$
          #enlevé pour concat#pnumligne, tlngno_AM,e$
          spaces$ = 0
          @e53_AM
          #enlevé pour concat#pnumligne," ", e53_AM,"=0",e$
          nplus_AM = n_AM + ( 5 * seqinc$)
          spaces$ = 0
          e40 = tprint_AM
           #enlevé pour concat#pnumligne," G79 E40000=", e40," ", *nplus_AM,e$
          spaces$ = 1
          ]
          #enlevé pour concat#pnumligne, SCLOCHE, spaces$ = 0, "0", spaces$ = 1, e$
          if t$ > 16 & t$ < 20 | t$ > 29 ,  [
                                            if prog_AM = 1, q4
                                            ]
          if t$ < 16 , station_tool = 1
          if t$ > 20 , station_tool = 2
         # if t$ > 20 & station_tool = 2, pnumligne, "M6 T0",e$# depose outil 
          if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
          if t$ = tete_rev_ang_12 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
          if t$ = tete_rev_ang_21 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
          if t$ = tete_rev_ang_22 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
          tlngno_AM = tlngno$
		  pchange_AM
          pnumligne, "M6", *tprint_AM, *tlngno_AM,e$
          ptlngno_AM
          spaces$ = 0
          mr4_AM = mr4$
          pnumligne," ", e53_AM,"=", *mr4_AM,e$
          spaces$ = 1
          if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)) | t$ > 16, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
              old_ss = ssprint_AM
            plubrifon_AM,e$
            numpp = 4
            comment$
            pnumligne, strcom_AM, e$
            if mi2_A_base_AM = 0, invers_AM = 0
            if mi2_A_base_AM = 2, invers_AM = 1
			progno_AM = progno$
            if opcode$ = 16, pchange_BG, psof_BG
            prot1_AM
            pprint_AM
           if mr2print_AM = 0, mr2print_AM =zsecuprint
                prvmr2_AM = mr2print_AM
                pcalxyz3d_AM
           if  mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
             else, pnumligne, pgcode_force_AM,*z1_AM,e$
          spaces$ = 0
           spaces$ = 1

           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_AM
           old_x_AM=xrprint_AM
           old_y_AM=yrprint_AM
           old_z_AM=zrprint_AM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_AM = mi4_AM
       frbase_AM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       pugv_AM
       changop_AM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_BM        # Debut si outil
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_BM
            if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
            if mr2$ = -1, psortie13_BM
            ptrans_option_BM  # mise a jour des variable mi1 et mi2 
            pcantext_BM
            if oscilliation = 1 & mi7$ <> 0, psortie12_BM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BM
            ptestcloche_BM
          gcode$ = 0
          spaces$ = 0
          #enlevé pour concat#pnumligne, " CRENO_START", e$
          mr8_BM = DEC_X_BM + mr8$
          mr9_BM = DEC_Y_BM + mr9$
          mr10_BM = DEC_Z_BM +mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          #enlevé pour concat#pnumligne, " $P_UIFR[1]=CTRANS(",mr8_BM,","mr9_BM,","mr10_BM,",A,0.,C,0.)",e$
          #enlevé pour concat#pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          #enlevé pour concat#pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_BM = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          #enlevé pour concat#pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          #enlevé pour concat#pnumligne, "ROT ; RAZ ROTATION ", e$
          #enlevé pour concat#pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          #enlevé pour concat#pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          #enlevé pour concat#pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          tlngno$ = 1
          ptestrenvoi_angle_BM
          spaces$ = 0
          pappeloutil_BM
          mr4_BM = mr4$
          if mr4$ > 0, pnumligne, mr4_BM, e$
          ptlngno_BM
          spaces$ = 1
          pnumligne, *spdlon_BM, ssprint_BM,e$
          old_ss = ssprint_BM
          plubrifon_BM
          numpp = 5
          comment$
          pnumligne, strcom_BM, e$
          if mi2_A_base_BM = 0, invers_BM = 0
          if mi2_A_base_BM = 2, invers_BM = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_BM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            if mi9$ = -1, pnumligne, "M210", e$
            else, pnumligne, "M211", e$
			progno_BM = progno$
            if opcode$ = 16, pchange_CG, psof_CG
            prot1_BM
            pprint_BM
            if mr2print_BM = 0, mr2print_BM =zsecuprint
            prvmr2_BM = mr2print_BM
            pcalxyz3d_BM
            if  mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            else, pnumligne, pgcode_force_BM,*z1_BM,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_BM
           old_x_BM=xrprint_BM
           old_y_BM=yrprint_BM
           old_z_BM=zrprint_BM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_BM = mi4_BM
       frbase_BM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_BM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_CM        # Debut si outil
            flagmr2_CM = 0
            old_opcode_cloche_CM = opcode$
            POURCENTAGE_AVANCE_CM = (POURCENTAGE_AVANCE_CM/100)
            if POURCENTAGE_AVANCE_CM = 0, POURCENTAGE_AVANCE_CM = 1

            #if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
            #else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM

            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_CM
            if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
            if mr2$ = -1, psortie13_CM
            ptrans_option_CM  # mise a jour des variable mi1 et mi2 
            pcantext_CM
            if oscilliation = 1 & mi7$ <> 0, psortie12_CM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CM
            ptestcloche_CM
          gcode$ = 0
          spaces$ = 0
          #enlevé pour concat#pnumligne, " CRENO_START", e$
          mr8_CM = DEC_X_CM + mr8$
          mr9_CM = DEC_Y_CM + mr9$
          mr10_CM = DEC_Z_CM + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          #enlevé pour concat#pnumligne, " $P_UIFR[1]=CTRANS(",mr8_CM,","mr9_CM,","mr10_CM,",A,0.,C,0.)",e$
          #enlevé pour concat#pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          #enlevé pour concat#pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_CM = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          #enlevé pour concat#pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          #enlevé pour concat#pnumligne, "ROT ; RAZ ROTATION ", e$
          #enlevé pour concat#pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          #enlevé pour concat#pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          #enlevé pour concat#pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          tlngno$ = 1
          ptestrenvoi_angle_CM
          spaces$ = 0
          pappeloutil_CM
          mr4_CM = mr4$
          if mr4$ > 0, pnumligne, mr4_CM, e$, pnumligne, "USURE", e$ 
          ptlngno_CM
          spaces$ = 1
          pnumligne, *spdlon_CM, ssprint_CM,e$
          old_ss = ssprint_CM
          plubrifon_CM
          numpp = 6
          comment$
          pnumligne, strcom_CM, e$
          if mi2_A_base_CM = 0, invers_CM = 0
          if mi2_A_base_CM = 2, invers_CM = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_CM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, pnumligne, "M210", e$
            #else, pnumligne, "M211", e$
			progno_CM = progno$
            if opcode$ = 16, pchange_DG, psof_DG
            prot1_CM
            pprint_CM
            if mr2print_CM = 0, mr2print_CM =zsecuprint
            prvmr2_CM = mr2print_CM
            pcalxyz3d_CM
            if  mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *mr2print_CM ,e$
            else, pnumligne, pgcode_force_CM,*z1_CM,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_CM
           old_x_CM=xrprint_CM
           old_y_CM=yrprint_CM
           old_z_CM=zrprint_CM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_CM = mi4_CM
       frbase_CM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_CM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_DM        # Debut si outil
            flagmr2_DM = 0
            old_opcode_cloche_DM = opcode$
            POURCENTAGE_AVANCE_DM = (POURCENTAGE_AVANCE_DM/100)
            if POURCENTAGE_AVANCE_DM = 0, POURCENTAGE_AVANCE_DM = 1

            #if (mi4_DM > 0) & (mi4_DM <> 9), mini_c_DM = mini_c_avec_cloche_DM, maxi_c_DM = maxi_c_avec_cloche_DM
            #else, mini_c_DM = mini_c_sans_cloche_DM, maxi_c_DM = maxi_c_sans_cloche_DM

            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_DM
            if (mr2$ = 0) | (mr2$ = 1), psortie15_DM
            if mr2$ = -1, psortie13_DM
            ptrans_option_DM  # mise a jour des variable mi1 et mi2 
            pcantext_DM
            if oscilliation = 1 & mi7$ <> 0, psortie12_DM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DM
            if opcode$ = 16, drill5axes_DM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_DM
            ptestcloche_DM
          gcode$ = 0
          spaces$ = 0
          #enlevé pour concat#pnumligne, " CRENO_START", e$
          mr8_DM = DEC_X_DM + mr8$
          mr9_DM = DEC_Y_DM + mr9$
          mr10_DM = DEC_Z_DM + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          #enlevé pour concat#pnumligne, " $P_UIFR[1]=CTRANS(",mr8_DM,","mr9_DM,","mr10_DM,",A,0.,C,0.)",e$
          #enlevé pour concat#pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          #enlevé pour concat#pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_DM = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          #enlevé pour concat#pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          #enlevé pour concat#pnumligne, "ROT ; RAZ ROTATION ", e$
          #enlevé pour concat#pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          #enlevé pour concat#pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          #enlevé pour concat#pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          tlngno$ = 1
          ptestrenvoi_angle_DM
          spaces$ = 0
          pappeloutil_DM
          mr4_DM = mr4$
          if mr4$ > 0, pnumligne, mr4_DM, e$, pnumligne, "USURE", e$ 
          ptlngno_DM
          spaces$ = 1
          pnumligne, *spdlon_DM, ssprint_DM,e$
          old_ss = ssprint_DM
          plubrifon_DM
          numpp = 6
          comment$
          pnumligne, strcom_DM, e$
          if mi2_A_base_DM = 0, invers_DM = 0
          if mi2_A_base_DM = 2, invers_DM = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_DM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, pnumligne, "M210", e$
            #else, pnumligne, "M211", e$
			progno_DM = progno$
            if opcode$ = 16, ex$
            prot1_DM
            pprint_DM
            if mr2print_DM = 0, mr2print_DM =zsecuprint
            prvmr2_DM = mr2print_DM
            pcalxyz3d_DM
            if  mr2print_DM <>   -1,pnumligne,pgcode_force_DM, *mr2print_DM ,e$
            else, pnumligne, pgcode_force_DM,*z1_DM,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_DM
           old_x_DM=xrprint_DM
           old_y_DM=yrprint_DM
           old_z_DM=zrprint_DM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_DM = mi4_DM
       frbase_DM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_DM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes       
#endregion
#region plansecu2

plansecu2_AG    # retour au plan de retournement 
       pcalxyz3d_AG
plansecu2_BG    # retour au plan de retournement 
       pcalxyz3d_BG
plansecu2_CG    # retour au plan de retournement 
       pcalxyz3d_CG
plansecu2_DG    # retour au plan de retournement 
       pcalxyz3d_DG
plansecu2_AM    # retour au plan de retournement 
       pcalxyz3d_AM
plansecu2_BM    # retour au plan de retournement 
       pcalxyz3d_BM
plansecu2_CM    # retour au plan de retournement 
       pcalxyz3d_CM
plansecu2_DM    # retour au plan de retournement 
       pcalxyz3d_DM
#endregion
#region plansecu

plansecu_AG    # voir si pas deja passer dans premx
        pcalxyz3d_AG
        if prvop_id_AG <> op_id$,
        [
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if  opcode$ <> 16  & mr2print_AG <>   -1,pnumligne,pgcode_force_AG, *mr2print_AG ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_AG <>   -1,pnumligne,pgcode_AG,zrprint_AG,e$
            if opcode$ = 16 & mr2print_AG <>   -1,pnumligne,pgcode_AG,zrprint_AG,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_AG = -1,   pgcode_force_AG, *x3dprint_AG, *y3dprint_AG, *z3dprint_AG, axeCpos1_AG, axeApos1_AG, e$
                         else, pgcode_force_AG, *x3dprint_AG, *y3dprint_AG,axeCpos1_AG, axeApos1_AG, e$
                         ]
           else,
                        [
                         if mr2print_AG = -1,  pnumligne, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*z3dprint_AG, e$
                         else,  pnumligne, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,e$
                        ]
           pnumligne, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
        ]

plansecu_BG    # voir si pas deja passer dans premx
        pcalxyz3d_BG
        if prvop_id_BG <> op_id$,
        [
            panul_plan_inc_BG
            if  opcode$ <> 16  & mr2print_BG <>   -1,pnumligne,pgcode_force_BG, *mr2print_BG ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_BG <>   -1,pnumligne,pgcode_BG,zrprint_BG,e$
            if opcode$ = 16 & mr2print_BG <>   -1,pnumligne,pgcode_BG,zrprint_BG,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_BG = -1,   pgcode_force_BG, *x3dprint_BG, *y3dprint_BG, *z3dprint_BG, axeCpos1_BG, axeApos1_BG, e$
                         else, pgcode_force_BG, *x3dprint_BG, *y3dprint_BG,axeCpos1_BG, axeApos1_BG, e$
                         ]
           else,
                        [
                         if mr2print_BG = -1,  pnumligne, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*z3dprint_BG, e$
                         else,  pnumligne, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,e$
                        ]
           pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$
        ]

plansecu_CG    # voir si pas deja passer dans premx
        pcalxyz3d_CG
        if prvop_id_CG <> op_id$,
        [
            panul_plan_inc_CG
            pgestionduB_cloche_CG
            if axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG

            if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG = 0 ,   [
                                                                            if flagmr2_CG = 2, pnumligne, pgcode_force_CG, *mr2print_CG, e$
                                                                            else, pnumligne, pgcode_force_CG, *mr2print_CG, e$, ptlngno2_CG
                                                                            ]

            if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG <> 0 ,  [
                                                                            if flagmr2_CG = 2, pnumligne, pgcode_force_CG, *mr2print_CG, e$
                                                                            else, pnumligne, pgcode_force_CG, *mr2print_CG, *axeA_cloche_CG, e$, ptlngno2_CG
                                                                            ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_CG <>   -1,pnumligne,pgcode_CG,zrprint_CG,e$
            if opcode$ = 16 & mr2print_CG <> -1 & axeA_cloche_CG = 0, pnumligne, pgcode_CG, zrprint_CG, e$
            if opcode$ = 16 & mr2print_CG <> -1 & axeA_cloche_CG <> 0, pnumligne, pgcode_CG, zrprint_CG, *axeA_cloche_CG, e$, ptlngno2_CG

            if nextop$ <> 11,
                         [
                         if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
                         if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
                         if mr2print_CG = -1,   pnumligne, pgcode_force_CG, *x3dprint_CG, *y3dprint_CG, *z3dprint_CG, axeCpos1_CG, axeApos1_CG, e$
                         else, pnumligne, pgcode_force_CG, *x3dprint_CG, *y3dprint_CG,axeCpos1_CG, axeApos1_CG, e$
                         ]
           else,
                        [
                         if mr2print_CG = -1,  pnumligne, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*z3dprint_CG, e$
                         else,  pnumligne, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,e$
                        ]


             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CG = axeApos_CG
                                axeCpos_cycle800_CG = axeCpos_CG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
        ]
plansecu_DG    # voir si pas deja passer dans premx
        pcalxyz3d_DG
        if prvop_id_DG <> op_id$,
        [
            panul_plan_inc_DG
            pgestionduB_cloche_DG
            if axeA_cloche_DG <> 0 & mr2print_DG = -1, psortie_cloche_DG

            if  opcode$ <> 16  & mr2print_DG <> -1 & axeA_cloche_DG = 0 ,   [
                                                                            if flagmr2_DG = 2, pnumligne, pgcode_force_DG, *mr2print_DG, e$
                                                                            else, pnumligne, pgcode_force_DG, *mr2print_DG, e$, ptlngno2_DG
                                                                            ]

            if  opcode$ <> 16  & mr2print_DG <> -1 & axeA_cloche_DG <> 0 ,  [
                                                                            if flagmr2_DG = 2, pnumligne, pgcode_force_DG, *mr2print_DG, e$
                                                                            else, pnumligne, pgcode_force_DG, *mr2print_DG, *axeA_cloche_DG, e$, ptlngno2_DG
                                                                            ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_DG <>   -1,pnumligne,pgcode_DG,zrprint_DG,e$
            if opcode$ = 16 & mr2print_DG <> -1 & axeA_cloche_DG = 0, pnumligne, pgcode_DG, zrprint_DG, e$
            if opcode$ = 16 & mr2print_DG <> -1 & axeA_cloche_DG <> 0, pnumligne, pgcode_DG, zrprint_DG, *axeA_cloche_DG, e$, ptlngno2_DG

            if nextop$ <> 11,
                         [
                         if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
                         if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
                         if mr2print_DG = -1,   pnumligne, pgcode_force_DG, *x3dprint_DG, *y3dprint_DG, *z3dprint_DG, axeCpos1_DG, axeApos1_DG, e$
                         else, pnumligne, pgcode_force_DG, *x3dprint_DG, *y3dprint_DG,axeCpos1_DG, axeApos1_DG, e$
                         ]
           else,
                        [
                         if mr2print_DG = -1,  pnumligne, pgcode_force_DG, *x3dprint_DG,*y3dprint_DG,*z3dprint_DG, e$
                         else,  pnumligne, pgcode_force_DG, *x3dprint_DG,*y3dprint_DG,e$
                        ]


             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DG = axeApos_DG
                                axeCpos_cycle800_DG = axeCpos_DG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DG = 1
        ]

plansecu_AM    # voir si pas deja passer dans premx
        pcalxyz3d_AM
        if prvop_id_AM <> op_id$,
        [
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if  opcode$ <> 16  & mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_AM <>   -1,pnumligne,pgcode_AM,zrprint_AM,e$
            if opcode$ = 16 & mr2print_AM <>   -1,pnumligne,pgcode_AM,zrprint_AM,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_AM = -1,   pgcode_force_AM, *x3dprint_AM, *y3dprint_AM, *z3dprint_AM, axeCpos1_AM, axeApos1_AM, e$
                         else, pgcode_force_AM, *x3dprint_AM, *y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
                         ]
           else,
                        [
                         if mr2print_AM = -1,  pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,*z3dprint_AM, e$
                         else,  pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,e$
                        ]
           pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
        ]

plansecu_BM    # voir si pas deja passer dans premx
        pcalxyz3d_BM
        if prvop_id_BM <> op_id$,
        [
            panul_plan_inc_BM
            if  opcode$ <> 16  & mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_BM <>   -1,pnumligne,pgcode_BM,zrprint_BM,e$
            if opcode$ = 16 & mr2print_BM <>   -1,pnumligne,pgcode_BM,zrprint_BM,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_BM = -1,   pgcode_force_BM, *x3dprint_BM, *y3dprint_BM, *z3dprint_BM, axeCpos1_BM, axeApos1_BM, e$
                         else, pgcode_force_BM, *x3dprint_BM, *y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
                         ]
           else,
                        [
                         if mr2print_BM = -1,  pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,*z3dprint_BM, e$
                         else,  pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,e$
                        ]
           pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
        ]

plansecu_CM    # voir si pas deja passer dans premx
        pcalxyz3d_CM
        if prvop_id_CM <> op_id$,
        [
            panul_plan_inc_CM
            pgestionduB_cloche_CM
            if axeA_cloche_CM <> 0 & mr2print_CM = -1, #psortie_cloche_CM

            if  opcode$ <> 16  & mr2print_CM <> -1 & axeA_cloche_CM = 0 ,   [
                                                                            if flagmr2_CM = 2, pnumligne, pgcode_force_CM, *mr2print_CM, e$
                                                                            else, pnumligne, pgcode_force_CM, *mr2print_CM, e$, ptlngno2_CM
                                                                            ]

            if  opcode$ <> 16  & mr2print_CM <> -1 & axeA_cloche_CM <> 0 ,  [
                                                                            if flagmr2_CM = 2, pnumligne, pgcode_force_CM, *mr2print_CM, e$
                                                                            else, pnumligne, pgcode_force_CM, *mr2print_CM, e$, ptlngno2_CM#*axeA_cloche_CM, e$, ptlngno2_CM
                                                                            ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_CM <>   -1,pnumligne,pgcode_CM,zrprint_CM,e$
            if opcode$ = 16 & mr2print_CM <> -1 & axeA_cloche_CM = 0, pnumligne, pgcode_CM, zrprint_CM, e$
            if opcode$ = 16 & mr2print_CM <> -1 & axeA_cloche_CM <> 0, pnumligne, pgcode_CM, zrprint_CM, e$, ptlngno2_CM#*axeA_cloche_CM, e$, ptlngno2_CM

            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_CM = -1,   pgcode_force_CM, *x3dprint_CM, *y3dprint_CM, *z3dprint_CM, axeCpos1_CM, axeApos1_CM, e$
                         else, pgcode_force_CM, *x3dprint_CM, *y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
                         ]
           else,
                        [
                         if mr2print_CM = -1,  pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,*z3dprint_CM, e$
                         else,  pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,e$
                        ]
             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CM = axeApos_CM
                                axeCpos_cycle800_CM = axeCpos_CM
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
        ]

plansecu_DM    # voir si pas deja passer dans premx
        pcalxyz3d_DM
        if prvop_id_DM <> op_id$,
        [
            panul_plan_inc_DM
            pgestionduB_cloche_DM
            if axeA_cloche_DM <> 0 & mr2print_DM = -1, #psortie_cloche_DM

            if  opcode$ <> 16  & mr2print_DM <> -1 & axeA_cloche_DM = 0 ,   [
                                                                            if flagmr2_DM = 2, pnumligne, pgcode_force_DM, *mr2print_DM, e$
                                                                            else, pnumligne, pgcode_force_DM, *mr2print_DM, e$, ptlngno2_DM
                                                                            ]

            if  opcode$ <> 16  & mr2print_DM <> -1 & axeA_cloche_DM <> 0 ,  [
                                                                            if flagmr2_DM = 2, pnumligne, pgcode_force_DM, *mr2print_DM, e$
                                                                            else, pnumligne, pgcode_force_DM, *mr2print_DM, e$, ptlngno2_DM#*axeA_cloche_DM, e$, ptlngno2_DM
                                                                            ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_DM <>   -1,pnumligne,pgcode_DM,zrprint_DM,e$
            if opcode$ = 16 & mr2print_DM <> -1 & axeA_cloche_DM = 0, pnumligne, pgcode_DM, zrprint_DM, e$
            if opcode$ = 16 & mr2print_DM <> -1 & axeA_cloche_DM <> 0, pnumligne, pgcode_DM, zrprint_DM, e$, ptlngno2_DM#*axeA_cloche_DM, e$, ptlngno2_DM

            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_DM = -1,   pgcode_force_DM, *x3dprint_DM, *y3dprint_DM, *z3dprint_DM, axeCpos1_DM, axeApos1_DM, e$
                         else, pgcode_force_DM, *x3dprint_DM, *y3dprint_DM,axeCpos1_DM, axeApos1_DM, e$
                         ]
           else,
                        [
                         if mr2print_DM = -1,  pnumligne, pgcode_force_DM, *x3dprint_DM,*y3dprint_DM,*z3dprint_DM, e$
                         else,  pnumligne, pgcode_force_DM, *x3dprint_DM,*y3dprint_DM,e$
                        ]
             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DM = axeApos_DM
                                axeCpos_cycle800_DM = axeCpos_DM
                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DM = 1
        ]
#endregion      
#endregion

#region   PTLCHG PEOF #OK
#region ptlchg0
fmt 4 progno_AM
fmt 4 progno_BM
fmt 4 progno_CM
fmt 4 progno_DM
ptlchg0$
            if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")), [
                                                                                            if opcode$ > 16, psortieplan5X
                                                                                            ]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            ptlchg0_AG

            if op_id$ <> prvop_id_AM & (mi10$ <> 0 | progno_AM <> progno$),	[
																			pchange_AM
																			pcont_garage_AM
            																ptlchg_AM
																			]
			else,	[										
            		pcont_garage_AM
            		pchange_AM
            		ptlchg0_AM
					]

            pchange_BG
            ptlchg0_BG

            if op_id$ <> prvop_id_BM & (mi10$ <> 0 | progno_BM <> progno$),	[
																			pchange_BM
																			pcont_garage_BM
            																ptlchg_BM
																			]
			else,	[										
            		pcont_garage_BM
            		pchange_BM
            		ptlchg0_BM
					]

            pchange_CG
            ptlchg0_CG

			if op_id$ <> prvop_id_CM & (mi10$ <> 0 | progno_CM <> progno$),	[
																			pchange_CM
																			pcont_garage_CM
            																ptlchg_CM
																			]
			else,	[										
            		pcont_garage_CM
            		pchange_CM
            		ptlchg0_CM
					]

            pchange_DG
            ptlchg0_DG

            if op_id$ <> prvop_id_DM & (mi10$ <> 0 | progno_DM <> progno$),	[
																			pchange_DM
																			pcont_garage_DM
            																ptlchg_DM
																			]
			else,	[										
            		pcont_garage_DM
            		pchange_DM
            		ptlchg0_DM
					]

            old_numprg_garage_AM = numprg_garage_AM
            old_numprg_garage_BM = numprg_garage_BM
            old_numprg_garage_CM = numprg_garage_CM
            old_numprg_garage_DM = numprg_garage_DM
            old_progno_AM = numprg_concat_AM
            old_progno_BM = numprg_concat_BM
            old_progno_CM = numprg_concat_CM
            old_progno_DM = numprg_concat_DM

ptlchg0_AG     # Changement outil nul
              pnumop_AG
              if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
              if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
              if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
              ptrans_option_AG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_AG = 0
                if op_id$ <> prvop_id_AG & mi10$ <> 1 & mi10$ <> -1, pcantext_AG

            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AG
         #"axeC_AG  =", axeC_AG, e

         #"cont_axe_c_AG=", cont_axe_c_AG, e


        if operation_AG = 11,[
            gfr_AG = 1
             pnumligne,*sgfr_AG,*fretrait_AG,e$
        ]
        pdmodalxyz_AG
    #   "opcode",*opcode
        if mr2print_AG = 0, mr2print_AG =zsecuprint
        gcode$ = 0
        plubrifoff_AG,e$
        if drill5axes_AG = 1 | opcode$ = 3,pnumligne, "G151 EC0. EA0. EU0. EV0. EW0",e$
        if ((drill5axes_AG = 1)|(opcode$ = 3)) & mr2print_AG <>   -1,pnumligne, pgcode_force_AG, mr2print_AG,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_AG = 1)|(opcode = 3),n , pgcode_force_AG, mr2
        drill5axes_AG = 0
            typcycle_AG = 0
            if op_id$ <> prvop_id_AG,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_AG
                                        ]
            if oldstation_AG = 0 & mi4_AG = 9, pnumligne,"M151",e$
        else,
         [
         if oldstation_AG < 0 & mi4_AG = 0, pnumligne,"M150",e$
         else,[
                      if oldstation_AG <> mi4_AG, ptlngno2_AG
                      ]
            ]
            prvmr2_AG = mr2print_AG
            xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
            pasmi7 = 0
            oldstation_AG = mi4_AG
            if mi2_A_base_AG = 0, invers_AG = 0
        if mi2_A_base_AG = 2, invers_AG = 1
        if operation_AG = 11 & nextop$ = 11 & op_id$ <> prvop_id_AG, premx_AG
        #if operation_AG = 11 & nextop = 11 & op_id = prvop_id_AG, mr2 = -1
        if (oldstation_AG = mi4_AG) & (ssprint_AG <> old_ss) , pnumligne, *spdlon_AG, "M40", *ssprint_AG,e$
        old_ss = ssprint_AG
        plubrifon_AG,e$
            if opcode$ = 16,
            [
                 drill5axes_AG = 1
                 pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
                  tourne = 0
                 !tourne
            ]
            if opcode$ = 16,    [    
                                if op_id$ <> prvop_id_AG, comment$
                                if op_id$ <> prvop_id_AM & (mi10$ <> 0 | progno_AM <> progno$),	[
																			pchange_AM
																			pcont_garage_AM
            																ptlchg_AM
																			]
			else,	[										
            		pcont_garage_AM
            		pchange_AM
            		ptlchg0_AM
					]
                                ]
            prot1_AG
            pprint_AG
       # *old_axeCpos_AG, *axeCpos_AG, *old_axeApos_AG, *axeApos_AG, *old_tox4_AG,*tox4, *old_toy4_AG,toy4, *old_toz4_AG, *toz4         
            !old_axeCpos_AG, !axeCpos_AG, !old_axeApos_AG, !axeApos_AG, !old_tox4_AG, !old_toy4_AG, !old_toz4_AG, !tox4print_AG, !toy4print_AG, !toz4print_AG
            if drill5axes_AG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_AG <> axeCpos_AG) | (old_axeApos_AG <> axeApos_AG) | (old_tox4_AG <> tox4print_AG) | (old_toy4_AG <> toy4print_AG) | (old_toz4_AG <> toz4print_AG), prot3_AG,e$
                 else,
                [
                if operation_AG <> 11 | nextop$ <> 11, plansecu_AG
                ]
            ]

            if operation_AG <> 11 & nextop$ = 11, operation_AG = 1
        else, operation_AG = 0

        if prvop_id_AG <> op_id$, changop_AG = 1, pugv_AG
        else, changop_AG = 0
            
            if op_id$ <> prvop_id_AG, comment$
			prvop_id_AG = op_id$
            numpp = 1
            
        frbase_AG = fr$
        debut_AG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_BG     # Changement outil nul

                pnumop_BG
                if oscilliation = 1 & mi7$ <> 0, psortie12_BG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
                ptrans_option_BG  # on est dans le cas d'une transformation 
               cycle_heli_spiral_BG = 0
                if op_id$ <> prvop_id_BG & mi10$ <> 1 & mi10$ <> -1, pcantext_BG

                if op_id$ <> prvop_id_BG,
                [
                if mi9$ = -1, pnumligne, "M210", e$
                else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_BG
            ptestcloche_BG

        if operation_BG = 11,[
            gfr_BG = 1
             pnumligne,*sgfr_BG,*fretrait_BG,e$
        ]
        pdmodalxyz_BG
    #   "opcode",*opcode
        if mr2print_BG = 0, mr2print_BG =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_BG,
        [
         pcontrol_lubrif_BG
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_BG
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_BG = 1 | opcode$ = 3, panul_plan_inc_BG
        if ((drill5axes_BG = 1)|(opcode$ = 3)) & mr2print_BG <>   -1,pnumligne, pgcode_force_BG, mr2print_BG,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_BG = 1)|(opcode = 3),n , pgcode_force_BG, mr2
        drill5axes_BG = 0
            typcycle_BG = 0
            if op_id$ <> prvop_id_BG,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_BG
                                        ]
            if op_id$ <> prvop_id_BG & ((mi10$ > 1) | (mi10$ < -1)), ptempo_BG
            if oldstation_BG = 0 & mi4_BG = 9, pnumligne,"M151 ; ARRET ASPI",e$
            else,
                [
                if oldstation_BG < 0 & mi4_BG = 0, pnumligne,"M150 ; MARCHE ASPI",e$
                else,[
                      if oldstation_BG <> mi4_BG, ptlngno2_BG
                     ]
                ]
        prvmr2_BG = mr2print_BG
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_BG = 0, invers_BG = 0
        if mi2_A_base_BG = 2, invers_BG = 1
        if operation_BG = 11 & nextop$ = 11 & op_id$ <> prvop_id_BG, premx_BG
        #if operation_BG = 11 & nextop = 11 & op_id = prvop_id_BG, mr2 = -1
        if (oldstation_BG = mi4_BG) & (ssprint_BG <> old_ss) , pnumligne, *spdlon_BG, *ssprint_BG,e$
        old_ss = ssprint_BG
        oldstation_BG = mi4_BG
        if op_id$ <> prvop_id_BG, plubrifon_BG
        pcycle832_BG
        #prot1_BG
            if opcode$ = 16,
            [
                 drill5axes_BG = 1
                 panul_plan_inc_BG
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                
                                if op_id$ <> prvop_id_BG, comment$
                                if op_id$ <> prvop_id_BM & (mi10$ <> 0 | progno_BM <> progno$),	[
																			pchange_BM
																			pcont_garage_BM
            																ptlchg_BM
																			]
			else,	[										
            		pcont_garage_BM
            		pchange_BM
            		ptlchg0_BM
					]
                                ]
            prot1_BG
            pprint_BG
       # *old_axeCpos_BG, *axeCpos_BG, *old_axeApos_BG, *axeApos_BG, *old_tox4_BG,*tox4, *old_toy4_BG,toy4, *old_toz4_BG, *toz4         
            !old_axeCpos_BG, !axeCpos_BG, !old_axeApos_BG, !axeApos_BG, !old_tox4_BG, !old_toy4_BG, !old_toz4_BG, !tox4print_BG, !toy4print_BG, !toz4print_BG
            if drill5axes_BG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_BG <> axeCpos_BG) | (old_axeApos_BG <> axeApos_BG) | (old_tox4_BG <> tox4print_BG) | (old_toy4_BG <> toy4print_BG) | (old_toz4_BG <> toz4print_BG), prot3_BG,e$
                 else,
                [
                if operation_BG <> 11 | nextop$ <> 11, plansecu_BG
                ]
            ]

            if operation_BG <> 11 & nextop$ = 11, operation_BG = 1
            else, operation_BG = 0

        if prvop_id_BG <> op_id$, changop_BG = 1
        else, changop_BG = 0
            
            if op_id$ <> prvop_id_BG, comment$
			prvop_id_BG = op_id$
            numpp = 2
            
        frbase_BG = fr$
        debut_BG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_CG     # Changement outil nul
                garage_CG = 0
                pprep_cloche_CG
                pnumop_CG
                if oscilliation = 1 & mi7$ <> 0, psortie12_CG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
                ptrans_option_CG  # on est dans le cas d'une transformation 
               cycle_heli_spiral_CG = 0
                if op_id$ <> prvop_id_CG & mi10$ <> 1 & mi10$ <> -1, pcantext_CG

                if op_id$ <> prvop_id_CG,
                [
                #if mi9$ = -1, pnumligne, "M210", e$
                #else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_CG
            ptestcloche_CG

        if operation_CG = 11,[
            gfr_CG = 1
            fretrait_CG = fretrait_CG/POURCENTAGE_AVANCE_CG

            pnumligne,*sgfr_CG,*fretrait_CG,e$

            fretrait_CG = fretrait_CG*POURCENTAGE_AVANCE_CG
        ]
        pdmodalxyz_CG
    #   "opcode",*opcode
        if mr2print_CG = 0, mr2print_CG =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_CG,
        [
         pcontrol_lubrif_CG
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_CG
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_CG = 1 | opcode$ = 3, panul_plan_inc_CG, pgestionduB_cloche_CG
        if ((drill5axes_CG = 1)|(opcode$ = 3)) & axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG
        if ((drill5axes_CG = 1)|(opcode$ = 3)) & mr2print_CG <> -1, [
                                                                    if garage_CG <> 0, axeA_cloche_CG = 0
                                                                    if axeA_cloche_CG = 0, pnumligne, pgcode_force_CG, mr2print_CG, e$
                                                                    if axeA_cloche_CG <> 0, pnumligne, pgcode_force_CG, mr2print_CG, *axeA_cloche_CG, e$
                                                                    flagmr2_CG = 1
                                                                    ]
#       if (drill5axes_CG = 1)|(opcode = 3),n , pgcode_force_CG, mr2
        drill5axes_CG = 0
            typcycle_CG = 0
            if op_id$ <> prvop_id_CG,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_CG
                                        ]
            if op_id$ <> prvop_id_CG & ((mi10$ > 1) | (mi10$ < -1)), ptempo_CG

        prvmr2_CG = mr2print_CG
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_CG = 0, invers_CG = 0
        if mi2_A_base_CG = 2, invers_CG = 1
        if operation_CG = 11 & nextop$ = 11 & op_id$ <> prvop_id_CG, premx_CG
        if oldstation_CG = 0 & mi4_CG = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
        else,   [
                if oldstation_CG < 0 & mi4_CG = 0, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$
                else,[
                      if flagmr2_CG = 1, ptlngno2_CG, flagmr2_CG = 2
                      #if oldstation_CG <> mi4_CG, ptlngno2_CG
                     ]
                ]
        #if operation_CG = 11 & nextop = 11 & op_id = prvop_id_CG, mr2 = -1
        if (oldstation_CG = mi4_CG) & (ssprint_CG <> old_ss) , pnumligne, *spdlon_CG, *ssprint_CG,e$
        old_ss = ssprint_CG
        oldstation_CG = mi4_CG
        if op_id$ <> prvop_id_CG, plubrifon_CG
        pcycle832_CG
        #prot1_CG
            if opcode$ = 16,
            [
                 drill5axes_CG = 1
                 panul_plan_inc_CG
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                if op_id$ <> prvop_id_CG, comment$
                                old_opcode_cloche_CG = 16
								if op_id$ <> prvop_id_CM & (mi10$ <> 0 | progno_CM <> progno$),	[
																			pchange_CM
																			pcont_garage_CM
            																ptlchg_CM
																			]
			else,	[										
            		pcont_garage_CM
            		pchange_CM
            		ptlchg0_CM
					]
                                ]
            prot1_CG
            pprint_CG
       # *old_axeCpos_CG, *axeCpos_CG, *old_axeApos_CG, *axeApos_CG, *old_tox4_CG,*tox4, *old_toy4_CG,toy4, *old_toz4_CG, *toz4         
            !old_axeCpos_CG, !axeCpos_CG, !old_axeApos_CG, !axeApos_CG, !old_tox4_CG, !old_toy4_CG, !old_toz4_CG, !tox4print_CG, !toy4print_CG, !toz4print_CG
            if drill5axes_CG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_CG <> axeCpos_CG) | (old_axeApos_CG <> axeApos_CG) | (old_tox4_CG <> tox4print_CG) | (old_toy4_CG <> toy4print_CG) | (old_toz4_CG <> toz4print_CG), prot3_CG,e$
                 else,
                [
                if operation_CG <> 11 | nextop$ <> 11, plansecu_CG
                ]
            ]

            if operation_CG <> 11 & nextop$ = 11, operation_CG = 1
            else, operation_CG = 0
		
        if prvop_id_CG <> op_id$, changop_CG = 1
        else, changop_CG = 0
            
            if op_id$ <> prvop_id_CG, comment$
			prvop_id_CG = op_id$
            numpp = 3
            
        frbase_CG = fr$
        debut_CG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
                old_opcode_cloche_CG = opcode$

ptlchg0_DG     # Changement outil nul
                garage_DG = 0
                pprep_cloche_DG
                pnumop_DG
                if oscilliation = 1 & mi7$ <> 0, psortie12_DG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_DG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DG
                ptrans_option_DG  # on est dans le cas d'une transformation 
               cycle_heli_spiral_DG = 0
                if op_id$ <> prvop_id_DG & mi10$ <> 1 & mi10$ <> -1, pcantext_DG

                if op_id$ <> prvop_id_DG,
                [
                #if mi9$ = -1, pnumligne, "M210", e$
                #else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_DG = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_DG
            ptestcloche_DG

        if operation_DG = 11,[
            gfr_DG = 1
            fretrait_DG = fretrait_DG/POURCENTAGE_AVANCE_DG

            pnumligne,*sgfr_DG,*fretrait_DG,e$

            fretrait_DG = fretrait_DG*POURCENTAGE_AVANCE_DG
        ]
        pdmodalxyz_DG
    #   "opcode",*opcode
        if mr2print_DG = 0, mr2print_DG =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_DG,
        [
         pcontrol_lubrif_DG
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_DG
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_DG = 1 | opcode$ = 3, panul_plan_inc_DG, pgestionduB_cloche_DG
        if ((drill5axes_DG = 1)|(opcode$ = 3)) & axeA_cloche_DG <> 0 & mr2print_DG = -1, psortie_cloche_DG
        if ((drill5axes_DG = 1)|(opcode$ = 3)) & mr2print_DG <> -1, [
                                                                    if garage_DG <> 0, axeA_cloche_DG = 0
                                                                    if axeA_cloche_DG = 0, pnumligne, pgcode_force_DG, mr2print_DG, e$
                                                                    if axeA_cloche_DG <> 0, pnumligne, pgcode_force_DG, mr2print_DG, *axeA_cloche_DG, e$
                                                                    flagmr2_DG = 1
                                                                    ]
#       if (drill5axes_DG = 1)|(opcode = 3),n , pgcode_force_DG, mr2
        drill5axes_DG = 0
            typcycle_DG = 0
            if op_id$ <> prvop_id_DG,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_DG
                                        ]
            if op_id$ <> prvop_id_DG & ((mi10$ > 1) | (mi10$ < -1)), ptempo_DG

        prvmr2_DG = mr2print_DG
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_DG = 0, invers_DG = 0
        if mi2_A_base_DG = 2, invers_DG = 1
        if operation_DG = 11 & nextop$ = 11 & op_id$ <> prvop_id_DG, premx_DG
        if oldstation_DG = 0 & mi4_DG = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
        else,   [
                if oldstation_DG < 0 & mi4_DG = 0, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$
                else,[
                      if flagmr2_DG = 1, ptlngno2_DG, flagmr2_DG = 2
                      #if oldstation_DG <> mi4_DG, ptlngno2_DG
                     ]
                ]
        #if operation_DG = 11 & nextop = 11 & op_id = prvop_id_DG, mr2 = -1
        if (oldstation_DG = mi4_DG) & (ssprint_DG <> old_ss) , pnumligne, *spdlon_DG, *ssprint_DG,e$
        old_ss = ssprint_DG
        oldstation_DG = mi4_DG
        if op_id$ <> prvop_id_DG, plubrifon_DG
        pcycle832_DG
        #prot1_DG
            if opcode$ = 16,
            [
                 drill5axes_DG = 1
                 panul_plan_inc_DG
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                
                                if op_id$ <> prvop_id_DG, comment$
                                old_opcode_cloche_DG = 16
								if op_id$ <> prvop_id_DM & (mi10$ <> 0 | progno_DM <> progno$),	[
																			pchange_DM
																			pcont_garage_DM
            																ptlchg_DM
																			]
			else,	[										
            		pcont_garage_DM
            		pchange_DM
            		ptlchg0_DM
					]
                                ]
            prot1_DG
            pprint_DG
       # *old_axeCpos_DG, *axeCpos_DG, *old_axeApos_DG, *axeApos_DG, *old_tox4_DG,*tox4, *old_toy4_DG,toy4, *old_toz4_DG, *toz4         
            !old_axeCpos_DG, !axeCpos_DG, !old_axeApos_DG, !axeApos_DG, !old_tox4_DG, !old_toy4_DG, !old_toz4_DG, !tox4print_DG, !toy4print_DG, !toz4print_DG
            if drill5axes_DG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_DG <> axeCpos_DG) | (old_axeApos_DG <> axeApos_DG) | (old_tox4_DG <> tox4print_DG) | (old_toy4_DG <> toy4print_DG) | (old_toz4_DG <> toz4print_DG), prot3_DG,e$
                 else,
                [
                if operation_DG <> 11 | nextop$ <> 11, plansecu_DG
                ]
            ]

            if operation_DG <> 11 & nextop$ = 11, operation_DG = 1
            else, operation_DG = 0

        if prvop_id_DG <> op_id$, changop_DG = 1
        else, changop_DG = 0
            
            if op_id$ <> prvop_id_DG, comment$
			prvop_id_DG = op_id$
            numpp = 3
            
        frbase_DG = fr$
        debut_DG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
                old_opcode_cloche_DG = opcode$

ptlchg0_AM     # Changement outil nul

              pnumop_AM
              if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
              if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
              if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
              ptrans_option_AM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_AM = 0
                if op_id$ <> prvop_id_AM & mi10$ <> 1 & mi10$ <> -1, pcantext_AM

            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AM
         #"axeC_AM  =", axeC_AM, e

         #"cont_axe_c_AM=", cont_axe_c_AM, e


        if operation_AM = 11,[
            gfr_AM = 1
             pnumligne,*sgfr_AM, *fretrait_AM, e$
        ]
        pdmodalxyz_AM
    #   "opcode",*opcode
        if mr2print_AM = 0, mr2print_AM =zsecuprint
        gcode$ = 0
        plubrifoff_AM,e$
        if drill5axes_AM = 1 | opcode$ = 3,pnumligne, "G151 EC0. EA0. EU0. EV0. EW0",e$
        if ((drill5axes_AM = 1)|(opcode$ = 3)) & mr2print_AM <>   -1,pnumligne, pgcode_force_AM, mr2print_AM,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_AM = 1)|(opcode = 3),n , pgcode_force_AM, mr2
        drill5axes_AM = 0
            typcycle_AM = 0
            if op_id$ <> prvop_id_AM,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_AM
                                        ]
            if oldstation_AM = 0 & mi4_AM = 9, pnumligne,"M151",e$
        else,
         [
         if oldstation_AM < 0 & mi4_AM = 0, pnumligne,"M150",e$
         else,[
                      if oldstation_AM <> mi4_AM, ptlngno2_AM
                      ]
            ]
            prvmr2_AM = mr2print_AM
            xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
            pasmi7 = 0
            oldstation_AM = mi4_AM
            if mi2_A_base_AM = 0, invers_AM = 0
        if mi2_A_base_AM = 2, invers_AM = 1
        if operation_AM = 11 & nextop$ = 11 & op_id$ <> prvop_id_AM, premx_AM
        #if operation_AM = 11 & nextop = 11 & op_id = prvop_id_AM, mr2 = -1
        if (oldstation_AM = mi4_AM) & (ssprint_AM <> old_ss) , pnumligne, *spdlon_AM, "M40", *ssprint_AM,e$
        old_ss = ssprint_AM
        plubrifon_AM,e$
            if opcode$ = 16,
            [
                 drill5axes_AM = 1
                 pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
                  tourne = 0
                 !tourne
            ]
            if opcode$ = 16,    [
                                progno_AM = progno$
                                if op_id$ <> prvop_id_AM, comment$, pnumligne, strcom_AM, e$
                                pchange_BG, ptlchg0_BG
                                ]
            prot1_AM
            pprint_AM
       # *old_axeCpos_AM, *axeCpos_AM, *old_axeApos_AM, *axeApos_AM, *old_tox4_AM,*tox4, *old_toy4_AM,toy4, *old_toz4_AM, *toz4         
            !old_axeCpos_AM, !axeCpos_AM, !old_axeApos_AM, !axeApos_AM, !old_tox4_AM, !old_toy4_AM, !old_toz4_AM, !tox4print_AM, !toy4print_AM, !toz4print_AM
            if drill5axes_AM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_AM <> axeCpos_AM) | (old_axeApos_AM <> axeApos_AM) | (old_tox4_AM <> tox4print_AM) | (old_toy4_AM <> toy4print_AM) | (old_toz4_AM <> toz4print_AM), prot3_AM,e$
                 else,
                [
                if operation_AM <> 11 | nextop$ <> 11, plansecu_AM
                ]
            ]

            if operation_AM <> 11 & nextop$ = 11, operation_AM = 1
        else, operation_AM = 0

        if prvop_id_AM <> op_id$, changop_AM = 1, pugv_AM
        else, changop_AM = 0
            
            if op_id$ <> prvop_id_AM, comment$, pnumligne, strcom_AM, e$
			prvop_id_AM = op_id$
            numpp = 4
            
        frbase_AM = fr$
        debut_AM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
			   progno_AM = progno$
ptlchg0_BM     # Changement outil nul

                pnumop_BM
                if oscilliation = 1 & mi7$ <> 0, psortie12_BM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
                ptrans_option_BM  # on est dans le cas d'une transformation 
               cycle_heli_spiral_BM = 0
                if op_id$ <> prvop_id_BM & mi10$ <> 1 & mi10$ <> -1, pcantext_BM

                if op_id$ <> prvop_id_BM,
                [
                if mi9$ = -1, pnumligne, "M210", e$
                else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_BM
            ptestcloche_BM

        if operation_BM = 11,[
            gfr_BM = 1
             pnumligne,*sgfr_BM,*fretrait_BM,e$
        ]
        pdmodalxyz_BM
    #   "opcode",*opcode
        if mr2print_BM = 0, mr2print_BM =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_BM,
        [
         pcontrol_lubrif_BM
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_BM
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_BM = 1 | opcode$ = 3, panul_plan_inc_BM
        if ((drill5axes_BM = 1)|(opcode$ = 3)) & mr2print_BM <>   -1,pnumligne, pgcode_force_BM, mr2print_BM,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_BM = 1)|(opcode = 3),n , pgcode_force_BM, mr2
        drill5axes_BM = 0
            typcycle_BM = 0
            if op_id$ <> prvop_id_BM,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_BM
                                        ]
            if op_id$ <> prvop_id_BM & ((mi10$ > 1) | (mi10$ < -1)), ptempo_BM
            if oldstation_BM = 0 & mi4_BM = 9, pnumligne,"M151 ; ARRET ASPI",e$
            else,
                [
                if oldstation_BM < 0 & mi4_BM = 0, pnumligne,"M150 ; MARCHE ASPI",e$
                else,[
                      if oldstation_BM <> mi4_BM, ptlngno2_BM
                     ]
                ]
        prvmr2_BM = mr2print_BM
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_BM = 0, invers_BM = 0
        if mi2_A_base_BM = 2, invers_BM = 1
        if operation_BM = 11 & nextop$ = 11 & op_id$ <> prvop_id_BM, premx_BM
        #if operation_BM = 11 & nextop = 11 & op_id = prvop_id_BM, mr2 = -1
        if (oldstation_BM = mi4_BM) & (ssprint_BM <> old_ss) , pnumligne, *spdlon_BM, *ssprint_BM,e$
        old_ss = ssprint_BM
        oldstation_BM = mi4_BM
        if op_id$ <> prvop_id_BM, plubrifon_BM
        pcycle832_BM
        #prot1_BM
            if opcode$ = 16,
            [
                 drill5axes_BM = 1
                 panul_plan_inc_BM
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                progno_BM = progno$
                                if op_id$ <> prvop_id_BM, comment$, pnumligne, strcom_BM, e$
                                pchange_CG, ptlchg0_CG
                                ]
            prot1_BM
            pprint_BM
       # *old_axeCpos_BM, *axeCpos_BM, *old_axeApos_BM, *axeApos_BM, *old_tox4_BM,*tox4, *old_toy4_BM,toy4, *old_toz4_BM, *toz4         
            !old_axeCpos_BM, !axeCpos_BM, !old_axeApos_BM, !axeApos_BM, !old_tox4_BM, !old_toy4_BM, !old_toz4_BM, !tox4print_BM, !toy4print_BM, !toz4print_BM
            if drill5axes_BM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_BM <> axeCpos_BM) | (old_axeApos_BM <> axeApos_BM) | (old_tox4_BM <> tox4print_BM) | (old_toy4_BM <> toy4print_BM) | (old_toz4_BM <> toz4print_BM), prot3_BM,e$
                 else,
                [
                if operation_BM <> 11 | nextop$ <> 11, plansecu_BM
                ]
            ]

            if operation_BM <> 11 & nextop$ = 11, operation_BM = 1
            else, operation_BM = 0

        if prvop_id_BM <> op_id$, changop_BM = 1
        else, changop_BM = 0
            
            if op_id$ <> prvop_id_BM, comment$, pnumligne, strcom_BM, e$
			prvop_id_BM = op_id$
            numpp = 5
            
        frbase_BM = fr$
        debut_BM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
			   progno_BM = progno$
ptlchg0_CM     # Changement outil nul
                pprep_cloche_CM
                pnumop_CM
                if oscilliation = 1 & mi7$ <> 0, psortie12_CM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
                ptrans_option_CM  # on est dans le cas d'une transformation 
               cycle_heli_spiral_CM = 0
                if op_id$ <> prvop_id_CM & mi10$ <> 1 & mi10$ <> -1, pcantext_CM

                if op_id$ <> prvop_id_CM,
                [
                #if mi9$ = -1, pnumligne, "M210", e$
                #else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_CM
            ptestcloche_CM

        if operation_CM = 11,[
            gfr_CM = 1
            fretrait_CM = fretrait_CM/POURCENTAGE_AVANCE_CM

            pnumligne,*sgfr_CM,*fretrait_CM,e$

            fretrait_CM = fretrait_CM*POURCENTAGE_AVANCE_CM

        ]
        pdmodalxyz_CM
    #   "opcode",*opcode
        if mr2print_CM = 0, mr2print_CM =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_CM,
        [
         pcontrol_lubrif_CM
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_CM
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]

        if drill5axes_CM = 1 | opcode$ = 3, panul_plan_inc_CM, pgestionduB_cloche_CM
        if ((drill5axes_CM = 1)|(opcode$ = 3)) & axeA_cloche_CM <> 0 & mr2print_CM = -1, #psortie_cloche_CM
        if ((drill5axes_CM = 1)|(opcode$ = 3)) & mr2print_CM <> -1, [
                                                                    if axeA_cloche_CM = 0, pnumligne, pgcode_force_CM, mr2print_CM, e$
                                                                    if axeA_cloche_CM <> 0, pnumligne, pgcode_force_CM, mr2print_CM, e$ #*axeA_cloche_CM, e$
                                                                    flagmr2_CM = 1
                                                                    ]

#       if (drill5axes_CM = 1)|(opcode = 3),n , pgcode_force_CM, mr2
        drill5axes_CM = 0
            typcycle_CM = 0
            if op_id$ <> prvop_id_CM,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_CM
                                        ]
            if op_id$ <> prvop_id_CM & ((mi10$ > 1) | (mi10$ < -1)), ptempo_CM

        prvmr2_CM = mr2print_CM
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_CM = 0, invers_CM = 0
        if mi2_A_base_CM = 2, invers_CM = 1
        if operation_CM = 11 & nextop$ = 11 & op_id$ <> prvop_id_CM, premx_CM
        #if operation_CM = 11 & nextop = 11 & op_id = prvop_id_CM, mr2 = -1
        if oldstation_CM = 0 & mi4_CM = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
        else,   [
                if oldstation_CM < 0 & mi4_CM = 0, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$
                else,[
                      if flagmr2_CM = 1, spaces$ = 0, ptlngno2_CM, spaces$ = 1, flagmr2_CM = 2
                      #if oldstation_CM <> mi4_CM, ptlngno2_CM
                     ]
                ]
        if (oldstation_CM = mi4_CM) & (ssprint_CM <> old_ss) , pnumligne, *spdlon_CM, *ssprint_CM,e$
        old_ss = ssprint_CM
        oldstation_CM = mi4_CM
        if op_id$ <> prvop_id_CM, plubrifon_CM
        pcycle832_CM
        #prot1_CM
            if opcode$ = 16,
            [
                 drill5axes_CM = 1
                 panul_plan_inc_CM
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                progno_CM = progno$
                                if op_id$ <> prvop_id_CM, comment$, pnumligne, strcom_CM, e$
                                old_opcode_cloche_CM = 16, pchange_DG, ptlchg0_DG
                                ]
            prot1_CM
            pprint_CM
       # *old_axeCpos_CM, *axeCpos_CM, *old_axeApos_CM, *axeApos_CM, *old_tox4_CM,*tox4, *old_toy4_CM,toy4, *old_toz4_CM, *toz4         
            !old_axeCpos_CM, !axeCpos_CM, !old_axeApos_CM, !axeApos_CM, !old_tox4_CM, !old_toy4_CM, !old_toz4_CM, !tox4print_CM, !toy4print_CM, !toz4print_CM
            if drill5axes_CM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_CM <> axeCpos_CM) | (old_axeApos_CM <> axeApos_CM) | (old_tox4_CM <> tox4print_CM) | (old_toy4_CM <> toy4print_CM) | (old_toz4_CM <> toz4print_CM), prot3_CM,e$
                 else,
                [
                if operation_CM <> 11 | nextop$ <> 11, plansecu_CM
                ]
            ]

            if operation_CM <> 11 & nextop$ = 11, operation_CM = 1
            else, operation_CM = 0

        if prvop_id_CM <> op_id$, changop_CM = 1
        else, changop_CM = 0
            
            if op_id$ <> prvop_id_CM, comment$, pnumligne, strcom_CM, e$
			prvop_id_CM = op_id$
            numpp = 6
            
        frbase_CM = fr$
        debut_CM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
               old_opcode_cloche_CM = opcode$
			   progno_CM = progno$
ptlchg0_DM     # Changement outil nul
                pprep_cloche_DM
                pnumop_DM
                if oscilliation = 1 & mi7$ <> 0, psortie12_DM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_DM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DM
                ptrans_option_DM  # on est dans le cas d'une transformation 
               cycle_heli_spiral_DM = 0
                if op_id$ <> prvop_id_DM & mi10$ <> 1 & mi10$ <> -1, pcantext_DM

                if op_id$ <> prvop_id_DM,
                [
                #if mi9$ = -1, pnumligne, "M210", e$
                #else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_DM = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_DM
            ptestcloche_DM

        if operation_DM = 11,[
            gfr_DM = 1
            fretrait_DM = fretrait_DM/POURCENTAGE_AVANCE_DM

            pnumligne,*sgfr_DM,*fretrait_DM,e$

            fretrait_DM = fretrait_DM*POURCENTAGE_AVANCE_DM

        ]
        pdmodalxyz_DM
    #   "opcode",*opcode
        if mr2print_DM = 0, mr2print_DM =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_DM,
        [
         pcontrol_lubrif_DM
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_DM
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]

        if drill5axes_DM = 1 | opcode$ = 3, panul_plan_inc_DM, pgestionduB_cloche_DM
        if ((drill5axes_DM = 1)|(opcode$ = 3)) & axeA_cloche_DM <> 0 & mr2print_DM = -1, #psortie_cloche_DM
        if ((drill5axes_DM = 1)|(opcode$ = 3)) & mr2print_DM <> -1, [
                                                                    if axeA_cloche_DM = 0, pnumligne, pgcode_force_DM, mr2print_DM, e$
                                                                    if axeA_cloche_DM <> 0, pnumligne, pgcode_force_DM, mr2print_DM, e$ #*axeA_cloche_DM, e$
                                                                    flagmr2_DM = 1
                                                                    ]

#       if (drill5axes_DM = 1)|(opcode = 3),n , pgcode_force_DM, mr2
        drill5axes_DM = 0
            typcycle_DM = 0
            if op_id$ <> prvop_id_DM,   [
                                        if (mi10$ = 1) | (mi10$ = -1), parretprog_DM
                                        ]
            if op_id$ <> prvop_id_DM & ((mi10$ > 1) | (mi10$ < -1)), ptempo_DM

        prvmr2_DM = mr2print_DM
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_DM = 0, invers_DM = 0
        if mi2_A_base_DM = 2, invers_DM = 1
        if operation_DM = 11 & nextop$ = 11 & op_id$ <> prvop_id_DM, premx_DM
        #if operation_DM = 11 & nextop = 11 & op_id = prvop_id_DM, mr2 = -1
        if oldstation_DM = 0 & mi4_DM = 9, pnumligne, "M302 ; ARRET ASPI 1", e$, pnumligne, "M304 ; ARRET ASPI 2", e$
        else,   [
                if oldstation_DM < 0 & mi4_DM = 0, pnumligne, "M301 ; MARCHE ASPI 1 ", e$, pnumligne, "M303 ; MARCHE ASPI 2 ", e$
                else,[
                      if flagmr2_DM = 1, spaces$ = 0, ptlngno2_DM, spaces$ = 1, flagmr2_DM = 2
                      #if oldstation_DM <> mi4_DM, ptlngno2_DM
                     ]
                ]
        if (oldstation_DM = mi4_DM) & (ssprint_DM <> old_ss) , pnumligne, *spdlon_DM, *ssprint_DM,e$
        old_ss = ssprint_DM
        oldstation_DM = mi4_DM
        if op_id$ <> prvop_id_DM, plubrifon_DM
        pcycle832_DM
        #prot1_DM
            if opcode$ = 16,
            [
                 drill5axes_DM = 1
                 panul_plan_inc_DM
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,    [
                                progno_DM = progno$
                                if op_id$ <> prvop_id_DM, comment$, pnumligne, strcom_DM, e$
                                old_opcode_cloche_DM = 16, ex$
                                ]
            prot1_DM
            pprint_DM
       # *old_axeCpos_DM, *axeCpos_DM, *old_axeApos_DM, *axeApos_DM, *old_tox4_DM,*tox4, *old_toy4_DM,toy4, *old_toz4_DM, *toz4         
            !old_axeCpos_DM, !axeCpos_DM, !old_axeApos_DM, !axeApos_DM, !old_tox4_DM, !old_toy4_DM, !old_toz4_DM, !tox4print_DM, !toy4print_DM, !toz4print_DM
            if drill5axes_DM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_DM <> axeCpos_DM) | (old_axeApos_DM <> axeApos_DM) | (old_tox4_DM <> tox4print_DM) | (old_toy4_DM <> toy4print_DM) | (old_toz4_DM <> toz4print_DM), prot3_DM,e$
                 else,
                [
                if operation_DM <> 11 | nextop$ <> 11, plansecu_DM
                ]
            ]

            if operation_DM <> 11 & nextop$ = 11, operation_DM = 1
            else, operation_DM = 0

        if prvop_id_DM <> op_id$, changop_DM = 1
        else, changop_DM = 0
            
            if op_id$ <> prvop_id_DM,comment$, pnumligne, strcom_DM, e$
			prvop_id_DM = op_id$
            numpp = 6
            
        frbase_DM = fr$
        debut_DM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
               old_opcode_cloche_DM = opcode$
			   progno_DM = progno$
#endregion
#region ptlchg
fmt 2 change_tool
change_tool : 0
ptlchg$       
			change_tool = 1
			if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")), [
                                                                                            if opcode$ > 16, psortieplan5X
                                                                                            ]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            ptlchg_AG

            pchange_AM
			pcont_garage_AM
            ptlchg_AM

            pchange_BG
            ptlchg_BG

            pchange_BM
			pcont_garage_BM
            ptlchg_BM

            pchange_CG
            ptlchg_CG

            pchange_CM
			pcont_garage_CM
            ptlchg_CM

            pchange_DG
            ptlchg_DG

            pchange_DM
			pcont_garage_DM
            ptlchg_DM

            old_numprg_garage_AM = numprg_garage_AM
            old_numprg_garage_BM = numprg_garage_BM
            old_numprg_garage_CM = numprg_garage_CM
            old_numprg_garage_DM = numprg_garage_DM
            old_progno_AM = numprg_concat_AM
            old_progno_BM = numprg_concat_BM
            old_progno_CM = numprg_concat_CM
            old_progno_DM = numprg_concat_DM
			change_tool = 0
ptlchg_AG      # Changement outil
				pnumop_AG
                rayon_outil = tldia$/2
                longeur_outil = paramT3 + paramT7
                var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
                if stl_mfg_com = svide, psortietest_outil

                if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
				if mr2$ = -1, psortie13_AG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
                 ptrans_option_AG  # on est dans le cas d'une transformation 
        #      "opcode",*opcode
            cycle_heli_spiral_AG = 0

            if mi10$ <> 1 & mi10$ <> -1, pcantext_AG
            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0

        pprint_AG

        if operation_AG = 11,[
            gfr_AG = 1
             pnumligne,*sgfr_AG, *fretrait_AG,e$
        ]
        pdmodalxyz_AG
            drill5axes_AG = 0



        gcode$ = 0
            pnumligne, "G151 S0",e$
            if (mi10$ = 1) | (mi10$ = -1), parretprog2_AG
            else,
            [
                if  mr2print_AG <> -1 & prvmr2_AG <> -1,pnumligne,pgcode_force_AG, *prvmr2_AG,e$
            ]
            spaces$ = 0
            pnumligne," ", e53_AG,"=0",e$
            spaces$ = 1
            pnumligne, "M9",e$
            pnumligne, "M151",e$
        pnumligne, "M5",e$
        pnumligne, "M170",e$
        xcor = 0
        ycor = 0
        zcor = 0
            pasmi7 = 0
        pasn = 0
       # if t$ > 20 & station_tool = 1, pnumligne, "M6 T0",e$ # depose outil 
        #if t$ < 16 & station_tool = 2, pnumligne, "M6 T0",e$
        if t$ > 16 & t$ < 20 | t$ > 29, [
                                        if prog_AG = 1, q1
                                        ]
        if t$ < 16 , station_tool = 1
        if t$ > 20 , station_tool = 2
        if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
        if t$ = tete_rev_ang_12, pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
        if t$ = tete_rev_ang_21, pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
        if t$ = tete_rev_ang_22, pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
        pnumligne, "M6", *tprint_AG, tlngno$,e$
        spaces$ = 0
        e53_AG = 53000 + tlngno$
        mr4_AG = mr4$
        pnumligne, " ", e53_AG,"=", *mr4_AG,e$
        spaces$ = 1
        ptlngno_AG
            frbase_AG = fr$
        if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)),  pnumligne, *spdlon_AG, "M40", ssprint_AG,e$
            old_ss = ssprint_AG
        plubrifon_AG,e$
            numpp = 1
            comment$
            debut_AG = 0
            prvop_id_AG = op_id$
            if mi2_A_base_AG = 0, invers_AG = 0
            if mi2_A_base_AG = 2 , invers_AG = 1
            if opcode$ = 16, drill5axes_AG = 1
            if opcode$ = 16, pchange_AM, pcont_garage_AM, ptlchg_AM
            prot1_AG
            pprint_AG
            gcode$ = 0
        if mr2print_AG = 0, mr2print_AG =zsecuprint
        prvmr2_AG = mr2print_AG
        pcalxyz3d_AG
            if mr2print_AG <>   -1,pnumligne,pgcode_force_AG, *mr2print_AG ,e$
            else, pnumligne, pgcode_force_AG,*z1_AG,e$
            #if xr <> 0 | yr <> 0
            prot2_AG



            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

                operation_AG = 0

        oldstation_AG = mi4_AG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_AG = 1

               pugv_AG
               vale53 = 0
               sens_pas = -1
               debutvar = 0


ptlchg_BG      # Changement outil
                pnumop_BG
                if oscilliation = 1 & mi7$ <> 0, psortie12_BG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
				if mr2$ = -1, psortie13_BG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
                ptrans_option_BG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_BG = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_BG
            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BG
        ptestcloche_BG

        if operation_BG = 11,
            [
            gfr_BG = 1
            pnumligne,*sgfr_BG, *fretrait_BG,e$
            ]
        pdmodalxyz_BG
        drill5axes_BG = 0
        gcode$ = 0
        panul_plan_inc_BG
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_BG
        else,
            [
                if  mr2print_BG <> -1 & prvmr2_BG <> -1,pnumligne,pgcode_force_BG, *prvmr2_BG,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_BG
            ]
        plubrifoff_BG
        pnumligne, "M151 ; ARRET ASPI",e$
        pnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_BG



        pappeloutil_BG

        mr4_BG = mr4$
        if mr4$ > 0, mr4_BG, e$

        ptlngno_BG
        frbase_BG = fr$
        pnumligne, *spdlon_BG, ssprint_BG,e$
        old_ss = ssprint_BG
        plubrifon_BG

        pcycle832_BG
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         if mi9$ = -1, pnumligne, "M210", e$
         else, pnumligne, "M211", e$
            numpp = 2
            comment$
            debut_BG = 0
            prvop_id_BG = op_id$
            if mi2_A_base_BG = 0, invers_BG = 0
            if mi2_A_base_BG = 2, invers_BG = 1
            if opcode$ = 16, drill5axes_BG = 1
            if opcode$ = 16, pchange_BM, pcont_garage_BM, ptlchg_BM
            prot1_BG
            pprint_BG
            gcode$ = 0
        if mr2print_BG = 0, mr2print_BG =zsecuprint
        prvmr2_BG = mr2print_BG
        pcalxyz3d_BG
            if mr2print_BG <>   -1,pnumligne,pgcode_force_BG, *mr2print_BG ,e$
            else, pnumligne, pgcode_force_BG,*z1_BG,e$
            #if xr <> 0 | yr <> 0
            prot2_BG



            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

                operation_BG = 0

        oldstation_BG = mi4_BG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_BG = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_CG      # Changement outil
                change_outil_CG = 1
                garage_CG = 0
                flagmr2_CG = 0
                old_opcode_cloche_CG = opcode$

                #if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
                #else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG

                pnumop_CG
                if oscilliation = 1 & mi7$ <> 0, psortie12_CG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
				if mr2$ = -1, psortie13_CG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
                ptrans_option_CG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_CG = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_CG
            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CG
        ptestcloche_CG

        if operation_CG = 11,
            [
            gfr_CG = 1
            fretrait_CG = fretrait_CG/POURCENTAGE_AVANCE_CG

            pnumligne,*sgfr_CG,*fretrait_CG,e$

            fretrait_CG = fretrait_CG*POURCENTAGE_AVANCE_CG
            ]
        pdmodalxyz_CG
        drill5axes_CG = 0
        gcode$ = 0
        panul_plan_inc_CG
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_CG
        else,
            [
                if  mr2print_CG <> -1 & prvmr2_CG <> -1,pnumligne,pgcode_force_CG, *prvmr2_CG,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_CG
            ]
        plubrifoff_CG
        pnumligne, "M302 ; ARRET ASPI 1", e$
        pnumligne, "M304 ; ARRET ASPI 2", e$
        pnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_CG



        pappeloutil_CG

        mr4_CG = mr4$
        if mr4$ > 0, mr4_CG, e$, pnumligne, "USURE", e$ 

        ptlngno_CG
        frbase_CG = fr$
        pnumligne, *spdlon_CG, ssprint_CG,e$
        old_ss = ssprint_CG
        plubrifon_CG

        pcycle832_CG
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, pnumligne, "M210", e$
         #else, pnumligne, "M211", e$
            numpp = 3
            comment$
            debut_CG = 0
            prvop_id_CG = op_id$
            if mi2_A_base_CG = 0, invers_CG = 0
            if mi2_A_base_CG = 2, invers_CG = 1
            if opcode$ = 16, drill5axes_CG = 1
            if opcode$ = 16, pchange_CM, pcont_garage_CM, ptlchg_CM
            prot1_CG
            pprint_CG
            gcode$ = 0
        if mr2print_CG = 0, mr2print_CG =zsecuprint
        prvmr2_CG = mr2print_CG
        pcalxyz3d_CG
            if mr2print_CG <>   -1,pnumligne,pgcode_force_CG, *mr2print_CG ,e$
            else, pnumligne, pgcode_force_CG,*z1_CG,e$
            #if xr <> 0 | yr <> 0
            prot2_CG



            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

                operation_CG = 0

        oldstation_CG = mi4_CG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_CG = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_DG      # Changement outil
                change_outil_DG = 1
                garage_DG = 0
                flagmr2_DG = 0
                old_opcode_cloche_DG = opcode$

                #if (mi4_DG > 0) & (mi4_DG <> 9), mini_c_DG = mini_c_avec_cloche_DG, maxi_c_DG = maxi_c_avec_cloche_DG
                #else, mini_c_DG = mini_c_sans_cloche_DG, maxi_c_DG = maxi_c_sans_cloche_DG

                pnumop_DG
                if oscilliation = 1 & mi7$ <> 0, psortie12_DG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_DG
				if mr2$ = -1, psortie13_DG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DG
                ptrans_option_DG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_DG = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_DG
            if opcode$ = 16, drill5axes_DG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_DG
        ptestcloche_DG

        if operation_DG = 11,
            [
            gfr_DG = 1
            fretrait_DG = fretrait_DG/POURCENTAGE_AVANCE_DG

            pnumligne,*sgfr_DG,*fretrait_DG,e$

            fretrait_DG = fretrait_DG*POURCENTAGE_AVANCE_DG
            ]
        pdmodalxyz_DG
        drill5axes_DG = 0
        gcode$ = 0
        panul_plan_inc_DG
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_DG
        else,
            [
                if  mr2print_DG <> -1 & prvmr2_DG <> -1,pnumligne,pgcode_force_DG, *prvmr2_DG,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_DG
            ]
        plubrifoff_DG
        pnumligne, "M302 ; ARRET ASPI 1", e$
        pnumligne, "M304 ; ARRET ASPI 2", e$
        pnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_DG



        pappeloutil_DG

        mr4_DG = mr4$
        if mr4$ > 0, mr4_DG, e$, pnumligne, "USURE", e$ 

        ptlngno_DG
        frbase_DG = fr$
        pnumligne, *spdlon_DG, ssprint_DG,e$
        old_ss = ssprint_DG
        plubrifon_DG

        pcycle832_DG
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, pnumligne, "M210", e$
         #else, pnumligne, "M211", e$
            numpp = 3
            comment$
            debut_DG = 0
            prvop_id_DG = op_id$
            if mi2_A_base_DG = 0, invers_DG = 0
            if mi2_A_base_DG = 2, invers_DG = 1
            if opcode$ = 16, drill5axes_DG = 1
            if opcode$ = 16, pchange_DM, pcont_garage_DM, ptlchg_DM
            prot1_DG
            pprint_DG
            gcode$ = 0
        if mr2print_DG = 0, mr2print_DG =zsecuprint
        prvmr2_DG = mr2print_DG
        pcalxyz3d_DG
            if mr2print_DG <>   -1,pnumligne,pgcode_force_DG, *mr2print_DG ,e$
            else, pnumligne, pgcode_force_DG,*z1_DG,e$
            #if xr <> 0 | yr <> 0
            prot2_DG



            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG

                operation_DG = 0

        oldstation_DG = mi4_DG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_DG = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_AM      # Changement outil
                pnumop_AM

                if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
				#enlevé pour concatif mr2$ = -1, psortie13_AM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
                 ptrans_option_AM  # on est dans le cas d'une transformation 
        #      "opcode",*opcode
            cycle_heli_spiral_AM = 0

            if mi10$ <> 1 & mi10$ <> -1, pcantext_AM
            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0

        pprint_AM

        if operation_AM = 11,[
            gfr_AM = 1
             pnumligne,*sgfr_AM, *fretrait_AM, e$
        ]
        pdmodalxyz_AM
            drill5axes_AM = 0



        gcode$ = 0
            pnumligne, "G151 S0",e$
            if (mi10$ = 1) | (mi10$ = -1), parretprog2_AM
            else,
            [
                #enlevé pour concatif  mr2print_AM <> -1 & prvmr2_AM <> -1,pnumligne,pgcode_force_AM, *prvmr2_AM,e$
            ]
            spaces$ = 0
            #enlevé pour concatpnumligne," ", e53_AM,"=0",e$
            spaces$ = 1
            #enlevé pour concatpnumligne, "M9",e$
            #enlevé pour concatpnumligne, "M151",e$
        #enlevé pour concatpnumligne, "M5",e$
        #enlevé pour concatpnumligne, "M170",e$
        xcor = 0
        ycor = 0
        zcor = 0
            pasmi7 = 0
        pasn = 0
       # if t$ > 20 & station_tool = 1, pnumligne, "M6 T0",e$ # depose outil 
        #if t$ < 16 & station_tool = 2, pnumligne, "M6 T0",e$
        if t$ > 16 & t$ < 20 | t$ > 29, [
                                        if prog_AM = 1, q4
                                        ]
        if t$ < 16 , station_tool = 1
        if t$ > 20 , station_tool = 2
        
        tlngno_AM = tlngno$
		pchange_AM
        pnumligne, "M6", *tprint_AM, *tlngno_AM,e$
		if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
        if t$ = tete_rev_ang_12, pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
        if t$ = tete_rev_ang_21, pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
        if t$ = tete_rev_ang_22, pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
        spaces$ = 0
        e53_AM = 53000 + tlngno$
        #e53_AM = tlngno$
        mr4_AM = mr4$
        pnumligne, " ", e53_AM,"=", *mr4_AM,e$
        spaces$ = 1
        ptlngno_AM
            frbase_AM = fr$
        if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)),  pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
            old_ss = ssprint_AM
        plubrifon_AM,e$
            numpp = 4
            comment$
			pnumligne, strcom_AM, e$
            debut_AM = 0
            prvop_id_AM = op_id$
            if mi2_A_base_AM = 0, invers_AM = 0
            if mi2_A_base_AM = 2 , invers_AM = 1
            if opcode$ = 16, drill5axes_AM = 1
			progno_AM = progno$
            if opcode$ = 16,	[
								if change_tool = 1, pchange_BG, ptlchg_BG
								else, pchange_BG, ptlchg0_BG
								]
            prot1_AM
            pprint_AM
            gcode$ = 0
        if mr2print_AM = 0, mr2print_AM =zsecuprint
        prvmr2_AM = mr2print_AM
        pcalxyz3d_AM
            if mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
            else, pnumligne, pgcode_force_AM,*z1_AM,e$
            #if xr <> 0 | yr <> 0
            prot2_AM



            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

                operation_AM = 0

        oldstation_AM = mi4_AM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_AM = 1

               pugv_AM
               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_BM      # Changement outil

                pnumop_BM
                if oscilliation = 1 & mi7$ <> 0, psortie12_BM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
				#enlevé pour concatif mr2$ = -1, psortie13_BM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
                ptrans_option_BM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_BM = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_BM
            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BM
        ptestcloche_BM

        if operation_BM = 11,
            [
            gfr_BM = 1
            pnumligne,*sgfr_BM, *fretrait_BM,e$
            ]
        pdmodalxyz_BM
        drill5axes_BM = 0
        gcode$ = 0
        panul_plan_inc_BM
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_BM
        else,
            [
                #enlevé pour concatif  mr2print_BM <> -1 & prvmr2_BM <> -1,pnumligne,pgcode_force_BM, *prvmr2_BM,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_BM
            ]
        #enlevé pour concatplubrifoff_BM
        #enlevé pour concatpnumligne, "M151 ; ARRET ASPI",e$
        #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_BM



        pappeloutil_BM

        mr4_BM = mr4$
        if mr4$ > 0, mr4_BM, e$

        ptlngno_BM
        frbase_BM = fr$
        pnumligne, *spdlon_BM, ssprint_BM,e$
        old_ss = ssprint_BM
        plubrifon_BM

        pcycle832_BM
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         if mi9$ = -1, pnumligne, "M210", e$
         else, pnumligne, "M211", e$
            numpp = 5
            comment$
			pnumligne, strcom_BM, e$
            debut_BM = 0
            prvop_id_BM = op_id$
            if mi2_A_base_BM = 0, invers_BM = 0
            if mi2_A_base_BM = 2, invers_BM = 1
            if opcode$ = 16, drill5axes_BM = 1
			progno_BM = progno$
            if opcode$ = 16,	[
								if change_tool = 1, pchange_CG, ptlchg_CG
								else, pchange_CG, ptlchg0_CG
								]
            prot1_BM
            pprint_BM
            gcode$ = 0
        if mr2print_BM = 0, mr2print_BM =zsecuprint
        prvmr2_BM = mr2print_BM
        pcalxyz3d_BM
            if mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            else, pnumligne, pgcode_force_BM,*z1_BM,e$
            #if xr <> 0 | yr <> 0
            prot2_BM



            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

                operation_BM = 0

        oldstation_BM = mi4_BM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_BM = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_CM      # Changement outil
				
            
                flagmr2_CM = 0
                old_opcode_cloche_CM = opcode$

                #if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
                #else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM

                pnumop_CM
                if oscilliation = 1 & mi7$ <> 0, psortie12_CM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
				#enlevé pour concatif mr2$ = -1, psortie13_CM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
                ptrans_option_CM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_CM = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_CM
            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CM
        ptestcloche_CM

        if operation_CM = 11,
            [
            gfr_CM = 1
            fretrait_CM = fretrait_CM/POURCENTAGE_AVANCE_CM

            pnumligne,*sgfr_CM,*fretrait_CM,e$

            fretrait_CM = fretrait_CM*POURCENTAGE_AVANCE_CM
            ]
        pdmodalxyz_CM
        drill5axes_CM = 0
        gcode$ = 0
        panul_plan_inc_CM
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_CM
        else,
            [
                #enlevé pour concatif  mr2print_CM <> -1 & prvmr2_CM <> -1,pnumligne,pgcode_force_CM, *prvmr2_CM,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_CM
            ]
        #enlevé pour concatplubrifoff_CM
        #enlevé pour concatpnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concatpnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_CM

        pappeloutil_CM

        mr4_CM = mr4$
        if mr4$ > 0, mr4_CM, e$, pnumligne, "USURE", e$ 

        ptlngno_CM
        frbase_CM = fr$
        pnumligne, *spdlon_CM, ssprint_CM,e$
        old_ss = ssprint_CM
        plubrifon_CM

        pcycle832_CM
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, pnumligne, "M210", e$
         #else, pnumligne, "M211", e$
            numpp = 6
            comment$
			pnumligne, strcom_CM, e$
            debut_CM = 0
            prvop_id_CM = op_id$
            if mi2_A_base_CM = 0, invers_CM = 0
            if mi2_A_base_CM = 2, invers_CM = 1
            if opcode$ = 16, drill5axes_CM = 1
			progno_CM = progno$
            if opcode$ = 16, 	[
								if change_tool = 1, pchange_DG, ptlchg_DG
								else, pchange_DG, ptlchg0_DG
								]
            prot1_CM
            pprint_CM
            gcode$ = 0
        if mr2print_CM = 0, mr2print_CM =zsecuprint
        prvmr2_CM = mr2print_CM
        pcalxyz3d_CM
            if mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *mr2print_CM ,e$
            else, pnumligne, pgcode_force_CM,*z1_CM,e$
            #if xr <> 0 | yr <> 0
            prot2_CM



            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

                operation_CM = 0

        oldstation_CM = mi4_CM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_CM = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_DM      # Changement outil
                flagmr2_DM = 0
                old_opcode_cloche_DM = opcode$

                #if (mi4_DM > 0) & (mi4_DM <> 9), mini_c_DM = mini_c_avec_cloche_DM, maxi_c_DM = maxi_c_avec_cloche_DM
                #else, mini_c_DM = mini_c_sans_cloche_DM, maxi_c_DM = maxi_c_sans_cloche_DM

                pnumop_DM
                if oscilliation = 1 & mi7$ <> 0, psortie12_DM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_DM
				#enlevé pour concatif mr2$ = -1, psortie13_DM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_DM
                ptrans_option_DM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_DM = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_DM
            if opcode$ = 16, drill5axes_DM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_DM
        ptestcloche_DM

        if operation_DM = 11,
            [
            gfr_DM = 1
            fretrait_DM = fretrait_DM/POURCENTAGE_AVANCE_DM

            pnumligne,*sgfr_DM,*fretrait_DM,e$

            fretrait_DM = fretrait_DM*POURCENTAGE_AVANCE_DM
            ]
        pdmodalxyz_DM
        drill5axes_DM = 0
        gcode$ = 0
        panul_plan_inc_DM
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_DM
        else,
            [
                #enlevé pour concatif  mr2print_DM <> -1 & prvmr2_DM <> -1,pnumligne,pgcode_force_DM, *prvmr2_DM,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_DM
            ]
        #enlevé pour concatplubrifoff_DM
        #enlevé pour concatpnumligne, "M302 ; ARRET ASPI 1", e$
        #enlevé pour concatpnumligne, "M304 ; ARRET ASPI 2", e$
        #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_DM



        pappeloutil_DM

        mr4_DM = mr4$
        if mr4$ > 0, mr4_DM, e$, pnumligne, "USURE", e$ 

        ptlngno_DM
        frbase_DM = fr$
        pnumligne, *spdlon_DM, ssprint_DM,e$
        old_ss = ssprint_DM
        plubrifon_DM

        pcycle832_DM
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, pnumligne, "M210", e$
         #else, pnumligne, "M211", e$
            numpp = 6
            comment$
			pnumligne, strcom_DM, e$
            debut_DM = 0
            prvop_id_DM = op_id$
            if mi2_A_base_DM = 0, invers_DM = 0
            if mi2_A_base_DM = 2, invers_DM = 1
            if opcode$ = 16, drill5axes_DM = 1
			progno_DM = progno$
            if opcode$ = 16, change_tool = 0, ex$
            prot1_DM
            pprint_DM
            gcode$ = 0
        if mr2print_DM = 0, mr2print_DM =zsecuprint
        prvmr2_DM = mr2print_DM
        pcalxyz3d_DM
            if mr2print_DM <>   -1,pnumligne,pgcode_force_DM, *mr2print_DM ,e$
            else, pnumligne, pgcode_force_DM,*z1_DM,e$
            #if xr <> 0 | yr <> 0
            prot2_DM



            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM

                operation_DM = 0

        oldstation_DM = mi4_DM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_DM = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0
#endregion
#region peof0
peof0$
            pchange_AG
            peof0_AG

            pchange_AM
            peof0_AM

            pchange_BG
            peof0_BG

            pchange_BM
            peof0_BM

            pchange_CG
            peof0_CG

            pchange_CM
            peof0_CM

            pchange_DG
            peof0_DG

            pchange_DM
            peof0_DM

peof0_AG      # Fin outil nul
            peof$
peof0_BG       # Fin outil nul
            peof$
peof0_CG       # Fin outil nul
            peof$
peof0_DG       # Fin outil nul
            peof$
peof0_AM      # Fin outil nul
            peof$
peof0_BM       # Fin outil nul
            peof$
peof0_CM       # Fin outil nul
            peof$
peof0_DM       # Fin outil nul
            peof$
#endregion
#region peofpprdr

peofpprdr_AG     #ecriture fin prog mode passant table droite           
                pnumligne,"E10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0",e$
        pnumligne,"E10002=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$

peofpprdr_AM     #ecriture fin prog mode passant table droite           
                pnumligne,"E10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0",e$
        pnumligne,"E10002=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peofpprga

peofpprga_AG    #ecriture fin prog mode passant table gauche           
                pnumligne,"E10003=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10001=0",e$
        pnumligne,"E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$

peofpprga_AM    #ecriture fin prog mode passant table gauche           
                pnumligne,"E10003=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10001=0",e$
        pnumligne,"E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peofpprsy

peofpprsy_AG     #ecriture fin prog mode passant table gauche/droite           
                pnumligne,"E10003=1 E=10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0 E10001=0",e$
        pnumligne,"E10002=0 E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$

peofpprsy_AM     #ecriture fin prog mode passant table gauche/droite           
                pnumligne,"E10003=1 E=10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0 E10001=0",e$
        pnumligne,"E10002=0 E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peof
peof$
                pchange_AG
                peof_AG

                pchange_AM
                peof_AM

                pchange_BG
                peof_BG

                pchange_BM
                peof_BM

                pchange_CG
                peof_CG

                pchange_CM
                peof_CM

                pchange_DG
                peof_DG

                pchange_DM
                peof_DM

                if (erreur_AG = 1) | (erreur_AM = 1) | (erreur_BG = 1) | (erreur_BM = 1) | (erreur_CG = 1) | (erreur_CM = 1) | (erreur_DG = 1) | (erreur_DM = 1),pdestruc_rep

                subout$ = 0  # on ecrit dans le prog de synthese
                clearext$
                " ", e$
                "*************************", e$
                "DIMENSION DE L'OUTILLAGE:", e$
                "*************************", e$
                if sdim_outillage <> svide, " - ", sdim_outillage, e$
                " ", e$
                "************************", e$
                "LISTE DES USURES OUTILS:", e$
                "************************", e$
                if susure_outil_1 <> svide, " - ", susure_outil_1, e$
                if susure_outil_2 <> svide, " - ", susure_outil_2, e$
                if susure_outil_3 <> svide, " - ", susure_outil_3, e$
                if susure_outil_4 <> svide, " - ", susure_outil_4, e$
                if susure_outil_5 <> svide, " - ", susure_outil_5, e$
                if susure_outil_6 <> svide, " - ", susure_outil_6, e$
                if susure_outil_7 <> svide, " - ", susure_outil_7, e$
                if susure_outil_8 <> svide, " - ", susure_outil_8, e$
                if susure_outil_9 <> svide, " - ", susure_outil_9, e$
                if susure_outil_10 <> svide, " - ", susure_outil_10, e$
                if susure_outil_11 <> svide, " - ", susure_outil_11, e$
                if susure_outil_12 <> svide, " - ", susure_outil_12, e$
                if susure_outil_13 <> svide, " - ", susure_outil_13, e$
                if susure_outil_14 <> svide, " - ", susure_outil_14, e$
                if susure_outil_15 <> svide, " - ", susure_outil_15, e$
                if susure_outil_16 <> svide, " - ", susure_outil_16, e$
                if susure_outil_17 <> svide, " - ", susure_outil_17, e$
                if susure_outil_18 <> svide, " - ", susure_outil_18, e$
                if susure_outil_19 <> svide, " - ", susure_outil_19, e$
                if susure_outil_20 <> svide, " - ", susure_outil_20, e$
                if susure_outil_21 <> svide, " - ", susure_outil_21, e$
                if susure_outil_22 <> svide, " - ", susure_outil_22, e$
                if susure_outil_23 <> svide, " - ", susure_outil_23, e$
                if susure_outil_24 <> svide, " - ", susure_outil_24, e$
                if susure_outil_25 <> svide, " - ", susure_outil_25, e$
                if susure_outil_26 <> svide, " - ", susure_outil_26, e$
                if susure_outil_27 <> svide, " - ", susure_outil_27, e$
                if susure_outil_28 <> svide, " - ", susure_outil_28, e$
                if susure_outil_29 <> svide, " - ", susure_outil_29, e$
                if susure_outil_30 <> svide, " - ", susure_outil_30, e$

                " ", e$
                "****************************", e$
                "LISTE DES DECALAGES MACHINE:", e$
                "****************************", e$
                mr8AF_AG = mr8_AG
                mr9AF_AG = mr9_AG
                mr10AF_AG = mr10_AG
                mr8AF_BG = mr8_BG
                mr9AF_BG = mr9_BG
                mr10AF_BG = mr10_BG
                mr8AF_CG = mr8_CG
                mr9AF_CG = mr9_CG
                mr10AF_CG = mr10_CG
                mr8AF_DG = mr8_DG
                mr9AF_DG = mr9_DG
                mr10AF_DG = mr10_DG

                if (prog_AG = 1) | (prog_AM = 1),   [
                                                    smachine_AG, " :", e$
                                                    " - ",*mr8AF_AG, e$
                                                    " - ",*mr9AF_AG, e$
                                                    " - ",*mr10AF_AG, e$
                                                    " ", e$
                                                    ]

                if (prog_BG = 1) | (prog_BM = 1),   [
                                                    smachine_BG, " :", e$
                                                    " - ",*mr8AF_BG, e$
                                                    " - ",*mr9AF_BG, e$
                                                    " - ",*mr10AF_BG, e$
                                                    " ", e$
                                                    ]
                if (prog_CG = 1) | (prog_CM = 1),   [
                                                    smachine_CG, " :", e$
                                                    " - ",*mr8AF_CG, e$
                                                    " - ",*mr9AF_CG, e$
                                                    " - ",*mr10AF_CG, e$
                                                    " ", e$
                                                    ]
                if (prog_DG = 1) | (prog_DM = 1),   [
                                                    smachine_DG, " :", e$
                                                    " - ",*mr8AF_DG, e$
                                                    " - ",*mr9AF_DG, e$
                                                    " - ",*mr10AF_DG, e$
                                                    " ", e$
                                                    ]
                "***************************************", e$
                "TYPE DE MODE DE TRANSFERT DU PROGRAMME:", e$
                "***************************************", e$
                if (prog_AG = 1) | (prog_AM = 1),   [
                                                    smachine_AG, " :", e$
                                                    if mi5_AG = 1," - ", "PPR DR", e$
                                                    if mi5_AG = 2," - ", "PPR GA", e$
                                                    if mi5_AG = 3," - ", "PPR*2", e$
                                                    if mi5_AG = 9," - ", "CONTINU", e$
                                                    " ", e$
                                                    ]

                if (prog_BG = 1) | (prog_BM = 1),   [
                                                    smachine_BG, " :", e$
                                                    if mi5_BG = 1, " - ", "TOUTE LE TABLE", e$
                                                    if mi5_BG = 9, " - ", "MODE PENDULAIRE", e$
                                                    " ", e$
                                                    ]
                if (prog_CG = 1) | (prog_CM = 1),   [
                                                    smachine_CG, " :", e$
                                                    if mi5_CG = 1, " - ", "ZONE 1", e$
                                                    if mi5_CG = 2, " - ", "ZONE 2", e$
                                                    if mi5_CG = 9, " - ", "TOUTE LE TABLE", e$
                                                    " ", e$
                                                    ]
                if (prog_DG = 1) | (prog_DM = 1),   [
                                                    smachine_DG, " :", e$
                                                    if mi5_DG = 1, " - ", "ZONE 1", e$
                                                    if mi5_DG = 2, " - ", "ZONE 2", e$
                                                    if mi5_DG = 9, " - ", "TOUTE LE TABLE", e$
                                                    " ", e$
                                                    ]
                "************************************************", e$
                "LISTE DES FICHIERS CREES PAR LE POST PROCESSEUR:", e$
                "************************************************", e$
                if (erreur_AG = 0) & (erreur_AM = 0) & (erreur_BG = 0) & (erreur_BM = 0) & (erreur_CG = 0) & (erreur_CM = 0) & (erreur_DG = 0) & (erreur_DM = 0), mergeaux$   # on y rajoute la liste des programme generer
                clearaux$
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101, STC9103 et STC9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101, STC9103 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101, STC9110 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9103, STC9110 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101 et STC9103 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9110 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9103 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9103 et STC9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101 et STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101 et STC9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 0) | (erreur_DM = 0)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STEMA01 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 0) | (erreur_CM = 0)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 1) & (erreur_AM = 1)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9103 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 1) & (erreur_BM = 1)) & ((erreur_CG = 1) | (erreur_CM = 1)) & ((erreur_DG = 1) | (erreur_DM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9101 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]

                if (erreur_AG = 1) | (erreur_AM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9101, vérifier le rapport des erreurs et modifier votre programme.", e$
                if (erreur_BG = 1) | (erreur_BM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9103, vérifier le rapport des erreurs et modifier votre programme.", e$
                if (erreur_CG = 1) | (erreur_CM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9110, vérifier le rapport des erreurs et modifier votre programme.", e$
                if (erreur_DG = 1) | (erreur_DM = 1), "- Il n'y a aucun fichier créé pour la Machine STEMA01, vérifier le rapport des erreurs et modifier votre programme.", e$
                " ", e$
                "***************************************", e$
                "RAPPORT DES ERREURS DE POST TRAITEMENT:", e$
                "***************************************", e$
                mergelcc$
                if (erreur_AG = 0) & (erreur_AM = 0) & (erreur_BG = 0) & (erreur_BM = 0) & (erreur_CG = 0) & (erreur_CM = 0) & (erreur_DG = 0) & (erreur_DM = 0),
                [
                " ", e$
                "Il n'y a aucune erreur à signaler.", e$
                " ", e$
                ]
                clearlcc$
                "*******************************************************************", e$
                "Fin de fichier de synthèse", e$

peof_AG        # Fin 
                pprint_AG

            if typcycle_AG = 1 & cycle_heli_spiral_AG = 0, pnumligne, "G80", initht$,e$
            typcycle_AG = 0
            if operation_AG = 11,[
             gfr_AG = 1
             pnumligne,*sgfr_AG,*fretrait_AG,e$
            ]
            pnumligne, "G151 S0",e$

            if prvmr2_AG <>   -1 & mr2print_AG <>   -1,pnumligne,"G0", *prvmr2_AG,e$
            spaces$ = 0
        pnumligne," ", e53_AG,"=0",e$
        spaces$ = 1
            pnumligne, "M09",e$
            pnumligne, "M05",e$
            pnumligne, "M151",e$
            pnumligne,"E60001=0",e$
            pnumligne,"E61001=0",e$
        pnumligne,"E62001=0",e$
        pnumligne,"E64001=E61001",e$
        pnumligne,"E80004=-130000.",e$

          # n, "M170"
          # n, "G0 A0 C0"
            if ppr = 1, peofpprdr_AG
            if ppr = 2, peofpprga_AG
            if ppr = 3, peofpprsy_AG

peof_BG        # Fin 
                pprint_BG
            gcode$ = 0
            if typcycle_BG = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_BG, initht$,e$
            typcycle_BG = 0
            if operation_BG = 11,[
             gfr_BG = 1
             pnumligne,*sgfr_BG,*fretrait_BG,e$
            ]
            panul_plan_inc_BG
            if prvmr2_BG <>   -1 & mr2print_BG <>   -1,pnumligne, pgcode_force_BG, *prvmr2_BG,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            pnumligne, "TRAFOOF",e$
            pnumligne, "M9 ; ARRET LUBRIFIANT",e$
            pnumligne, "M5 ; ARRET BROCHE",e$
            pnumligne, "M201 ; CONTROLE DU VIDE",e$
            pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            pnumligne, "M151 ; ARRET ASPI",e$
            pnumligne, "M2 ; FIN DE PROGRAMME", e$

peof_CG        # Fin 
                pprint_CG
            gcode$ = 0
            if typcycle_CG = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_CG, initht$,e$
            typcycle_CG = 0
            if operation_CG = 11,[
             gfr_CG = 1
             fretrait_CG = fretrait_CG/POURCENTAGE_AVANCE_CG

             pnumligne,*sgfr_CG,*fretrait_CG,e$

             fretrait_CG = fretrait_CG*POURCENTAGE_AVANCE_CG
            ]
            panul_plan_inc_CG
            if prvmr2_CG <>   -1 & mr2print_CG <>   -1,pnumligne, pgcode_force_CG, *prvmr2_CG,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            pnumligne, "TRAFOOF",e$
            pnumligne, "M9 ; ARRET LUBRIFIANT",e$
            pnumligne, "M5 ; ARRET BROCHE",e$
            #pnumligne, "M201 ; CONTROLE DU VIDE",e$
            pnumligne, "CMS_END ; MACRO FIN DE PROG", e$
            pnumligne, "M302 ; ARRET ASPI 1", e$
            pnumligne, "M304 ; ARRET ASPI 2", e$
            pnumligne, "M2 ; FIN DE PROGRAMME", e$
            pnumligne, "M17", e$
            pnumligne, ";END", e$

peof_DG        # Fin 
                pprint_DG
            gcode$ = 0
            if typcycle_DG = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_DG, initht$,e$
            typcycle_DG = 0
            if operation_DG = 11,[
             gfr_DG = 1
             fretrait_DG = fretrait_DG/POURCENTAGE_AVANCE_DG

             pnumligne,*sgfr_DG,*fretrait_DG,e$

             fretrait_DG = fretrait_DG*POURCENTAGE_AVANCE_DG
            ]
            panul_plan_inc_DG
            if prvmr2_DG <>   -1 & mr2print_DG <>   -1,pnumligne, pgcode_force_DG, *prvmr2_DG,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            pnumligne, "TRAFOOF",e$
            pnumligne, "M9 ; ARRET LUBRIFIANT",e$
            pnumligne, "M5 ; ARRET BROCHE",e$
            #pnumligne, "M201 ; CONTROLE DU VIDE",e$
            pnumligne, "CMS_END ; MACRO FIN DE PROG", e$
            pnumligne, "M302 ; ARRET ASPI 1", e$
            pnumligne, "M304 ; ARRET ASPI 2", e$
            pnumligne, "M2 ; FIN DE PROGRAMME", e$
            pnumligne, "M17", e$
            pnumligne, ";END", e$

peof_AM        # Fin 
                pprint_AM

            if typcycle_AM = 1 & cycle_heli_spiral_AM = 0, pnumligne, "G80", initht$,e$
            typcycle_AM = 0
            if operation_AM = 11,[
             gfr_AM = 1
             pnumligne,*sgfr_AM, *fretrait_AM, e$
            ]
            pnumligne, "G151 S0",e$

            #enlevé pour concatif prvmr2_AM <>   -1 & mr2print_AM <>   -1,pnumligne,"G0", *prvmr2_AM,e$
            spaces$ = 0
            #enlevé pour concatpnumligne," ", e53_AM,"=0",e$
            spaces$ = 1
            #enlevé pour concatpnumligne, "M09",e$
            #enlevé pour concatpnumligne, "M05",e$
            #enlevé pour concatpnumligne, "M151",e$
            #enlevé pour concat#pnumligne,"E60001=0",e$
            #enlevé pour concat#pnumligne,"E61001=0",e$
            #enlevé pour concat#pnumligne,"E62001=0",e$
            #enlevé pour concat#pnumligne,"E64001=E61001",e$
            #enlevé pour concat#pnumligne,"E80004=-130000.",e$

            #enlevé pour concat#if ppr = 1, peofpprdr_AM
            #enlevé pour concat#if ppr = 2, peofpprga_AM
            #enlevé pour concat#if ppr = 3, peofpprsy_AM

peof_BM        # Fin 
                pprint_BM
            gcode$ = 0
            if typcycle_BM = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_BM, initht$,e$
            typcycle_BM = 0
            if operation_BM = 11,[
             gfr_BM = 1
             pnumligne,*sgfr_BM,*fretrait_BM,e$
            ]
            panul_plan_inc_BM
            #enlevé pour concatif prvmr2_BM <>   -1 & mr2print_BM <>   -1,pnumligne, pgcode_force_BM, *prvmr2_BM,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            #enlevé pour concatpnumligne, "TRAFOOF",e$
            #enlevé pour concatpnumligne, "M9 ; ARRET LUBRIFIANT",e$
            #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$
            #enlevé pour concat#pnumligne, "M201 ; CONTROLE DU VIDE",e$
            #enlevé pour concat#pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            #enlevé pour concatpnumligne, "M151 ; ARRET ASPI",e$
            #enlevé pour concat#pnumligne, "M2 ; FIN DE PROGRAMME", e$         

peof_CM        # Fin 
                pprint_CM
            gcode$ = 0
            if typcycle_CM = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_CM, initht$,e$
            typcycle_CM = 0
            if operation_CM = 11,[
             gfr_CM = 1
             fretrait_CM = fretrait_CM/POURCENTAGE_AVANCE_CM

            pnumligne,*sgfr_CM,*fretrait_CM,e$

            fretrait_CM = fretrait_CM*POURCENTAGE_AVANCE_CM
            ]
            panul_plan_inc_CM
            #enlevé pour concatif prvmr2_CM <>   -1 & mr2print_CM <>   -1,pnumligne, pgcode_force_CM, *prvmr2_CM,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            #enlevé pour concatpnumligne, "TRAFOOF",e$
            #enlevé pour concatpnumligne, "M9 ; ARRET LUBRIFIANT",e$
            #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$
            #enlevé pour concat#pnumligne, "M201 ; CONTROLE DU VIDE",e$
            #enlevé pour concat#pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            #enlevé pour concatpnumligne, "M302 ; ARRET ASPI 1", e$
            #enlevé pour concatpnumligne, "M304 ; ARRET ASPI 2", e$
            #enlevé pour concat#pnumligne, "M2 ; FIN DE PROGRAMME", e$  

peof_DM        # Fin 
                pprint_DM
            gcode$ = 0
            if typcycle_DM = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_DM, initht$,e$
            typcycle_DM = 0
            if operation_DM = 11,[
             gfr_DM = 1
             fretrait_DM = fretrait_DM/POURCENTAGE_AVANCE_DM

            pnumligne,*sgfr_DM,*fretrait_DM,e$

            fretrait_DM = fretrait_DM*POURCENTAGE_AVANCE_DM
            ]
            panul_plan_inc_DM
            #enlevé pour concatif prvmr2_DM <>   -1 & mr2print_DM <>   -1,pnumligne, pgcode_force_DM, *prvmr2_DM,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            #enlevé pour concatpnumligne, "TRAFOOF",e$
            #enlevé pour concatpnumligne, "M9 ; ARRET LUBRIFIANT",e$
            #enlevé pour concatpnumligne, "M5 ; ARRET BROCHE",e$
            #enlevé pour concat#pnumligne, "M201 ; CONTROLE DU VIDE",e$
            #enlevé pour concat#pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            #enlevé pour concatpnumligne, "M302 ; ARRET ASPI 1", e$
            #enlevé pour concatpnumligne, "M304 ; ARRET ASPI 2", e$
            #enlevé pour concat#pnumligne, "M2 ; FIN DE PROGRAMME", e$ 

#endregion
#endregion

#region   PLIN, PCIR #OK
#region prapid
prapid$
            pchange_AG
            prapid_AG

            pchange_AM
            prapid_AM

            pchange_BG
            prapid_BG

            pchange_BM
            prapid_BM

            pchange_CG
            prapid_CG

            pchange_CM
            prapid_CM

            pchange_DG
            prapid_DG

            pchange_DM
            prapid_DM

prapid_AG     # Ligne rapide
            pprint_AG
           pnumligne, pgcode_force_AG, xprint_AG, yprint_AG , zprint_AG,e$
           old_x_AG=xprint_AG
           old_y_AG=yprint_AG
           old_z_AG=zprint_AG

prapid_BG     # Ligne rapide
            pprint_BG
           pnumligne, pgcode_force_BG, xprint_BG, yprint_BG , zprint_BG,e$
           old_x_BG=xprint_BG
           old_y_BG=yprint_BG
           old_z_BG=zprint_BG

prapid_CG     # Ligne rapide
            pprint_CG
           pnumligne, pgcode_force_CG, xprint_CG, yprint_CG , zprint_CG,e$
           old_x_CG=xprint_CG
           old_y_CG=yprint_CG
           old_z_CG=zprint_CG

prapid_DG     # Ligne rapide
            pprint_DG
           pnumligne, pgcode_force_DG, xprint_DG, yprint_DG , zprint_DG,e$
           old_x_DG=xprint_DG
           old_y_DG=yprint_DG
           old_z_DG=zprint_DG

prapid_AM     # Ligne rapide
            pprint_AM
           pnumligne, pgcode_force_AM, xprint_AM, yprint_AM , zprint_AM,e$
           old_x_AM=xprint_AM
           old_y_AM=yprint_AM
           old_z_AM=zprint_AM

prapid_BM     # Ligne rapide
            pprint_BM
           pnumligne, pgcode_force_BM, xprint_BM, yprint_BM , zprint_BM,e$
           old_x_BM=xprint_BM
           old_y_BM=yprint_BM
           old_z_BM=zprint_BM

prapid_CM     # Ligne rapide
            pprint_CM
           pnumligne, pgcode_force_CM, xprint_CM, yprint_CM , zprint_CM,e$
           old_x_CM=xprint_CM
           old_y_CM=yprint_CM
           old_z_CM=zprint_CM

prapid_DM     # Ligne rapide
            pprint_DM
           pnumligne, pgcode_force_DM, xprint_DM, yprint_DM , zprint_DM,e$
           old_x_DM=xprint_DM
           old_y_DM=yprint_DM
           old_z_DM=zprint_DM
#endregion
#region pzrapid
pzrapid$
            pchange_AG
            pzrapid_AG

            pchange_AM
            pzrapid_AM

            pchange_BG
            pzrapid_BG

            pchange_BM
            pzrapid_BM

            pchange_CG
            pzrapid_CG

            pchange_CM
            pzrapid_CM

            pchange_DG
            pzrapid_DG

            pchange_DM
            pzrapid_DM
pzrapid_AG    # Ligne Z rapide

            pprint_AG
           pnumligne, pgcode_force_AG, zprint_AG,e$
           old_z_AG=zprint_AG

pzrapid_BG    # Ligne Z rapide

            pprint_BG
           pnumligne, pgcode_force_BG, zprint_BG,e$
           old_z_BG=zprint_BG

pzrapid_CG    # Ligne Z rapide

            pprint_CG
           pnumligne, pgcode_force_CG, zprint_CG,e$
           old_z_CG=zprint_CG

pzrapid_DG    # Ligne Z rapide

            pprint_DG
           pnumligne, pgcode_force_DG, zprint_DG,e$
           old_z_DG=zprint_DG

pzrapid_AM    # Ligne Z rapide

            pprint_AM
           pnumligne, pgcode_force_AM, zprint_AM,e$
           old_z_AM=zprint_AM

pzrapid_BM    # Ligne Z rapide

            pprint_BM
           pnumligne, pgcode_force_BM, zprint_BM,e$
           old_z_BM=zprint_BM

pzrapid_CM    # Ligne Z rapide

            pprint_CM
           pnumligne, pgcode_force_CM, zprint_CM,e$
           old_z_CM=zprint_CM

pzrapid_DM    # Ligne Z rapide

            pprint_DM
           pnumligne, pgcode_force_DM, zprint_DM,e$
           old_z_DM=zprint_DM
#endregion
#region plin
plin$
            pchange_AG
            plin_AG

            pchange_AM
            plin_AM

            pchange_BG
            plin_BG

            pchange_BM
            plin_BM

            pchange_CG
            plin_CG

            pchange_CM
            plin_CM

            pchange_DG
            plin_DG

            pchange_DM
            plin_DM

plin_AG       # Ligne travail       
            pprint_AG
            gfr_AG = 1
           pnumligne, sgfr_AG,e$
           pnumligne, pgcode_force_AG, pcord_AG, xprint_AG, yprint_AG, zprint_AG, pfr_AG, pg9_AG,e$
           old_x_AG=xprint_AG
           old_y_AG=yprint_AG
           old_z_AG=zprint_AG

plin_BG       # Ligne travail
            pprint_BG
            gfr_BG = 1
           pnumligne, sgfr_BG,e$
           pnumligne, pgcode_force_BG, pcord_BG, xprint_BG, yprint_BG, zprint_BG, pfr_BG, pg9_BG,e$
           old_x_BG=xprint_BG
           old_y_BG=yprint_BG
           old_z_BG=zprint_BG

plin_CG       # Ligne travail
            pprint_CG
            gfr_CG = 1
           pnumligne, sgfr_CG,e$
           pnumligne, pgcode_force_CG, pcord_CG, xprint_CG, yprint_CG, zprint_CG, pfr_CG, pg9_CG,e$
           old_x_CG=xprint_CG
           old_y_CG=yprint_CG
           old_z_CG=zprint_CG

plin_DG       # Ligne travail
            pprint_DG
            gfr_DG = 1
           pnumligne, sgfr_DG,e$
           pnumligne, pgcode_force_DG, pcord_DG, xprint_DG, yprint_DG, zprint_DG, pfr_DG, pg9_DG,e$
           old_x_DG=xprint_DG
           old_y_DG=yprint_DG
           old_z_DG=zprint_DG


plin_AM       # Ligne travail       
            pprint_AM
            gfr_AM = 1
           pnumligne, sgfr_AM,e$
           pnumligne, pgcode_force_AM, pcord_AM, xprint_AM, yprint_AM, zprint_AM, pfr_AM, pg9_AM,e$
           old_x_AM=xprint_AM
           old_y_AM=yprint_AM
           old_z_AM=zprint_AM

plin_BM       # Ligne travail
            pprint_BM
            gfr_BM = 1
           pnumligne, sgfr_BM,e$
           pnumligne, pgcode_force_BM, pcord_BM, xprint_BM, yprint_BM, zprint_BM, pfr_BM, pg9_BM,e$
           old_x_BM=xprint_BM
           old_y_BM=yprint_BM
           old_z_BM=zprint_BM

plin_CM       # Ligne travail
            pprint_CM
            gfr_CM = 1
           pnumligne, sgfr_CM,e$
           pnumligne, pgcode_force_CM, pcord_CM, xprint_CM, yprint_CM, zprint_CM, pfr_CM, pg9_CM,e$
           old_x_CM=xprint_CM
           old_y_CM=yprint_CM
           old_z_CM=zprint_CM

plin_DM       # Ligne travail
            pprint_DM
            gfr_DM = 1
           pnumligne, sgfr_DM,e$
           pnumligne, pgcode_force_DM, pcord_DM, xprint_DM, yprint_DM, zprint_DM, pfr_DM, pg9_DM,e$
           old_x_DM=xprint_DM
           old_y_DM=yprint_DM
           old_z_DM=zprint_DM
#endregion
#region pz
pz$
            pchange_AG
            pz_AG

            pchange_AM
            pz_AM

            pchange_BG
            pz_BG

            pchange_BM
            pz_BM

            pchange_CG
            pz_CG

            pchange_CM
            pz_CM

            pchange_DG
            pz_DG

            pchange_DM
            pz_DM

pz_AG         # z en avance rapide
            pprint_AG
           pnumligne, pgcode_force_AG, zprint_AG,e$
           old_z_AG=zprint_AG

pz_BG         # z en avance rapide
            pprint_BG
           pnumligne, pgcode_force_BG, zprint_BG,e$
           old_z_BG=zprint_BG

pz_CG         # z en avance rapide
            pprint_CG
           pnumligne, pgcode_force_CG, zprint_CG,e$
           old_z_CG=zprint_CG

pz_DG         # z en avance rapide
            pprint_DG
           pnumligne, pgcode_force_DG, zprint_DG,e$
           old_z_DG=zprint_DG

pz_AM         # z en avance rapide
            pprint_AM
           pnumligne, pgcode_force_AM, zprint_AM,e$
           old_z_AM=zprint_AM

pz_BM         # z en avance rapide
            pprint_BM
           pnumligne, pgcode_force_BM, zprint_BM,e$
           old_z_BM=zprint_BM

pz_CM         # z en avance rapide
            pprint_CM
           pnumligne, pgcode_force_CM, zprint_CM,e$
           old_z_CM=zprint_CM

pz_DM         # z en avance rapide
            pprint_DM
           pnumligne, pgcode_force_DM, zprint_DM,e$
           old_z_DM=zprint_DM
#endregion
#region pcir
pcir$
            pchange_AG
            pcir_AG

            pchange_AM
            pcir_AM

            pchange_BG
            pcir_BG

            pchange_BM
            pcir_BM

            pchange_CG
            pcir_CG

            pchange_CM
            pcir_CM

            pchange_DG
            pcir_DG

            pchange_DM
            pcir_DM
pcir_AG     # Circulaire
            pprint_AG
            gfr_AG = 1
            pnumligne, sgfr_AG,e$
            iprint_AG = xc_AG
            jprint_AG = yc_AG
            if tete_rev_AG = 1,
            [
            plane$ = 2
            pnumligne, splcode_AG, pgcode_force_AG, *xprint_AG, *yprint_AG, zprint_AG, *iprint_AG,*jprint_AG, pfr_AG, pg9_AG,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_AG, pgcode_force_AG, *xprint_AG, *yprint_AG, zprint_AG, *iprint_AG,*jprint_AG, pfr_AG,e$
            if plane$ = 2, pnumligne, splcode_AG, pgcode_force_AG, *xprint_AG, *zprint_AG, yprint_AG, *iprint_AG,*kprint_AG, pfr_AG,e$
            if plane$ = 1, pnumligne, splcode_AG, pgcode_force_AG, *yprint_AG, *zprint_AG, xprint_AG, *jprint_AG,*kprint_AG, pfr_AG,e$
            ]
            old_x_AG=xprint_AG
            old_y_AG=yprint_AG
            old_z_AG=zprint_AG

pcir_BG     # Circulaire
            pprint_BG
            gfr_BG = 1
            pnumligne, sgfr_BG,e$
            if tete_rev_BG = 1,
            [
            plane$ = 2
            pnumligne, splcode_BG, pgcode_force_BG, *xprint_BG, *yprint_BG, zprint_BG, *iprint_BG,*jprint_BG, pfr_BG, pg9_BG,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_BG, pgcode_force_BG, *xprint_BG, *yprint_BG, zprint_BG, *iprint_BG,*jprint_BG, pfr_BG,e$
            if plane$ = 2, pnumligne, splcode_BG, pgcode_force_BG, *xprint_BG, *zprint_BG, yprint_BG, *iprint_BG,*kprint_BG, pfr_BG,e$
            if plane$ = 1, pnumligne, splcode_BG, pgcode_force_BG, *yprint_BG, *zprint_BG, xprint_BG, *jprint_BG,*kprint_BG, pfr_BG,e$
            ]
            old_x_BG=xprint_BG
            old_y_BG=yprint_BG
            old_z_BG=zprint_BG

pcir_CG     # Circulaire
            pprint_CG
            gfr_CG = 1
            pnumligne, sgfr_CG,e$
            if tete_rev_CG = 1,
            [
            plane$ = 2
            pnumligne, splcode_CG, pgcode_force_CG, *xprint_CG, *yprint_CG, zprint_CG, *iprint_CG,*jprint_CG, pfr_CG, pg9_CG,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_CG, pgcode_force_CG, *xprint_CG, *yprint_CG, zprint_CG, *iprint_CG,*jprint_CG, pfr_CG,e$
            if plane$ = 2, pnumligne, splcode_CG, pgcode_force_CG, *xprint_CG, *zprint_CG, yprint_CG, *iprint_CG,*kprint_CG, pfr_CG,e$
            if plane$ = 1, pnumligne, splcode_CG, pgcode_force_CG, *yprint_CG, *zprint_CG, xprint_CG, *jprint_CG,*kprint_CG, pfr_CG,e$
            ]
            old_x_CG=xprint_CG
            old_y_CG=yprint_CG
            old_z_CG=zprint_CG

pcir_DG     # Circulaire
            pprint_DG
            gfr_DG = 1
            pnumligne, sgfr_DG,e$
            if tete_rev_DG = 1,
            [
            plane$ = 2
            pnumligne, splcode_DG, pgcode_force_DG, *xprint_DG, *yprint_DG, zprint_DG, *iprint_DG,*jprint_DG, pfr_DG, pg9_DG,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_DG, pgcode_force_DG, *xprint_DG, *yprint_DG, zprint_DG, *iprint_DG,*jprint_DG, pfr_DG,e$
            if plane$ = 2, pnumligne, splcode_DG, pgcode_force_DG, *xprint_DG, *zprint_DG, yprint_DG, *iprint_DG,*kprint_DG, pfr_DG,e$
            if plane$ = 1, pnumligne, splcode_DG, pgcode_force_DG, *yprint_DG, *zprint_DG, xprint_DG, *jprint_DG,*kprint_DG, pfr_DG,e$
            ]
            old_x_DG=xprint_DG
            old_y_DG=yprint_DG
            old_z_DG=zprint_DG

pcir_AM     # Circulaire
            pprint_AM
            gfr_AM = 1
            pnumligne, sgfr_AM,e$
            iprint_AM = xc_AM
            jprint_AM = yc_AM
            if tete_rev_AM = 1,
            [
            plane$ = 2
            pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *yprint_AM, zprint_AM, *iprint_AM,*jprint_AM, pfr_AM, pg9_AM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *yprint_AM, zprint_AM, *iprint_AM,*jprint_AM, pfr_AM,e$
            if plane$ = 2, pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *zprint_AM, yprint_AM, *iprint_AM,*kprint_AM, pfr_AM,e$
            if plane$ = 1, pnumligne, splcode_AM, pgcode_force_AM, *yprint_AM, *zprint_AM, xprint_AM, *jprint_AM,*kprint_AM, pfr_AM,e$
            ]
            old_x_AM=xprint_AM
            old_y_AM=yprint_AM
            old_z_AM=zprint_AM

pcir_BM     # Circulaire
            pprint_BM
            gfr_BM = 1
            pnumligne, sgfr_BM,e$
            if tete_rev_BM = 1,
            [
            plane$ = 2
            pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *yprint_BM, zprint_BM, *iprint_BM,*jprint_BM, pfr_BM, pg9_BM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *yprint_BM, zprint_BM, *iprint_BM,*jprint_BM, pfr_BM,e$
            if plane$ = 2, pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *zprint_BM, yprint_BM, *iprint_BM,*kprint_BM, pfr_BM,e$
            if plane$ = 1, pnumligne, splcode_BM, pgcode_force_BM, *yprint_BM, *zprint_BM, xprint_BM, *jprint_BM,*kprint_BM, pfr_BM,e$
            ]
            old_x_BM=xprint_BM
            old_y_BM=yprint_BM
            old_z_BM=zprint_BM

pcir_CM     # Circulaire
            pprint_CM
            gfr_CM = 1
            pnumligne, sgfr_CM,e$
            if tete_rev_CM = 1,
            [
            plane$ = 2
            pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *yprint_CM, zprint_CM, *iprint_CM,*jprint_CM, pfr_CM, pg9_CM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *yprint_CM, zprint_CM, *iprint_CM,*jprint_CM, pfr_CM,e$
            if plane$ = 2, pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *zprint_CM, yprint_CM, *iprint_CM,*kprint_CM, pfr_CM,e$
            if plane$ = 1, pnumligne, splcode_CM, pgcode_force_CM, *yprint_CM, *zprint_CM, xprint_CM, *jprint_CM,*kprint_CM, pfr_CM,e$
            ]
            old_x_CM=xprint_CM
            old_y_CM=yprint_CM
            old_z_CM=zprint_CM

pcir_DM     # Circulaire
            pprint_DM
            gfr_DM = 1
            pnumligne, sgfr_DM,e$
            if tete_rev_DM = 1,
            [
            plane$ = 2
            pnumligne, splcode_DM, pgcode_force_DM, *xprint_DM, *yprint_DM, zprint_DM, *iprint_DM,*jprint_DM, pfr_DM, pg9_DM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_DM, pgcode_force_DM, *xprint_DM, *yprint_DM, zprint_DM, *iprint_DM,*jprint_DM, pfr_DM,e$
            if plane$ = 2, pnumligne, splcode_DM, pgcode_force_DM, *xprint_DM, *zprint_DM, yprint_DM, *iprint_DM,*kprint_DM, pfr_DM,e$
            if plane$ = 1, pnumligne, splcode_DM, pgcode_force_DM, *yprint_DM, *zprint_DM, xprint_DM, *jprint_DM,*kprint_DM, pfr_DM,e$
            ]
            old_x_DM=xprint_DM
            old_y_DM=yprint_DM
            old_z_DM=zprint_DM
#endregion         
#endregion

#region   PCONT, PMX,... #OK
#region pcont
#-------------------5 axes continue---------------------------------------------------------

pcont_AG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_AG",*cont_axe_c_AG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_AG = cont_axe_c_AG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_AG = cont_axe_c_AG + 360    # retrait de 360 deg    
         axeC_AG = atan2(Vx_AG,Vy_AG)
     #    "voir axeC_AG pur de pcont",*axeC_AG,e
      #   "voir reel axeCpos_AG",*reel_axeCpos_AG,e
         axeC_AG = cont_axe_c_AG + reel_axeCpos_AG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_AG + axeC_AG",*axeC_AG,e  

pcont_BG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_BG",*cont_axe_c_BG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_BG = cont_axe_c_BG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_BG = cont_axe_c_BG + 360    # retrait de 360 deg    
         axeC_BG = atan2(Vx_BG,Vy_BG)
     #    "voir axeC_BG pur de pcont",*axeC_BG,e
      #   "voir reel axeCpos_BG",*reel_axeCpos_BG,e
         axeC_BG = cont_axe_c_BG + reel_axeCpos_BG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_BG + axeC_BG",*axeC_BG,e  

pcont_CG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_CG",*cont_axe_c_CG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_CG = cont_axe_c_CG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_CG = cont_axe_c_CG + 360    # retrait de 360 deg    
         axeC_CG = atan2(-Vy_CG,Vx_CG)
     #    "voir axeC_CG pur de pcont",*axeC_CG,e
      #   "voir reel axeCpos_CG",*reel_axeCpos_CG,e
         axeC_CG = cont_axe_c_CG + reel_axeCpos_CG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_CG + axeC_CG",*axeC_CG,e    

pcont_DG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_DG",*cont_axe_c_DG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_DG = cont_axe_c_DG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_DG = cont_axe_c_DG + 360    # retrait de 360 deg    
         axeC_DG = atan2(-Vy_DG,Vx_DG)
     #    "voir axeC_DG pur de pcont",*axeC_DG,e
      #   "voir reel axeCpos_DG",*reel_axeCpos_DG,e
         axeC_DG = cont_axe_c_DG + reel_axeCpos_DG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_DG + axeC_DG",*axeC_DG,e         

pcont_AM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_AM",*cont_axe_c_AM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_AM = cont_axe_c_AM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_AM = cont_axe_c_AM + 360    # retrait de 360 deg    
         axeC_AM = atan2(Vx_AM,Vy_AM)
     #    "voir axeC_AM pur de pcont",*axeC_AM,e
      #   "voir reel axeCpos_AM",*reel_axeCpos_AM,e
         axeC_AM = cont_axe_c_AM + reel_axeCpos_AM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_AM + axeC_AM",*axeC_AM,e  

pcont_BM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_BM",*cont_axe_c_BM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_BM = cont_axe_c_BM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_BM = cont_axe_c_BM + 360    # retrait de 360 deg    
         axeC_BM = atan2(Vx_BM,Vy_BM)
     #    "voir axeC_BM pur de pcont",*axeC_BM,e
      #   "voir reel axeCpos_BM",*reel_axeCpos_BM,e
         axeC_BM = cont_axe_c_BM + reel_axeCpos_BM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_BM + axeC_BM",*axeC_BM,e  

pcont_CM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_CM",*cont_axe_c_CM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_CM = cont_axe_c_CM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_CM = cont_axe_c_CM + 360    # retrait de 360 deg    
         axeC_CM = atan2(-Vy_CM,Vx_CM)
     #    "voir axeC_CM pur de pcont",*axeC_CM,e
      #   "voir reel axeCpos_CM",*reel_axeCpos_CM,e
         axeC_CM = cont_axe_c_CM + reel_axeCpos_CM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_CM + axeC_CM",*axeC_CM,e    

pcont_DM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_DM",*cont_axe_c_DM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_DM = cont_axe_c_DM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_DM = cont_axe_c_DM + 360    # retrait de 360 deg    
         axeC_DM = atan2(-Vy_DM,Vx_DM)
     #    "voir axeC_DM pur de pcont",*axeC_DM,e
      #   "voir reel axeCpos_DM",*reel_axeCpos_DM,e
         axeC_DM = cont_axe_c_DM + reel_axeCpos_DM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_DM + axeC_DM",*axeC_DM,e      
#endregion
#region pderoul

pderoul_AG    # retrait de 360 deg sur axeC_AG
         if rattrapage_angle = 0, psortie_ratrap_deroul_AG
         cont_axe_c_AG = cont_axe_c_AG - (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AG = prvaxec_AG - (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AG = atan2(Vx_AG,Vy_AG)
   #         "axeC_AG  =", axeC_AG, e
    #     "cont_axe_c_AG=", cont_axe_c_AG, e
         axeC_AG = cont_axe_c_AG + axeC_AG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AG = mr2print_AG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AG = (deltax / old_longvec) * vectdeg
         ydeg_AG = (deltay / old_longvec) * vectdeg
         zdeg_AG = (deltaz / old_longvec) * vectdeg
         xdeg_AG = xdeg_AG + old_x_AG
         ydeg_AG = ydeg_AG + old_y_AG
         zdeg_AG = zdeg_AG + old_z_AG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post processeur suite buttée axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "(RATRAPPAGE D ANGLE DEROULE )",e$
                                    ]
         gfr_AG = 1

         pnumligne,*sgfr_AG , *frbase_AG ,e$
         pnumligne,pgcode_AG, *xdeg_AG, *ydeg_AG, *zdeg_AG,e$
         if mr2print_AG <>   -1 & mr2print_AG > zdeg_AG, pnumligne,pgcode_AG, *zdeg2_AG,e$
         pnumligne,pgcode_AG, *prvaxec_AG ,e$
         pnumligne,pgcode_AG, *zdeg_AG,e$
         gcode$ = 1
         pnumligne,pgcode_AG,*sgfr_AG,*old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, e$
         gfr_AG = 0
pderoul_BG    # retrait de 360 deg sur axeC_BG
         if rattrapage_angle = 0, psortie_ratrap_deroul_BG
         cont_axe_c_BG = cont_axe_c_BG - (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BG = prvaxec_BG - (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BG = atan2(Vx_BG,Vy_BG)
   #         "axeC_BG  =", axeC_BG, e
    #     "cont_axe_c_BG=", cont_axe_c_BG, e
         axeC_BG = cont_axe_c_BG + axeC_BG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BG = mr2print_BG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BG = (deltax / old_longvec) * vectdeg
         ydeg_BG = (deltay / old_longvec) * vectdeg
         zdeg_BG = (deltaz / old_longvec) * vectdeg
         xdeg_BG = xdeg_BG + old_x_BG
         ydeg_BG = ydeg_BG + old_y_BG
         zdeg_BG = zdeg_BG + old_z_BG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_BG = 1

         pnumligne,*sgfr_BG , *frbase_BG ,e$
         pnumligne,pgcode_BG, *xdeg_BG, *ydeg_BG, *zdeg_BG,e$
         if mr2print_BG <>   -1 & mr2print_BG > zdeg_BG, pnumligne,pgcode_BG, *zdeg2_BG,e$
         pnumligne,pgcode_BG, *prvaxec_BG ,e$
         pnumligne,pgcode_BG, *zdeg_BG,e$
         gcode$ = 1
         pnumligne,pgcode_BG,*sgfr_BG,*old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, e$
         gfr_BG = 0
pderoul_CG    # retrait de 360 deg sur axeC_CG
         if rattrapage_angle = 0, psortie_ratrap_deroul_CG
         cont_axe_c_CG = cont_axe_c_CG - (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CG = prvaxec_CG - (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CG = atan2(-Vy_CG,Vx_CG)
   #         "axeC_CG  =", axeC_CG, e
    #     "cont_axe_c_CG=", cont_axe_c_CG, e
         axeC_CG = cont_axe_c_CG + axeC_CG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CG = mr2print_CG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CG = (deltax / old_longvec) * vectdeg
         ydeg_CG = (deltay / old_longvec) * vectdeg
         zdeg_CG = (deltaz / old_longvec) * vectdeg
         xdeg_CG = xdeg_CG + old_x_CG
         ydeg_CG = ydeg_CG + old_y_CG
         zdeg_CG = zdeg_CG + old_z_CG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_CG = 1

         frbase_CG = frbase_CG/POURCENTAGE_AVANCE_CG

         pnumligne,*sgfr_CG , *frbase_CG ,e$
         pnumligne,pgcode_CG, *xdeg_CG, *ydeg_CG, *zdeg_CG,e$
         if mr2print_CG <>   -1 & mr2print_CG > zdeg_CG, pnumligne,pgcode_CG, *zdeg2_CG,e$
         pnumligne,pgcode_CG, *prvaxec_CG ,e$
         pnumligne,pgcode_CG, *zdeg_CG,e$
         gcode$ = 1
         pnumligne,pgcode_CG,*sgfr_CG,*old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, e$
         gfr_CG = 0
pderoul_DG    # retrait de 360 deg sur axeC_DG
         if rattrapage_angle = 0, psortie_ratrap_deroul_DG
         cont_axe_c_DG = cont_axe_c_DG - (360 * nbt_DG)  # retrait de 360 deg 
         prvaxec_DG = prvaxec_DG - (360 * nbt_DG)    # retrait de 360 deg 
         axeC_DG = atan2(-Vy_DG,Vx_DG)
   #         "axeC_DG  =", axeC_DG, e
    #     "cont_axe_c_DG=", cont_axe_c_DG, e
         axeC_DG = cont_axe_c_DG + axeC_DG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_DG = mr2print_DG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_DG = (deltax / old_longvec) * vectdeg
         ydeg_DG = (deltay / old_longvec) * vectdeg
         zdeg_DG = (deltaz / old_longvec) * vectdeg
         xdeg_DG = xdeg_DG + old_x_DG
         ydeg_DG = ydeg_DG + old_y_DG
         zdeg_DG = zdeg_DG + old_z_DG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_DG = 1

         frbase_DG = frbase_DG/POURCENTAGE_AVANCE_DG

         pnumligne,*sgfr_DG , *frbase_DG ,e$
         pnumligne,pgcode_DG, *xdeg_DG, *ydeg_DG, *zdeg_DG,e$
         if mr2print_DG <>   -1 & mr2print_DG > zdeg_DG, pnumligne,pgcode_DG, *zdeg2_DG,e$
         pnumligne,pgcode_DG, *prvaxec_DG ,e$
         pnumligne,pgcode_DG, *zdeg_DG,e$
         gcode$ = 1
         pnumligne,pgcode_DG,*sgfr_DG,*old_x_DG, *old_y_DG, *old_z_DG, *frbase_DG, e$
         gfr_DG = 0
pderoul_AM    # retrait de 360 deg sur axeC_AM
		 if rattrapage_angle = 0, psortie_ratrap_deroul_AM
         cont_axe_c_AM = cont_axe_c_AM - (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AM = prvaxec_AM - (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AM = atan2(Vx_AM,Vy_AM)
   #         "axeC_AM  =", axeC_AM, e
    #     "cont_axe_c_AM=", cont_axe_c_AM, e
         axeC_AM = cont_axe_c_AM + axeC_AM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AM = mr2print_AM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AM = (deltax / old_longvec) * vectdeg
         ydeg_AM = (deltay / old_longvec) * vectdeg
         zdeg_AM = (deltaz / old_longvec) * vectdeg
         xdeg_AM = xdeg_AM + old_x_AM
         ydeg_AM = ydeg_AM + old_y_AM
         zdeg_AM = zdeg_AM + old_z_AM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post processeur suite buttée axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "(RATRAPPAGE D ANGLE DEROULE )",e$
                                    ]
         gfr_AM = 1

         pnumligne,*sgfr_AM , *frbase_AM ,e$
         pnumligne,pgcode_AM, *xdeg_AM, *ydeg_AM, *zdeg_AM,e$
         if mr2print_AM <>   -1 & mr2print_AM > zdeg_AM, pnumligne,pgcode_AM, *zdeg2_AM,e$
         pnumligne,pgcode_AM, *prvaxec_AM ,e$
         pnumligne,pgcode_AM, *zdeg_AM,e$
         gcode$ = 1
         pnumligne,pgcode_AM,*sgfr_AM,*old_x_AM, *old_y_AM, *old_z_AM, *frbase_AM, e$
         gfr_AM = 0
pderoul_BM    # retrait de 360 deg sur axeC_BM
		 if rattrapage_angle = 0, psortie_ratrap_deroul_BM
         cont_axe_c_BM = cont_axe_c_BM - (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BM = prvaxec_BM - (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BM = atan2(Vx_BM,Vy_BM)
   #         "axeC_BM  =", axeC_BM, e
    #     "cont_axe_c_BM=", cont_axe_c_BM, e
         axeC_BM = cont_axe_c_BM + axeC_BM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BM = mr2print_BM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BM = (deltax / old_longvec) * vectdeg
         ydeg_BM = (deltay / old_longvec) * vectdeg
         zdeg_BM = (deltaz / old_longvec) * vectdeg
         xdeg_BM = xdeg_BM + old_x_BM
         ydeg_BM = ydeg_BM + old_y_BM
         zdeg_BM = zdeg_BM + old_z_BM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_BM = 1

         pnumligne,*sgfr_BM , *frbase_BM ,e$
         pnumligne,pgcode_BM, *xdeg_BM, *ydeg_BM, *zdeg_BM,e$
         if mr2print_BM <>   -1 & mr2print_BM > zdeg_BM, pnumligne,pgcode_BM, *zdeg2_BM,e$
         pnumligne,pgcode_BM, *prvaxec_BM ,e$
         pnumligne,pgcode_BM, *zdeg_BM,e$
         gcode$ = 1
         pnumligne,pgcode_BM,*sgfr_BM,*old_x_BM, *old_y_BM, *old_z_BM, *frbase_BM, e$
         gfr_BM = 0
pderoul_CM    # retrait de 360 deg sur axeC_CM
		 if rattrapage_angle = 0, psortie_ratrap_deroul_CM
         cont_axe_c_CM = cont_axe_c_CM - (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CM = prvaxec_CM - (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CM = atan2(-Vy_CM,Vx_CM)
   #         "axeC_CM  =", axeC_CM, e
    #     "cont_axe_c_CM=", cont_axe_c_CM, e
         axeC_CM = cont_axe_c_CM + axeC_CM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CM = mr2print_CM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CM = (deltax / old_longvec) * vectdeg
         ydeg_CM = (deltay / old_longvec) * vectdeg
         zdeg_CM = (deltaz / old_longvec) * vectdeg
         xdeg_CM = xdeg_CM + old_x_CM
         ydeg_CM = ydeg_CM + old_y_CM
         zdeg_CM = zdeg_CM + old_z_CM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_CM = 1

         frbase_CM = frbase_CM/POURCENTAGE_AVANCE_CM

         pnumligne,*sgfr_CM , *frbase_CM ,e$
         pnumligne,pgcode_CM, *xdeg_CM, *ydeg_CM, *zdeg_CM,e$
         if mr2print_CM <>   -1 & mr2print_CM > zdeg_CM, pnumligne,pgcode_CM, *zdeg2_CM,e$
         pnumligne,pgcode_CM, *prvaxec_CM ,e$
         pnumligne,pgcode_CM, *zdeg_CM,e$
         gcode$ = 1
         pnumligne,pgcode_CM,*sgfr_CM,*old_x_CM, *old_y_CM, *old_z_CM, *frbase_CM, e$
         gfr_CM = 0

pderoul_DM    # retrait de 360 deg sur axeC_DM
		 if rattrapage_angle = 0, psortie_ratrap_deroul_DM
         cont_axe_c_DM = cont_axe_c_DM - (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_DM = prvaxec_DM - (360 * nbt_CG)    # retrait de 360 deg 
         axeC_DM = atan2(-Vy_DM,Vx_DM)
   #         "axeC_DM  =", axeC_DM, e
    #     "cont_axe_c_DM=", cont_axe_c_DM, e
         axeC_DM = cont_axe_c_DM + axeC_DM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_DM = mr2print_DM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_DM = (deltax / old_longvec) * vectdeg
         ydeg_DM = (deltay / old_longvec) * vectdeg
         zdeg_DM = (deltaz / old_longvec) * vectdeg
         xdeg_DM = xdeg_DM + old_x_DM
         ydeg_DM = ydeg_DM + old_y_DM
         zdeg_DM = zdeg_DM + old_z_DM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
                                    ]
         gfr_DM = 1

         frbase_DM = frbase_DM/POURCENTAGE_AVANCE_DM

         pnumligne,*sgfr_DM , *frbase_DM ,e$
         pnumligne,pgcode_DM, *xdeg_DM, *ydeg_DM, *zdeg_DM,e$
         if mr2print_DM <>   -1 & mr2print_DM > zdeg_DM, pnumligne,pgcode_DM, *zdeg2_DM,e$
         pnumligne,pgcode_DM, *prvaxec_DM ,e$
         pnumligne,pgcode_DM, *zdeg_DM,e$
         gcode$ = 1
         pnumligne,pgcode_DM,*sgfr_DM,*old_x_DM, *old_y_DM, *old_z_DM, *frbase_DM, e$
         gfr_DM = 0
#endregion
#region penroul

penroul_AG    # retrait de 360 deg sur axeC_AG
         if rattrapage_angle = 0, psortie_ratrap_enroul_AG
    #     "voir",*axeC_AG,e
         cont_axe_c_AG = cont_axe_c_AG + (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AG = prvaxec_AG + (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AG = atan2(Vx_AG,Vy_AG)

         axeC_AG = cont_axe_c_AG + axeC_AG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AG = mr2print_AG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AG = (deltax / old_longvec) * vectdeg
         ydeg_AG = (deltay / old_longvec) * vectdeg
         zdeg_AG = (deltaz / old_longvec) * vectdeg
         xdeg_AG = xdeg_AG + old_x_AG
         ydeg_AG = ydeg_AG + old_y_AG
         zdeg_AG = zdeg_AG + old_z_AG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post processeur suite buttée axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "(RATRAPPAGE D ANGLE ENROULE )", e$
                                    ]
         gfr_AG = 1

         pnumligne, *sgfr_AG,*frbase_AG ,e$
         pnumligne,pgcode_AG, *xdeg_AG, *ydeg_AG, *zdeg_AG, e$
         if mr2print_AG <>   -1 & mr2print_AG > zdeg_AG, pnumligne,pgcode_AG, *zdeg2_AG, e$
         pnumligne,pgcode_AG, *prvaxec_AG, e$
         pnumligne,pgcode_AG, *zdeg_AG, e$
         gcode$ = 1
         gfr_AG = 0
         pnumligne,pgcode_AG,*sgfr_AG, *old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, e$
       #  "voir",*axeC_AG,e

penroul_BG    # retrait de 360 deg sur axeC_BG
         if rattrapage_angle = 0, psortie_ratrap_enroul_BG
    #     "voir",*axeC_BG,e
         cont_axe_c_BG = cont_axe_c_BG + (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BG = prvaxec_BG + (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BG = atan2(Vx_BG,Vy_BG)

         axeC_BG = cont_axe_c_BG + axeC_BG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BG = mr2print_BG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BG = (deltax / old_longvec) * vectdeg
         ydeg_BG = (deltay / old_longvec) * vectdeg
         zdeg_BG = (deltaz / old_longvec) * vectdeg
         xdeg_BG = xdeg_BG + old_x_BG
         ydeg_BG = ydeg_BG + old_y_BG
         zdeg_BG = zdeg_BG + old_z_BG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_BG = 1

         pnumligne, *sgfr_BG,*frbase_BG ,e$
         pnumligne,pgcode_BG, *xdeg_BG, *ydeg_BG, *zdeg_BG, e$
         if mr2print_BG <>   -1 & mr2print_BG > zdeg_BG, pnumligne,pgcode_BG, *zdeg2_BG, e$
         pnumligne,pgcode_BG, *prvaxec_BG, e$
         pnumligne,pgcode_BG, *zdeg_BG, e$
         gcode$ = 1
         gfr_BG = 0
         pnumligne,pgcode_BG,*sgfr_BG, *old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, e$
       #  "voir",*axeC_BG,e
penroul_CG    # retrait de 360 deg sur axeC_CG
         if rattrapage_angle = 0, psortie_ratrap_enroul_CG
    #     "voir",*axeC_CG,e
         cont_axe_c_CG = cont_axe_c_CG + (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CG = prvaxec_CG + (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CG = atan2(-Vy_CG,Vx_CG)

         axeC_CG = cont_axe_c_CG + axeC_CG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CG = mr2print_CG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CG = (deltax / old_longvec) * vectdeg
         ydeg_CG = (deltay / old_longvec) * vectdeg
         zdeg_CG = (deltaz / old_longvec) * vectdeg
         xdeg_CG = xdeg_CG + old_x_CG
         ydeg_CG = ydeg_CG + old_y_CG
         zdeg_CG = zdeg_CG + old_z_CG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_CG = 1

         frbase_CG = frbase_CG/POURCENTAGE_AVANCE_CG

         pnumligne, *sgfr_CG,*frbase_CG ,e$

         frbase_CG = frbase_CG*POURCENTAGE_AVANCE_CG

         pnumligne,pgcode_CG, *xdeg_CG, *ydeg_CG, *zdeg_CG, e$
         if mr2print_CG <>   -1 & mr2print_CG > zdeg_CG, pnumligne,pgcode_CG, *zdeg2_CG, e$
         pnumligne,pgcode_CG, *prvaxec_CG, e$
         pnumligne,pgcode_CG, *zdeg_CG, e$
         gcode$ = 1
         gfr_CG = 0

         frbase_CG = frbase_CG*POURCENTAGE_AVANCE_CG

         pnumligne, pgcode_CG,*sgfr_CG, *old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, e$
       #  "voir",*axeC_CG,e

penroul_DG    # retrait de 360 deg sur axeC_DG
         if rattrapage_angle = 0, psortie_ratrap_enroul_DG
    #     "voir",*axeC_DG,e
         cont_axe_c_DG = cont_axe_c_DG + (360 * nbt_DG)  # retrait de 360 deg 
         prvaxec_DG = prvaxec_DG + (360 * nbt_DG)    # retrait de 360 deg 
         axeC_DG = atan2(-Vy_DG,Vx_DG)

         axeC_DG = cont_axe_c_DG + axeC_DG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_DG = mr2print_DG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_DG = (deltax / old_longvec) * vectdeg
         ydeg_DG = (deltay / old_longvec) * vectdeg
         zdeg_DG = (deltaz / old_longvec) * vectdeg
         xdeg_DG = xdeg_DG + old_x_DG
         ydeg_DG = ydeg_DG + old_y_DG
         zdeg_DG = zdeg_DG + old_z_DG
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_DG = 1

         frbase_DG = frbase_DG/POURCENTAGE_AVANCE_DG

         pnumligne, *sgfr_DG,*frbase_DG ,e$

         frbase_DG = frbase_DG*POURCENTAGE_AVANCE_DG

         pnumligne,pgcode_DG, *xdeg_DG, *ydeg_DG, *zdeg_DG, e$
         if mr2print_DG <>   -1 & mr2print_DG > zdeg_DG, pnumligne,pgcode_DG, *zdeg2_DG, e$
         pnumligne,pgcode_DG, *prvaxec_DG, e$
         pnumligne,pgcode_DG, *zdeg_DG, e$
         gcode$ = 1
         gfr_DG = 0

         frbase_DG = frbase_DG*POURCENTAGE_AVANCE_DG

         pnumligne, pgcode_DG,*sgfr_DG, *old_x_DG, *old_y_DG, *old_z_DG, *frbase_DG, e$
       #  "voir",*axeC_DG,e    
penroul_AM    # retrait de 360 deg sur axeC_AM
    #     "voir",*axeC_AM,e
		if rattrapage_angle = 0, psortie_ratrap_enroul_AM
         cont_axe_c_AM = cont_axe_c_AM + (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AM = prvaxec_AM + (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AM = atan2(Vx_AM,Vy_AM)

         axeC_AM = cont_axe_c_AM + axeC_AM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AM = mr2print_AM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AM = (deltax / old_longvec) * vectdeg
         ydeg_AM = (deltay / old_longvec) * vectdeg
         zdeg_AM = (deltaz / old_longvec) * vectdeg
         xdeg_AM = xdeg_AM + old_x_AM
         ydeg_AM = ydeg_AM + old_y_AM
         zdeg_AM = zdeg_AM + old_z_AM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post processeur suite buttée axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "(RATRAPPAGE D ANGLE ENROULE )", e$
                                    ]
         gfr_AM = 1

         pnumligne, *sgfr_AM,*frbase_AM ,e$
         pnumligne,pgcode_AM, *xdeg_AM, *ydeg_AM, *zdeg_AM, e$
         if mr2print_AM <>   -1 & mr2print_AM > zdeg_AM, pnumligne,pgcode_AM, *zdeg2_AM, e$
         pnumligne,pgcode_AM, *prvaxec_AM, e$
         pnumligne,pgcode_AM, *zdeg_AM, e$
         gcode$ = 1
         gfr_AM = 0
         pnumligne,pgcode_AM,*sgfr_AM, *old_x_AM, *old_y_AM, *old_z_AM, *frbase_AM, e$
       #  "voir",*axeC_AM,e
penroul_BM    # retrait de 360 deg sur axeC_BM
    #     "voir",*axeC_BM,e
		 if rattrapage_angle = 0, psortie_ratrap_enroul_BM
         cont_axe_c_BM = cont_axe_c_BM + (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BM = prvaxec_BM + (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BM = atan2(Vx_BM,Vy_BM)

         axeC_BM = cont_axe_c_BM + axeC_BM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BM = mr2print_BM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BM = (deltax / old_longvec) * vectdeg
         ydeg_BM = (deltay / old_longvec) * vectdeg
         zdeg_BM = (deltaz / old_longvec) * vectdeg
         xdeg_BM = xdeg_BM + old_x_BM
         ydeg_BM = ydeg_BM + old_y_BM
         zdeg_BM = zdeg_BM + old_z_BM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_BM = 1

         pnumligne, *sgfr_BM,*frbase_BM ,e$
         pnumligne,pgcode_BM, *xdeg_BM, *ydeg_BM, *zdeg_BM, e$
         if mr2print_BM <>   -1 & mr2print_BM > zdeg_BM, pnumligne,pgcode_BM, *zdeg2_BM, e$
         pnumligne,pgcode_BM, *prvaxec_BM, e$
         pnumligne,pgcode_BM, *zdeg_BM, e$
         gcode$ = 1
         gfr_BM = 0
         pnumligne,pgcode_BM,*sgfr_BM, *old_x_BM, *old_y_BM, *old_z_BM, *frbase_BM, e$
       #  "voir",*axeC_BM,e
penroul_CM    # retrait de 360 deg sur axeC_CM
    #     "voir",*axeC_CM,e
		 if rattrapage_angle = 0, psortie_ratrap_enroul_CM
         cont_axe_c_CM = cont_axe_c_CM + (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CM = prvaxec_CM + (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CM = atan2(-Vy_CM,Vx_CM)

         axeC_CM = cont_axe_c_CM + axeC_CM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CM = mr2print_CM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CM = (deltax / old_longvec) * vectdeg
         ydeg_CM = (deltay / old_longvec) * vectdeg
         zdeg_CM = (deltaz / old_longvec) * vectdeg
         xdeg_CM = xdeg_CM + old_x_CM
         ydeg_CM = ydeg_CM + old_y_CM
         zdeg_CM = zdeg_CM + old_z_CM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_CM = 1

         frbase_CM = frbase_CM/POURCENTAGE_AVANCE_CM

         pnumligne, *sgfr_CM,*frbase_CM ,e$

         frbase_CM = frbase_CM*POURCENTAGE_AVANCE_CM

         pnumligne,pgcode_CM, *xdeg_CM, *ydeg_CM, *zdeg_CM, e$
         if mr2print_CM <>   -1 & mr2print_CM > zdeg_CM, pnumligne,pgcode_CM, *zdeg2_CM, e$
         pnumligne,pgcode_CM, *prvaxec_CM, e$
         pnumligne,pgcode_CM, *zdeg_CM, e$
         gcode$ = 1
         gfr_CM = 0

         frbase_CM = frbase_CM*POURCENTAGE_AVANCE_CM

         pnumligne,pgcode_CM,*sgfr_CM, *old_x_CM, *old_y_CM, *old_z_CM, *frbase_CM, e$
       #  "voir",*axeC_CM,e 

penroul_DM    # retrait de 360 deg sur axeC_DM
    #     "voir",*axeC_DM,e
		 if rattrapage_angle = 0, psortie_ratrap_enroul_DM
         cont_axe_c_DM = cont_axe_c_DM + (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_DM = prvaxec_DM + (360 * nbt_CG)    # retrait de 360 deg 
         axeC_DM = atan2(-Vy_DM,Vx_DM)

         axeC_DM = cont_axe_c_DM + axeC_DM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_DM = mr2print_DM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_DM = (deltax / old_longvec) * vectdeg
         ydeg_DM = (deltay / old_longvec) * vectdeg
         zdeg_DM = (deltaz / old_longvec) * vectdeg
         xdeg_DM = xdeg_DM + old_x_DM
         ydeg_DM = ydeg_DM + old_y_DM
         zdeg_DM = zdeg_DM + old_z_DM
         gcode$ = 0
         if rattrapage_angle = 1,   [
         result = mprint(sderoul, 3)
         if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
                                    ]
         gfr_DM = 1

         frbase_DM = frbase_DM/POURCENTAGE_AVANCE_DM

         pnumligne, *sgfr_DM,*frbase_DM ,e$

         frbase_DM = frbase_DM*POURCENTAGE_AVANCE_DM

         pnumligne,pgcode_DM, *xdeg_DM, *ydeg_DM, *zdeg_DM, e$
         if mr2print_DM <>   -1 & mr2print_DM > zdeg_DM, pnumligne,pgcode_DM, *zdeg2_DM, e$
         pnumligne,pgcode_DM, *prvaxec_DM, e$
         pnumligne,pgcode_DM, *zdeg_DM, e$
         gcode$ = 1
         gfr_DM = 0

         frbase_DM = frbase_DM*POURCENTAGE_AVANCE_DM

         pnumligne,pgcode_DM,*sgfr_DM, *old_x_DM, *old_y_DM, *old_z_DM, *frbase_DM, e$
       #  "voir",*axeC_DM,e        
#endregion
#region pdebut2

pdebut2_AG    # retour car angle trop grand ou trop petit          
         if prog_AG = 1, q19
         if prog_AG = 1, q13
          cont_axe_c_AG = 360 * trplus_AG
                axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.998, axeC_AG = 0
        axeC_AG = cont_axe_c_AG + axeC_AG
pdebut2_BG    # retour car angle trop grand ou trop petit          
         if prog_BG = 1, q20
         if prog_BG = 1, q14
          cont_axe_c_BG = 360 * trplus_BG
                axeC_BG = atan2(Vx_BG,Vy_BG)
                if abs(axeC_BG) > 359.998, axeC_BG = 0
        axeC_BG = cont_axe_c_BG + axeC_BG
pdebut2_CG    # retour car angle trop grand ou trop petit          
         if prog_CG = 1, q21
         if prog_CG = 1, q15
          cont_axe_c_CG = 360 * trplus_CG
                axeC_CG = atan2(-Vy_CG,Vx_CG)
                if abs(axeC_CG) > 359.998, axeC_CG = 0
        axeC_CG = cont_axe_c_CG + axeC_CG

pdebut2_DG    # retour car angle trop grand ou trop petit          
         if prog_DG = 1, q21
         if prog_DG = 1, q15
          cont_axe_c_DG = 360 * trplus_DG
                axeC_DG = atan2(-Vy_DG,Vx_DG)
                if abs(axeC_DG) > 359.998, axeC_DG = 0
        axeC_DG = cont_axe_c_DG + axeC_DG

pdebut2_AM    # retour car angle trop grand ou trop petit          
         if prog_AM = 1, q22
         if prog_AM = 1, q16
          cont_axe_c_AM = 360 * trplus_AM
                axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.998, axeC_AM = 0
        axeC_AM = cont_axe_c_AM + axeC_AM
pdebut2_BM    # retour car angle trop grand ou trop petit          
         if prog_BM = 1, q23
         if prog_BM = 1, q17
          cont_axe_c_BM = 360 * trplus_BM
                axeC_BM = atan2(Vx_BM,Vy_BM)
                if abs(axeC_BM) > 359.998, axeC_BM = 0
        axeC_BM = cont_axe_c_BM + axeC_BM
pdebut2_CM    # retour car angle trop grand ou trop petit          
         if prog_CM = 1, q24
         if prog_CM = 1, q18
          cont_axe_c_CM = 360 * trplus_CM
                axeC_CM = atan2(-Vy_CM,Vx_CM)
                if abs(axeC_CM) > 359.998, axeC_CM = 0
        axeC_CM = cont_axe_c_CM + axeC_CM
pdebut2_DM    # retour car angle trop grand ou trop petit          
         if prog_DM = 1, q24
         if prog_DM = 1, q18
          cont_axe_c_DM = 360 * trplus_DM
                axeC_DM = atan2(-Vy_DM,Vx_DM)
                if abs(axeC_DM) > 359.998, axeC_DM = 0
        axeC_DM = cont_axe_c_DM + axeC_DM
#endregion
#region pdebut

pdebut_AG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
          if mi1_C_base_AG = 1, trplus_AG = 1
          if mi1_C_base_AG = 2, trplus_AG = -1
          if mi1_C_base_AG = 0, trplus_AG = 0
         !trplus_AG
             cont_axe_c_AG = 360 * trplus_AG


             if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
             else, axeC_AG = atan2(Vx_AG,Vy_AG)
         if abs(axeC_AG) > 359.998, axeC_AG = 0
         reel_axeCpos_AG = axeC_AG
         axeC_AG = cont_axe_c_AG + axeC_AG

         @maxi_c_AG,@mini_c_AG
         if axeC_AG > maxi_c_AG, axeC_AG = axeC_AG - 360
         if axeC_AG < mini_c_AG, axeC_AG = axeC_AG + 360

pdebut_BG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_BG = 1, trplus_BG = 1
          if mi1_C_base_BG = 2, trplus_BG = -1
          if mi1_C_base_BG = 0, trplus_BG = 0
         !trplus_BG
             cont_axe_c_BG = 360 * trplus_BG
             if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
                 else, axeC_BG = atan2(Vx_BG,Vy_BG)

                 if abs(axeC_BG) > 359.998, axeC_BG = 0
         reel_axeCpos_BG = axeC_BG
         axeC_BG = cont_axe_c_BG + axeC_BG

         @maxi_c_BG,@mini_c_BG
         if axeC_BG > maxi_c_BG, axeC_BG = axeC_BG - 360
         if axeC_BG < mini_c_BG, axeC_BG = axeC_BG + 360

pdebut_CG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_CG = 1, trplus_CG = 1
          if mi1_C_base_CG = 2, trplus_CG = -1
          if mi1_C_base_CG = 0, trplus_CG = 0
         !trplus_CG
             cont_axe_c_CG = 360 * trplus_CG
             if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
                 else, axeC_CG = atan2(-Vy_CG,Vx_CG)

                 if abs(axeC_CG) > 359.998, axeC_CG = 0
         reel_axeCpos_CG = axeC_CG
         axeC_CG = cont_axe_c_CG + axeC_CG

         @maxi_c_CG,@mini_c_CG
         if axeC_CG > maxi_c_CG, axeC_CG = axeC_CG - 360
         if axeC_CG < mini_c_CG, axeC_CG = axeC_CG + 360

pdebut_DG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_DG = 1, trplus_DG = 1
          if mi1_C_base_DG = 2, trplus_DG = -1
          if mi1_C_base_DG = 0, trplus_DG = 0
         !trplus_DG
             cont_axe_c_DG = 360 * trplus_DG
             if Vx_DG = 0 & Vy_DG = 0, axeC_DG = prvaxec_DG
                 else, axeC_DG = atan2(-Vy_DG,Vx_DG)

                 if abs(axeC_DG) > 359.998, axeC_DG = 0
         reel_axeCpos_DG = axeC_DG
         axeC_DG = cont_axe_c_DG + axeC_DG

         @maxi_c_DG,@mini_c_DG
         if axeC_DG > maxi_c_DG, axeC_DG = axeC_DG - 360
         if axeC_DG < mini_c_DG, axeC_DG = axeC_DG + 360

pdebut_AM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
          if mi1_C_base_AM = 1, trplus_AM = 1
          if mi1_C_base_AM = 2, trplus_AM = -1
          if mi1_C_base_AM = 0, trplus_AM = 0
         !trplus_AM
             cont_axe_c_AM = 360 * trplus_AM


             if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
             else, axeC_AM = atan2(Vx_AM,Vy_AM)
         if abs(axeC_AM) > 359.998, axeC_AM = 0
         reel_axeCpos_AM = axeC_AM
         axeC_AM = cont_axe_c_AM + axeC_AM

         @maxi_c_AM,@mini_c_AM
         if axeC_AM > maxi_c_AM, axeC_AM = axeC_AM - 360
         if axeC_AM < mini_c_AM, axeC_AM = axeC_AM + 360

pdebut_BM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_BM = 1, trplus_BM = 1
          if mi1_C_base_BM = 2, trplus_BM = -1
          if mi1_C_base_BM = 0, trplus_BM = 0
         !trplus_BM
             cont_axe_c_BM = 360 * trplus_BM
             if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
                 else, axeC_BM = atan2(Vx_BM,Vy_BM)

                 if abs(axeC_BM) > 359.998, axeC_BM = 0
         reel_axeCpos_BM = axeC_BM
         axeC_BM = cont_axe_c_BM + axeC_BM

         @maxi_c_BM,@mini_c_BM
         if axeC_BM > maxi_c_BM, axeC_BM = axeC_BM - 360
         if axeC_BM < mini_c_BM, axeC_BM = axeC_BM + 360

pdebut_CM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_CM = 1, trplus_CM = 1
          if mi1_C_base_CM = 2, trplus_CM = -1
          if mi1_C_base_CM = 0, trplus_CM = 0
         !trplus_CM
             cont_axe_c_CM = 360 * trplus_CM
             if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
                 else, axeC_CM = atan2(-Vy_CM,Vx_CM)

                 if abs(axeC_CM) > 359.998, axeC_CM = 0
         reel_axeCpos_CM = axeC_CM
         axeC_CM = cont_axe_c_CM + axeC_CM

         @maxi_c_CM,@mini_c_CM
         if axeC_CM > maxi_c_CM, axeC_CM = axeC_CM - 360
         if axeC_CM < mini_c_CM, axeC_CM = axeC_CM + 360

pdebut_DM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_DM = 1, trplus_DM = 1
          if mi1_C_base_DM = 2, trplus_DM = -1
          if mi1_C_base_DM = 0, trplus_DM = 0
         !trplus_DM
             cont_axe_c_DM = 360 * trplus_DM
             if Vx_DM = 0 & Vy_DM = 0, axeC_DM = prvaxec_DM
                 else, axeC_DM = atan2(-Vy_DM,Vx_DM)

                 if abs(axeC_DM) > 359.998, axeC_DM = 0
         reel_axeCpos_DM = axeC_DM
         axeC_DM = cont_axe_c_DM + axeC_DM

         @maxi_c_DM,@mini_c_DM
         if axeC_DM > maxi_c_DM, axeC_DM = axeC_DM - 360
         if axeC_DM < mini_c_DM, axeC_DM = axeC_DM + 360
#endregion
#region ptest_axec

ptest_axec_AG   # routine pour savoir les axes 
             axeC_AG = atan2(Vx_AG,Vy_AG)
            "voir solution 1 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vx_AG,Vy_AG)
            "voir solution 2 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vx_AG,-Vy_AG)
            "voir solution 3 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vx_AG,-Vy_AG)
            "voir solution 4 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vy_AG,Vx_AG)
            "voir solution 5 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vy_AG,Vx_AG)
            "voir solution 6 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vy_AG,-Vx_AG)
            "voir solution 7 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vy_AG,-Vx_AG)
            "voir solution 8 pour C dans pmxinvg=", *axeC_AG, e$

ptest_axec_AM   # routine pour savoir les axes 
             axeC_AM = atan2(Vx_AM,Vy_AM)
            "voir solution 1 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vx_AM,Vy_AM)
            "voir solution 2 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vx_AM,-Vy_AM)
            "voir solution 3 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vx_AM,-Vy_AM)
            "voir solution 4 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vy_AM,Vx_AM)
            "voir solution 5 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vy_AM,Vx_AM)
            "voir solution 6 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vy_AM,-Vx_AM)
            "voir solution 7 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vy_AM,-Vx_AM)
            "voir solution 8 pour C dans pmxinvg=", *axeC_AM, e$
#endregion
#region pmxinvd

pmxinvd_AG   # ecriture de axes A positif 
            #"on est dans  pmxinvd_AG", e$    
           Vx_AG = ucal - xcal
           Vy_AG = ycal - vcal
           Vz_AG = wcal - zcal
           vertical_z = z$ - w$
           !vertical_z
           #"Voir ", vertical_z ,e$ 
          # "voir ", *Vx_AG, *Vy_AG, *Vz_AG, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
           if tete_rev_AG = 1 & ((Vx_AG = 0 & Vy_AG = 0) | vertical_z = 0 ),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc.
                [
                # "on y est", e$        
                axeA_AG = 0
                Vx_AG = x$ - u$
                Vy_AG = v$ - y$
                axeC_AG = atan2(Vx_AG,Vy_AG)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AG) < cone_mini & abs(Vy_AG) < cone_mini & tete_rev_AG = 0, Vx_AG = 0, Vy_AG = 0
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)
                if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
                else, axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.999, axeC_AG = 0
                reel_axeCpos_AG = axeC_AG
                if longvec = 0, longvec = 1
                axeA_AG = acos(Vz_AG / longvec)
                ]

           invers_AG = 0
           deja_AG = 1

pmxinvd_BG   # ecriture de axes A positif      
             Vx_BG = ucal - xcal
             Vy_BG = ycal - vcal
             Vz_BG = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_BG = 1 & ((Vx_BG = 0 & Vy_BG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BG = 0
            Vx_BG = x$ - u$
            Vy_BG = v$ - y$
            axeC_BG = atan2(Vx_BG,Vy_BG)
            #"voir C pmxinvd_BG", *axeC_BG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
           if abs(Vx_BG) < cone_mini & abs(Vy_BG) < cone_mini, Vx_BG = 0, Vy_BG = 0
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
       @Vx_BG,@Vy_BG,@Vz_BG
       longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)
       if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
           else, axeC_BG = atan2(Vx_BG,Vy_BG)

           if abs(axeC_BG) > 359.999, axeC_BG = 0

           reel_axeCpos_BG = axeC_BG
           if longvec = 0, longvec = 1
           axeA_BG = acos(Vz_BG / longvec)
           ]
           invers_BG = 0
           deja_BG = 1

pmxinvd_CG   # ecriture de axes A positif      
             Vx_CG = ucal - xcal
             Vy_CG = ycal - vcal
             Vz_CG = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_CG = 1 & ((Vx_CG = 0 & Vy_CG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CG = 0
            Vx_CG = x$ - u$
            Vy_CG = v$ - y$
            axeC_CG = atan2(-Vy_CG,Vx_CG)
            #"voir C pmxinvd_CG", *axeC_CG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
           if abs(Vx_CG) < cone_mini & abs(Vy_CG) < cone_mini, Vx_CG = 0, Vy_CG = 0
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
       @Vx_CG,@Vy_CG,@Vz_CG
       longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)
       if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
           else, axeC_CG = atan2(-Vy_CG,Vx_CG)

           if abs(axeC_CG) > 359.999, axeC_CG = 0

           reel_axeCpos_CG = axeC_CG
           if longvec = 0, longvec = 1
           axeA_CG = acos(Vz_CG / longvec)
           ]
           invers_CG = 0
           deja_CG = 1

pmxinvd_DG   # ecriture de axes A positif      
             Vx_DG = ucal - xcal
             Vy_DG = ycal - vcal
             Vz_DG = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_DG = 1 & ((Vx_DG = 0 & Vy_DG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_DG = 0
            Vx_DG = x$ - u$
            Vy_DG = v$ - y$
            axeC_DG = atan2(-Vy_DG,Vx_DG)
            #"voir C pmxinvd_DG", *axeC_DG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_DG,*Vy_DG,*Vz_DG, e$
           if abs(Vx_DG) < cone_mini & abs(Vy_DG) < cone_mini, Vx_DG = 0, Vy_DG = 0
           #"--------------------voirvxvyvz",*Vx_DG,*Vy_DG,*Vz_DG, e$
       @Vx_DG,@Vy_DG,@Vz_DG
       longvec=sqrt(Vx_DG * Vx_DG + Vy_DG * Vy_DG + Vz_DG * Vz_DG)
       if Vx_DG = 0 & Vy_DG = 0, axeC_DG = prvaxec_DG
           else, axeC_DG = atan2(-Vy_DG,Vx_DG)

           if abs(axeC_DG) > 359.999, axeC_DG = 0

           reel_axeCpos_DG = axeC_DG
           if longvec = 0, longvec = 1
           axeA_DG = acos(Vz_DG / longvec)
           ]
           invers_DG = 0
           deja_DG = 1

pmxinvd_AM   # ecriture de axes A positif 
            #"on est dans  pmxinvd_AM", e$    
           Vx_AM = ucal - xcal
           Vy_AM = ycal - vcal
           Vz_AM = wcal - zcal
           vertical_z = z$ - w$
           !vertical_z
           #"Voir ", vertical_z ,e$ 
          # "voir ", *Vx_AM, *Vy_AM, *Vz_AM, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
           if tete_rev_AM = 1 & ((Vx_AM = 0 & Vy_AM = 0) | vertical_z = 0 ),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc.
                [
                # "on y est", e$        
                axeA_AM = 0
                Vx_AM = x$ - u$
                Vy_AM = v$ - y$
                axeC_AM = atan2(Vx_AM,Vy_AM)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AM) < cone_mini & abs(Vy_AM) < cone_mini & tete_rev_AM = 0, Vx_AM = 0, Vy_AM = 0
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)
                if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
                else, axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.999, axeC_AM = 0
                reel_axeCpos_AM = axeC_AM
                if longvec = 0, longvec = 1
                axeA_AM = acos(Vz_AM / longvec)
                ]

           invers_AM = 0
           deja_AM = 1

pmxinvd_BM   # ecriture de axes A positif      
             Vx_BM = ucal - xcal
             Vy_BM = ycal - vcal
             Vz_BM = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_BM = 1 & ((Vx_BM = 0 & Vy_BM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BM = 0
            Vx_BM = x$ - u$
            Vy_BM = v$ - y$
            axeC_BM = atan2(Vx_BM,Vy_BM)
            #"voir C pmxinvd_BM", *axeC_BM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
           if abs(Vx_BM) < cone_mini & abs(Vy_BM) < cone_mini, Vx_BM = 0, Vy_BM = 0
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
       @Vx_BM,@Vy_BM,@Vz_BM
       longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)
       if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
           else, axeC_BM = atan2(Vx_BM,Vy_BM)

           if abs(axeC_BM) > 359.999, axeC_BM = 0

           reel_axeCpos_BM = axeC_BM
           if longvec = 0, longvec = 1
           axeA_BM = acos(Vz_BM / longvec)
           ]
           invers_BM = 0
           deja_BM = 1

pmxinvd_CM   # ecriture de axes A positif      
             Vx_CM = ucal - xcal
             Vy_CM = ycal - vcal
             Vz_CM = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_CM = 1 & ((Vx_CM = 0 & Vy_CM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CM = 0
            Vx_CM = x$ - u$
            Vy_CM = v$ - y$
            axeC_CM = atan2(-Vy_CM,Vx_CM)
            #"voir C pmxinvd_CM", *axeC_CM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
           if abs(Vx_CM) < cone_mini & abs(Vy_CM) < cone_mini, Vx_CM = 0, Vy_CM = 0
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
       @Vx_CM,@Vy_CM,@Vz_CM
       longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)
       if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
           else, axeC_CM = atan2(-Vy_CM,Vx_CM)

           if abs(axeC_CM) > 359.999, axeC_CM = 0

           reel_axeCpos_CM = axeC_CM
           if longvec = 0, longvec = 1
           axeA_CM = acos(Vz_CM / longvec)
           ]
           invers_CM = 0
           deja_CM = 1

pmxinvd_DM   # ecriture de axes A positif      
             Vx_DM = ucal - xcal
             Vy_DM = ycal - vcal
             Vz_DM = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_DM = 1 & ((Vx_DM = 0 & Vy_DM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_DM = 0
            Vx_DM = x$ - u$
            Vy_DM = v$ - y$
            axeC_DM = atan2(-Vy_DM,Vx_DM)
            #"voir C pmxinvd_DM", *axeC_DM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_DM,*Vy_DM,*Vz_DM, e$
           if abs(Vx_DM) < cone_mini & abs(Vy_DM) < cone_mini, Vx_DM = 0, Vy_DM = 0
           #"--------------------voirvxvyvz",*Vx_DM,*Vy_DM,*Vz_DM, e$
       @Vx_DM,@Vy_DM,@Vz_DM
       longvec=sqrt(Vx_DM * Vx_DM + Vy_DM * Vy_DM + Vz_DM * Vz_DM)
       if Vx_DM = 0 & Vy_DM = 0, axeC_DM = prvaxec_DM
           else, axeC_DM = atan2(-Vy_DM,Vx_DM)

           if abs(axeC_DM) > 359.999, axeC_DM = 0

           reel_axeCpos_DM = axeC_DM
           if longvec = 0, longvec = 1
           axeA_DM = acos(Vz_DM / longvec)
           ]
           invers_DM = 0
           deja_DM = 1

#endregion
#region pmxinvg

pmxinvg_AG   # ecriture de axes A negatif    
            #"on est dans  pmxinvg_AG", e$  
            Vx_AG = xcal - ucal
            Vy_AG = vcal - ycal
            Vz_AG = wcal - zcal
            vertical_z = z$ - w$
            !vertical_z
           # "Voir ", vertical_z ,e$ 
           # "voir ", *Vx_AG, *Vy_AG, *Vz_AG, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
            if tete_rev_AG = 1 & ((Vx_AG = 0 & Vy_AG = 0) | vertical_z = 0),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc..
                [
                # "on y est aussi", e$      
                axeA_AG = 0
                Vx_AG = u$ - x$
                Vy_AG = y$ - v$
                axeC_AG = atan2(Vx_AG,Vy_AG)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AG) < cone_mini & abs(Vy_AG) < cone_mini & tete_rev_AG = 0, Vx_AG = 0, Vy_AG = 0
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)
                if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
                else, axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.999, axeC_AG = 0
                reel_axeCpos_AG = axeC_AG
                if longvec = 0, longvec = 1
                axeA_AG = acos(Vz_AG / longvec) *   -1
                ]

            invers_AG = 1
            deja_AG = 1

pmxinvg_BG   # ecriture de axes A negatif    
            Vx_BG = xcal - ucal
            Vy_BG = vcal - ycal
            Vz_BG = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_BG = 1 & ((Vx_BG = 0 & Vy_BG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BG = 0
            Vx_BG = u$ - x$
            Vy_BG = y$ - v$
            axeC_BG = atan2(Vx_BG,Vy_BG)
            #"voir C dans pmxinvg_BG", *axeC_BG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
           if abs(Vx_BG) < cone_mini & abs(Vy_BG) < cone_mini, Vx_BG = 0, Vy_BG = 0
          # "--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
            @Vx_BG,@Vy_BG,@Vz_BG
            longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)
            if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
            else, axeC_BG = atan2(Vx_BG,Vy_BG)

            if abs(axeC_BG) > 359.999, axeC_BG = 0

            reel_axeCpos_BG = axeC_BG
            if longvec = 0, longvec = 1
            axeA_BG = acos(Vz_BG / longvec) *   -1
            ]
            invers_BG = 1
            deja_BG = 1

pmxinvg_CG   # ecriture de axes A negatif    
            Vx_CG = xcal - ucal
            Vy_CG = vcal - ycal
            Vz_CG = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_CG = 1 & ((Vx_CG = 0 & Vy_CG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CG = 0
            Vx_CG = u$ - x$
            Vy_CG = y$ - v$
            axeC_CG = atan2(-Vy_CG,Vx_CG)
            #"voir C dans pmxinvg_CG", *axeC_CG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
           if abs(Vx_CG) < cone_mini & abs(Vy_CG) < cone_mini, Vx_CG = 0, Vy_CG = 0
          # "--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
            @Vx_CG,@Vy_CG,@Vz_CG
            longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)
            if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
            else, axeC_CG = atan2(-Vy_CG,Vx_CG)

            if abs(axeC_CG) > 359.999, axeC_CG = 0

            reel_axeCpos_CG = axeC_CG
            if longvec = 0, longvec = 1
            axeA_CG = acos(Vz_CG / longvec) *   -1
            ]
            invers_CG = 1
            deja_CG = 1

pmxinvg_DG   # ecriture de axes A negatif    
            Vx_DG = xcal - ucal
            Vy_DG = vcal - ycal
            Vz_DG = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_DG = 1 & ((Vx_DG = 0 & Vy_DG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_DG = 0
            Vx_DG = u$ - x$
            Vy_DG = y$ - v$
            axeC_DG = atan2(-Vy_DG,Vx_DG)
            #"voir C dans pmxinvg_DG", *axeC_DG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_DG,*Vy_DG,*Vz_DG, e$
           if abs(Vx_DG) < cone_mini & abs(Vy_DG) < cone_mini, Vx_DG = 0, Vy_DG = 0
          # "--------------------voirvxvyvz",*Vx_DG,*Vy_DG,*Vz_DG, e$
            @Vx_DG,@Vy_DG,@Vz_DG
            longvec=sqrt(Vx_DG * Vx_DG + Vy_DG * Vy_DG + Vz_DG * Vz_DG)
            if Vx_DG = 0 & Vy_DG = 0, axeC_DG = prvaxec_DG
            else, axeC_DG = atan2(-Vy_DG,Vx_DG)

            if abs(axeC_DG) > 359.999, axeC_DG = 0

            reel_axeCpos_DG = axeC_DG
            if longvec = 0, longvec = 1
            axeA_DG = acos(Vz_DG / longvec) *   -1
            ]
            invers_DG = 1
            deja_DG = 1

pmxinvg_AM   # ecriture de axes A negatif    
            #"on est dans  pmxinvg_AM", e$  
            Vx_AM = xcal - ucal
            Vy_AM = vcal - ycal
            Vz_AM = wcal - zcal
            vertical_z = z$ - w$
            !vertical_z
           # "Voir ", vertical_z ,e$ 
           # "voir ", *Vx_AM, *Vy_AM, *Vz_AM, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
            if tete_rev_AM = 1 & ((Vx_AM = 0 & Vy_AM = 0) | vertical_z = 0),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc..
                [
                # "on y est aussi", e$      
                axeA_AM = 0
                Vx_AM = u$ - x$
                Vy_AM = y$ - v$
                axeC_AM = atan2(Vx_AM,Vy_AM)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AM) < cone_mini & abs(Vy_AM) < cone_mini & tete_rev_AM = 0, Vx_AM = 0, Vy_AM = 0
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)
                if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
                else, axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.999, axeC_AM = 0
                reel_axeCpos_AM = axeC_AM
                if longvec = 0, longvec = 1
                axeA_AM = acos(Vz_AM / longvec) *   -1
                ]

            invers_AM = 1
            deja_AM = 1

pmxinvg_BM   # ecriture de axes A negatif    
            Vx_BM = xcal - ucal
            Vy_BM = vcal - ycal
            Vz_BM = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_BM = 1 & ((Vx_BM = 0 & Vy_BM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BM = 0
            Vx_BM = u$ - x$
            Vy_BM = y$ - v$
            axeC_BM = atan2(Vx_BM,Vy_BM)
            #"voir C dans pmxinvg_BM", *axeC_BM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
           if abs(Vx_BM) < cone_mini & abs(Vy_BM) < cone_mini, Vx_BM = 0, Vy_BM = 0
          # "--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
            @Vx_BM,@Vy_BM,@Vz_BM
            longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)
            if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
            else, axeC_BM = atan2(Vx_BM,Vy_BM)

            if abs(axeC_BM) > 359.999, axeC_BM = 0

            reel_axeCpos_BM = axeC_BM
            if longvec = 0, longvec = 1
            axeA_BM = acos(Vz_BM / longvec) *   -1
            ]
            invers_BM = 1
            deja_BM = 1

pmxinvg_CM   # ecriture de axes A negatif    
            Vx_CM = xcal - ucal
            Vy_CM = vcal - ycal
            Vz_CM = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_CM = 1 & ((Vx_CM = 0 & Vy_CM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CM = 0
            Vx_CM = u$ - x$
            Vy_CM = y$ - v$
            axeC_CM = atan2(-Vy_CM,Vx_CM)
            #"voir C dans pmxinvg_CM", *axeC_CM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
           if abs(Vx_CM) < cone_mini & abs(Vy_CM) < cone_mini, Vx_CM = 0, Vy_CM = 0
          # "--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
            @Vx_CM,@Vy_CM,@Vz_CM
            longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)
            if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
            else, axeC_CM = atan2(-Vy_CM,Vx_CM)

            if abs(axeC_CM) > 359.999, axeC_CM = 0

            reel_axeCpos_CM = axeC_CM
            if longvec = 0, longvec = 1
            axeA_CM = acos(Vz_CM / longvec) *   -1
            ]
            invers_CM = 1
            deja_CM = 1

pmxinvg_DM   # ecriture de axes A negatif    
            Vx_DM = xcal - ucal
            Vy_DM = vcal - ycal
            Vz_DM = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_DM = 1 & ((Vx_DM = 0 & Vy_DM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_DM = 0
            Vx_DM = u$ - x$
            Vy_DM = y$ - v$
            axeC_DM = atan2(-Vy_DM,Vx_DM)
            #"voir C dans pmxinvg_DM", *axeC_DM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_DM,*Vy_DM,*Vz_DM, e$
           if abs(Vx_DM) < cone_mini & abs(Vy_DM) < cone_mini, Vx_DM = 0, Vy_DM = 0
          # "--------------------voirvxvyvz",*Vx_DM,*Vy_DM,*Vz_DM, e$
            @Vx_DM,@Vy_DM,@Vz_DM
            longvec=sqrt(Vx_DM * Vx_DM + Vy_DM * Vy_DM + Vz_DM * Vz_DM)
            if Vx_DM = 0 & Vy_DM = 0, axeC_DM = prvaxec_DM
            else, axeC_DM = atan2(-Vy_DM,Vx_DM)

            if abs(axeC_DM) > 359.999, axeC_DM = 0

            reel_axeCpos_DM = axeC_DM
            if longvec = 0, longvec = 1
            axeA_DM = acos(Vz_DM / longvec) *   -1
            ]
            invers_DM = 1
            deja_DM = 1
#endregion
#region pmxinvgd

pmxinvgd_AG   # droite ou gauche
        #"voir",*invers_AG ,e
        if invers_AG = 0, pmxinvg_AG
             else, pmxinvd_AG
pmxinvgd_BG   # droite ou gauche
        #"voir",*invers_BG ,e
        if invers_BG = 0, pmxinvg_BG
             else, pmxinvd_BG
pmxinvgd_CG   # droite ou gauche
        #"voir",*invers_CG ,e
        if invers_CG = 0, pmxinvg_CG
             else, pmxinvd_CG
pmxinvgd_DG   # droite ou gauche
        #"voir",*invers_CG ,e
        if invers_DG = 0, pmxinvg_DG
             else, pmxinvd_DG
pmxinvgd_AM   # droite ou gauche
        #"voir",*invers_AM ,e
        if invers_AM = 0, pmxinvg_AM
             else, pmxinvd_AM
pmxinvgd_BM   # droite ou gauche
        #"voir",*invers_BM ,e
        if invers_BM = 0, pmxinvg_BM
             else, pmxinvd_BM
pmxinvgd_CM   # droite ou gauche
        #"voir",*invers_CM ,e
        if invers_CM = 0, pmxinvg_CM
             else, pmxinvd_CM
pmxinvgd_DM   # droite ou gauche
        #"voir",*invers_CM ,e
        if invers_DM = 0, pmxinvg_DM
             else, pmxinvd_DM
#endregion
#region pmxsens

pmxsens_AG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_AG,*Vx_AG," et ",*old_vy_AG,*Vy_AG  ,e
        if Vx_AG >=   -0.002& Vx_AG <= 0.002, Vx_AG = 0
        if Vy_AG >=   -0.002& Vy_AG <= 0.002, Vy_AG = 0

        deja_AG = 0
        if axeA_AG <> 0 & axeC_AG <> 0, [
        if deja_AG = 0 & old_vx_AG <= 0 & Vx_AG > 0 & old_vy_AG = 0 & Vy_AG = 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG >= 0 & Vx_AG < 0 & old_vy_AG = 0 & Vy_AG = 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG = 0 & Vx_AG = 0 & old_vy_AG >= 0 & Vy_AG < 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG = 0 & Vx_AG = 0 & old_vy_AG <= 0 & Vy_AG > 0 , pmxinvgd_AG

        if deja_AG = 0 & old_vx_AG < 0 & Vx_AG > 0 & old_vy_AG < 0 & Vy_AG > 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG > 0 & Vx_AG < 0 & old_vy_AG > 0 & Vy_AG < 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG <= 0 & Vx_AG >= 0 & old_vy_AG >= 0 & Vy_AG <= 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG >= 0 & Vx_AG <= 0 & old_vy_AG <= 0 & Vy_AG >= 0 , pmxinvgd_AG
        ]
        deja_AG = 0


pmxsens_BG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_BG,*Vx_BG," et ",*old_vy_BG,*Vy_BG  ,e
        if Vx_BG >=   -0.002&Vx_BG <= 0.002, Vx_BG = 0
        if Vy_BG >=   -0.002&Vy_BG <= 0.002, Vy_BG = 0

        deja_BG = 0
        if axeA_BG <> 0 & axeC_BG <> 0, [
        if deja_BG = 0 & old_vx_BG <= 0 & Vx_BG > 0 & old_vy_BG = 0 & Vy_BG = 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG >= 0 & Vx_BG < 0 & old_vy_BG = 0 & Vy_BG = 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG = 0 & Vx_BG = 0 & old_vy_BG >= 0 & Vy_BG < 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG = 0 & Vx_BG = 0 & old_vy_BG <= 0 & Vy_BG > 0 , pmxinvgd_BG

        if deja_BG = 0 & old_vx_BG < 0 & Vx_BG > 0 & old_vy_BG < 0 & Vy_BG > 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG > 0 & Vx_BG < 0 & old_vy_BG > 0 & Vy_BG < 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG <= 0 & Vx_BG >= 0 & old_vy_BG >= 0 & Vy_BG <= 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG >= 0 & Vx_BG <= 0 & old_vy_BG <= 0 & Vy_BG >= 0 , pmxinvgd_BG
        ]
        deja_BG = 0


pmxsens_CG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_CG,*Vx_CG," et ",*old_vy_CG,*Vy_CG  ,e
        if Vx_CG >=   -0.002&Vx_CG <= 0.002, Vx_CG = 0
        if Vy_CG >=   -0.002&Vy_CG <= 0.002, Vy_CG = 0

        deja_CG = 0
        if axeA_CG <> 0 & axeC_CG <> 0, [
        if deja_CG = 0 & old_vx_CG <= 0 & Vx_CG > 0 & old_vy_CG = 0 & Vy_CG = 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG >= 0 & Vx_CG < 0 & old_vy_CG = 0 & Vy_CG = 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG = 0 & Vx_CG = 0 & old_vy_CG >= 0 & Vy_CG < 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG = 0 & Vx_CG = 0 & old_vy_CG <= 0 & Vy_CG > 0 , pmxinvgd_CG

        if deja_CG = 0 & old_vx_CG < 0 & Vx_CG > 0 & old_vy_CG < 0 & Vy_CG > 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG > 0 & Vx_CG < 0 & old_vy_CG > 0 & Vy_CG < 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG <= 0 & Vx_CG >= 0 & old_vy_CG >= 0 & Vy_CG <= 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG >= 0 & Vx_CG <= 0 & old_vy_CG <= 0 & Vy_CG >= 0 , pmxinvgd_CG
        ]
        deja_CG = 0

pmxsens_DG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_DG,*Vx_DG," et ",*old_vy_DG,*Vy_DG  ,e
        if Vx_DG >=   -0.002&Vx_DG <= 0.002, Vx_DG = 0
        if Vy_DG >=   -0.002&Vy_DG <= 0.002, Vy_DG = 0

        deja_DG = 0
        if axeA_DG <> 0 & axeC_DG <> 0, [
        if deja_DG = 0 & old_vx_DG <= 0 & Vx_DG > 0 & old_vy_DG = 0 & Vy_DG = 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG >= 0 & Vx_DG < 0 & old_vy_DG = 0 & Vy_DG = 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG = 0 & Vx_DG = 0 & old_vy_DG >= 0 & Vy_DG < 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG = 0 & Vx_DG = 0 & old_vy_DG <= 0 & Vy_DG > 0 , pmxinvgd_DG

        if deja_DG = 0 & old_vx_DG < 0 & Vx_DG > 0 & old_vy_DG < 0 & Vy_DG > 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG > 0 & Vx_DG < 0 & old_vy_DG > 0 & Vy_DG < 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG <= 0 & Vx_DG >= 0 & old_vy_DG >= 0 & Vy_DG <= 0 , pmxinvgd_DG
        if deja_DG = 0 & old_vx_DG >= 0 & Vx_DG <= 0 & old_vy_DG <= 0 & Vy_DG >= 0 , pmxinvgd_DG
        ]
        deja_DG = 0

pmxsens_AM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_AM,*Vx_AM," et ",*old_vy_AM,*Vy_AM  ,e
        if Vx_AM >=   -0.002&Vx_AM <= 0.002, Vx_AM = 0
        if Vy_AM >=   -0.002&Vy_AM <= 0.002, Vy_AM = 0

        deja_AM = 0
        if axeA_AM <> 0 & axeC_AM <> 0, [
        if deja_AM = 0 & old_vx_AM <= 0 & Vx_AM > 0 & old_vy_AM = 0 & Vy_AM = 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM >= 0 & Vx_AM < 0 & old_vy_AM = 0 & Vy_AM = 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM = 0 & Vx_AM = 0 & old_vy_AM >= 0 & Vy_AM < 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM = 0 & Vx_AM = 0 & old_vy_AM <= 0 & Vy_AM > 0 , pmxinvgd_AM

        if deja_AM = 0 & old_vx_AM < 0 & Vx_AM > 0 & old_vy_AM < 0 & Vy_AM > 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM > 0 & Vx_AM < 0 & old_vy_AM > 0 & Vy_AM < 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM <= 0 & Vx_AM >= 0 & old_vy_AM >= 0 & Vy_AM <= 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM >= 0 & Vx_AM <= 0 & old_vy_AM <= 0 & Vy_AM >= 0 , pmxinvgd_AM
        ]
        deja_AM = 0


pmxsens_BM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_BM,*Vx_BM," et ",*old_vy_BM,*Vy_BM  ,e
        if Vx_BM >=   -0.002&Vx_BM <= 0.002, Vx_BM = 0
        if Vy_BM >=   -0.002&Vy_BM <= 0.002, Vy_BM = 0

        deja_BM = 0
        if axeA_BM <> 0 & axeC_BM <> 0, [
        if deja_BM = 0 & old_vx_BM <= 0 & Vx_BM > 0 & old_vy_BM = 0 & Vy_BM = 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM >= 0 & Vx_BM < 0 & old_vy_BM = 0 & Vy_BM = 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM = 0 & Vx_BM = 0 & old_vy_BM >= 0 & Vy_BM < 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM = 0 & Vx_BM = 0 & old_vy_BM <= 0 & Vy_BM > 0 , pmxinvgd_BM

        if deja_BM = 0 & old_vx_BM < 0 & Vx_BM > 0 & old_vy_BM < 0 & Vy_BM > 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM > 0 & Vx_BM < 0 & old_vy_BM > 0 & Vy_BM < 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM <= 0 & Vx_BM >= 0 & old_vy_BM >= 0 & Vy_BM <= 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM >= 0 & Vx_BM <= 0 & old_vy_BM <= 0 & Vy_BM >= 0 , pmxinvgd_BM
        ]
        deja_BM = 0


pmxsens_CM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_CM,*Vx_CM," et ",*old_vy_CM,*Vy_CM  ,e
        if Vx_CM >=   -0.002&Vx_CM <= 0.002, Vx_CM = 0
        if Vy_CM >=   -0.002&Vy_CM <= 0.002, Vy_CM = 0

        deja_CM = 0
        if axeA_CM <> 0 & axeC_CM <> 0, [
        if deja_CM = 0 & old_vx_CM <= 0 & Vx_CM > 0 & old_vy_CM = 0 & Vy_CM = 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM >= 0 & Vx_CM < 0 & old_vy_CM = 0 & Vy_CM = 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM = 0 & Vx_CM = 0 & old_vy_CM >= 0 & Vy_CM < 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM = 0 & Vx_CM = 0 & old_vy_CM <= 0 & Vy_CM > 0 , pmxinvgd_CM

        if deja_CM = 0 & old_vx_CM < 0 & Vx_CM > 0 & old_vy_CM < 0 & Vy_CM > 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM > 0 & Vx_CM < 0 & old_vy_CM > 0 & Vy_CM < 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM <= 0 & Vx_CM >= 0 & old_vy_CM >= 0 & Vy_CM <= 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM >= 0 & Vx_CM <= 0 & old_vy_CM <= 0 & Vy_CM >= 0 , pmxinvgd_CM
        ]
        deja_CM = 0

pmxsens_DM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_DM,*Vx_DM," et ",*old_vy_DM,*Vy_DM  ,e
        if Vx_DM >=   -0.002&Vx_DM <= 0.002, Vx_DM = 0
        if Vy_DM >=   -0.002&Vy_DM <= 0.002, Vy_DM = 0

        deja_DM = 0
        if axeA_DM <> 0 & axeC_DM <> 0, [
        if deja_DM = 0 & old_vx_DM <= 0 & Vx_DM > 0 & old_vy_DM = 0 & Vy_DM = 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM >= 0 & Vx_DM < 0 & old_vy_DM = 0 & Vy_DM = 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM = 0 & Vx_DM = 0 & old_vy_DM >= 0 & Vy_DM < 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM = 0 & Vx_DM = 0 & old_vy_DM <= 0 & Vy_DM > 0 , pmxinvgd_DM

        if deja_DM = 0 & old_vx_DM < 0 & Vx_DM > 0 & old_vy_DM < 0 & Vy_DM > 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM > 0 & Vx_DM < 0 & old_vy_DM > 0 & Vy_DM < 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM <= 0 & Vx_DM >= 0 & old_vy_DM >= 0 & Vy_DM <= 0 , pmxinvgd_DM
        if deja_DM = 0 & old_vx_DM >= 0 & Vx_DM <= 0 & old_vy_DM <= 0 & Vy_DM >= 0 , pmxinvgd_DM
        ]
        deja_DM = 0
#endregion
#region pvariok

pvariok_AG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_BG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_CG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_DG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_AM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_BM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_CM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_DM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53
#endregion
#region pvarioutil
fmt "demi periode" 1 moit_per
#fmt "pasn" 1 pasn
#fmt "moitier de periode" 1 moit_per
fmt "pas de base" 1 pas_base
fmt "val_pas" 1 val_pas
fmt "sens du pas" 1 sens_pas
fmt "dbut de variation" 1 debutvar
fmt "" 3 vale53abs

pvarioutil_AG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_AG
         pasn = 1 + pasn

pvarioutil_BG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_BG
         pasn = 1 + pasn

pvarioutil_CG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_CG
         pasn = 1 + pasn
pvarioutil_DG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_DG
         pasn = 1 + pasn
pvarioutil_AM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_AM
         pasn = 1 + pasn

pvarioutil_BM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_BM
         pasn = 1 + pasn

pvarioutil_CM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_CM
         pasn = 1 + pasn

pvarioutil_DM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_DM
         pasn = 1 + pasn


#endregion
#region pmx
pmx$
            pchange_AG
            pmx_AG

            pchange_AM
            pmx_AM

            pchange_BG
            pmx_BG

            pchange_BM
            pmx_BM

            pchange_CG
            pmx_CG

            pchange_CM
            pmx_CM

            pchange_DG
            pmx_DG

            pchange_DM
            pmx_DM

pmx_AG        # 5 axes

            pprint_AG
            @xprint_AG, @yprint_AG,@zprint_AG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                pchange_AM
                pmx_AM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_AG = 0

            if invers_AG = 0, pmxinvd_AG
            if invers_AG = 1, pmxinvg_AG

             if debut_AG = 1, pmxsens_AG
             !maxi_c_AG, !mini_c_AG

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_AG
           Dy = ycal - old_y_AG
           Dz = zcal - old_z_AG
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)

            if fr$ =   -1,fr$= frbase_AG
            if fr$ > 0, frbase_AG = fr$

            if deltaXYZ < mr5$ & debut_AG = 1, pchange_AM, pmx_AM   # modif du 30/10/02
            else,
                [
                if fr$ > 0 & deltaXYZ <> 0,fr5axe_AG = fr$ / deltaXYZ
                ]

            if debut_AG = 0 & changop_AG <> 0, cont_axe_c_AG = 0
            if debut_AG = 0 & changop_AG <> 0, prvaxec_AG = axeC_AG


        #"Voir cont_axe_c_AG=", *cont_axe_c_AG, e$

         axeC_AG = cont_axe_c_AG + axeC_AG       # cumul du compteur avec c   

         dif_axe_c = axeC_AG - prvaxec_AG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)

         if absdif > 180,  pcont_AG         # ajout + - 360
         dif_axe_c2 = axeC_AG - prvaxec_AG
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_AG


        if axeC_AG > maxi_c_AG & debut_AG <> 0, pderoul_AG
        if axeC_AG < mini_c_AG & debut_AG <> 0, penroul_AG

        if debut_AG = 0,
                [
                if axeC_AG >= (360+mini_c_AG) & changop_AG <> 0, pdebut_AG
                if axeC_AG <= (maxi_c_AG - 360) & changop_AG <> 0, pdebut_AG
                #if debut = 0, n, pgcode_force_AG, *axeC_AG, *axeA_AG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
                gcode$ = 0
                pnumligne, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
                if mr2print_AG <>   -1,
                            [
                             #"voir operation_AG", *operation_AG,e
                            if operation_AG = 1 , pnumligne , pgcode_force_AG, mr2print_AG,e$
                            if changop_AG = 1, pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG,*axeC_AG, *axeA_AG, e$, pnumligne, *zprint_AG,e$
                            else, pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,*axeC_AG, *axeA_AG,e$
                            ]
                 else,
                            [
                            pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG,*zprint_AG, *axeC_AG, *axeA_AG,e$
                            ]

                pasmi7 = 0
                pasn = 0
                vale53 = 0
                ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_AG = 1
        if deltaXYZ < mr5$ , fr5axe_AG = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53_AG,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_AG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_AG
          old_x_AG = xcal
          old_y_AG = ycal
          old_z_AG = zcal
         xprint_AG = xcor + xprint_AG
         yprint_AG = ycor + yprint_AG
         zprint_AG = zcor + zprint_AG
         if (xnci$ = 0) & (ynci$ = 0) & (znci$ = 0) & (u$ = 0) & (v$ = 0) & (w$ = 0), psortie11_AG
         if axeA_AG > maxi_a_AG | axeA_AG < mini_a_AG, psortie10_AG
         if gcode$ = 1 ,
                [
                if tete_rev_AG = 1,
                    [
                    gfr_AG = 1
                    pnumligne,sgfr_AG, pgcode_AG, xprint_AG, yprint_AG, zprint_AG, *axeC_AG, axeA_AG ,pfr_AG, e$
                    ]
                else,
                    [
                    pnumligne, sgfr_AG, *fr5axe_AG, pgcode_AG, xprint_AG, yprint_AG, zprint_AG, *axeC_AG, axeA_AG, pg9_5x_AG, e$
                    ]
                 ]
        else, pnumligne, pgcode_AG, xprint_AG, yprint_AG, zprint_AG, axeC_AG, axeA_AG,e$

        debut_AG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_AG = Vx_AG
           old_vy_AG = Vy_AG
           old_vz_AG = Vz_AG
       old_longvec = longvec
       prvaxec_AG = axeC_AG
       prvaxea = axeA_AG
       operation_AG = 11
       old_x_5x_AG = x$
       old_y_5x_AG = y$
       old_z_5x_AG = z$

pmx_BG        # 5 axes

            pprint_BG
            @xprint_BG, @yprint_BG,@zprint_BG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_BM
                pmx_BM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_BG = 0
            if invers_BG = 0, pmxinvd_BG
            if invers_BG = 1, pmxinvg_BG
         #"voir dans pmx",*axeC_BG,e 

             if debut_BG = 1, pmxsens_BG
         !maxi_c_BG, !mini_c_BG


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_BG
           Dy = ycal - old_y_BG
           Dz = zcal - old_z_BG

           #"voir x,y,z,old_x_BG,old_y_BG,old_z_BG",*x,*y,*z,*old_x_BG,*old_y_BG,*old_z_BG,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_BG
         if fr$ > 0, frbase_BG = fr$

         if deltaXYZ < mr5$ & debut_BG = 1, pchange_BM, pmx_BM   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe_BG = fr$ / deltaXYZ
        ]




            if debut_BG = 0 & changop_BG <> 0, cont_axe_c_BG = 0
            if debut_BG = 0 & changop_BG <> 0, prvaxec_BG = axeC_BG



         axeC_BG = cont_axe_c_BG + axeC_BG       # cumul du compteur avec c   

         dif_axe_c = axeC_BG - prvaxec_BG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_BG         # ajout + - 360
         dif_axe_c2 = axeC_BG - prvaxec_BG
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_BG


        if axeC_BG > maxi_c_BG & debut_BG <> 0, pderoul_BG
        if axeC_BG < mini_c_BG & debut_BG <> 0, penroul_BG
        if debut_BG = 0,
        [

        if axeC_BG >= (360+mini_c_BG) & changop_BG <> 0, pdebut_BG

        if axeC_BG <= (maxi_c_BG - 360) & changop_BG <> 0, pdebut_BG

        #if debut = 0, n, pgcode_force_BG, *axeC_BG, *axeA_BG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$
             if mr2print_BG <>   -1,
            [
            #"voir operation_BG", *operation_BG,e
            if operation_BG = 1 , pnumligne , pgcode_force_BG, mr2print_BG,e$
            if changop_BG = 1, pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG,*axeC_BG, *axeA_BG,e$, pnumligne, *zprint_BG,e$
            else, pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,*axeC_BG, *axeA_BG,e$
                ]
             else,
            [
            pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG,*zprint_BG, *axeC_BG, *axeA_BG,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_BG = 1
        if deltaXYZ < mr5$ , fr5axe_BG = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_BG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_BG
          old_x_BG = xcal
          old_y_BG = ycal
          old_z_BG = zcal
         xprint_BG = xcor + xprint_BG
         yprint_BG = ycor + yprint_BG
         zprint_BG = zcor + zprint_BG
        if axeA_BG > maxi_a_BG | axeA_BG < mini_a_BG, psortie10_BG # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_BG
         if gcode$ = 1 ,
                [
                if tete_rev_BG = 1,
                    [
                    gfr_BG = 1
                    pnumligne, sgfr_BG, pgcode_BG, xprint_BG, yprint_BG, zprint_BG, *axeC_BG, axeA_BG ,pfr_BG, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_BG, sgfr_BG, *fr5axe_BG, xprint_BG, yprint_BG, zprint_BG, *axeC_BG, axeA_BG, pg9_5x_BG, e$
                    ]
                 ]
        else, pnumligne, pgcode_BG, xprint_BG, yprint_BG, zprint_BG, axeC_BG, axeA_BG,e$
        debut_BG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_BG = Vx_BG
           old_vy_BG = Vy_BG
           old_vz_BG = Vz_BG
       old_longvec = longvec
       prvaxec_BG = axeC_BG
       prvaxea = axeA_BG
       operation_BG = 11
       old_x_5x_BG = x$
       old_y_5x_BG = y$
       old_z_5x_BG = z$

pmx_CG        # 5 axes

            pprint_CG
            @xprint_CG, @yprint_CG,@zprint_CG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_CM
                pmx_CM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_CG = 0
            if invers_CG = 0, pmxinvd_CG
            if invers_CG = 1, pmxinvg_CG
         #"voir dans pmx",*axeC_CG,e 

             if debut_CG = 1, pmxsens_CG
            !maxi_c_CG, !mini_c_CG


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_CG
           Dy = ycal - old_y_CG
           Dz = zcal - old_z_CG

           #"voir x,y,z,old_x_CG,old_y_CG,old_z_CG",*x,*y,*z,*old_x_CG,*old_y_CG,*old_z_CG,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_CG
         if fr$ > 0, frbase_CG = fr$

         if deltaXYZ < mr5$ & debut_CG = 1, pchange_CM, pmx_CM   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0, [
                                    fr5axe_CG = fr$ / deltaXYZ
                                    if gfr_CG = 1, fr5axe_CG = fr5axe_CG/POURCENTAGE_AVANCE_CG
                                    else, fr5axe_CG = fr5axe_CG*POURCENTAGE_AVANCE_CG
                                    ]
        ]




            if debut_CG = 0 & changop_CG <> 0, cont_axe_c_CG = 0
            if debut_CG = 0 & changop_CG <> 0, prvaxec_CG = axeC_CG



         axeC_CG = cont_axe_c_CG + axeC_CG       # cumul du compteur avec c   

         dif_axe_c = axeC_CG - prvaxec_CG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_CG         # ajout + - 360
         dif_axe_c2 = axeC_CG - prvaxec_CG
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_CG


        if axeC_CG > maxi_c_CG & debut_CG <> 0, pderoul_CG
        if axeC_CG < mini_c_CG & debut_CG <> 0, penroul_CG
        if debut_CG = 0,
        [

        if axeC_CG >= (360+mini_c_CG) & changop_CG <> 0, pdebut_CG

        if axeC_CG <= (maxi_c_CG - 360) & changop_CG <> 0, pdebut_CG

        #if debut = 0, n, pgcode_force_CG, *axeC_CG, *axeA_CG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CG = axeApos_CG
                                axeCpos_cycle800_CG = axeCpos_CG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$
             if mr2print_CG <>   -1,
            [
            #"voir operation_CG", *operation_CG,e
            if operation_CG = 1 , pnumligne , pgcode_force_CG, mr2print_CG,e$
            if changop_CG = 1,  [
                                if garage_CG <> 0 & change_outil_CG = 0, pnumligne, pgcode_force_CG, *axeC_CG, e$
                                pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG,*axeC_CG, *axeA_CG,e$
                                pnumligne, *zprint_CG,e$
                                change_outil_CG = 0
                                ]
            else, pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,*axeC_CG, *axeA_CG,e$
                ]
             else,
            [
            pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG,*zprint_CG, *axeC_CG, *axeA_CG,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_CG = 1
        if deltaXYZ < mr5$ ,    [
                                fr5axe_CG = fr$
                                if gfr_CG = 1, fr5axe_CG = fr5axe_CG/POURCENTAGE_AVANCE_CG
                                else, fr5axe_CG = fr5axe_CG*POURCENTAGE_AVANCE_CG
                                ]
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_CG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_CG
          old_x_CG = xcal
          old_y_CG = ycal
          old_z_CG = zcal
         xprint_CG = xcor + xprint_CG
         yprint_CG = ycor + yprint_CG
         zprint_CG = zcor + zprint_CG
        if axeA_CG > maxi_a_CG | axeA_CG < mini_a_CG, psortie10_CG # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_CG
         if gcode$ = 1 ,
                [
                if tete_rev_CG = 1,
                    [
                    gfr_CG = 1
                    pnumligne, sgfr_CG, pgcode_CG, xprint_CG, yprint_CG, zprint_CG, *axeC_CG, axeA_CG ,pfr_CG, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_CG, sgfr_CG, *fr5axe_CG, xprint_CG, yprint_CG, zprint_CG, *axeC_CG, axeA_CG, pg9_5x_CG, e$
                    ]
                 ]
        else, pnumligne, pgcode_CG, xprint_CG, yprint_CG, zprint_CG, axeC_CG, axeA_CG,e$
        debut_CG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_CG = Vx_CG
           old_vy_CG = Vy_CG
           old_vz_CG = Vz_CG
       old_longvec = longvec
       prvaxec_CG = axeC_CG
       prvaxea = axeA_CG
       operation_CG = 11
       old_x_5x_CG = x$
       old_y_5x_CG = y$
       old_z_5x_CG = z$

pmx_DG        # 5 axes

            pprint_DG
            @xprint_DG, @yprint_DG,@zprint_DG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_DM
                pmx_DM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_DG = 0
            if invers_DG = 0, pmxinvd_DG
            if invers_DG = 1, pmxinvg_DG
         #"voir dans pmx",*axeC_DG,e 

             if debut_DG = 1, pmxsens_DG
            !maxi_c_DG, !mini_c_DG


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_DG
           Dy = ycal - old_y_DG
           Dz = zcal - old_z_DG

           #"voir x,y,z,old_x_DG,old_y_DG,old_z_DG",*x,*y,*z,*old_x_DG,*old_y_DG,*old_z_DG,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_DG
         if fr$ > 0, frbase_DG = fr$

         if deltaXYZ < mr5$ & debut_DG = 1, pchange_DM, pmx_DM   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0, [
                                    fr5axe_DG = fr$ / deltaXYZ
                                    if gfr_DG = 1, fr5axe_DG = fr5axe_DG/POURCENTAGE_AVANCE_DG
                                    else, fr5axe_DG = fr5axe_DG*POURCENTAGE_AVANCE_DG
                                    ]
        ]




            if debut_DG = 0 & changop_DG <> 0, cont_axe_c_DG = 0
            if debut_DG = 0 & changop_DG <> 0, prvaxec_DG = axeC_DG



         axeC_DG = cont_axe_c_DG + axeC_DG       # cumul du compteur avec c   

         dif_axe_c = axeC_DG - prvaxec_DG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_DG         # ajout + - 360
         dif_axe_c2 = axeC_DG - prvaxec_DG
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_DG


        if axeC_DG > maxi_c_DG & debut_DG <> 0, pderoul_DG
        if axeC_DG < mini_c_DG & debut_DG <> 0, penroul_DG
        if debut_DG = 0,
        [

        if axeC_DG >= (360+mini_c_DG) & changop_DG <> 0, pdebut_DG

        if axeC_DG <= (maxi_c_DG - 360) & changop_DG <> 0, pdebut_DG

        #if debut = 0, n, pgcode_force_DG, *axeC_DG, *axeA_DG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DG = axeApos_DG
                                axeCpos_cycle800_DG = axeCpos_DG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$
             if mr2print_DG <>   -1,
            [
            #"voir operation_DG", *operation_DG,e
            if operation_DG = 1 , pnumligne , pgcode_force_DG, mr2print_DG,e$
            if changop_DG = 1,  [
                                if garage_DG <> 0 & change_outil_DG = 0, pnumligne, pgcode_force_DG, *axeC_DG, e$
                                pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG,*axeC_DG, *axeA_DG,e$
                                pnumligne, *zprint_DG,e$
                                change_outil_DG = 0
                                ]

            else, pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zprint_DG,*axeC_DG, *axeA_DG,e$
                ]
             else,
            [
            pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG,*zprint_DG, *axeC_DG, *axeA_DG,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_DG = 1
        if deltaXYZ < mr5$ ,    [
                                fr5axe_DG = fr$
                                if gfr_DG = 1, fr5axe_DG = fr5axe_DG/POURCENTAGE_AVANCE_DG
                                else, fr5axe_DG = fr5axe_DG*POURCENTAGE_AVANCE_DG
                                ]
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_DG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_DG
          old_x_DG = xcal
          old_y_DG = ycal
          old_z_DG = zcal
         xprint_DG = xcor + xprint_DG
         yprint_DG = ycor + yprint_DG
         zprint_DG = zcor + zprint_DG
        if axeA_DG > maxi_a_DG | axeA_DG < mini_a_DG, psortie10_DG # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_DG
         if gcode$ = 1 ,
                [
                if tete_rev_DG = 1,
                    [
                    gfr_DG = 1
                    pnumligne, sgfr_DG, pgcode_DG, xprint_DG, yprint_DG, zprint_DG, *axeC_DG, axeA_DG ,pfr_DG, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_DG, sgfr_DG, *fr5axe_DG, xprint_DG, yprint_DG, zprint_DG, *axeC_DG, axeA_DG, pg9_5x_DG, e$
                    ]
                 ]
        else, pnumligne, pgcode_DG, xprint_DG, yprint_DG, zprint_DG, axeC_DG, axeA_DG,e$
        debut_DG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_DG = Vx_DG
           old_vy_DG = Vy_DG
           old_vz_DG = Vz_DG
       old_longvec = longvec
       prvaxec_DG = axeC_DG
       prvaxea = axeA_DG
       operation_DG = 11
       old_x_5x_DG = x$
       old_y_5x_DG = y$
       old_z_5x_DG = z$

pmx_AM        # 5 axes

            pprint_AM
            @xprint_AM, @yprint_AM,@zprint_AM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                pchange_BG
                pmx_BG
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_AM = 0

            if invers_AM = 0, pmxinvd_AM
            if invers_AM = 1, pmxinvg_AM

             if debut_AM = 1, pmxsens_AM
             !maxi_c_AM, !mini_c_AM

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_AM
           Dy = ycal - old_y_AM
           Dz = zcal - old_z_AM
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)

            if fr$ =   -1,fr$= frbase_AM
            if fr$ > 0, frbase_AM = fr$

            if deltaXYZ < mr5$ & debut_AM = 1, pchange_BG, pmx_BG   # modif du 30/10/02
            else,
                [
                if fr$ > 0 & deltaXYZ <> 0,	[
											fr5axe_AM = fr$ / deltaXYZ
											av_plonge_5x_AM = av_plonge / deltaXYZ
											av_travail_5x_AM = av_travail / deltaXYZ
											if gfr_AM = 1,	[
															if fr5axe_AM = av_plonge_5x_AM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_AM)
															if fr5axe_AM = av_travail_5x_AM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_AM)
															]
                							else,	[
													if fr5axe_AM = av_plonge_5x_AM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_AM)
													if fr5axe_AM = av_travail_5x_AM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_AM)
													]
											]
				]

            if debut_AM = 0 & changop_AM <> 0, cont_axe_c_AM = 0
            if debut_AM = 0 & changop_AM <> 0, prvaxec_AM = axeC_AM


        #"Voir cont_axe_c_AM=", *cont_axe_c_AM, e$

         axeC_AM = cont_axe_c_AM + axeC_AM       # cumul du compteur avec c   

         dif_axe_c = axeC_AM - prvaxec_AM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)

         if absdif > 180,  pcont_AM         # ajout + - 360
         dif_axe_c2 = axeC_AM - prvaxec_AM
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_AM


        if axeC_AM > maxi_c_AM & debut_AM <> 0, pderoul_AM
        if axeC_AM < mini_c_AM & debut_AM <> 0, penroul_AM

        if debut_AM = 0,
                [
                if axeC_AM >= (360+mini_c_AM) & changop_AM <> 0, pdebut_AM
                if axeC_AM <= (maxi_c_AM - 360) & changop_AM <> 0, pdebut_AM
                #if debut = 0, n, pgcode_force_AM, *axeC_AM, *axeA_AM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
                gcode$ = 0
                pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
                if mr2print_AM <>   -1,
                            [
                             #"voir operation_AM", *operation_AM,e
                            if operation_AM = 1 , pnumligne , pgcode_force_AM, mr2print_AM,e$
                            if changop_AM = 1, pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM,*axeC_AM, *axeA_AM, e$, pnumligne, *zprint_AM,e$
                            else, pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,*axeC_AM, *axeA_AM,e$
                            ]
                 else,
                            [
                            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM,*zprint_AM, *axeC_AM, *axeA_AM,e$
                            ]

                pasmi7 = 0
                pasn = 0
                vale53 = 0
                ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_AM = 1
        if deltaXYZ < mr5$ ,	[
								fr5axe_AM = fr$
								av_plonge_5x_AM = av_plonge
								av_travail_5x_AM = av_travail
								if gfr_AM = 1,	[
												if fr5axe_AM = av_plonge_5x_AM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_AM)
												if fr5axe_AM = av_travail_5x_AM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_AM)
												]
                							else,	[
													if fr5axe_AM = av_plonge_5x_AM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_AM)
													if fr5axe_AM = av_travail_5x_AM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_AM)
													]
								]				
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53_AM,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_AM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_AM
          old_x_AM = xcal
          old_y_AM = ycal
          old_z_AM = zcal
         xprint_AM = xcor + xprint_AM
         yprint_AM = ycor + yprint_AM
         zprint_AM = zcor + zprint_AM
         if (xnci$ = 0) & (ynci$ = 0) & (znci$ = 0) & (u$ = 0) & (v$ = 0) & (w$ = 0), psortie11_AM
         if axeA_AM > maxi_a_AM | axeA_AM < mini_a_AM, psortie10_AM
         if gcode$ = 1 ,
                [
                if tete_rev_AM = 1,
                    [
                    gfr_AM = 1
					result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_AM)
                    pnumligne,sgfr_AM, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, *axeC_AM, axeA_AM ,pfr_AM, e$
                    ]
                else,
                    [
                    pnumligne, sgfr_AM, *fr5axe_AM, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, *axeC_AM, axeA_AM, pg9_5x_AM, e$
                    ]
                 ]
        else, pnumligne, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, axeC_AM, axeA_AM,e$

        debut_AM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_AM = Vx_AM
           old_vy_AM = Vy_AM
           old_vz_AM = Vz_AM
       old_longvec = longvec
       prvaxec_AM = axeC_AM
       prvaxea = axeA_AM
       operation_AM = 11
       old_x_5x_AM = x$
       old_y_5x_AM = y$
       old_z_5x_AM = z$

pmx_BM        # 5 axes

            pprint_BM
            @xprint_BM, @yprint_BM,@zprint_BM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_CG
                pmx_CG
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_BM = 0
            if invers_BM = 0, pmxinvd_BM
            if invers_BM = 1, pmxinvg_BM
         #"voir dans pmx",*axeC_BM,e 

             if debut_BM = 1, pmxsens_BM
         !maxi_c_BM, !mini_c_BM


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_BM
           Dy = ycal - old_y_BM
           Dz = zcal - old_z_BM

           #"voir x,y,z,old_x_BM,old_y_BM,old_z_BM",*x,*y,*z,*old_x_BM,*old_y_BM,*old_z_BM,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_BM
         if fr$ > 0, frbase_BM = fr$

         if deltaXYZ < mr5$ & debut_BM = 1, pchange_CG, pmx_CG   # modif du 30/10/02
         else,
        [
                if fr$ > 0 & deltaXYZ <> 0,	[
											fr5axe_BM = fr$ / deltaXYZ
											av_plonge_5x_BM = av_plonge / deltaXYZ
											av_travail_5x_BM = av_travail / deltaXYZ
											if gfr_BM = 1,	[
															if fr5axe_BM = av_plonge_5x_BM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_BM)
															if fr5axe_BM = av_travail_5x_BM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_BM)
															]
                							else,	[
													if fr5axe_BM = av_plonge_5x_BM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_BM)
													if fr5axe_BM = av_travail_5x_BM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_BM)
													]
											]
        ]




            if debut_BM = 0 & changop_BM <> 0, cont_axe_c_BM = 0
            if debut_BM = 0 & changop_BM <> 0, prvaxec_BM = axeC_BM



         axeC_BM = cont_axe_c_BM + axeC_BM       # cumul du compteur avec c   

         dif_axe_c = axeC_BM - prvaxec_BM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_BM         # ajout + - 360
         dif_axe_c2 = axeC_BM - prvaxec_BM
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_BM


        if axeC_BM > maxi_c_BM & debut_BM <> 0, pderoul_BM
        if axeC_BM < mini_c_BM & debut_BM <> 0, penroul_BM
        if debut_BM = 0,
        [

        if axeC_BM >= (360+mini_c_BM) & changop_BM <> 0, pdebut_BM

        if axeC_BM <= (maxi_c_BM - 360) & changop_BM <> 0, pdebut_BM

        #if debut = 0, n, pgcode_force_BM, *axeC_BM, *axeA_BM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
             if mr2print_BM <>   -1,
            [
            #"voir operation_BM", *operation_BM,e
            if operation_BM = 1 , pnumligne , pgcode_force_BM, mr2print_BM,e$
            if changop_BM = 1, pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM,*axeC_BM, *axeA_BM,e$, pnumligne, *zprint_BM,e$
            else, pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,*axeC_BM, *axeA_BM,e$
                ]
             else,
            [
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM,*zprint_BM, *axeC_BM, *axeA_BM,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_BM = 1
        if deltaXYZ < mr5$ ,	[
								fr5axe_BM = fr$
								av_plonge_5x_BM = av_plonge
								av_travail_5x_BM = av_travail
								if gfr_BM = 1,	[
												if fr5axe_BM = av_plonge_5x_BM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_BM)
												if fr5axe_BM = av_travail_5x_BM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_BM)
												]
                							else,	[
													if fr5axe_BM = av_plonge_5x_BM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_BM)
													if fr5axe_BM = av_travail_5x_BM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_BM)
													]
								]	
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_BM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_BM
          old_x_BM = xcal
          old_y_BM = ycal
          old_z_BM = zcal
         xprint_BM = xcor + xprint_BM
         yprint_BM = ycor + yprint_BM
         zprint_BM = zcor + zprint_BM
        if axeA_BM > maxi_a_BM | axeA_BM < mini_a_BM, psortie10_BM # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_BM
         if gcode$ = 1 ,
                [
                if tete_rev_BM = 1,
                    [
                    gfr_BM = 1
					result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_BM)
                    pnumligne, sgfr_BM, pgcode_BM, xprint_BM, yprint_BM, zprint_BM, *axeC_BM, axeA_BM ,pfr_BM, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_BM, sgfr_BM, *fr5axe_BM, xprint_BM, yprint_BM, zprint_BM, *axeC_BM, axeA_BM, pg9_5x_BM, e$
                    ]
                 ]
        else, pnumligne, pgcode_BM, xprint_BM, yprint_BM, zprint_BM, axeC_BM, axeA_BM,e$
        debut_BM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_BM = Vx_BM
           old_vy_BM = Vy_BM
           old_vz_BM = Vz_BM
       old_longvec = longvec
       prvaxec_BM = axeC_BM
       prvaxea = axeA_BM
       operation_BM = 11
       old_x_5x_BM = x$
       old_y_5x_BM = y$
       old_z_5x_BM = z$

pmx_CM        # 5 axes

            pprint_CM
            @xprint_CM, @yprint_CM,@zprint_CM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_DG
                pmx_DG
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_CM = 0
            if invers_CM = 0, pmxinvd_CM
            if invers_CM = 1, pmxinvg_CM
         #"voir dans pmx",*axeC_CM,e 

             if debut_CM = 1, pmxsens_CM
         !maxi_c_CM, !mini_c_CM


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_CM
           Dy = ycal - old_y_CM
           Dz = zcal - old_z_CM

           #"voir x,y,z,old_x_CM,old_y_CM,old_z_CM",*x,*y,*z,*old_x_CM,*old_y_CM,*old_z_CM,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_CM
         if fr$ > 0, frbase_CM = fr$

         if deltaXYZ < mr5$ & debut_CM = 1, pchange_DG, pmx_DG   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,	[
									fr5axe_CM = fr$ / deltaXYZ
									av_plonge_5x_CM = av_plonge / deltaXYZ
									av_travail_5x_CM = av_travail / deltaXYZ
									if gfr_CM = 1,	[
													fr5axe_CM = fr5axe_CM/POURCENTAGE_AVANCE_CM
													av_plonge_5x_CM = av_plonge_5x_CM/POURCENTAGE_AVANCE_CM
													av_travail_5x_CM = av_travail_5x_CM/POURCENTAGE_AVANCE_CM
													if fr5axe_CM = av_plonge_5x_CM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_CM)
													if fr5axe_CM = av_travail_5x_CM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_CM)
													]
                					else,	[
											fr5axe_CM = fr5axe_CM*POURCENTAGE_AVANCE_CM
											av_plonge_5x_CM = av_plonge_5x_CM*POURCENTAGE_AVANCE_CM
											av_travail_5x_CM = av_travail_5x_CM*POURCENTAGE_AVANCE_CM
											if fr5axe_CM = av_plonge_5x_CM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_CM)
											if fr5axe_CM = av_travail_5x_CM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_CM)
											]
									]														
        ]

            if debut_CM = 0 & changop_CM <> 0, cont_axe_c_CM = 0
            if debut_CM = 0 & changop_CM <> 0, prvaxec_CM = axeC_CM



         axeC_CM = cont_axe_c_CM + axeC_CM       # cumul du compteur avec c   

         dif_axe_c = axeC_CM - prvaxec_CM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_CM         # ajout + - 360
         dif_axe_c2 = axeC_CM - prvaxec_CM
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_CM


        if axeC_CM > maxi_c_CM & debut_CM <> 0, pderoul_CM
        if axeC_CM < mini_c_CM & debut_CM <> 0, penroul_CM
        if debut_CM = 0,
        [

        if axeC_CM >= (360+mini_c_CM) & changop_CM <> 0, pdebut_CM

        if axeC_CM <= (maxi_c_CM - 360) & changop_CM <> 0, pdebut_CM

        #if debut = 0, n, pgcode_force_CM, *axeC_CM, *axeA_CM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_CM = axeApos_CM
                                axeCpos_cycle800_CM = axeCpos_CM
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
             if mr2print_CM <>   -1,
            [
            #"voir operation_CM", *operation_CM,e
            if operation_CM = 1 , pnumligne , pgcode_force_CM, mr2print_CM,e$
            if changop_CM = 1, pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM,*axeC_CM, *axeA_CM,e$, pnumligne, *zprint_CM,e$
            else, pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,*axeC_CM, *axeA_CM,e$
                ]
             else,
            [
            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM,*zprint_CM, *axeC_CM, *axeA_CM,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_CM = 1
        if deltaXYZ < mr5$ ,    [
                                fr5axe_CM = fr$
								av_plonge_5x_CM = av_plonge
								av_travail_5x_CM = av_travail
								if gfr_CM = 1,	[
												fr5axe_CM = fr5axe_CM/POURCENTAGE_AVANCE_CM
												av_plonge_5x_CM = av_plonge_5x_CM/POURCENTAGE_AVANCE_CM
												av_travail_5x_CM = av_travail_5x_CM/POURCENTAGE_AVANCE_CM
												if fr5axe_CM = av_plonge_5x_CM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_CM)
												if fr5axe_CM = av_travail_5x_CM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_CM)
												]
                				else,	[
										fr5axe_CM = fr5axe_CM*POURCENTAGE_AVANCE_CM
										av_plonge_5x_CM = av_plonge_5x_CM*POURCENTAGE_AVANCE_CM
										av_travail_5x_CM = av_travail_5x_CM*POURCENTAGE_AVANCE_CM
										if fr5axe_CM = av_plonge_5x_CM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_CM)
										if fr5axe_CM = av_travail_5x_CM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_CM)
										]
								]								
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_CM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_CM
          old_x_CM = xcal
          old_y_CM = ycal
          old_z_CM = zcal
         xprint_CM = xcor + xprint_CM
         yprint_CM = ycor + yprint_CM
         zprint_CM = zcor + zprint_CM
        if axeA_CM > maxi_a_CM | axeA_CM < mini_a_CM, psortie10_CM # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_CM
         if gcode$ = 1 ,
                [
                if tete_rev_CM = 1,
                    [
                    gfr_CM = 1
					result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_CM)
                    pnumligne, sgfr_CM, pgcode_CM, xprint_CM, yprint_CM, zprint_CM, *axeC_CM, axeA_CM ,pfr_CM, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_CM, sgfr_CM, *fr5axe_CM, xprint_CM, yprint_CM, zprint_CM, *axeC_CM, axeA_CM, pg9_5x_CM, e$
                    ]
                 ]
        else, pnumligne, pgcode_CM, xprint_CM, yprint_CM, zprint_CM, axeC_CM, axeA_CM,e$
        debut_CM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_CM = Vx_CM
           old_vy_CM = Vy_CM
           old_vz_CM = Vz_CM
       old_longvec = longvec
       prvaxec_CM = axeC_CM
       prvaxea = axeA_CM
       operation_CM = 11
       old_x_5x_CM = x$
       old_y_5x_CM = y$
       old_z_5x_CM = z$


pmx_DM        # 5 axes

            pprint_DM
            @xprint_DM, @yprint_DM,@zprint_DM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                  ex$
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_DM = 0
            if invers_DM = 0, pmxinvd_DM
            if invers_DM = 1, pmxinvg_DM
         #"voir dans pmx",*axeC_DM,e 

             if debut_DM = 1, pmxsens_DM
         !maxi_c_DM, !mini_c_DM


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_DM
           Dy = ycal - old_y_DM
           Dz = zcal - old_z_DM

           #"voir x,y,z,old_x_DM,old_y_DM,old_z_DM",*x,*y,*z,*old_x_DM,*old_y_DM,*old_z_DM,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_DM
         if fr$ > 0, frbase_DM = fr$

         if deltaXYZ < mr5$ & debut_DM = 1, ex$   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,	[
									fr5axe_DM = fr$ / deltaXYZ
									av_plonge_5x_DM = av_plonge / deltaXYZ
									av_travail_5x_DM = av_travail / deltaXYZ
									if gfr_DM = 1,	[
													fr5axe_DM = fr5axe_DM/POURCENTAGE_AVANCE_DM
													av_plonge_5x_DM = av_plonge_5x_DM/POURCENTAGE_AVANCE_DM
													av_travail_5x_DM = av_travail_5x_DM/POURCENTAGE_AVANCE_DM
													if fr5axe_DM = av_plonge_5x_DM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_DM)
													if fr5axe_DM = av_travail_5x_DM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_DM)
													]
                					else,	[
											fr5axe_DM = fr5axe_DM*POURCENTAGE_AVANCE_DM
											av_plonge_5x_DM = av_plonge_5x_DM*POURCENTAGE_AVANCE_DM
											av_travail_5x_DM = av_travail_5x_DM*POURCENTAGE_AVANCE_DM
											if fr5axe_DM = av_plonge_5x_DM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_DM)
											if fr5axe_DM = av_travail_5x_DM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_DM)
											]
									]		
        ]




            if debut_DM = 0 & changop_DM <> 0, cont_axe_c_DM = 0
            if debut_DM = 0 & changop_DM <> 0, prvaxec_DM = axeC_DM



         axeC_DM = cont_axe_c_DM + axeC_DM       # cumul du compteur avec c   

         dif_axe_c = axeC_DM - prvaxec_DM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_DM         # ajout + - 360
         dif_axe_c2 = axeC_DM - prvaxec_DM
         absdif2 = abs(dif_axe_c2)
         if absdif2 > delta_rot_C, psortie_axeC_5X_DM


        if axeC_DM > maxi_c_DM & debut_DM <> 0, pderoul_DM
        if axeC_DM < mini_c_DM & debut_DM <> 0, penroul_DM
        if debut_DM = 0,
        [

        if axeC_DM >= (360+mini_c_DM) & changop_DM <> 0, pdebut_DM

        if axeC_DM <= (maxi_c_DM - 360) & changop_DM <> 0, pdebut_DM

        #if debut = 0, n, pgcode_force_DM, *axeC_DM, *axeA_DM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             if cycle_800 = 1,  [
                                spaces$ = 0
                                axeApos_cycle800_DM = axeApos_DM
                                axeCpos_cycle800_DM = axeCpos_DM
                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
            else, pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$
             if mr2print_DM <>   -1,
            [
            #"voir operation_DM", *operation_DM,e
            if operation_DM = 1 , pnumligne , pgcode_force_DM, mr2print_DM,e$
            if changop_DM = 1, pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM,*axeC_DM, *axeA_DM,e$, pnumligne, *zprint_DM,e$
            else, pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zprint_DM,*axeC_DM, *axeA_DM,e$
                ]
             else,
            [
            pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM,*zprint_DM, *axeC_DM, *axeA_DM,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_DM = 1
        if deltaXYZ < mr5$ ,    [
                                fr5axe_DM = fr$
								av_plonge_5x_DM = av_plonge
								av_travail_5x_DM = av_travail
								if gfr_DM = 1,	[
												fr5axe_DM = fr5axe_DM/POURCENTAGE_AVANCE_DM
												av_plonge_5x_DM = av_plonge_5x_DM/POURCENTAGE_AVANCE_DM
												av_travail_5x_DM = av_travail_5x_DM/POURCENTAGE_AVANCE_DM
												if fr5axe_DM = av_plonge_5x_DM, result = nwadrs(SAVANCE_PLONGEE_STANDARD, fr5axe_DM)
												if fr5axe_DM = av_travail_5x_DM, result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_DM)
												]
                				else,	[
										fr5axe_DM = fr5axe_DM*POURCENTAGE_AVANCE_DM
										av_plonge_5x_DM = av_plonge_5x_DM*POURCENTAGE_AVANCE_DM
										av_travail_5x_DM = av_travail_5x_DM*POURCENTAGE_AVANCE_DM
										if fr5axe_DM = av_plonge_5x_DM, result = nwadrs(SAVANCE_PLONGEE_INVERSE, fr5axe_DM)
										if fr5axe_DM = av_travail_5x_DM, result = nwadrs(SAVANCE_TRAVAIL_INVERSE, fr5axe_DM)
										]
								]
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_DM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_DM
          old_x_DM = xcal
          old_y_DM = ycal
          old_z_DM = zcal
         xprint_DM = xcor + xprint_DM
         yprint_DM = ycor + yprint_DM
         zprint_DM = zcor + zprint_DM
        if axeA_DM > maxi_a_DM | axeA_DM < mini_a_DM, psortie10_DM # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_DM
         if gcode$ = 1 ,
                [
                if tete_rev_DM = 1,
                    [
                    gfr_DM = 1
					result = nwadrs(SAVANCE_TRAVAIL_STANDARD, fr5axe_DM)
                    pnumligne, sgfr_DM, pgcode_DM, xprint_DM, yprint_DM, zprint_DM, *axeC_DM, axeA_DM ,pfr_DM, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_DM, sgfr_DM, *fr5axe_DM, xprint_DM, yprint_DM, zprint_DM, *axeC_DM, axeA_DM, pg9_5x_DM, e$
                    ]
                 ]
        else, pnumligne, pgcode_DM, xprint_DM, yprint_DM, zprint_DM, axeC_DM, axeA_DM,e$
        debut_DM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_DM = Vx_DM
           old_vy_DM = Vy_DM
           old_vz_DM = Vz_DM
       old_longvec = longvec
       prvaxec_DM = axeC_DM
       prvaxea = axeA_DM
       operation_DM = 11
       old_x_5x_DM = x$
       old_y_5x_DM = y$
       old_z_5x_DM = z$
#endregion
#region pmx2
pmx2$
            pchange_AG
            pmx2_AG

            pchange_AM
            pmx2_AM

            pchange_BG
            pmx2_BG

            pchange_BM
            pmx2_BM

            pchange_CG
            pmx2_CG

            pchange_CM
            pmx2_CM

            pchange_DG
            pmx2_DG

            pchange_DM
            pmx2_DM

pmx2_AG     # 1 er mouv 5 axes

           if opcode$ = 16,  pchange_AM, pmx2_AM
       pmx$

pmx2_BG     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_BM, pmx2_BM
       pmx$

pmx2_CG     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_CM, pmx2_CM
       pmx$

pmx2_DG     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_DM, pmx2_DM
       pmx$

pmx2_AM     # 1 er mouv 5 axes

           if opcode$ = 16,  pchange_BG, pmx2_BG
       pmx$

pmx2_BM     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_CG, pmx2_CG
       pmx$

pmx2_CM     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_DG, pmx2_DG
       pmx$

pmx2_DM     # 1 er mouv 5 axes


           if opcode$ = 16,  ex$
       pmx$
#endregion
#endregion

#region   PERCAGES #OK
#region pdrl5

pdrl5_AG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_AG
        gcode$ = 0
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AG = 1
        if invers_AG = 0, pmxinvd_AG
        if invers_AG = 1, pmxinvg_AG
        pdebut_AG
        Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        axeCpos_AG = axeC_AG
        axeApos_AG = axeA_AG

        if mi1_C_base_AG <> 1 & mi1_C_base_AG <> 2, pessaicompteur_AG
        axeCpos1_AG = axeCpos_AG
        axeApos1_AG = axeApos_AG
       !axeApos1_AG,!axeCpos_AG
       if mr2print_AG = 0, mr2print_AG =zsecuprint
       prvmr2_AG = mr2print_AG

       if mr2print_AG <> -1,pnumligne,*mr2print_AG,e$

       gcode$ = 0
       tox4print_AG = (((Vx_AG/longvec) * (depth$ * -1)) + x$)
       toy4print_AG = (((Vy_AG/longvec) * (depth$ * -1)) + y$)
       toz4print_AG = (((Vz_AG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_AG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$

           if mr2print_AG =  -1,pnumligne,pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, axeCpos1_AG, axeApos1_AG,e$     #orientationtete 
           else, pnumligne, pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, axeCpos1_AG, axeApos1_AG,e$, pnumligne, *zrprintrap_AG,e$     #orientationtete
           #if mr2print_AG =  -1,pnumligne,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete 
           #else, pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, axeCpos1_AG, axeApos1_AG,e$, pnumligne, *zrprint_AG, e$     #orientationtete
           #pnumligne,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, e$     #orientationtete 

           pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, e$                         # dep au plan garde 
           gcode$ = 1
           pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,frplunge$, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG,e$            # retour plan de secu
            else, pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

        oldstation_AG = mi4_AG
        frbase_AG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_AG
       xprint_AG = 0
       yprint_AG = 0
       #zinitht_AG = dest_ret_5x_AG
       #*sav_x_pmx, *tox4print_AG, e$
       #*sav_y_pmx,  *toy4print_AG, e$
       #*sav_z_pmx, *toz4print_AG, e$
       zinitht_AG = sqrt((sav_x_pmx - tox4print_AG)^2 + (sav_y_pmx - toy4print_AG)^2 + (sav_z_pmx - toz4print_AG)^2)
       old_zinitht_AG = zinitht_AG

       @initht$
       @zinitht_AG
       zprint_AG = refht$
       pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
       if (x$ = u$) & (y$ = v$), [axeCpos1_AG = 0, axeApos1_AG = 0, axeCpos_AG = 0, axeApos_AG = 0]
       if axeApos1_AG > maxi_a_AG | axeApos1_AG < mini_a_AG, psortie10_AG
           if mr2print_AG =  -1,pnumligne,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete
           else, pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete
           pnumligne, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$


            pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG, *zinitht_AG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AG = toy4print_AG
           old_toz4_AG = toz4print_AG
           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG
         xprint_AG = 0
         yprint_AG = 0

        oldstation_AG = mi4_AG
        frbase_AG = fr$
       ]

pdrl5_BG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_BG
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_BG = 1
        if invers_BG = 0, pmxinvd_BG
        if invers_BG = 1, pmxinvg_BG
        pdebut_BG
        Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        axeCpos_BG = axeC_BG
        axeApos_BG = axeA_BG

        if mi1_C_base_BG <> 1 & mi1_C_base_BG <> 2, pessaicompteur_BG
        axeCpos1_BG = axeCpos_BG
        axeApos1_BG = axeApos_BG
       !axeApos1_BG,!axeCpos_BG
       if mr2print_BG = 0, mr2print_BG =zsecuprint
       prvmr2_BG = mr2print_BG

       if mr2print_BG <> -1,pnumligne,*mr2print_BG,e$

       gcode$ = 0

       tox4print_BG = (((Vx_BG/longvec) * (depth$ * -1)) + x$)
       toy4print_BG = (((Vy_BG/longvec) * (depth$ * -1)) + y$)
       toz4print_BG = (((Vz_BG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_BG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_BG

           if mr2print_BG =  -1,pnumligne,pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete 
           else, pnumligne, pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, axeCpos1_BG, axeApos1_BG,e$, pnumligne, *zrprintrap_BG, e$     #orientationtete
           #if mr2print_BG =  -1,pnumligne,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete 
           #else, pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, axeCpos1_BG, axeApos1_BG,e$, pnumligne, *zrprint_BG, e$     #orientationtete
           #pnumligne,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$     #orientationtete 

           pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
           gcode$ = 1
           pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,frplunge$ e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$            # retour plan de secu
            else, pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

        oldstation_BG = mi4_BG
        frbase_BG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_BG
       xprint_BG = 0
       yprint_BG = 0
       #zinitht_BG = dest_ret_5x_BG
       #*sav_x_pmx, *tox4print_BG, e$
       #*sav_y_pmx,  *toy4print_BG, e$
       #*sav_z_pmx, *toz4print_BG, e$
       zinitht_BG = sqrt((sav_x_pmx - tox4print_BG)^2 + (sav_y_pmx - toy4print_BG)^2 + (sav_z_pmx - toz4print_BG)^2)
       old_zinitht_BG = zinitht_BG

       @initht$
       @zinitht_BG
       zprint_BG = refht$
       panul_plan_inc_BG
            if (x$ = u$) & (y$ = v$), [axeCpos1_BG = 0, axeApos1_BG = 0, axeCpos_BG = 0, axeApos_BG = 0]
            if axeApos1_BG > maxi_a_BG | axeApos1_BG < mini_a_BG, psortie10_BG
           if mr2print_BG =  -1,pnumligne,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete
           else, pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete
           pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$


            pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG, *zinitht_BG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BG = toy4print_BG
           old_toz4_BG = toz4print_BG
           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG
         xprint_BG = 0
         yprint_BG = 0

        oldstation_BG = mi4_BG
        frbase_BG = fr$
       ]

pdrl5_CG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_CG
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_CG = 1
        if invers_CG = 0, pmxinvd_CG
        if invers_CG = 1, pmxinvg_CG
        pdebut_CG
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        axeCpos_CG = axeC_CG
        axeApos_CG = axeA_CG

        if mi1_C_base_CG <> 1 & mi1_C_base_CG <> 2, pessaicompteur_CG
        axeCpos1_CG = axeCpos_CG
        axeApos1_CG = axeApos_CG
        axeCpos_CG = axeCpos_CG + 90
       !axeApos1_CG,!axeCpos_CG
       if mr2print_CG = 0, mr2print_CG =zsecuprint
       prvmr2_CG = mr2print_CG

       if mr2print_CG <> -1,pnumligne,*mr2print_CG,e$

       gcode$ = 0

       tox4print_CG = (((Vx_CG/longvec) * (depth$ * -1)) + x$)
       toy4print_CG = (((Vy_CG/longvec) * (depth$ * -1)) + y$)
       toz4print_CG = (((Vz_CG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_CG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_CG
           if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
           if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
           if mr2print_CG =  -1,pnumligne,pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete 
           else, pnumligne, pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, axeCpos1_CG, axeApos1_CG,e$, pnumligne, *zrprintrap_CG, e$     #orientationtete
           #if mr2print_CG =  -1,pnumligne,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete 
           #else, pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, axeCpos1_CG, axeApos1_CG,e$, pnumligne, *zrprint_CG, e$     #orientationtete
           #pnumligne,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$     #orientationtete 

           pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
           gcode$ = 1

           if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
           else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

           pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,frplunge_CG, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$            # retour plan de secu
            else, pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

        oldstation_CG = mi4_CG
        frbase_CG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_CG
       xprint_CG = 0
       yprint_CG = 0
       #zinitht_CG = dest_ret_5x_CG
       #*sav_x_pmx, *tox4print_CG, e$
       #*sav_y_pmx,  *toy4print_CG, e$
       #*sav_z_pmx, *toz4print_CG, e$
       zinitht_CG = sqrt((sav_x_pmx - tox4print_CG)^2 + (sav_y_pmx - toy4print_CG)^2 + (sav_z_pmx - toz4print_CG)^2)
       old_zinitht_CG = zinitht_CG

       @initht$
       @zinitht_CG
       zprint_CG = refht$
       panul_plan_inc_CG
            if (x$ = u$) & (y$ = v$), [axeCpos1_CG = 0, axeApos1_CG = 0, axeCpos_CG = 0, axeApos_CG = 0]
            if axeApos1_CG > maxi_a_CG | axeApos1_CG < mini_a_CG, psortie10_CG
            if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
            if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
           if garage_CG <> 0 & change_outil_CG = 0, pnumligne,pgcode_force_CG, *axeCpos1_CG, e$
           change_outil_CG = 0
           if mr2print_CG =  -1,pnumligne,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete
           else, pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete

           if cycle_800 = 1,    [
                                spaces$ = 0
                                axeApos_cycle800_CG = axeApos_CG
                                axeCpos_cycle800_CG = axeCpos_CG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
           else, pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$

           pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1

            pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zinitht_CG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CG = toy4print_CG
           old_toz4_CG = toz4print_CG
           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG
         xprint_CG = 0
         yprint_CG = 0

        oldstation_CG = mi4_CG
        frbase_CG = fr$
       ]

pdrl5_DG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_DG
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_DG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_DG = 1
        if invers_DG = 0, pmxinvd_DG
        if invers_DG = 1, pmxinvg_DG
        pdebut_DG
        Vx_DG = u$ - x$
        Vy_DG = v$ - y$
        Vz_DG = w$ - z$
        axeCpos_DG = axeC_DG
        axeApos_DG = axeA_DG

        if mi1_C_base_DG <> 1 & mi1_C_base_DG <> 2, pessaicompteur_DG
        axeCpos1_DG = axeCpos_DG
        axeApos1_DG = axeApos_DG
        axeCpos_DG = axeCpos_DG + 90
       !axeApos1_DG,!axeCpos_DG
       if mr2print_DG = 0, mr2print_DG =zsecuprint
       prvmr2_DG = mr2print_DG

       if mr2print_DG <> -1,pnumligne,*mr2print_DG,e$

       gcode$ = 0

       tox4print_DG = (((Vx_DG/longvec) * (depth$ * -1)) + x$)
       toy4print_DG = (((Vy_DG/longvec) * (depth$ * -1)) + y$)
       toz4print_DG = (((Vz_DG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_DG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_DG
           if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
           if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
           if mr2print_DG =  -1,pnumligne,pgcode_force_DG, *xrprintrap_DG, *yrprintrap_DG, *zrprintrap_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete 
           else, pnumligne, pgcode_force_DG, *xrprintrap_DG, *yrprintrap_DG, axeCpos1_DG, axeApos1_DG,e$, pnumligne, *zrprintrap_DG, e$     #orientationtete
           #if mr2print_DG =  -1,pnumligne,pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete 
           #else, pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, axeCpos1_DG, axeApos1_DG,e$, pnumligne, *zrprint_DG, e$     #orientationtete
           #pnumligne,pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, e$     #orientationtete 

           pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG,e$                         # dep au plan garde 
           gcode$ = 1

           if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
           else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

           pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zprint_DG,frplunge_DG, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, e$            # retour plan de secu
            else, pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_DG = axeCpos_DG
           old_axeApos_DG = axeApos_DG
           oldreel_axeCpos_DG = reel_axeCpos_DG

            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG

        oldstation_DG = mi4_DG
        frbase_DG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_DG
       xprint_DG = 0
       yprint_DG = 0
       #zinitht_DG = dest_ret_5x_DG
       #*sav_x_pmx, *tox4print_DG, e$
       #*sav_y_pmx,  *toy4print_DG, e$
       #*sav_z_pmx, *toz4print_DG, e$
       zinitht_DG = sqrt((sav_x_pmx - tox4print_DG)^2 + (sav_y_pmx - toy4print_DG)^2 + (sav_z_pmx - toz4print_DG)^2)
       old_zinitht_DG = zinitht_DG

       @initht$
       @zinitht_DG
       zprint_DG = refht$
       panul_plan_inc_DG
            if (x$ = u$) & (y$ = v$), [axeCpos1_DG = 0, axeApos1_DG = 0, axeCpos_DG = 0, axeApos_DG = 0]
            if axeApos1_DG > maxi_a_DG | axeApos1_DG < mini_a_DG, psortie10_DG
            if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
            if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
           if garage_DG <> 0 & change_outil_DG = 0, pnumligne, pgcode_force_DG, *axeCpos1_DG, e$
           change_outil_DG = 0
           if mr2print_DG =  -1,pnumligne,pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete
           else, pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete

           if cycle_800 = 1,    [
                                spaces$ = 0
                                axeApos_cycle800_DG = axeApos_DG
                                axeCpos_cycle800_DG = axeCpos_DG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
           else, pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$

           pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DG = 1

            pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zinitht_DG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_DG = tox4print_DG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_DG = toy4print_DG
           old_toz4_DG = toz4print_DG
           old_axeCpos_DG = axeCpos_DG
           old_axeApos_DG = axeApos_DG
           oldreel_axeCpos_DG = reel_axeCpos_DG

            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG
         xprint_DG = 0
         yprint_DG = 0

        oldstation_DG = mi4_DG
        frbase_DG = fr$
       ]

pdrl5_AM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_AM
        gcode$ = 0
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AM = 1
        if invers_AM = 0, pmxinvd_AM
        if invers_AM = 1, pmxinvg_AM
        pdebut_AM
        Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        axeCpos_AM = axeC_AM
        axeApos_AM = axeA_AM

        if mi1_C_base_AM <> 1 & mi1_C_base_AM <> 2, pessaicompteur_AM
        axeCpos1_AM = axeCpos_AM
        axeApos1_AM = axeApos_AM
       !axeApos1_AM,!axeCpos_AM
       if mr2print_AM = 0, mr2print_AM =zsecuprint
       prvmr2_AM = mr2print_AM

       if mr2print_AM <> -1,pnumligne,*mr2print_AM,e$

       gcode$ = 0

       tox4print_AM = (((Vx_AM/longvec) * (depth$ * -1)) + x$)
       toy4print_AM = (((Vy_AM/longvec) * (depth$ * -1)) + y$)
       toz4print_AM = (((Vz_AM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_AM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$

           if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, *zrprintrap_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
           else, pnumligne, pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprintrap_AM, e$     #orientationtete
           #if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprint_AM, e$     #orientationtete
           #pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$     #orientationtete 

           pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,frplunge_AM, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

        oldstation_AM = mi4_AM
        frbase_AM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_AM
       xprint_AM = 0
       yprint_AM = 0
       #zinitht_AM = dest_ret_5x_AM
       #*sav_x_pmx, *tox4print_AM, e$
       #*sav_y_pmx,  *toy4print_AM, e$
       #*sav_z_pmx, *toz4print_AM, e$
       zinitht_AM = sqrt((sav_x_pmx - tox4print_AM)^2 + (sav_y_pmx - toy4print_AM)^2 + (sav_z_pmx - toz4print_AM)^2)
       old_zinitht_AM = zinitht_AM

       @initht$
       @zinitht_AM
       zprint_AM = refht$
       pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
       if (x$ = u$) & (y$ = v$), [axeCpos1_AM = 0, axeApos1_AM = 0, axeCpos_AM = 0, axeApos_AM = 0]
       if axeApos1_AM > maxi_a_AM | axeApos1_AM < mini_a_AM, psortie10_AM
           if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
           else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
           pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$


            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zinitht_AM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AM = toy4print_AM
           old_toz4_AM = toz4print_AM
           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM
         xprint_AM = 0
         yprint_AM = 0

        oldstation_AM = mi4_AM
        frbase_AM = fr$
       ]

pdrl5_BM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_BM
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_BM = 1
        if invers_BM = 0, pmxinvd_BM
        if invers_BM = 1, pmxinvg_BM
        pdebut_BM
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        axeCpos_BM = axeC_BM
        axeApos_BM = axeA_BM

        if mi1_C_base_BM <> 1 & mi1_C_base_BM <> 2, pessaicompteur_BM
        axeCpos1_BM = axeCpos_BM
        axeApos1_BM = axeApos_BM
       !axeApos1_BM,!axeCpos_BM
       if mr2print_BM = 0, mr2print_BM =zsecuprint
       prvmr2_BM = mr2print_BM

       if mr2print_BM <> -1,pnumligne,*mr2print_BM,e$

       gcode$ = 0

       tox4print_BM = (((Vx_BM/longvec) * (depth$ * -1)) + x$)
       toy4print_BM = (((Vy_BM/longvec) * (depth$ * -1)) + y$)
       toz4print_BM = (((Vz_BM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_BM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_BM

           if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, *zrprintrap_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
           else, pnumligne, pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprintrap_BM, e$     #orientationtete
           #if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprint_BM, e$     #orientationtete
           #pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$     #orientationtete 

           pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,frplunge_BM e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

        oldstation_BM = mi4_BM
        frbase_BM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_BM
       xprint_BM = 0
       yprint_BM = 0
       #zinitht_BM = dest_ret_5x_BM
       #*sav_x_pmx, *tox4print_BM, e$
       #*sav_y_pmx,  *toy4print_BM, e$
       #*sav_z_pmx, *toz4print_BM, e$
       zinitht_BM = sqrt((sav_x_pmx - tox4print_BM)^2 + (sav_y_pmx - toy4print_BM)^2 + (sav_z_pmx - toz4print_BM)^2)
       old_zinitht_BM = zinitht_BM

       @initht$
       @zinitht_BM
       zprint_BM = refht$
       panul_plan_inc_BM
            if (x$ = u$) & (y$ = v$), [axeCpos1_BM = 0, axeApos1_BM = 0, axeCpos_BM = 0, axeApos_BM = 0]
            if axeApos1_BM > maxi_a_BM | axeApos1_BM < mini_a_BM, psortie10_BM
           if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
           else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
           pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$


            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zinitht_BM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BM = toy4print_BM
           old_toz4_BM = toz4print_BM
           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM
         xprint_BM = 0
         yprint_BM = 0

        oldstation_BM = mi4_BM
        frbase_BM = fr$
       ]

pdrl5_CM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_CM
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_CM = 1
        if invers_CM = 0, pmxinvd_CM
        if invers_CM = 1, pmxinvg_CM
        pdebut_CM
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        axeCpos_CM = axeC_CM
        axeApos_CM = axeA_CM

        if mi1_C_base_CM <> 1 & mi1_C_base_CM <> 2, pessaicompteur_CM
        axeCpos1_CM = axeCpos_CM
        axeApos1_CM = axeApos_CM
        axeCpos_CM = axeCpos_CM + 90
       !axeApos1_CM,!axeCpos_CM
       if mr2print_CM = 0, mr2print_CM =zsecuprint
       prvmr2_CM = mr2print_CM

       if mr2print_CM <> -1,pnumligne,*mr2print_CM,e$

       gcode$ = 0

       tox4print_CM = (((Vx_CM/longvec) * (depth$ * -1)) + x$)
       toy4print_CM = (((Vy_CM/longvec) * (depth$ * -1)) + y$)
       toz4print_CM = (((Vz_CM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_CM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_CM

           if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, *zrprintrap_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
           else, pnumligne, pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprintrap_CM, e$     #orientationtete
           #if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprint_CM, e$     #orientationtete
           #pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$     #orientationtete 

           pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
           gcode$ = 1

           if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
           else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

           pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,frplunge_CM e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

        oldstation_CM = mi4_CM
        frbase_CM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_CM
       xprint_CM = 0
       yprint_CM = 0
       #zinitht_CM = dest_ret_5x_CM
       #*sav_x_pmx, *tox4print_CM, e$
       #*sav_y_pmx,  *toy4print_CM, e$
       #*sav_z_pmx, *toz4print_CM, e$
       zinitht_CM = sqrt((sav_x_pmx - tox4print_CM)^2 + (sav_y_pmx - toy4print_CM)^2 + (sav_z_pmx - toz4print_CM)^2)
       old_zinitht_CM = zinitht_CM

       @initht$
       @zinitht_CM
       zprint_CM = refht$
       panul_plan_inc_CM
            if (x$ = u$) & (y$ = v$), [axeCpos1_CM = 0, axeApos1_CM = 0, axeCpos_CM = 0, axeApos_CM = 0]
            if axeApos1_CM > maxi_a_CM | axeApos1_CM < mini_a_CM, psortie10_CM
           if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete
           else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete

           if cycle_800 = 1,    [
                                spaces$ = 0
                                axeApos_cycle800_CM = axeApos_CM
                                axeCpos_cycle800_CM = axeCpos_CM
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
           else, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$

           pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1

            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zinitht_CM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CM = toy4print_CM
           old_toz4_CM = toz4print_CM
           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM
         xprint_CM = 0
         yprint_CM = 0

        oldstation_CM = mi4_CM
        frbase_CM = fr$
       ]

pdrl5_DM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_DM
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_DM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_DM = 1
        if invers_DM = 0, pmxinvd_DM
        if invers_DM = 1, pmxinvg_DM
        pdebut_DM
        Vx_DM = u$ - x$
        Vy_DM = v$ - y$
        Vz_DM = w$ - z$
        axeCpos_DM = axeC_DM
        axeApos_DM = axeA_DM

        if mi1_C_base_DM <> 1 & mi1_C_base_DM <> 2, pessaicompteur_DM
        axeCpos1_DM = axeCpos_DM
        axeApos1_DM = axeApos_DM
        axeCpos_DM = axeCpos_DM + 90
       !axeApos1_DM,!axeCpos_DM
       if mr2print_DM = 0, mr2print_DM =zsecuprint
       prvmr2_DM = mr2print_DM

       if mr2print_DM <> -1,pnumligne,*mr2print_DM,e$

       gcode$ = 0

       tox4print_DM = (((Vx_DM/longvec) * (depth$ * -1)) + x$)
       toy4print_DM = (((Vy_DM/longvec) * (depth$ * -1)) + y$)
       toz4print_DM = (((Vz_DM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_DM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_DM

           if mr2print_DM =  -1,pnumligne,pgcode_force_DM, *xrprintrap_DM, *yrprintrap_DM, *zrprintrap_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete 
           else, pnumligne, pgcode_force_DM, *xrprintrap_DM, *yrprintrap_DM, axeCpos1_DM, axeApos1_DM,e$, pnumligne, *zrprintrap_DM, e$     #orientationtete
           #if mr2print_DM =  -1,pnumligne,pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, axeCpos1_DM, axeApos1_DM,e$, pnumligne, *zrprint_DM, e$     #orientationtete
           #pnumligne,pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, e$     #orientationtete 

           pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM,e$                         # dep au plan garde 
           gcode$ = 1

           if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
           else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

           pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zprint_DM,frplunge_DM e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_DM = axeCpos_DM
           old_axeApos_DM = axeApos_DM
           oldreel_axeCpos_DM = reel_axeCpos_DM

            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM

        oldstation_DM = mi4_DM
        frbase_DM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_DM
       xprint_DM = 0
       yprint_DM = 0
       #zinitht_DM = dest_ret_5x_DM
       #*sav_x_pmx, *tox4print_DM, e$
       #*sav_y_pmx,  *toy4print_DM, e$
       #*sav_z_pmx, *toz4print_DM, e$
       zinitht_DM = sqrt((sav_x_pmx - tox4print_DM)^2 + (sav_y_pmx - toy4print_DM)^2 + (sav_z_pmx - toz4print_DM)^2)
       old_zinitht_DM = zinitht_DM

       @initht$
       @zinitht_DM
       zprint_DM = refht$
       panul_plan_inc_DM
            if (x$ = u$) & (y$ = v$), [axeCpos1_DM = 0, axeApos1_DM = 0, axeCpos_DM = 0, axeApos_DM = 0]
            if axeApos1_DM > maxi_a_DM | axeApos1_DM < mini_a_DM, psortie10_DM
           if mr2print_DM =  -1,pnumligne,pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete
           else, pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete

           if cycle_800 = 1,    [
                                spaces$ = 0
                                axeApos_cycle800_DM = axeApos_DM
                                axeCpos_cycle800_DM = axeCpos_DM
                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
           else, pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$

           pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DM = 1

            pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zinitht_DM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_DM = tox4print_DM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_DM = toy4print_DM
           old_toz4_DM = toz4print_DM
           old_axeCpos_DM = axeCpos_DM
           old_axeApos_DM = axeApos_DM
           oldreel_axeCpos_DM = reel_axeCpos_DM

            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM
         xprint_DM = 0
         yprint_DM = 0

        oldstation_DM = mi4_DM
        frbase_DM = fr$
       ]
#endregion
#region pdrl5_2

pdrl5_2_AG   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AG = 1
        if invers_AG = 0, pmxinvd_AG
        if invers_AG = 1, pmxinvg_AG
        pdebut_AG
        Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        axeCpos_AG = axeC_AG
        axeApos_AG = axeA_AG
        if mi1_C_base_AG <> 1 & mi1_C_base_AG <> 2, pessaicompteur_AG, e$
        axeCpos1_AG = axeCpos_AG
        axeApos1_AG = axeApos_AG
        !axeApos1_AG,!axeCpos_AG
        if mr2print_AG = 0, mr2print_AG = zsecuprint
        prvmr2_AG = mr2print_AG

        if tete_rev_AG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 
            #pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
            !xrprint_AG, !xgarde_AG, !yrprint_AG, !ygarde_AG, !zrprint_AG, !zgarde_AG

             if xrprint_AG = xgarde_AG & yrprint_AG = ygarde_AG & zrprint_AG = zgarde_AG,""
             else,
             [
             old_x_print_AG = old_x_AG
             old_y_print_AG = old_y_AG
             old_z_print_AG = old_z_AG
             if retplangarde = 0, pnumligne, pgcode_force_AG, *old_x_print_AG, *old_y_print_AG, *old_z_print_AG,e$
             ]

            #if mi3$ = 0 & mr2print_AG <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_AG, *mr2print_AG ,e$
            #    pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, axeCpos1_AG, axeApos1_AG,e$, pnumligne, *zrprint_AG, e$
            #    ]
           #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_AG = old_z_AG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, axeCpos1_AG, axeApos1_AG, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete 
                else, pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete
              #   ]



            if xrprint_AG <> xgarde_AG | yrprint_AG <> ygarde_AG | zrprint_AG <> zgarde_AG,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,frplunge$, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_AG <> zrprint_AG, pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, e$
                gcode$ = 0
                pnumligne, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_AG = xdegvec + nextx$
                yrprintrap_AG = ydegvec + nexty$
                zrprintrap_AG = zdegvec + nextz$
                pnumligne,pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, e$
                ]

            ]
            else,   pnumligne, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

            oldstation_AG = mi4_AG
            frbase_AG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
            tox4print_AG = ((Vx_AG/longvec) * (depth$ * -1)) + xprint_AG
            toy4print_AG = ((Vy_AG/longvec) * (depth$ * -1)) + yprint_AG
            toz4print_AG = ((Vz_AG/longvec) * (depth$ * -1)) + zprint_AG
            pvoir_AG


            if cycle_heli_spiral_AG = 0,
            [
            if nextop$ <> 100, pnumligne, "G80", *old_dest_ret_5x_AG, e$
            else, pnumligne, "G80", *dest_ret_5x_AG,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_AG, *old_dest_ret_5x_AG, e$
            else, pnumligne, pgcode_AG , *dest_ret_5x_AG,e$ # retour a plan suite dernier usinage
            ]


            #if mi3$ = 0 & mr2print_AG <>   -1,
            #    [
            #    #pcalxyz3d_AG

            #    pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            #    pnumligne, *mr2print_AG ,e$
            #    xaproche = (((Vx_AG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_AG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_AG = (((Vz_AG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_AG longvec et xaproche", *Vx_AG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_AG, *xaproche, *yaproche, axeCpos1_AG, axeApos1_AG, e$
            #    ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_AG = 0, axeApos1_AG = 0, axeCpos_AG = 0, axeApos_AG = 0]
            gcode$ = 0
            pnumligne, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
            xprint_AG = 0
            yprint_AG = 0
            if nextop$ <> 100, zinitht_AG = old_dest_ret_5x_AG
            else, zinitht_AG = dest_ret_5x_AG
            zprint_AG = refht$
            # n, pgcode_force_AG, axeCpos1_AG, axeApos1_AG, e                    #orientation tete
            # n, pgcode_force_AG, *x, *y, *zinitht_AG,e          # dep au plan garde            
            if axeApos1_AG > maxi_a_AG | axeApos1_AG < mini_a_AG, psortie10_AG
            pnumligne, pgcode_force_AG, *xprint_AG, *yprint_AG, *zinitht_AG, axeCpos1_AG, axeApos1_AG, e$                    #orientation tete+ garde
            #n, pgcode_force_AG, *x, *y, *z, e
            old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AG = toy4print_AG
            old_toz4_AG = toz4print_AG
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG
            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG
            oldstation_AG = mi4_AG
            frbase_AG = fr$
            ]

pdrl5_2_BG   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_BG = 1
        if invers_BG = 0, pmxinvd_BG
        if invers_BG = 1, pmxinvg_BG
        pdebut_BG
        Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        axeCpos_BG = axeC_BG
        axeApos_BG = axeA_BG
        if mi1_C_base_BG <> 1 & mi1_C_base_BG <> 2, pessaicompteur_BG
        axeCpos1_BG = axeCpos_BG
        axeApos1_BG = axeApos_BG
        !axeApos1_BG,!axeCpos_BG
        if mr2print_BG = 0, mr2print_BG = zsecuprint
        prvmr2_BG = mr2print_BG

        if tete_rev_BG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_BG, !xgarde_BG, !yrprint_BG, !ygarde_BG, !zrprint_BG, !zgarde_BG

             if xrprint_BG = xgarde_BG & yrprint_BG = ygarde_BG & zrprint_BG = zgarde_BG,""
             else,
             [
             old_x_print_BG = old_x_BG
             old_y_print_BG = old_y_BG
             old_z_print_BG = old_z_BG
             if retplangarde = 0, pnumligne, pgcode_force_BG, *old_x_print_BG, *old_y_print_BG, *old_z_print_BG, e$
             ]

            #if mi3$ = 0 & mr2print_BG <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_BG, *mr2print_BG ,e$
            #    pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, axeCpos1_BG, axeApos1_BG,e$, pnumligne, *zrprint_BG, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_BG = old_z_BG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG, axeCpos1_BG, axeApos1_BG, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete 
                else, pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *old_z_print_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete
            #     ]



            if xrprint_BG <> xgarde_BG | yrprint_BG <> ygarde_BG | zrprint_BG <> zgarde_BG,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,frplunge$ e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_BG <> zrprint_BG, pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$
                gcode$ = 0
                pnumligne, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_BG = xdegvec + nextx$
                yrprintrap_BG = ydegvec + nexty$
                zrprintrap_BG = zdegvec + nextz$
                pnumligne,pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, e$
                ]

            ]
            else,   pnumligne, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

            oldstation_BG = mi4_BG
            frbase_BG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_BG,yprint_BG    ,zprint_BG, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_BG = ((Vx_BG/longvec) * (depth$ * -1)) + xprint_BG
            toy4print_BG = ((Vy_BG/longvec) * (depth$ * -1)) + yprint_BG
            toz4print_BG = ((Vz_BG/longvec) * (depth$ * -1)) + zprint_BG
            pvoir_BG

            if cycle_heli_spiral_BG = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_BG, *old_dest_ret_5x_BG,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_BG, *dest_ret_5x_BG,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_BG, *old_dest_ret_5x_BG, e$
            else, pnumligne, pgcode_BG , *dest_ret_5x_BG,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_BG <>   -1,
            #    [
            #    #pcalxyz3d_BG
            #
            #    panul_plan_inc_BG
            #    pnumligne, *mr2print_BG ,e$
            #    xaproche = (((Vx_BG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_BG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_BG = (((Vz_BG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_BG longvec et xaproche", *Vx_BG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_BG, *xaproche, *yaproche, axeCpos1_BG, axeApos1_BG, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_BG = 0, axeApos1_BG = 0, axeCpos_BG = 0, axeApos_BG = 0]
            gcode$ = 0
            pnumligne, "TRANS", e$, pnumligne, "ROT", e$
            pnumligne, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, pnumligne, "AROT", axeCpos_BG, axeApos_BG, e$
            xprint_BG = 0
            yprint_BG = 0
            if nextop$ <> 100, zinitht_BG = old_dest_ret_5x_BG
            else, zinitht_BG = dest_ret_5x_BG
            zprint_BG = refht$
            # n, pgcode_force_BG, axeCpos1_BG, axeApos1_BG, e                    #orientation tete
            # n, pgcode_force_BG, *x, *y, *zinitht_BG,e          # dep au plan garde            
            if axeApos1_BG > maxi_a_BG | axeApos1_BG < mini_a_BG, psortie10_BG
            pnumligne, pgcode_force_BG, *xprint_BG, *yprint_BG, *zinitht_BG, axeCpos1_BG, axeApos1_BG, e$                    #orientation tete+ garde
            #n, pgcode_force_BG, *x, *y, *z, e
            old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BG = toy4print_BG
            old_toz4_BG = toz4print_BG
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG
            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG
            oldstation_BG = mi4_BG
            frbase_BG = fr$
            ]

pdrl5_2_CG   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_CG = 1
        if invers_CG = 0, pmxinvd_CG
        if invers_CG = 1, pmxinvg_CG
        pdebut_CG
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        axeCpos_CG = axeC_CG
        axeApos_CG = axeA_CG
        if mi1_C_base_CG <> 1 & mi1_C_base_CG <> 2, pessaicompteur_CG
        axeCpos1_CG = axeCpos_CG
        axeApos1_CG = axeApos_CG
        axeCpos_CG = axeCpos_CG + 90
        !axeApos1_CG,!axeCpos_CG
        if mr2print_CG = 0, mr2print_CG = zsecuprint
        prvmr2_CG = mr2print_CG

        if tete_rev_CG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_CG, !xgarde_CG, !yrprint_CG, !ygarde_CG, !zrprint_CG, !zgarde_CG

             if xrprint_CG = xgarde_CG & yrprint_CG = ygarde_CG & zrprint_CG = zgarde_CG,""
             else,
             [
             old_x_print_CG = old_x_CG
             old_y_print_CG = old_y_CG
             old_z_print_CG = old_z_CG
             if retplangarde = 0, pnumligne, pgcode_force_CG, *old_x_print_CG, *old_y_print_CG, *old_z_print_CG, e$
             ]

            #if mi3$ = 0 & mr2print_CG <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_CG, *mr2print_CG ,e$
            #    pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, axeCpos1_CG, axeApos1_CG,e$, pnumligne, *zrprint_CG, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                old_z_print_CG = old_z_CG
                if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
                if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG, axeCpos1_CG, axeApos1_CG, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete 
                else, pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *old_z_print_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete
            #     ]



            if xrprint_CG <> xgarde_CG | yrprint_CG <> ygarde_CG | zrprint_CG <> zgarde_CG,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

            pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,frplunge_CG, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_CG <> zrprint_CG, pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$
                gcode$ = 0
                pnumligne, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_CG = xdegvec + nextx$
                yrprintrap_CG = ydegvec + nexty$
                zrprintrap_CG = zdegvec + nextz$
                pnumligne,pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, e$
                ]

            ]
            else,   pnumligne, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

            oldstation_CG = mi4_CG
            frbase_CG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_CG,yprint_CG    ,zprint_CG, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_CG = ((Vx_CG/longvec) * (depth$ * -1)) + xprint_CG
            toy4print_CG = ((Vy_CG/longvec) * (depth$ * -1)) + yprint_CG
            toz4print_CG = ((Vz_CG/longvec) * (depth$ * -1)) + zprint_CG
            pvoir_CG

            if cycle_heli_spiral_CG = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_CG, *old_dest_ret_5x_CG,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_CG, *dest_ret_5x_CG,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_CG, *old_dest_ret_5x_CG, e$
            else, pnumligne, pgcode_CG , *dest_ret_5x_CG,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_CG <>   -1,
            #    [
            #    #pcalxyz3d_CG
            #
            #    panul_plan_inc_CG
            #    pnumligne, *mr2print_CG ,e$
            #    xaproche = (((Vx_CG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_CG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_CG = (((Vz_CG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_CG longvec et xaproche", *Vx_CG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_CG, *xaproche, *yaproche, axeCpos1_CG, axeApos1_CG, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_CG = 0, axeApos1_CG = 0, axeCpos_CG = 0, axeApos_CG = 0]
            gcode$ = 0
            if blocaxe_CG = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CG = 0

            if cycle_800 = 1,   [
                                pnumligne, "CYCLE800()", e$
                                spaces$ = 0
                                axeApos_cycle800_CG = axeApos_CG
                                axeCpos_cycle800_CG = axeCpos_CG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CG,",",*toy4print_CG,",",*toz4print_CG,",",axeCpos_cycle800_CG,",",axeApos_cycle800_CG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
                        else,   [
                                pnumligne, "TRANS", e$, pnumligne, "ROT", e$
                                xaproche_CG = (((Vx_CG/longvec) * (initht$ - refht$) ) + ucal)
                                yaproche_CG = (((Vy_CG/longvec) * (initht$ - refht$) ) + vcal)
                                zaproche_CG = (((Vz_CG/longvec) * (initht$ - refht$) ) + wcal)
                                if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
                                if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
                                pnumligne,pgcode_force_CG, *xaproche_CG, *yaproche_CG, *zaproche_CG, axeCpos1_CG, axeApos1_CG, e$
                                pnumligne, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, pnumligne, "AROT", axeCpos_CG, axeApos_CG, e$
                                ]

            xprint_CG = 0
            yprint_CG = 0
            if nextop$ <> 100, zinitht_CG = old_dest_ret_5x_CG
            else, zinitht_CG = dest_ret_5x_CG
            zprint_CG = refht$
            # n, pgcode_force_CG, axeCpos1_CG, axeApos1_CG, e                    #orientation tete
            # n, pgcode_force_CG, *x, *y, *zinitht_CG,e          # dep au plan garde            
            if axeApos1_CG > maxi_a_CG | axeApos1_CG < mini_a_CG, psortie10_CG
            #pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zinitht_CG, axeCpos1_CG, axeApos1_CG, e$                    #orientation tete+ garde
            pnumligne, pgcode_force_CG, *xprint_CG, *yprint_CG, *zinitht_CG, e$                    #orientation tete+ garde
            #n, pgcode_force_CG, *x, *y, *z, e
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
            old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CG = toy4print_CG
            old_toz4_CG = toz4print_CG
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG
            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG
            oldstation_CG = mi4_CG
            frbase_CG = fr$
            ]
pdrl5_2_DG   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_DG = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_DG = 1
        if invers_DG = 0, pmxinvd_DG
        if invers_DG = 1, pmxinvg_DG
        pdebut_DG
        Vx_DG = u$ - x$
        Vy_DG = v$ - y$
        Vz_DG = w$ - z$
        axeCpos_DG = axeC_DG
        axeApos_DG = axeA_DG
        if mi1_C_base_DG <> 1 & mi1_C_base_DG <> 2, pessaicompteur_DG
        axeCpos1_DG = axeCpos_DG
        axeApos1_DG = axeApos_DG
        axeCpos_DG = axeCpos_DG + 90
        !axeApos1_DG,!axeCpos_DG
        if mr2print_DG = 0, mr2print_DG = zsecuprint
        prvmr2_DG = mr2print_DG

        if tete_rev_DG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_DG, !xgarde_DG, !yrprint_DG, !ygarde_DG, !zrprint_DG, !zgarde_DG

             if xrprint_DG = xgarde_DG & yrprint_DG = ygarde_DG & zrprint_DG = zgarde_DG,""
             else,
             [
             old_x_print_DG = old_x_DG
             old_y_print_DG = old_y_DG
             old_z_print_DG = old_z_DG
             if retplangarde = 0, pnumligne, pgcode_force_DG, *old_x_print_DG, *old_y_print_DG, *old_z_print_DG, e$
             ]

            #if mi3$ = 0 & mr2print_DG <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_DG, *mr2print_DG ,e$
            #    pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, axeCpos1_DG, axeApos1_DG,e$, pnumligne, *zrprint_DG, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                old_z_print_DG = old_z_DG
                if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
                if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG, axeCpos1_DG, axeApos1_DG, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete 
                else, pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, *old_z_print_DG, axeCpos1_DG, axeApos1_DG, e$     #orientationtete
            #     ]



            if xrprint_DG <> xgarde_DG | yrprint_DG <> ygarde_DG | zrprint_DG <> zgarde_DG,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

            pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zprint_DG,frplunge_DG, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_DG <> zrprint_DG, pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG,e$
                gcode$ = 0
                pnumligne, pgcode_force_DG, *xrprint_DG, *yrprint_DG, *zrprint_DG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_DG = xdegvec + nextx$
                yrprintrap_DG = ydegvec + nexty$
                zrprintrap_DG = zdegvec + nextz$
                pnumligne,pgcode_force_DG, *xrprintrap_DG, *yrprintrap_DG, *zrprintrap_DG, e$
                ]

            ]
            else,   pnumligne, pgcode_force_DG, *xgarde_DG, *ygarde_DG, *zgarde_DG,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_DG = axeCpos_DG
            old_axeApos_DG = axeApos_DG
            oldreel_axeCpos_DG = reel_axeCpos_DG

            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG

            oldstation_DG = mi4_DG
            frbase_DG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_DG,yprint_DG    ,zprint_DG, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_DG = ((Vx_DG/longvec) * (depth$ * -1)) + xprint_DG
            toy4print_DG = ((Vy_DG/longvec) * (depth$ * -1)) + yprint_DG
            toz4print_DG = ((Vz_DG/longvec) * (depth$ * -1)) + zprint_DG
            pvoir_DG

            if cycle_heli_spiral_DG = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_DG, *old_dest_ret_5x_DG,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_DG, *dest_ret_5x_DG,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_DG, *old_dest_ret_5x_DG, e$
            else, pnumligne, pgcode_DG , *dest_ret_5x_DG,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_DG <>   -1,
            #    [
            #    #pcalxyz3d_DG
            #
            #    panul_plan_inc_DG
            #    pnumligne, *mr2print_DG ,e$
            #    xaproche = (((Vx_DG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_DG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_DG = (((Vz_DG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_DG longvec et xaproche", *Vx_DG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_DG, *xaproche, *yaproche, axeCpos1_DG, axeApos1_DG, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_DG = 0, axeApos1_DG = 0, axeCpos_DG = 0, axeApos_DG = 0]
            gcode$ = 0
            if blocaxe_DG = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_DG = 0

            if cycle_800 = 1,   [
                                pnumligne, "CYCLE800()", e$
                                spaces$ = 0
                                axeApos_cycle800_DG = axeApos_DG
                                axeCpos_cycle800_DG = axeCpos_DG
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_DG,",",*toy4print_DG,",",*toz4print_DG,",",axeCpos_cycle800_DG,",",axeApos_cycle800_DG,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
                        else,   [
                                pnumligne, "TRANS", e$, pnumligne, "ROT", e$
                                xaproche_DG = (((Vx_DG/longvec) * (initht$ - refht$) ) + ucal)
                                yaproche_DG = (((Vy_DG/longvec) * (initht$ - refht$) ) + vcal)
                                zaproche_DG = (((Vz_DG/longvec) * (initht$ - refht$) ) + wcal)
                                if axeCpos1_DG > maxi_c_DG, psortie_ratrap_planinc_deroul_DG
                                if axeCpos1_DG < mini_c_DG, psortie_ratrap_planinc_enroul_DG
                                pnumligne,pgcode_force_DG, *xaproche_DG, *yaproche_DG, *zaproche_DG, axeCpos1_DG, axeApos1_DG, e$
                                pnumligne, "TRANS", tox4print_DG, toy4print_DG, toz4print_DG, e$, pnumligne, "AROT", axeCpos_DG, axeApos_DG, e$
                                ]

            xprint_DG = 0
            yprint_DG = 0
            if nextop$ <> 100, zinitht_DG = old_dest_ret_5x_DG
            else, zinitht_DG = dest_ret_5x_DG
            zprint_DG = refht$
            # n, pgcode_force_DG, axeCpos1_DG, axeApos1_DG, e                    #orientation tete
            # n, pgcode_force_DG, *x, *y, *zinitht_DG,e          # dep au plan garde            
            if axeApos1_DG > maxi_a_DG | axeApos1_DG < mini_a_DG, psortie10_DG
            #pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zinitht_DG, axeCpos1_DG, axeApos1_DG, e$                    #orientation tete+ garde
            pnumligne, pgcode_force_DG, *xprint_DG, *yprint_DG, *zinitht_DG, e$                    #orientation tete+ garde
            #n, pgcode_force_DG, *x, *y, *z, e
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DG = 1
            old_tox4_DG = tox4print_DG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_DG = toy4print_DG
            old_toz4_DG = toz4print_DG
            old_axeCpos_DG = axeCpos_DG
            old_axeApos_DG = axeApos_DG
            oldreel_axeCpos_DG = reel_axeCpos_DG
            old_x_DG=xrprint_DG
            old_y_DG=yrprint_DG
            old_z_DG=zrprint_DG
            oldstation_DG = mi4_DG
            frbase_DG = fr$
            ]
pdrl5_2_AM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, invers_AM = 1
        if invers_AM = 0, pmxinvd_AM
        if invers_AM = 1, pmxinvg_AM
        pdebut_AM
        Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        axeCpos_AM = axeC_AM
        axeApos_AM = axeA_AM
        if mi1_C_base_AM <> 1 & mi1_C_base_AM <> 2, pessaicompteur_AM
        axeCpos1_AM = axeCpos_AM
        axeApos1_AM = axeApos_AM
        !axeApos1_AM,!axeCpos_AM
        if mr2print_AM = 0, mr2print_AM = zsecuprint
        prvmr2_AM = mr2print_AM

        if tete_rev_AM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 
            #pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
            !xrprint_AM, !xgarde_AM, !yrprint_AM, !ygarde_AM, !zrprint_AM, !zgarde_AM

             if xrprint_AM = xgarde_AM & yrprint_AM = ygarde_AM & zrprint_AM = zgarde_AM,""
             else,
             [
             old_x_print_AM = old_x_AM
             old_y_print_AM = old_y_AM
             old_z_print_AM = old_z_AM
             if retplangarde = 0, pnumligne, pgcode_force_AM, *old_x_print_AM, *old_y_print_AM, *old_z_print_AM, e$
             ]

            #if mi3$ = 0 & mr2print_AM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_AM, *mr2print_AM ,e$
            #    pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprint_AM, e$
            #    ]
           #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_AM = old_z_AM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM, axeCpos1_AM, axeApos1_AM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
                else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
              #   ]



            if xrprint_AM <> xgarde_AM | yrprint_AM <> ygarde_AM | zrprint_AM <> zgarde_AM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            frplunge_AM = frplunge$
            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,frplunge_AM e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_AM <> zrprint_AM, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$
                gcode$ = 0
                pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_AM = xdegvec + nextx$
                yrprintrap_AM = ydegvec + nexty$
                zrprintrap_AM = zdegvec + nextz$
                pnumligne,pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, *zrprintrap_AM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

            oldstation_AM = mi4_AM
            frbase_AM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
            tox4print_AM = ((Vx_AM/longvec) * (depth$ * -1)) + xprint_AM
            toy4print_AM = ((Vy_AM/longvec) * (depth$ * -1)) + yprint_AM
            toz4print_AM = ((Vz_AM/longvec) * (depth$ * -1)) + zprint_AM
            pvoir_AM


            if cycle_heli_spiral_AM = 0,
            [
            if nextop$ <> 100, pnumligne, "G80", *old_dest_ret_5x_AM, e$
            else, pnumligne, "G80", *dest_ret_5x_AM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_AM, *old_dest_ret_5x_AM, e$
            else, pnumligne, pgcode_AM , *dest_ret_5x_AM,e$ # retour a plan suite dernier usinage
            ]


            #if mi3$ = 0 & mr2print_AM <>   -1,
            #    [
            #    #pcalxyz3d_AM

            #    pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            #    pnumligne, *mr2print_AM ,e$
            #    xaproche = (((Vx_AM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_AM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_AM = (((Vz_AM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_AM longvec et xaproche", *Vx_AM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_AM, *xaproche, *yaproche, axeCpos1_AM, axeApos1_AM, e$
            #    ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_AM = 0, axeApos1_AM = 0, axeCpos_AM = 0, axeApos_AM = 0]
            gcode$ = 0
            pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
            xprint_AM = 0
            yprint_AM = 0
            if nextop$ <> 100, zinitht_AM = old_dest_ret_5x_AM
            else, zinitht_AM = dest_ret_5x_AM
            zprint_AM = refht$
            # n, pgcode_force_AM, axeCpos1_AM, axeApos1_AM, e                    #orientation tete
            # n, pgcode_force_AM, *x, *y, *zinitht_AM,e          # dep au plan garde            
            if axeApos1_AM > maxi_a_AM | axeApos1_AM < mini_a_AM, psortie10_AM
            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zinitht_AM, axeCpos1_AM, axeApos1_AM, e$                    #orientation tete+ garde
            #n, pgcode_force_AM, *x, *y, *z, e
            old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AM = toy4print_AM
            old_toz4_AM = toz4print_AM
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM
            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM
            oldstation_AM = mi4_AM
            frbase_AM = fr$
            ]

pdrl5_2_BM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_BM = 1
        if invers_BM = 0, pmxinvd_BM
        if invers_BM = 1, pmxinvg_BM
        pdebut_BM
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        axeCpos_BM = axeC_BM
        axeApos_BM = axeA_BM
        if mi1_C_base_BM <> 1 & mi1_C_base_BM <> 2, pessaicompteur_BM
        axeCpos1_BM = axeCpos_BM
        axeApos1_BM = axeApos_BM
        !axeApos1_BM,!axeCpos_BM
        if mr2print_BM = 0, mr2print_BM = zsecuprint
        prvmr2_BM = mr2print_BM

        if tete_rev_BM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_BM, !xgarde_BM, !yrprint_BM, !ygarde_BM, !zrprint_BM, !zgarde_BM

             if xrprint_BM = xgarde_BM & yrprint_BM = ygarde_BM & zrprint_BM = zgarde_BM,""
             else,
             [
             old_x_print_BM = old_x_BM
             old_y_print_BM = old_y_BM
             old_z_print_BM = old_z_BM
             if retplangarde = 0, pnumligne, pgcode_force_BM, *old_x_print_BM, *old_y_print_BM, *old_z_print_BM, e$
             ]

            #if mi3$ = 0 & mr2print_BM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_BM, *mr2print_BM ,e$
            #    pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprint_BM, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_BM = old_z_BM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM, axeCpos1_BM, axeApos1_BM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
                else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *old_z_print_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
            #     ]



            if xrprint_BM <> xgarde_BM | yrprint_BM <> ygarde_BM | zrprint_BM <> zgarde_BM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            frplunge_BM = frplunge$
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,frplunge_BM e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_BM <> zrprint_BM, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$
                gcode$ = 0
                pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_BM = xdegvec + nextx$
                yrprintrap_BM = ydegvec + nexty$
                zrprintrap_BM = zdegvec + nextz$
                pnumligne,pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, *zrprintrap_BM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

            oldstation_BM = mi4_BM
            frbase_BM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_BM,yprint_BM    ,zprint_BM, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_BM = ((Vx_BM/longvec) * (depth$ * -1)) + xprint_BM
            toy4print_BM = ((Vy_BM/longvec) * (depth$ * -1)) + yprint_BM
            toz4print_BM = ((Vz_BM/longvec) * (depth$ * -1)) + zprint_BM
            pvoir_BM

            if cycle_heli_spiral_BM = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_BM, *old_dest_ret_5x_BM,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_BM, *dest_ret_5x_BM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_BM, *old_dest_ret_5x_BM, e$
            else, pnumligne, pgcode_BM , *dest_ret_5x_BM,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_BM <>   -1,
            #    [
            #    #pcalxyz3d_BM
            #
            #    panul_plan_inc_BM
            #    pnumligne, *mr2print_BM ,e$
            #    xaproche = (((Vx_BM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_BM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_BM = (((Vz_BM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_BM longvec et xaproche", *Vx_BM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_BM, *xaproche, *yaproche, axeCpos1_BM, axeApos1_BM, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_BM = 0, axeApos1_BM = 0, axeCpos_BM = 0, axeApos_BM = 0]
            gcode$ = 0
            pnumligne, "TRANS", e$, pnumligne, "ROT", e$
            pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
            xprint_BM = 0
            yprint_BM = 0
            if nextop$ <> 100, zinitht_BM = old_dest_ret_5x_BM
            else, zinitht_BM = dest_ret_5x_BM
            zprint_BM = refht$
            # n, pgcode_force_BM, axeCpos1_BM, axeApos1_BM, e                    #orientation tete
            # n, pgcode_force_BM, *x, *y, *zinitht_BM,e          # dep au plan garde            
            if axeApos1_BM > maxi_a_BM | axeApos1_BM < mini_a_BM, psortie10_BM
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zinitht_BM, axeCpos1_BM, axeApos1_BM, e$                    #orientation tete+ garde
            #n, pgcode_force_BM, *x, *y, *z, e
            old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BM = toy4print_BM
            old_toz4_BM = toz4print_BM
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM
            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM
            oldstation_BM = mi4_BM
            frbase_BM = fr$
            ]

pdrl5_2_CM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_CM = 1
        if invers_CM = 0, pmxinvd_CM
        if invers_CM = 1, pmxinvg_CM
        pdebut_CM
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        axeCpos_CM = axeC_CM
        axeApos_CM = axeA_CM
        if mi1_C_base_CM <> 1 & mi1_C_base_CM <> 2, pessaicompteur_CM
        axeCpos1_CM = axeCpos_CM
        axeApos1_CM = axeApos_CM
        axeCpos_CM = axeCpos_CM + 90
        !axeApos1_CM,!axeCpos_CM
        if mr2print_CM = 0, mr2print_CM = zsecuprint
        prvmr2_CM = mr2print_CM

        if tete_rev_CM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_CM, !xgarde_CM, !yrprint_CM, !ygarde_CM, !zrprint_CM, !zgarde_CM

             if xrprint_CM = xgarde_CM & yrprint_CM = ygarde_CM & zrprint_CM = zgarde_CM,""
             else,
             [
             old_x_print_CM = old_x_CM
             old_y_print_CM = old_y_CM
             old_z_print_CM = old_z_CM
             if retplangarde = 0, pnumligne, pgcode_force_CM, *old_x_print_CM, *old_y_print_CM, *old_z_print_CM, e$
             ]

            #if mi3$ = 0 & mr2print_CM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_CM, *mr2print_CM ,e$
            #    pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprint_CM, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_CM = old_z_CM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM, axeCpos1_CM, axeApos1_CM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
                else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *old_z_print_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete
            #     ]



            if xrprint_CM <> xgarde_CM | yrprint_CM <> ygarde_CM | zrprint_CM <> zgarde_CM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,frplunge_CM, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_CM <> zrprint_CM, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$
                gcode$ = 0
                pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_CM = xdegvec + nextx$
                yrprintrap_CM = ydegvec + nexty$
                zrprintrap_CM = zdegvec + nextz$
                pnumligne,pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, *zrprintrap_CM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

            oldstation_CM = mi4_CM
            frbase_CM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_CM,yprint_CM    ,zprint_CM, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_CM = ((Vx_CM/longvec) * (depth$ * -1)) + xprint_CM
            toy4print_CM = ((Vy_CM/longvec) * (depth$ * -1)) + yprint_CM
            toz4print_CM = ((Vz_CM/longvec) * (depth$ * -1)) + zprint_CM
            pvoir_CM

            if cycle_heli_spiral_CM = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_CM, *old_dest_ret_5x_CM,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_CM, *dest_ret_5x_CM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_CM, *old_dest_ret_5x_CM, e$
            else, pnumligne, pgcode_CM , *dest_ret_5x_CM,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_CM <>   -1,
            #    [
            #    #pcalxyz3d_CM
            #
            #    panul_plan_inc_CM
            #    pnumligne, *mr2print_CM ,e$
            #    xaproche = (((Vx_CM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_CM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_CM = (((Vz_CM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_CM longvec et xaproche", *Vx_CM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_CM, *xaproche, *yaproche, axeCpos1_CM, axeApos1_CM, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_CM = 0, axeApos1_CM = 0, axeCpos_CM = 0, axeApos_CM = 0]
            gcode$ = 0
            if blocaxe_CM = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CM = 0

            if cycle_800 = 1,   [
                                pnumligne, "CYCLE800()", e$
                                spaces$ = 0
                                axeApos_cycle800_CM = axeApos_CM
                                axeCpos_cycle800_CM = axeCpos_CM
                                pnumligne, " CYCLE800(0,",34,"HEAD_CMS1",34,",100010,192,",*tox4print_CM,",",*toy4print_CM,",",*toz4print_CM,",",axeCpos_cycle800_CM,",",axeApos_cycle800_CM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
                        else,   [
                                pnumligne, "TRANS", e$, pnumligne, "ROT", e$
                                xaproche_CM = (((Vx_CM/longvec) * (initht$ - refht$) ) + ucal)
                                yaproche_CM = (((Vy_CM/longvec) * (initht$ - refht$) ) + vcal)
                                zaproche_CM = (((Vz_CM/longvec) * (initht$ - refht$) ) + wcal)
                                pnumligne,pgcode_force_CM, *xaproche_CM, *yaproche_CM, *zaproche_CM, axeCpos1_CM, axeApos1_CM, e$
                                pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
                                ]

            xprint_CM = 0
            yprint_CM = 0
            if nextop$ <> 100, zinitht_CM = old_dest_ret_5x_CM
            else, zinitht_CM = dest_ret_5x_CM
            zprint_CM = refht$
            # n, pgcode_force_CM, axeCpos1_CM, axeApos1_CM, e                    #orientation tete
            # n, pgcode_force_CM, *x, *y, *zinitht_CM,e          # dep au plan garde            
            if axeApos1_CM > maxi_a_CM | axeApos1_CM < mini_a_CM, psortie10_CM
            #pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zinitht_CM, axeCpos1_CM, axeApos1_CM, e$                    #orientation tete+ garde
            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zinitht_CM, e$                    #orientation tete+ garde
            #n, pgcode_force_CM, *x, *y, *z, e
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
            old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CM = toy4print_CM
            old_toz4_CM = toz4print_CM
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM
            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM
            oldstation_CM = mi4_CM
            frbase_CM = fr$
            ]

pdrl5_2_DM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers_DM = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers_DM = 1
        if invers_DM = 0, pmxinvd_DM
        if invers_DM = 1, pmxinvg_DM
        pdebut_DM
        Vx_DM = u$ - x$
        Vy_DM = v$ - y$
        Vz_DM = w$ - z$
        axeCpos_DM = axeC_DM
        axeApos_DM = axeA_DM
        if mi1_C_base_DM <> 1 & mi1_C_base_DM <> 2, pessaicompteur_DM
        axeCpos1_DM = axeCpos_DM
        axeApos1_DM = axeApos_DM
        axeCpos_DM = axeCpos_DM + 90
        !axeApos1_DM,!axeCpos_DM
        if mr2print_DM = 0, mr2print_DM = zsecuprint
        prvmr2_DM = mr2print_DM

        if tete_rev_DM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_DM, !xgarde_DM, !yrprint_DM, !ygarde_DM, !zrprint_DM, !zgarde_DM

             if xrprint_DM = xgarde_DM & yrprint_DM = ygarde_DM & zrprint_DM = zgarde_DM,""
             else,
             [
             old_x_print_DM = old_x_DM
             old_y_print_DM = old_y_DM
             old_z_print_DM = old_z_DM
             if retplangarde = 0, pnumligne, pgcode_force_DM, *old_x_print_DM, *old_y_print_DM, *old_z_print_DM, e$
             ]

            #if mi3$ = 0 & mr2print_DM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_DM, *mr2print_DM ,e$
            #    pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, axeCpos1_DM, axeApos1_DM,e$, pnumligne, *zrprint_DM, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_DM = old_z_DM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM, axeCpos1_DM, axeApos1_DM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete 
                else, pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, *old_z_print_DM, axeCpos1_DM, axeApos1_DM, e$     #orientationtete
            #     ]



            if xrprint_DM <> xgarde_DM | yrprint_DM <> ygarde_DM | zrprint_DM <> zgarde_DM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

            pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zprint_DM,frplunge_DM, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_DM <> zrprint_DM, pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM,e$
                gcode$ = 0
                pnumligne, pgcode_force_DM, *xrprint_DM, *yrprint_DM, *zrprint_DM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_DM = xdegvec + nextx$
                yrprintrap_DM = ydegvec + nexty$
                zrprintrap_DM = zdegvec + nextz$
                pnumligne,pgcode_force_DM, *xrprintrap_DM, *yrprintrap_DM, *zrprintrap_DM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_DM, *xgarde_DM, *ygarde_DM, *zgarde_DM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_DM = axeCpos_DM
            old_axeApos_DM = axeApos_DM
            oldreel_axeCpos_DM = reel_axeCpos_DM

            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM

            oldstation_DM = mi4_DM
            frbase_DM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_DM,yprint_DM    ,zprint_DM, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_DM = ((Vx_DM/longvec) * (depth$ * -1)) + xprint_DM
            toy4print_DM = ((Vy_DM/longvec) * (depth$ * -1)) + yprint_DM
            toz4print_DM = ((Vz_DM/longvec) * (depth$ * -1)) + zprint_DM
            pvoir_DM

            if cycle_heli_spiral_DM = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_DM, *old_dest_ret_5x_DM,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_DM, *dest_ret_5x_DM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_DM, *old_dest_ret_5x_DM, e$
            else, pnumligne, pgcode_DM , *dest_ret_5x_DM,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_DM <>   -1,
            #    [
            #    #pcalxyz3d_DM
            #
            #    panul_plan_inc_DM
            #    pnumligne, *mr2print_DM ,e$
            #    xaproche = (((Vx_DM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_DM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_DM = (((Vz_DM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_DM longvec et xaproche", *Vx_DM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_DM, *xaproche, *yaproche, axeCpos1_DM, axeApos1_DM, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_DM = 0, axeApos1_DM = 0, axeCpos_DM = 0, axeApos_DM = 0]
            gcode$ = 0
            if blocaxe_DM = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_DM = 0

            if cycle_800 = 1,   [
                                pnumligne, "CYCLE800()", e$
                                spaces$ = 0
                                axeApos_cycle800_DM = axeApos_DM
                                axeCpos_cycle800_DM = axeCpos_DM
                                pnumligne, " CYCLE800(0,",34,"HEAD_DMS1",34,",100010,192,",*tox4print_DM,",",*toy4print_DM,",",*toz4print_DM,",",axeCpos_cycle800_DM,",",axeApos_cycle800_DM,",0,0,0,0,0,100,1)", e$
                                spaces$ = 1
                                ]
                        else,   [
                                pnumligne, "TRANS", e$, pnumligne, "ROT", e$
                                xaproche_DM = (((Vx_DM/longvec) * (initht$ - refht$) ) + ucal)
                                yaproche_DM = (((Vy_DM/longvec) * (initht$ - refht$) ) + vcal)
                                zaproche_DM = (((Vz_DM/longvec) * (initht$ - refht$) ) + wcal)
                                pnumligne,pgcode_force_DM, *xaproche_DM, *yaproche_DM, *zaproche_DM, axeCpos1_DM, axeApos1_DM, e$
                                pnumligne, "TRANS", tox4print_DM, toy4print_DM, toz4print_DM, e$, pnumligne, "AROT", axeCpos_DM, axeApos_DM, e$
                                ]

            xprint_DM = 0
            yprint_DM = 0
            if nextop$ <> 100, zinitht_DM = old_dest_ret_5x_DM
            else, zinitht_DM = dest_ret_5x_DM
            zprint_DM = refht$
            # n, pgcode_force_DM, axeCpos1_DM, axeApos1_DM, e                    #orientation tete
            # n, pgcode_force_DM, *x, *y, *zinitht_DM,e          # dep au plan garde            
            if axeApos1_DM > maxi_a_DM | axeApos1_DM < mini_a_DM, psortie10_DM
            #pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zinitht_DM, axeCpos1_DM, axeApos1_DM, e$                    #orientation tete+ garde
            pnumligne, pgcode_force_DM, *xprint_DM, *yprint_DM, *zinitht_DM, e$                    #orientation tete+ garde
            #n, pgcode_force_DM, *x, *y, *z, e
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_DM = 1
            old_tox4_DM = tox4print_DM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_DM = toy4print_DM
            old_toz4_DM = toz4print_DM
            old_axeCpos_DM = axeCpos_DM
            old_axeApos_DM = axeApos_DM
            oldreel_axeCpos_DM = reel_axeCpos_DM
            old_x_DM=xrprint_DM
            old_y_DM=yrprint_DM
            old_z_DM=zrprint_DM
            oldstation_DM = mi4_DM
            frbase_DM = fr$
            ]
#endregion
#region pdrill
pdrill$
            pchange_AG
            pdrill_AG

            pchange_AM
            pdrill_AM

            pchange_BG
            pdrill_BG

            pchange_BM
            pdrill_BM

            pchange_CG
            pdrill_CG

            pchange_CM
            pdrill_CM

            pchange_DG
            pdrill_DG

            pchange_DM
            pdrill_DM

pdrill_AG      # Cycle de percage G81
            #pvoir_AG

            pprint_AG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_AG = 1, pdrl5_AG

            if tete_rev_AG = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AG , @inithtprint_AG
           pnumligne, pgcode_AG, xprint_AG, yprint_AG, inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 1
           pnumligne, pgcode_AG, depthprint_AG, frplunge$ , e$
           gcode$ = 0
           pnumligne, pgcode_AG, inithtprint_AG, e$
           ]
           if tete_rev_AG = 0,
           [
            if drill5axes_AG = 1,
                    [
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    pnumligne, "G81", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, frplunge$, e$
                    if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                    ]

            else,   [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    pnumligne, "G81", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, frplunge$, e$
                    ]

            typcycle_AG = 1
           ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pdrill_BG      # Cycle de percage G81
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_BG = 1, tosz$ = 0
            #pvoir_BG
            sdis_BG = refht$ - tosz$
            pprint_BG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_BG = 1, pdrl5_BG

           if tete_rev_BG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_BG , @inithtprint_BG
                pnumligne, pgcode_BG, xprint_BG, yprint_BG, inithtprint_BG, e$
                if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, refhtprint_BG, e$
                gcode$ = 1
                pnumligne, pgcode_BG, depthprint_BG, frplunge$ , e$
                gcode$ = 0
                pnumligne, pgcode_BG, inithtprint_BG, e$
                ]
           if tete_rev_BG = 0,
                [
                if drill5axes_BG = 1,
                    [
                    initht5x_BG = refht$
                    pnumligne, frplunge$, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    #pnumligne, "G81", xprint_BG, yprint_BG, *depth$, *refht$, *initht5x_BG, frplunge$, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                    ]
                else,
                    [
                    pnumligne, frplunge$, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    typcycle_BG = 1
                    ]
                ]
           old_dest_ret_5x_BG = dest_ret_5x_BG

pdrill_CG      # Cycle de percage G81
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_CG = 1, tosz$ = 0
            #pvoir_CG
            sdis_CG = refht$ - tosz$
            pprint_CG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_CG = 1, pdrl5_CG

           if tete_rev_CG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_CG , @inithtprint_CG
                pnumligne, pgcode_CG, xprint_CG, yprint_CG, inithtprint_CG, e$
                if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, refhtprint_CG, e$
                gcode$ = 1

                if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                pnumligne, pgcode_CG, depthprint_CG, frplunge_CG , e$
                gcode$ = 0
                pnumligne, pgcode_CG, inithtprint_CG, e$
                ]
           if tete_rev_CG = 0,
                [
                if drill5axes_CG = 1,
                    [
                    initht5x_CG = refht$

                    if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                    else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                    pnumligne, frplunge_CG, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    #pnumligne, "G81", xprint_CG, yprint_CG, *depth$, *refht$, *initht5x_CG, frplunge$, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                    ]
                else,
                    [
                    if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                    else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                    pnumligne, frplunge_CG, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    typcycle_CG = 1
                    ]
                ]
           old_dest_ret_5x_CG = dest_ret_5x_CG

pdrill_DG      # Cycle de percage G81
            if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_DG = 1, tosz$ = 0
            #pvoir_DG
            sdis_DG = refht$ - tosz$
            pprint_DG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_DG = 1, pdrl5_DG

           if tete_rev_DG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_DG , @inithtprint_DG
                pnumligne, pgcode_DG, xprint_DG, yprint_DG, inithtprint_DG, e$
                if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, refhtprint_DG, e$
                gcode$ = 1

                if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                pnumligne, pgcode_DG, depthprint_DG, frplunge_DG , e$
                gcode$ = 0
                pnumligne, pgcode_DG, inithtprint_DG, e$
                ]
           if tete_rev_DG = 0,
                [
                if drill5axes_DG = 1,
                    [
                    initht5x_DG = refht$

                    if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                    else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                    pnumligne, frplunge_DG, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_DG,",", *tosz$, ",",*sdis_DG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_DG, *yprint_DG, e$
                    psouf_imp_DG
                    #pnumligne, "G81", xprint_DG, yprint_DG, *depth$, *refht$, *initht5x_DG, frplunge$, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                    ]
                else,
                    [
                    if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                    else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                    pnumligne, frplunge_DG, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_DG,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_DG, *yprint_DG, e$
                    psouf_imp_DG
                    typcycle_DG = 1
                    ]
                ]
           old_dest_ret_5x_DG = dest_ret_5x_DG

pdrill_AM      # Cycle de percage G81
            #pvoir_AM

            pprint_AM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_AM = 1, pdrl5_AM

            if tete_rev_AM = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AM , @inithtprint_AM
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           gcode$ = 0
           pnumligne, pgcode_AM, inithtprint_AM, e$
           ]
           if tete_rev_AM = 0,
           [
            if drill5axes_AM = 1,
                    [
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    frplunge_AM = frplunge$
                    pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM, e$
                    if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                    ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM, e$
                    ]
            typcycle_AM = 1
           ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pdrill_BM      # Cycle de percage G81
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_BM = 1, tosz$ = 0
            #pvoir_BM
            sdis_BM = refht$ - tosz$
            pprint_BM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_BM = 1, pdrl5_BM

           if tete_rev_BM = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_BM , @inithtprint_BM
                pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
                gcode$ = 1
                frplunge_BM = frplunge$
                pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
                gcode$ = 0
                pnumligne, pgcode_BM, inithtprint_BM, e$
                ]
           if tete_rev_BM = 0,
                [
                if drill5axes_BM = 1,
                    [
                    initht5x_BM = refht$
                    frplunge_BM = frplunge$
                    pnumligne, frplunge_BM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BM, *yprint_BM, e$
                    psouf_imp_BM
                    #pnumligne, "G81", xprint_BM, yprint_BM, *depth$, *refht$, *initht5x_BM, frplunge_BM, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                    ]
                else,
                    [
                    frplunge_BM = frplunge$
                    pnumligne, frplunge_BM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BM, *yprint_BM, e$
                    psouf_imp_BM
                    typcycle_BM = 1
                    ]
                ]
           old_dest_ret_5x_BM = dest_ret_5x_BM

pdrill_CM      # Cycle de percage G81
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_CM = 1, tosz$ = 0
            #pvoir_CM
            sdis_CM = refht$ - tosz$
            pprint_CM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_CM = 1, pdrl5_CM

           if tete_rev_CM = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_CM , @inithtprint_CM
                pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
                gcode$ = 1

                if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
                gcode$ = 0
                pnumligne, pgcode_CM, inithtprint_CM, e$
                ]
           if tete_rev_CM = 0,
                [
                if drill5axes_CM = 1,
                    [
                    initht5x_CM = refht$

                    if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                    else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                    pnumligne, frplunge_CM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CM, *yprint_CM, e$
                    psouf_imp_CM
                    #pnumligne, "G81", xprint_CM, yprint_CM, *depth$, *refht$, *initht5x_CM, frplunge_CM, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                    ]
                else,
                    [
                    if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                    else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                    pnumligne, frplunge_CM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CM, *yprint_CM, e$
                    psouf_imp_CM
                    typcycle_CM = 1
                    ]
                ]
           old_dest_ret_5x_CM = dest_ret_5x_CM

pdrill_DM      # Cycle de percage G81
            if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
            if drill5axes_DM = 1, tosz$ = 0
            #pvoir_DM
            sdis_DM = refht$ - tosz$
            pprint_DM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_DM = 1, pdrl5_DM

           if tete_rev_DM = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_DM , @inithtprint_DM
                pnumligne, pgcode_DM, xprint_DM, yprint_DM, inithtprint_DM, e$
                if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, refhtprint_DM, e$
                gcode$ = 1

                if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                pnumligne, pgcode_DM, depthprint_DM, frplunge_DM , e$
                gcode$ = 0
                pnumligne, pgcode_DM, inithtprint_DM, e$
                ]
           if tete_rev_DM = 0,
                [
                if drill5axes_DM = 1,
                    [
                    initht5x_DM = refht$

                    if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                    else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                    pnumligne, frplunge_DM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_DM,",", *tosz$, ",",*sdis_DM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_DM, *yprint_DM, e$
                    psouf_imp_DM
                    #pnumligne, "G81", xprint_DM, yprint_DM, *depth$, *refht$, *initht5x_DM, frplunge_DM, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                    ]
                else,
                    [
                    if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                    else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                    pnumligne, frplunge_DM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_DM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_DM, *yprint_DM, e$
                    psouf_imp_DM
                    typcycle_DM = 1
                    ]
                ]
           old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region ppeck
ppeck$
            pchange_AG
            ppeck_AG

            pchange_AM
            ppeck_AM

            pchange_BG
            ppeck_BG

            pchange_BM
            ppeck_BM

            pchange_CG
            ppeck_CG

            pchange_CM
            ppeck_CM

            pchange_DG
            ppeck_DG

            pchange_DM
            ppeck_DM

ppeck_AG     # Cycle de debourrage G83

            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            peck1_AG = peck1$
                            peck2_AG = peck2$
                            pnumligne, "G83", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, peck1_AG, peck2_AG, frplunge$,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                             ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                    pnumligne, "G83", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, peck1_AG, peck2_AG, frplunge$,e$
                    ]
            old_dest_ret_5x_AG = dest_ret_5x_AG

ppeck_BG     # Cycle de debourrage G83
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
            sdis_BG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BG = 1
            if drill5axes_BG = 1,
                            [
                            pdrl5_BG
                            initht5x_BG = refht$
                            pnumligne, frplunge$, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                             ]
            else,
                            [
                            pnumligne, frplunge$, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            ]
            old_dest_ret_5x_BG = dest_ret_5x_BG

ppeck_CG     # Cycle de debourrage G83
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
            sdis_CG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CG = 1
            if drill5axes_CG = 1,
                            [
                            pdrl5_CG
                            initht5x_CG = refht$

                            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                            pnumligne, frplunge_CG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                             ]
            else,
                            [
                            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                            pnumligne, frplunge_CG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            ]
            old_dest_ret_5x_CG = dest_ret_5x_CG

ppeck_DG     # Cycle de debourrage G83
            if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_DG = 1, psortie_DG
            pprint_DG
            if drill5axes_DG = 1, tosz$ = 0
            sdis_DG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_DG = 1
            if drill5axes_DG = 1,
                            [
                            pdrl5_DG
                            initht5x_DG = refht$

                            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                            pnumligne, frplunge_DG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DG,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DG, *yprint_DG, e$
                            psouf_imp_DG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                             ]
            else,
                            [
                            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                            pnumligne, frplunge_DG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DG, *yprint_DG, e$
                            psouf_imp_DG
                            ]
            old_dest_ret_5x_DG = dest_ret_5x_DG
ppeck_AM     # Cycle de debourrage G83
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            peck1_AM = peck1$
                            peck2_AM = peck2$
                            frplunge_AM = frplunge$
                            pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                    ]
            old_dest_ret_5x_AM = dest_ret_5x_AM

ppeck_BM     # Cycle de debourrage G83
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
            sdis_BM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BM = 1
            if drill5axes_BM = 1,
                            [
                            pdrl5_BM
                            initht5x_BM = refht$
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                             ]
            else,
                            [
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            ]
            old_dest_ret_5x_BM = dest_ret_5x_BM

ppeck_CM     # Cycle de debourrage G83
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
            sdis_CM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CM = 1
            if drill5axes_CM = 1,
                            [
                            pdrl5_CM
                            initht5x_CM = refht$

                            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                             ]
            else,
                            [
                            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            ]
            old_dest_ret_5x_CM = dest_ret_5x_CM

ppeck_DM     # Cycle de debourrage G83
            if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_DM = 1, psortie_DM
            pprint_DM
            if drill5axes_DM = 1, tosz$ = 0
            sdis_DM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_DM = 1
            if drill5axes_DM = 1,
                            [
                            pdrl5_DM
                            initht5x_DM = refht$

                            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                            pnumligne, frplunge_DM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DM,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DM, *yprint_DM, e$
                            psouf_imp_DM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                             ]
            else,
                            [
                            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                            pnumligne, frplunge_DM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DM, *yprint_DM, e$
                            psouf_imp_DM
                            ]
            old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region pchpbrk
pchpbrk$
            pchange_AG
            pchpbrk_AG

            pchange_AM
            pchpbrk_AM

            pchange_BG
            pchpbrk_BG

            pchange_BM
            pchpbrk_BM

            pchange_CG
            pchpbrk_CG

            pchange_CM
            pchpbrk_CM

            pchange_DG
            pchpbrk_DG

            pchange_DM
            pchpbrk_DM

pchpbrk_AG   # Cycle de brise copeaux G87
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            peckclr_AG = peckclr$
                            peck1_AG = peck1$
                            peck2_AG = peck2$
                            pnumligne, "G87", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, peck1_AG, peck2_AG, peckclr_AG, frplunge$,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                             ]

           else,        [
                        depth_AG = depth$
                        refht_AG = refht$
                        dwell_AG = dwell$
                        initht_AG = initht$
                        peck1_AG = peck1$
                        peck2_AG = peck2$
                        pnumligne, "G87", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, peck1_AG, peck2_AG, dwell_AG, frplunge$,e$
                        ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pchpbrk_BG   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
            sdis_BG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BG = 1
            if drill5axes_BG = 1,
                            [
                            pdrl5_BG
                            initht5x_BG = refht$
                            pnumligne, frplunge$, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                             ]
            else,
                            [
                            pnumligne, frplunge$, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            ]
            old_dest_ret_5x_BG = dest_ret_5x_BG

pchpbrk_CG   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
            sdis_CG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CG = 1
            if drill5axes_CG = 1,
                            [
                            pdrl5_CG
                            initht5x_CG = refht$
                            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                            pnumligne, frplunge_CG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                             ]
            else,
                            [
                            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG
                            pnumligne, frplunge_CG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            ]
            old_dest_ret_5x_CG = dest_ret_5x_CG

pchpbrk_DG   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_DG = 1, psortie_DG
            pprint_DG
            if drill5axes_DG = 1, tosz$ = 0
            sdis_DG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_DG = 1
            if drill5axes_DG = 1,
                            [
                            pdrl5_DG
                            initht5x_DG = refht$
                            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                            pnumligne, frplunge_DG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DG,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DG, *yprint_DG, e$
                            psouf_imp_DG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                             ]
            else,
                            [
                            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG
                            pnumligne, frplunge_DG, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DG, *yprint_DG, e$
                            psouf_imp_DG
                            ]
            old_dest_ret_5x_DG = dest_ret_5x_DG
pchpbrk_AM   # Cycle de brise copeaux G87
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            peckclr_AM = peckclr$
                            peck1_AM = peck1$
                            peck2_AM = peck2$
                            frplunge_AM = frplunge$
                            pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, peckclr_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    dwell_AM = dwell$
                    initht_AM = initht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, peck1_AM, peck2_AM, dwell_AM, frplunge_AM,e$
                    ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pchpbrk_BM   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
            sdis_BM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BM = 1
            if drill5axes_BM = 1,
                            [
                            pdrl5_BM
                            initht5x_BM = refht$
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                             ]
            else,
                            [
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            ]
            old_dest_ret_5x_BM = dest_ret_5x_BM

pchpbrk_CM   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
            sdis_CM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CM = 1
            if drill5axes_CM = 1,
                            [
                            pdrl5_CM
                            initht5x_CM = refht$
                            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                             ]
            else,
                            [
                            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            ]
            old_dest_ret_5x_CM = dest_ret_5x_CM

pchpbrk_DM   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_DM = 1, psortie_DM
            pprint_DM
            if drill5axes_DM = 1, tosz$ = 0
            sdis_DM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_DM = 1
            if drill5axes_DM = 1,
                            [
                            pdrl5_DM
                            initht5x_DM = refht$
                            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                            pnumligne, frplunge_DM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DM,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DM, *yprint_DM, e$
                            psouf_imp_DM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                             ]
            else,
                            [
                            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

                            pnumligne, frplunge_DM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_DM, *yprint_DM, e$
                            psouf_imp_DM
                            ]
            old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region ptap
ptap$
            pchange_AG
            ptap_AG

            pchange_AM
            ptap_AM

            pchange_BG
            ptap_BG

            pchange_BM
            ptap_BM

            pchange_CG
            ptap_CG

            pchange_CM
            ptap_CM

            pchange_DG
            ptap_DG

            pchange_DM
            ptap_DM

ptap_AG        # Cycle de taraudage G84
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1

            if tldia$ = 3, pas_AG = 0.5
            if tldia$ = 4, pas_AG = 0.7
            if tldia$ = 5, pas_AG = 0.8
            if tldia$ = 6, pas_AG = 1
            if tldia$ = 8, pas_AG = 1.25
            if tldia$ = 10, pas_AG = 1.5
            if tldia$ = 12, pas_AG = 1.75
            if tldia$ = 14, pas_AG = 2
            if tldia$ = 16, pas_AG = 2
            if retr$ <> 0, pas_AG = retr$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            pnumligne, "G84", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, pas_AG,e$
            old_dest_ret_5x_AG = dest_ret_5x_AG

ptap_BG        # Cycle de taraudage G84
            psortie2_BG

ptap_CG        # Cycle de taraudage G84
            psortie2_CG
ptap_DG        # Cycle de taraudage G84
            psortie2_DG

ptap_AM        # Cycle de taraudage G84
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1

            if tldia$ = 3, pas_AM = 0.5
            if tldia$ = 4, pas_AM = 0.7
            if tldia$ = 5, pas_AM = 0.8
            if tldia$ = 6, pas_AM = 1
            if tldia$ = 8, pas_AM = 1.25
            if tldia$ = 10, pas_AM = 1.5
            if tldia$ = 12, pas_AM = 1.75
            if tldia$ = 14, pas_AM = 2
            if tldia$ = 16, pas_AM = 2
            if retr$ <> 0, pas_AM = retr$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            pnumligne, "G84", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, pas_AM,e$
            old_dest_ret_5x_AM = dest_ret_5x_AM

ptap_BM        # Cycle de taraudage G84
            psortie2_BM

ptap_CM        # Cycle de taraudage G84
            psortie2_CM
ptap_DM        # Cycle de taraudage G84
            psortie2_DM
#endregion
#region pmisc1
pmisc1$
            pchange_AG
            pmisc1_AG

            pchange_AM
            pmisc1_AM

            pchange_BG
            pmisc1_BG

            pchange_BM
            pmisc1_BM

            pchange_CG
            pmisc1_CG

            pchange_CM
            pmisc1_CM

            pchange_DG
            pmisc1_DG

            pchange_DM
            pmisc1_DM

pmisc1_AG      # Cycle d'alesage par points
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            pnumligne, "G82", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, frplunge$,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                             ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    pnumligne, "G82", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, frplunge$,e$
                    ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pmisc1_BG      # Cycle d'alesage G85
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
            sdis_BG = refht$ - tosz$
            avance_plonge = frplunge$
            typepercage = 1
            if drill5axes_BG = 1, pdrl5_BG

            if tete_rev_BG = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_BG , @inithtprint_BG
                                pnumligne, pgcode_BG, xprint_BG, yprint_BG, inithtprint_BG, e$
                                if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, refhtprint_BG, e$
                                gcode$ = 1
                                pnumligne, pgcode_force_BG, depthprint_BG, frplunge$ , e$
                                pnumligne, pgcode_BG, refhtprint_BG, e$
                                gcode$ = 0
                                if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, inithtprint_BG, e$
                                ]
           if tete_rev_BG = 0,
                                [
                                if drill5axes_BG = 1,
                                                [

                                                initht5x_BG = refht$
                                                pnumligne, frplunge$, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_BG,",", *tosz$, ",",sdis_BG,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BG, *yprint_BG, e$
                                                psouf_imp_BG
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                                                ]
                                else,
                                                [
                                                pnumligne, frplunge$, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_BG,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BG, *yprint_BG, e$
                                                psouf_imp_BG
                                                ]
                                typcycle_BG = 1
                                ]
           old_dest_ret_5x_BG = dest_ret_5x_BG

pmisc1_CG      # Cycle d'alesage G85
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
            sdis_CG = refht$ - tosz$
            if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
            else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

            avance_plonge_CG = frplunge_CG
            typepercage = 1
            if drill5axes_CG = 1, pdrl5_CG

            if tete_rev_CG = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_CG , @inithtprint_CG
                                pnumligne, pgcode_CG, xprint_CG, yprint_CG, inithtprint_CG, e$
                                if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, refhtprint_CG, e$
                                gcode$ = 1
                                if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                                else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

                                pnumligne, pgcode_force_CG, depthprint_CG, frplunge_CG , e$
                                pnumligne, pgcode_CG, refhtprint_CG, e$
                                gcode$ = 0
                                if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, inithtprint_CG, e$
                                ]
           if tete_rev_CG = 0,
                                [
                                if drill5axes_CG = 1,
                                                [

                                                initht5x_CG = refht$
                                                if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                                                else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG
                                                pnumligne, frplunge_CG, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_CG,",", *tosz$, ",",sdis_CG,",", *depth$,",, ",dwell$,",",*avance_plonge_CG,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CG, *yprint_CG, e$
                                                psouf_imp_CG
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                                                ]
                                else,
                                                [
                                                if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
                                                else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG
                                                pnumligne, frplunge_CG, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_CG,",", *depth$,",,",dwell$,",",avance_plonge_CG,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CG, *yprint_CG, e$
                                                psouf_imp_CG
                                                ]
                                typcycle_CG = 1
                                ]
           old_dest_ret_5x_CG = dest_ret_5x_CG

pmisc1_DG      # Cycle d'alesage G85
            if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_DG
            if drill5axes_DG = 1, tosz$ = 0
            sdis_DG = refht$ - tosz$
            if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
            else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

            avance_plonge_DG = frplunge_DG
            typepercage = 1
            if drill5axes_DG = 1, pdrl5_DG

            if tete_rev_DG = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_DG , @inithtprint_DG
                                pnumligne, pgcode_DG, xprint_DG, yprint_DG, inithtprint_DG, e$
                                if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, refhtprint_DG, e$
                                gcode$ = 1
                                if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                                else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

                                pnumligne, pgcode_force_DG, depthprint_DG, frplunge_DG , e$
                                pnumligne, pgcode_DG, refhtprint_DG, e$
                                gcode$ = 0
                                if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, inithtprint_DG, e$
                                ]
           if tete_rev_DG = 0,
                                [
                                if drill5axes_DG = 1,
                                                [

                                                initht5x_DG = refht$
                                                if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                                                else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG
                                                pnumligne, frplunge_DG, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_DG,",", *tosz$, ",",sdis_DG,",", *depth$,",, ",dwell$,",",*avance_plonge_DG,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_DG, *yprint_DG, e$
                                                psouf_imp_DG
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                                                ]
                                else,
                                                [
                                                if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
                                                else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG
                                                pnumligne, frplunge_DG, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_DG,",", *depth$,",,",dwell$,",",avance_plonge_DG,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_DG, *yprint_DG, e$
                                                psouf_imp_DG
                                                ]
                                typcycle_DG = 1
                                ]
           old_dest_ret_5x_DG = dest_ret_5x_DG

pmisc1_AM      # Cycle d'alesage par points
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            frplunge_AM = frplunge$
                            pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM,e$
                    ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pmisc1_BM      # Cycle d'alesage G85
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
            sdis_BM = refht$ - tosz$
            frplunge_BM = frplunge$
            avance_plonge = frplunge_BM
            typepercage = 1
            if drill5axes_BM = 1, pdrl5_BM

            if tete_rev_BM = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_BM , @inithtprint_BM
                                pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
                                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
                                gcode$ = 1
                                frplunge_BM = frplunge$
                                pnumligne, pgcode_force_BM, depthprint_BM, frplunge_BM , e$
                                pnumligne, pgcode_BM, refhtprint_BM, e$
                                gcode$ = 0
                                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, inithtprint_BM, e$
                                ]
           if tete_rev_BM = 0,
                                [
                                if drill5axes_BM = 1,
                                                [

                                                initht5x_BM = refht$
                                                frplunge_BM = frplunge$
                                                pnumligne, frplunge_BM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_BM,",", *tosz$, ",",sdis_BM,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BM, *yprint_BM, e$
                                                psouf_imp_BM
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                                ]
                                else,
                                                [
                                                frplunge_BM = frplunge$
                                                pnumligne, frplunge_BM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_BM,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BM, *yprint_BM, e$
                                                psouf_imp_BM
                                                ]
                                typcycle_BM = 1
                                ]
           old_dest_ret_5x_BM = dest_ret_5x_BM

pmisc1_CM      # Cycle d'alesage G85
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
            sdis_CM = refht$ - tosz$
            if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
            else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM
            avance_plonge_CM = frplunge_CM
            typepercage = 1
            if drill5axes_CM = 1, pdrl5_CM

            if tete_rev_CM = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_CM , @inithtprint_CM
                                pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
                                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
                                gcode$ = 1
                                if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                                else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM
                                pnumligne, pgcode_force_CM, depthprint_CM, frplunge_CM , e$
                                pnumligne, pgcode_CM, refhtprint_CM, e$
                                gcode$ = 0
                                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, inithtprint_CM, e$
                                ]
           if tete_rev_CM = 0,
                                [
                                if drill5axes_CM = 1,
                                                [

                                                initht5x_CM = refht$
                                                if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                                                else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM
                                                pnumligne, frplunge_CM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_CM,",", *tosz$, ",",sdis_CM,",", *depth$,",, ",dwell$,",",*avance_plonge_CM,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CM, *yprint_CM, e$
                                                psouf_imp_CM
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                                ]
                                else,
                                                [
                                                if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
                                                else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM
                                                pnumligne, frplunge_CM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_CM,",", *depth$,",,",dwell$,",",avance_plonge_CM,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CM, *yprint_CM, e$
                                                psouf_imp_CM
                                                ]
                                typcycle_CM = 1
                                ]
           old_dest_ret_5x_CM = dest_ret_5x_CM

pmisc1_DM      # Cycle d'alesage G85
            if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_DM
            if drill5axes_DM = 1, tosz$ = 0
            sdis_DM = refht$ - tosz$
            if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
            else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM
            avance_plonge_DM = frplunge_DM
            typepercage = 1
            if drill5axes_DM = 1, pdrl5_DM

            if tete_rev_DM = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_DM , @inithtprint_DM
                                pnumligne, pgcode_DM, xprint_DM, yprint_DM, inithtprint_DM, e$
                                if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, refhtprint_DM, e$
                                gcode$ = 1
                                if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                                else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM
                                pnumligne, pgcode_force_DM, depthprint_DM, frplunge_DM , e$
                                pnumligne, pgcode_DM, refhtprint_DM, e$
                                gcode$ = 0
                                if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, inithtprint_DM, e$
                                ]
           if tete_rev_DM = 0,
                                [
                                if drill5axes_DM = 1,
                                                [

                                                initht5x_DM = refht$
                                                if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                                                else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM
                                                pnumligne, frplunge_DM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_DM,",", *tosz$, ",",sdis_DM,",", *depth$,",, ",dwell$,",",*avance_plonge_DM,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_DM, *yprint_DM, e$
                                                psouf_imp_DM
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                                                ]
                                else,
                                                [
                                                if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
                                                else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM
                                                pnumligne, frplunge_DM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_DM,",", *depth$,",,",dwell$,",",avance_plonge_DM,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_DM, *yprint_DM, e$
                                                psouf_imp_DM
                                                ]
                                typcycle_DM = 1
                                ]
           old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region pbore2
pbore2$
            pchange_AG
            pbore2_AG

            pchange_AM
            pbore2_AM

            pchange_BG
            pbore2_BG

            pchange_BM
            pbore2_BM

            pchange_CG
            pbore2_CG

            pchange_CM
            pbore2_CM

            pchange_DG
            pbore2_DG

            pchange_DM
            pbore2_DM

pbore2_AG      # alesage indexe G86
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1, pdrl5_AG
            if drill5axes_AG = 1, initht$ = refht$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            pnumligne, "G86", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, "EP.2 EC0. EA180.", frplunge$, e$
            if drill5axes_AG = 1, pnumligne, "G80", *zinitht_AG, e$
            old_dest_ret_5x_AG = dest_ret_5x_AG

pbore2_BG      # alesage indexe G86
            psortie2_BG

pbore2_CG      # alesage indexe G86
            psortie2_CG
pbore2_DG      # alesage indexe G86
            psortie2_DG
pbore2_AM      # alesage indexe G86
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1, pdrl5_AM
            if drill5axes_AM = 1, initht$ = refht$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            frplunge_AM = frplunge$
            pnumligne, "G86", *xprint_AM, *yprint_AM, *depth_AM, *refht_AM, *initht_AM, "EP.2 EC0. EA180.", frplunge_AM, e$
            if drill5axes_AM = 1, pnumligne, "G80", *zinitht_AM, e$
            old_dest_ret_5x_AM = dest_ret_5x_AM

pbore2_BM      # alesage indexe G86
            psortie2_BM

pbore2_CM      # alesage indexe G86
            psortie2_CM
pbore2_DM      # alesage indexe G86
            psortie2_DM
#endregion
#region pbore1

pbore1$
            pchange_AG
            pbore1_AG

            pchange_AM
            pbore1_AM

            pchange_BG
            pbore1_BG

            pchange_BM
            pbore1_BM

            pchange_CG
            pbore1_CG

            pchange_CM
            pbore1_CM

            pchange_DG
            pbore1_DG

            pchange_DM
            pbore1_DM

pbore1_AG      # Cycle d'alesage G85

            pprint_AG
            typepercage = 1
            if drill5axes_AG = 1, pdrl5_AG

            if tete_rev_AG = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AG , @inithtprint_AG
           pnumligne, pgcode_AG, xprint_AG, yprint_AG, inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 1
           pnumligne, pgcode_force_AG, depthprint_AG, frplunge$ , e$
           pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 0
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, inithtprint_AG, e$
           ]
           if tete_rev_AG = 0,
           [
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            pnumligne, "G85", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, frplunge$, e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                             ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    pnumligne, "G85", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, frplunge$, e$
                    ]
           typcycle_AG = 1
           ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pbore1_BG      # Cycle d'alesage par points
            psortie2_BG

pbore1_CG      # Cycle d'alesage par points
            psortie2_CG

pbore1_DG      # Cycle d'alesage par points
            psortie2_DG

pbore1_AM      # Cycle d'alesage G85

            pprint_AM
            typepercage = 1
            if drill5axes_AM = 1, pdrl5_AM

            if tete_rev_AM = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AM , @inithtprint_AM
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_force_AM, depthprint_AM, frplunge_AM , e$
           pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 0
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, inithtprint_AM, e$
           ]
           if tete_rev_AM = 0,
           [
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            frplunge_AM = frplunge$
                            pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM, e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM, e$
                    ]
           typcycle_AM = 1
           ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pbore1_BM      # Cycle d'alesage par points
            psortie2_BM

pbore1_CM      # Cycle d'alesage par points
            psortie2_CM

pbore1_DM      # Cycle d'alesage par points
            psortie2_DM
#endregion
#region pmisc2_OLD 

pmisc2_OLD_BG     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_BG
                        !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_OLD_CG     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_CG
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
pmisc2_OLD_DG     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_DG
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
pmisc2_OLD_BM     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_BM
                        !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_OLD_CM     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_CM
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
pmisc2_OLD_DM     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_DM
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pmisc2
pmisc2$
            pchange_AG
            pmisc2_AG

            pchange_AM
            pmisc2_AM

            pchange_BG
            pmisc2_BG

            pchange_BM
            pmisc2_BM

            pchange_CG
            pmisc2_CG

            pchange_CM
            pmisc2_CM

            pchange_DG
            pmisc2_DG

            pchange_DM
            pmisc2_DM

pmisc2_AG      # Cycle  special helicoido-spiral
            pnumligne, sdcom_par, " DEBUT CYCLE CAQ", sfcom_par, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_AG
                            initht5x_AG = refht$
                            percage_helicoido_spiral_AG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AG, *old_zinitht_AG, e$
                             ]
           else, percage_helicoido_spiral_AG
           old_dest_ret_5x_AG = dest_ret_5x_AG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_BG      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            typcycle_BG = 1
            if drill5axes_BG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_BG
                            initht5x_BG = refht$
                            percage_helicoido_spiral_BG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BG, *old_zinitht_BG, e$
                             ]
           else, percage_helicoido_spiral_BG
           old_dest_ret_5x_BG = dest_ret_5x_BG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_CG      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            typcycle_CG = 1
            if drill5axes_CG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_CG
                            initht5x_CG = refht$
                            percage_helicoido_spiral_CG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CG, *old_zinitht_CG, e$
                             ]
           else, percage_helicoido_spiral_CG
           old_dest_ret_5x_CG = dest_ret_5x_CG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_DG      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_DG = 1, psortie_DG
            pprint_DG
            typcycle_DG = 1
            if drill5axes_DG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_DG
                            initht5x_DG = refht$
                            percage_helicoido_spiral_DG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DG, *old_zinitht_DG, e$
                             ]
           else, percage_helicoido_spiral_DG
           old_dest_ret_5x_DG = dest_ret_5x_DG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_AM      # Cycle  special helicoido-spiral
            pnumligne, sdcom_par, " DEBUT CYCLE CAQ", sfcom_par, e$
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_AM
                            initht5x_AM = refht$
                            percage_helicoido_spiral_AM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                             ]
           else, percage_helicoido_spiral_AM
           old_dest_ret_5x_AM = dest_ret_5x_AM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_BM      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            typcycle_BM = 1
            if drill5axes_BM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_BM
                            initht5x_BM = refht$
                            percage_helicoido_spiral_BM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                             ]
           else, percage_helicoido_spiral_BM
           old_dest_ret_5x_BM = dest_ret_5x_BM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_CM      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            typcycle_CM = 1
            if drill5axes_CM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_CM
                            initht5x_CM = refht$
                            percage_helicoido_spiral_CM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                             ]
           else, percage_helicoido_spiral_CM
           old_dest_ret_5x_CM = dest_ret_5x_CM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_DM      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_DM = 1, psortie_DM
            pprint_DM
            typcycle_DM = 1
            if drill5axes_DM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_DM
                            initht5x_DM = refht$
                            percage_helicoido_spiral_DM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DM, *old_zinitht_DM, e$
                             ]
           else, percage_helicoido_spiral_DM
           old_dest_ret_5x_DM = dest_ret_5x_DM
            !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pdrill_2
pdrill_2$
            pchange_AG
            pdrill_2_AG

            pchange_AM
            pdrill_2_AM

            pchange_BG
            pdrill_2_BG

            pchange_BM
            pdrill_2_BM

            pchange_CG
            pdrill_2_CG

            pchange_CM
            pdrill_2_CM

            pchange_DG
            pdrill_2_DG

            pchange_DM
            pdrill_2_DM

pdrill_2_AG    # Canned Drill Cycle
            #Pvoir_AG
            pprint_AG
            if drill5axes_AG = 1, pdrl5_2_AG
             if tete_rev_AG = 1 & mod5xcont = 0,
              [
            @refhtprint_AG , @inithtprint_AG
           gcode$ = 0
           pnumligne, pgcode_AG, xprint_AG, yprint_AG, inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 1
           pnumligne, pgcode_AG, depthprint_AG, frplunge$ , e$
           gcode$ = 0
           pnumligne, pgcode_AG, inithtprint_AG, e$
             ]
           if tete_rev_AG = 0,
             [
        if drill5axes_AG = 1, [
                initht5x_AG = refht$
                depth_AG = depth$
                refht_AG = refht$
                pnumligne, "G81", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, frplunge$,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                            ]

        else,   [
                depth_AG = depth$
                refht_AG = refht$
                initht_AG = initht$
                pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                ]
        old_dest_ret_5x_AG = dest_ret_5x_AG
           ]

pdrill_2_BG    # Canned Drill Cycle
            #Pvoir_BG
            pprint_BG
            if drill5axes_BG = 1, pdrl5_2_BG
             if tete_rev_BG = 1 & mod5xcont = 0,
              [
            @refhtprint_BG , @inithtprint_BG
           gcode$ = 0
           pnumligne, pgcode_BG, xprint_BG, yprint_BG, inithtprint_BG, e$
           if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, refhtprint_BG, e$
           gcode$ = 1
           pnumligne, pgcode_BG, depthprint_BG, frplunge$ , e$
           gcode$ = 0
           pnumligne, pgcode_BG, inithtprint_BG, e$
             ]
           if tete_rev_BG = 0,
                        [
                        if drill5axes_BG = 1, [
                        tosz$ = 0
                        initht5x_BG = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_BG, *yprint_BG, e$
                        psouf_imp_BG
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                        ]
        else, pnumligne, xprint_BG, yprint_BG, e$, # depth$, refht$, initht$,e$
        psouf_imp_BG
        old_dest_ret_5x_BG = dest_ret_5x_BG
           ]

pdrill_2_CG    # Canned Drill Cycle
            #Pvoir_CG
            pprint_CG
            if drill5axes_CG = 1, pdrl5_2_CG
             if tete_rev_CG = 1 & mod5xcont = 0,
              [
            @refhtprint_CG , @inithtprint_CG
           gcode$ = 0
           pnumligne, pgcode_CG, xprint_CG, yprint_CG, inithtprint_CG, e$
           if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, refhtprint_CG, e$
           gcode$ = 1
           if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
           else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

           pnumligne, pgcode_CG, depthprint_CG, frplunge_CG , e$
           gcode$ = 0
           pnumligne, pgcode_CG, inithtprint_CG, e$
             ]
           if tete_rev_CG = 0,
                        [
                        if drill5axes_CG = 1, [
                        tosz$ = 0
                        initht5x_CG = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_CG, *yprint_CG, e$
                        psouf_imp_CG
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                        ]
        else, pnumligne, xprint_CG, yprint_CG, e$, # depth$, refht$, initht$,e$
        psouf_imp_CG
        old_dest_ret_5x_CG = dest_ret_5x_CG
           ]

pdrill_2_DG    # Canned Drill Cycle
            #Pvoir_DG
            pprint_DG
            if drill5axes_DG = 1, pdrl5_2_DG
             if tete_rev_DG = 1 & mod5xcont = 0,
              [
            @refhtprint_DG , @inithtprint_DG
           gcode$ = 0
           pnumligne, pgcode_DG, xprint_DG, yprint_DG, inithtprint_DG, e$
           if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, refhtprint_DG, e$
           gcode$ = 1
           if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
           else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

           pnumligne, pgcode_DG, depthprint_DG, frplunge_DG , e$
           gcode$ = 0
           pnumligne, pgcode_DG, inithtprint_DG, e$
             ]
           if tete_rev_DG = 0,
                        [
                        if drill5axes_DG = 1, [
                        tosz$ = 0
                        initht5x_DG = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_DG,",", *tosz$, ",",*sdis_DG,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_DG, *yprint_DG, e$
                        psouf_imp_DG
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                        ]
        else, pnumligne, xprint_DG, yprint_DG, e$, # depth$, refht$, initht$,e$
        psouf_imp_DG
        old_dest_ret_5x_DG = dest_ret_5x_DG
           ]
pdrill_2_AM    # Canned Drill Cycle
            #Pvoir_AM
            pprint_AM
            if drill5axes_AM = 1, pdrl5_2_AM
             if tete_rev_AM = 1 & mod5xcont = 0,
              [
            @refhtprint_AM , @inithtprint_AM
           gcode$ = 0
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           gcode$ = 0
           pnumligne, pgcode_AM, inithtprint_AM, e$
             ]
           if tete_rev_AM = 0,
             [
        if drill5axes_AM = 1, [
                initht5x_AM = refht$
                depth_AM = depth$
                refht_AM = refht$
                frplunge_AM = frplunge$
                pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                            ]

        else,   [
                depth_AM = depth$
                refht_AM = refht$
                initht_AM = initht$
                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                ]
        old_dest_ret_5x_AM = dest_ret_5x_AM
           ]

pdrill_2_BM    # Canned Drill Cycle
            #Pvoir_BM
            pprint_BM
            if drill5axes_BM = 1, pdrl5_2_BM
             if tete_rev_BM = 1 & mod5xcont = 0,
              [
            @refhtprint_BM , @inithtprint_BM
           gcode$ = 0
           pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
           gcode$ = 0
           pnumligne, pgcode_BM, inithtprint_BM, e$
             ]
           if tete_rev_BM = 0,
                        [
                        if drill5axes_BM = 1, [
                        tosz$ = 0
                        initht5x_BM = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_BM, *yprint_BM, e$
                        psouf_imp_BM
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                        ]
        else, pnumligne, xprint_BM, yprint_BM, e$, # depth$, refht$, initht$,e$
        psouf_imp_BM
        old_dest_ret_5x_BM = dest_ret_5x_BM
           ]

pdrill_2_CM    # Canned Drill Cycle
            #Pvoir_CM
            pprint_CM
            if drill5axes_CM = 1, pdrl5_2_CM
             if tete_rev_CM = 1 & mod5xcont = 0,
              [
            @refhtprint_CM , @inithtprint_CM
           gcode$ = 0
           pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 1
           if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
           else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

           pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
           gcode$ = 0
           pnumligne, pgcode_CM, inithtprint_CM, e$
             ]
           if tete_rev_CM = 0,
                        [
                        if drill5axes_CM = 1, [
                        tosz$ = 0
                        initht5x_CM = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_CM, *yprint_CM, e$
                        psouf_imp_CM
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                        ]
        else, pnumligne, xprint_CM, yprint_CM, e$, # depth$, refht$, initht$,e$
        psouf_imp_CM
        old_dest_ret_5x_CM = dest_ret_5x_CM
           ]

pdrill_2_DM    # Canned Drill Cycle
            #Pvoir_DM
            pprint_DM
            if drill5axes_DM = 1, pdrl5_2_DM
             if tete_rev_DM = 1 & mod5xcont = 0,
              [
            @refhtprint_DM , @inithtprint_DM
           gcode$ = 0
           pnumligne, pgcode_DM, xprint_DM, yprint_DM, inithtprint_DM, e$
           if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, refhtprint_DM, e$
           gcode$ = 1
           if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
           else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

           pnumligne, pgcode_DM, depthprint_DM, frplunge_DM , e$
           gcode$ = 0
           pnumligne, pgcode_DM, inithtprint_DM, e$
             ]
           if tete_rev_DM = 0,
                        [
                        if drill5axes_DM = 1, [
                        tosz$ = 0
                        initht5x_DM = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_DM,",", *tosz$, ",",*sdis_DM,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_DM, *yprint_DM, e$
                        psouf_imp_DM
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                        ]
        else, pnumligne, xprint_DM, yprint_DM, e$, # depth$, refht$, initht$,e$
        psouf_imp_DM
        old_dest_ret_5x_DM = dest_ret_5x_DM
           ]
#endregion
#region ppeck_2
ppeck_2$
            pchange_AG
            ppeck_2_AG

            pchange_AM
            ppeck_2_AM

            pchange_BG
            ppeck_2_BG

            pchange_BM
            ppeck_2_BM

            pchange_CG
            ppeck_2_CG

            pchange_CM
            ppeck_2_CM

            pchange_DG
            ppeck_2_DG

            pchange_DM
            ppeck_2_DM

ppeck_2_AG     # Canned Peck Drill Cycle
            pprint_AG
            if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                     pnumligne, "G83", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, peck1_AG, peck2_AG, frplunge$,e$
                      if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                                ]

            else,   [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                    ]
             old_dest_ret_5x_AG = dest_ret_5x_AG

ppeck_2_BG     # Canned Peck Drill Cycle
            pprint_BG
            if drill5axes_BG = 1,[
                    pdrl5_2_BG
                    tosz$ = 0
                    initht5x_BG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BG, yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                                ]
            else, pnumligne, xprint_BG, yprint_BG, e$ #depth$, refht$, initht$,e$
            psouf_imp_BG
             old_dest_ret_5x_BG = dest_ret_5x_BG

ppeck_2_CG     # Canned Peck Drill Cycle
            pprint_CG
            if drill5axes_CG = 1,[
                    pdrl5_2_CG
                    tosz$ = 0
                    initht5x_CG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CG, yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                                ]
            else, pnumligne, xprint_CG, yprint_CG, e$ #depth$, refht$, initht$,e$
            psouf_imp_CG
             old_dest_ret_5x_CG = dest_ret_5x_CG

ppeck_2_DG     # Canned Peck Drill Cycle
            pprint_DG
            if drill5axes_DG = 1,[
                    pdrl5_2_DG
                    tosz$ = 0
                    initht5x_DG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DG,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_DG, yprint_DG, e$
                            psouf_imp_DG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                                ]
            else, pnumligne, xprint_DG, yprint_DG, e$ #depth$, refht$, initht$,e$
            psouf_imp_DG
             old_dest_ret_5x_DG = dest_ret_5x_DG
ppeck_2_AM     # Canned Peck Drill Cycle
            pprint_AM
            if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                     pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                      if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                                ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                    ]
             old_dest_ret_5x_AM = dest_ret_5x_AM

ppeck_2_BM     # Canned Peck Drill Cycle
            pprint_BM
            if drill5axes_BM = 1,[
                    pdrl5_2_BM
                    tosz$ = 0
                    initht5x_BM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BM, yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                ]
            else, pnumligne, xprint_BM, yprint_BM, e$ #depth$, refht$, initht$,e$
            psouf_imp_BM
             old_dest_ret_5x_BM = dest_ret_5x_BM

ppeck_2_CM     # Canned Peck Drill Cycle
            pprint_CM
            if drill5axes_CM = 1,[
                    pdrl5_2_CM
                    tosz$ = 0
                    initht5x_CM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CM, yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                ]
            else, pnumligne, xprint_CM, yprint_CM, e$ #depth$, refht$, initht$,e$
            psouf_imp_CM
             old_dest_ret_5x_CM = dest_ret_5x_CM

ppeck_2_DM     # Canned Peck Drill Cycle
            pprint_DM
            if drill5axes_DM = 1,[
                    pdrl5_2_DM
                    tosz$ = 0
                    initht5x_DM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DM,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_DM, yprint_DM, e$
                            psouf_imp_DM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                                ]
            else, pnumligne, xprint_DM, yprint_DM, e$ #depth$, refht$, initht$,e$
            psouf_imp_DM
             old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region pchpbrk_2
pchpbrk_2$
            pchange_AG
            pchpbrk_2_AG

            pchange_AM
            pchpbrk_2_AM

            pchange_BG
            pchpbrk_2_BG

            pchange_BM
            pchpbrk_2_BM

            pchange_CG
            pchpbrk_2_CG

            pchange_CM
            pchpbrk_2_CM

            pchange_DG
            pchpbrk_2_DG

            pchange_DM
            pchpbrk_2_DM

pchpbrk_2_AG   # Canned Chip Break Cycle
            pprint_AG
        if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    peckclr_AG = peckclr$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                    pnumligne, "G87", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, peck1_AG, peck2_AG, peckclr_AG, frplunge$,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                        ]

                         else,  [
                                depth_AG = depth$
                                refht_AG = refht$
                                initht_AG = initht$
                                pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                                ]
                     old_dest_ret_5x_AG = dest_ret_5x_AG

pchpbrk_2_BG   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_BG
            if drill5axes_BG = 1,[
                    pdrl5_2_BG
                    tosz$ = 0
                    initht5x_BG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BG, yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                                ]
            else, pnumligne, xprint_BG, yprint_BG, e$ #depth$, refht$, initht$,e$
            psouf_imp_BG
             old_dest_ret_5x_BG = dest_ret_5x_BG

pchpbrk_2_CG   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_CG
            if drill5axes_CG = 1,[
                    pdrl5_2_CG
                    tosz$ = 0
                    initht5x_CG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CG, yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                                ]
            else, pnumligne, xprint_CG, yprint_CG, e$ #depth$, refht$, initht$,e$
            psouf_imp_CG
             old_dest_ret_5x_CG = dest_ret_5x_CG

pchpbrk_2_DG   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_DG
            if drill5axes_DG = 1,[
                    pdrl5_2_DG
                    tosz$ = 0
                    initht5x_DG = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DG,",", *tosz$, ",", *sdis_DG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_DG, yprint_DG, e$
                            psouf_imp_DG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                                ]
            else, pnumligne, xprint_DG, yprint_DG, e$ #depth$, refht$, initht$,e$
            psouf_imp_DG
             old_dest_ret_5x_DG = dest_ret_5x_DG

pchpbrk_2_AM   # Canned Chip Break Cycle
            pprint_AM
        if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    peckclr_AM = peckclr$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, peckclr_AM, frplunge_AM,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                        ]

                         else,  [
                                depth_AM = depth$
                                refht_AM = refht$
                                initht_AM = initht$
                                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                                ]
                     old_dest_ret_5x_AM = dest_ret_5x_AM

pchpbrk_2_BM   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_BM
            if drill5axes_BM = 1,[
                    pdrl5_2_BM
                    tosz$ = 0
                    initht5x_BM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BM, yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                ]
            else, pnumligne, xprint_BM, yprint_BM, e$ #depth$, refht$, initht$,e$
            psouf_imp_BM
             old_dest_ret_5x_BM = dest_ret_5x_BM

pchpbrk_2_CM   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_CM
            if drill5axes_CM = 1,[
                    pdrl5_2_CM
                    tosz$ = 0
                    initht5x_CM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CM, yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                ]
            else, pnumligne, xprint_CM, yprint_CM, e$ #depth$, refht$, initht$,e$
            psouf_imp_CM
             old_dest_ret_5x_CM = dest_ret_5x_CM

pchpbrk_2_DM   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_DM
            if drill5axes_DM = 1,[
                    pdrl5_2_DM
                    tosz$ = 0
                    initht5x_DM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_DM,",", *tosz$, ",", *sdis_DM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_DM, yprint_DM, e$
                            psouf_imp_DM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                                ]
            else, pnumligne, xprint_DM, yprint_DM, e$ #depth$, refht$, initht$,e$
            psouf_imp_DM
             old_dest_ret_5x_DM = dest_ret_5x_DM
#endregion
#region ptap_2
ptap_2$
            pchange_AG
            ptap_2_AG

            pchange_AM
            ptap_2_AM

            pchange_BG
            ptap_2_BG

            pchange_BM
            ptap_2_BM

            pchange_CG
            ptap_2_CG

            pchange_CM
            ptap_2_CM

            pchange_DG
            ptap_2_DG

            pchange_DM
            ptap_2_DM

ptap_2_AG      # Canned Tap Cycle
            pprint_AG
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$

ptap_2_BG      # Canned Tap Cycle
            pprint_BG
            pnumligne, xprint_BG, yprint_BG, depth$, refht$, initht$,e$

ptap_2_CG      # Canned Tap Cycle
            pprint_CG
            pnumligne, xprint_CG, yprint_CG, depth$, refht$, initht$,e$

ptap_2_DG      # Canned Tap Cycle
            pprint_DG
            pnumligne, xprint_DG, yprint_DG, depth$, refht$, initht$,e$

ptap_2_AM      # Canned Tap Cycle
            pprint_AM
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$

ptap_2_BM      # Canned Tap Cycle
            pprint_BM
            pnumligne, xprint_BM, yprint_BM, depth$, refht$, initht$,e$

ptap_2_CM      # Canned Tap Cycle
            pprint_CM
            pnumligne, xprint_CM, yprint_CM, depth$, refht$, initht$,e$

ptap_2_DM      # Canned Tap Cycle
            pprint_DM
            pnumligne, xprint_DM, yprint_DM, depth$, refht$, initht$,e$

#endregion
#region pmisc1_2
pmisc1_2$
            pchange_AG
            pmisc1_2_AG

            pchange_AM
            pmisc1_2_AM

            pchange_BG
            pmisc1_2_BG

            pchange_BM
            pmisc1_2_BM

            pchange_CG
            pmisc1_2_CG

            pchange_CM
            pmisc1_2_CM

            pchange_DG
            pmisc1_2_DG

            pchange_DM
            pmisc1_2_DM

pmisc1_2_AG    # Canned Misc #1 Cycle
            pprint_AG
            if drill5axes_AG = 1,[
            pdrl5_2_AG
            initht$ = refht$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            pnumligne, "G82", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht_AG, frplunge$,e$
            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
             ]

            else,   [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                    ]
            old_dest_ret_5x_AG = dest_ret_5x_AG

pmisc1_2_BG    # Canned Bore #1 Cycle
            pprint_BG
            if drill5axes_BG = 1, pdrl5_2_BG
             if tete_rev_BG = 1 & mod5xcont = 0,
              [
            @refhtprint_BG , @inithtprint_BG
           gcode$ = 0
           pnumligne, pgcode_BG, xprint_BG, yprint_BG, inithtprint_BG, e$
           if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, refhtprint_BG, e$
           gcode$ = 1
           pnumligne, pgcode_BG, depthprint_BG, frplunge$ , e$
           pnumligne, pgcode_BG, refhtprint_BG, e$
           gcode$ = 0
           if refhtprint_BG <> inithtprint_BG, pnumligne, pgcode_BG, inithtprint_BG, e$
             ]
           if tete_rev_BG = 0,
             [
        if drill5axes_BG = 1,
                            [
                            tosz$ = 0
                            initht5x_BG = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BG, e$
                            ]

        else, pnumligne, xprint_BG, yprint_BG, e$ # depth$, refht$, initht$,e$
        psouf_imp_BG
        old_dest_ret_5x_BG = dest_ret_5x_BG
           ]

pmisc1_2_CG    # Canned Bore #1 Cycle
            pprint_CG
            if drill5axes_CG = 1, pdrl5_2_CG
             if tete_rev_CG = 1 & mod5xcont = 0,
              [
            @refhtprint_CG , @inithtprint_CG
           gcode$ = 0
           pnumligne, pgcode_CG, xprint_CG, yprint_CG, inithtprint_CG, e$
           if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, refhtprint_CG, e$
           gcode$ = 1
           if gfr_CG = 1, frplunge_CG = frplunge$/POURCENTAGE_AVANCE_CG
           else, frplunge_CG = frplunge$*POURCENTAGE_AVANCE_CG

           pnumligne, pgcode_CG, depthprint_CG, frplunge_CG , e$
           pnumligne, pgcode_CG, refhtprint_CG, e$
           gcode$ = 0
           if refhtprint_CG <> inithtprint_CG, pnumligne, pgcode_CG, inithtprint_CG, e$
             ]
           if tete_rev_CG = 0,
             [
        if drill5axes_CG = 1,
                            [
                            tosz$ = 0
                            initht5x_CG = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$,",, ",*dwell$,",",*avance_plonge_CG,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CG, e$
                            ]

        else, pnumligne, xprint_CG, yprint_CG, e$ # depth$, refht$, initht$,e$
        psouf_imp_CG
        old_dest_ret_5x_CG = dest_ret_5x_CG
           ]

pmisc1_2_DG    # Canned Bore #1 Cycle
            pprint_DG
            if drill5axes_DG = 1, pdrl5_2_DG
             if tete_rev_DG = 1 & mod5xcont = 0,
              [
            @refhtprint_DG , @inithtprint_DG
           gcode$ = 0
           pnumligne, pgcode_DG, xprint_DG, yprint_DG, inithtprint_DG, e$
           if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, refhtprint_DG, e$
           gcode$ = 1
           if gfr_DG = 1, frplunge_DG = frplunge$/POURCENTAGE_AVANCE_DG
           else, frplunge_DG = frplunge$*POURCENTAGE_AVANCE_DG

           pnumligne, pgcode_DG, depthprint_DG, frplunge_DG , e$
           pnumligne, pgcode_DG, refhtprint_DG, e$
           gcode$ = 0
           if refhtprint_DG <> inithtprint_DG, pnumligne, pgcode_DG, inithtprint_DG, e$
             ]
           if tete_rev_DG = 0,
             [
        if drill5axes_DG = 1,
                            [
                            tosz$ = 0
                            initht5x_DG = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_DG,",", *tosz$, ",",*sdis_DG,",", *depth$,",, ",*dwell$,",",*avance_plonge_DG,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_DG, *yprint_DG, e$
                            psouf_imp_DG
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DG, e$
                            ]

        else, pnumligne, xprint_DG, yprint_DG, e$ # depth$, refht$, initht$,e$
        psouf_imp_DG
        old_dest_ret_5x_DG = dest_ret_5x_DG
           ]

pmisc1_2_AM    # Canned Misc #1 Cycle
            pprint_AM
            if drill5axes_AM = 1,[
            pdrl5_2_AM
            initht$ = refht$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            frplunge_AM = frplunge$
            pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM,e$
            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
             ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                    ]
            old_dest_ret_5x_AM = dest_ret_5x_AM

pmisc1_2_BM    # Canned Bore #1 Cycle
            pprint_BM
            if drill5axes_BM = 1, pdrl5_2_BM
             if tete_rev_BM = 1 & mod5xcont = 0,
              [
            @refhtprint_BM , @inithtprint_BM
           gcode$ = 0
           pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
           pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 0
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, inithtprint_BM, e$
             ]
           if tete_rev_BM = 0,
             [
        if drill5axes_BM = 1,
                            [
                            tosz$ = 0
                            initht5x_BM = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                            ]

        else, pnumligne, xprint_BM, yprint_BM, e$ # depth$, refht$, initht$,e$
        psouf_imp_BM
        old_dest_ret_5x_BM = dest_ret_5x_BM
           ]

pmisc1_2_CM    # Canned Bore #1 Cycle
            pprint_CM
            if drill5axes_CM = 1, pdrl5_2_CM
             if tete_rev_CM = 1 & mod5xcont = 0,
              [
            @refhtprint_CM , @inithtprint_CM
           gcode$ = 0
           pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 1
           if gfr_CM = 1, frplunge_CM = frplunge$/POURCENTAGE_AVANCE_CM
           else, frplunge_CM = frplunge$*POURCENTAGE_AVANCE_CM

           pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
           pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 0
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, inithtprint_CM, e$
             ]
           if tete_rev_CM = 0,
             [
        if drill5axes_CM = 1,
                            [
                            tosz$ = 0
                            initht5x_CM = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$,",, ",*dwell$,",",*avance_plonge_CM,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                            ]

        else, pnumligne, xprint_CM, yprint_CM, e$ # depth$, refht$, initht$,e$
        psouf_imp_CM
        old_dest_ret_5x_CM = dest_ret_5x_CM
           ]

pmisc1_2_DM    # Canned Bore #1 Cycle
            pprint_DM
            if drill5axes_DM = 1, pdrl5_2_DM
             if tete_rev_DM = 1 & mod5xcont = 0,
              [
            @refhtprint_DM , @inithtprint_DM
           gcode$ = 0
           pnumligne, pgcode_DM, xprint_DM, yprint_DM, inithtprint_DM, e$
           if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, refhtprint_DM, e$
           gcode$ = 1
           if gfr_DM = 1, frplunge_DM = frplunge$/POURCENTAGE_AVANCE_DM
           else, frplunge_DM = frplunge$*POURCENTAGE_AVANCE_DM

           pnumligne, pgcode_DM, depthprint_DM, frplunge_DM , e$
           pnumligne, pgcode_DM, refhtprint_DM, e$
           gcode$ = 0
           if refhtprint_DM <> inithtprint_DM, pnumligne, pgcode_DM, inithtprint_DM, e$
             ]
           if tete_rev_DM = 0,
             [
        if drill5axes_DM = 1,
                            [
                            tosz$ = 0
                            initht5x_DM = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_DM,",", *tosz$, ",",*sdis_DM,",", *depth$,",, ",*dwell$,",",*avance_plonge_DM,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_DM, *yprint_DM, e$
                            psouf_imp_DM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_DM, e$
                            ]

        else, pnumligne, xprint_DM, yprint_DM, e$ # depth$, refht$, initht$,e$
        psouf_imp_DM
        old_dest_ret_5x_DM = dest_ret_5x_DM
           ]
#endregion
#region pbore2_2
pbore2_2$
            pchange_AG
            pbore2_2_AG

            pchange_AM
            pbore2_2_AM

            pchange_BG
            pbore2_2_BG

            pchange_BM
            pbore2_2_BM

            pchange_CG
            pbore2_2_CG

            pchange_CM
            pbore2_2_CM

            pchange_DG
            pbore2_2_DG

            pchange_DM
            pbore2_2_DM

pbore2_2_AG    # Canned Bore #2 Cycle
            pprint_AG
        if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    pnumligne, "G86", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, "EP.2 EC0. EA180.", frplunge$,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                          ]

                         else,  [
                                depth_AG = depth$
                                refht_AG = refht$
                                initht_AG = initht$
                                pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                                ]
                         old_dest_ret_5x_AG = dest_ret_5x_AG

pbore2_2_BG    # Canned Bore #2 Cycle

pbore2_2_CG    # Canned Bore #2 Cycle

pbore2_2_DG    # Canned Bore #2 Cycle

pbore2_2_AM    # Canned Bore #2 Cycle
            pprint_AM
        if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    frplunge_AM = frplunge$
                    pnumligne, "G86", *xprint_AM, *yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, "EP.2 EC0. EA180.", frplunge_AM,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                          ]

                         else,  [
                                depth_AM = depth$
                                refht_AM = refht$
                                initht_AM = initht$
                                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                                ]
                         old_dest_ret_5x_AM = dest_ret_5x_AM

pbore2_2_BM    # Canned Bore #2 Cycle

pbore2_2_CM    # Canned Bore #2 Cycle

pbore2_2_DM    # Canned Bore #2 Cycle
#endregion
#region pbore1_2
pbore1_2$
            pchange_AG
            pbore1_2_AG

            pchange_AM
            pbore1_2_AM

            pchange_BG
            pbore1_2_BG

            pchange_BM
            pbore1_2_BM

            pchange_CG
            pbore1_2_CG

            pchange_CM
            pbore1_2_CM

            pchange_DG
            pbore1_2_DG

            pchange_DM
            pbore1_2_DM

pbore1_2_AG    # Canned Bore #1 Cycle
            pprint_AG
            if drill5axes_AG = 1, pdrl5_2_AG
             if tete_rev_AG = 1 & mod5xcont = 0,
              [
            @refhtprint_AG , @inithtprint_AG
           gcode$ = 0
           pnumligne, pgcode_AG, xprint_AG, yprint_AG, inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 1
           pnumligne, pgcode_AG, depthprint_AG, frplunge$ , e$
           pnumligne, pgcode_AG, refhtprint_AG, e$
           gcode$ = 0
           if refhtprint_AG <> inithtprint_AG, pnumligne, pgcode_AG, inithtprint_AG, e$
             ]
           if tete_rev_AG = 0,
             [
        if drill5axes_AG = 1, [
                initht5x_AG = refht$
                depth_AG = depth$
                refht_AG = refht$
                pnumligne, "G85", xprint_AG, yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, frplunge$,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AG, e$
                            ]

        else,   [
                depth_AG = depth$
                refht_AG = refht$
                initht_AG = initht$
                pnumligne, xprint_AG, yprint_AG, depth_AG, refht_AG, initht_AG,e$
                ]
        old_dest_ret_5x_AG = dest_ret_5x_AG
           ]

pbore1_2_BG    # Canned Misc #1 Cycle

pbore1_2_CG    # Canned Misc #1 Cycle

pbore1_2_DG    # Canned Misc #1 Cycle

pbore1_2_AM    # Canned Bore #1 Cycle
            pprint_AM
            if drill5axes_AM = 1, pdrl5_2_AM
             if tete_rev_AM = 1 & mod5xcont = 0,
              [
            @refhtprint_AM , @inithtprint_AM
           gcode$ = 0
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 0
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, inithtprint_AM, e$
             ]
           if tete_rev_AM = 0,
             [
        if drill5axes_AM = 1, [
                initht5x_AM = refht$
                depth_AM = depth$
                refht_AM = refht$
                frplunge_AM = frplunge$
                pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                            ]

        else,   [
                depth_AM = depth$
                refht_AM = refht$
                initht_AM = initht$
                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                ]
        old_dest_ret_5x_AM = dest_ret_5x_AM
           ]

pbore1_2_BM    # Canned Misc #1 Cycle

pbore1_2_CM    # Canned Misc #1 Cycle

pbore1_2_DM    # Canned Misc #1 Cycle

#endregion
#region pmisc2_2_old

pmisc2_2_old_BG    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_BG
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_CG    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_CG
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_DG    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_DG
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_BM    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_BM
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_CM    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_CM
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_DM    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_DM
                !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pmisc2_2
pmisc2_2$
            pchange_AG
            pmisc2_2_AG

            pchange_AM
            pmisc2_2_AM

            pchange_BG
            pmisc2_2_BG

            pchange_BM
            pmisc2_2_BM

            pchange_CG
            pmisc2_2_CG

            pchange_CM
            pmisc2_2_CM

            pchange_DG
            pmisc2_2_DG

            pchange_DM
            pmisc2_2_DM

pmisc2_2_AG    # Canned Misc #2 Cycle
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AG
                            initht5x_AG = refht$
                           #xprint_AG = 0
                            #yprint_AG = 0
                            percage_helicoido_spiral_2_AG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AG, *old_zinitht_AG, e$
                             ]
           else, percage_helicoido_spiral_2_AG
           old_dest_ret_5x_AG = dest_ret_5x_AG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_BG    # Canned Misc #2 Cycle
            pprint_BG
            typcycle_BG = 1
            if drill5axes_BG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BG
                            initht5x_BG = refht$
                           #xprint_BG = 0
                            #yprint_BG = 0
                            percage_helicoido_spiral_2_BG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BG, *old_zinitht_BG, e$
                             ]
           else, percage_helicoido_spiral_2_BG
           old_dest_ret_5x_BG = dest_ret_5x_BG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_CG    # Canned Misc #2 Cycle
            pprint_CG
            typcycle_CG = 1
            if drill5axes_CG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CG
                            initht5x_CG = refht$
                           #xprint_CG = 0
                            #yprint_CG = 0
                            percage_helicoido_spiral_2_CG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CG, *old_zinitht_CG, e$
                             ]
           else, percage_helicoido_spiral_2_CG
           old_dest_ret_5x_CG = dest_ret_5x_CG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_DG    # Canned Misc #2 Cycle
            pprint_DG
            typcycle_DG = 1
            if drill5axes_DG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_DG
                            initht5x_DG = refht$
                           #xprint_DG = 0
                            #yprint_DG = 0
                            percage_helicoido_spiral_2_DG

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DG, *old_zinitht_DG, e$
                             ]
           else, percage_helicoido_spiral_2_DG
           old_dest_ret_5x_DG = dest_ret_5x_DG
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_AM    # Canned Misc #2 Cycle
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AM
                            initht5x_AM = refht$
                           #xprint_AM = 0
                            #yprint_AM = 0
                            percage_helicoido_spiral_2_AM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                             ]
           else, percage_helicoido_spiral_2_AM
           old_dest_ret_5x_AM = dest_ret_5x_AM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_BM    # Canned Misc #2 Cycle
            pprint_BM
            typcycle_BM = 1
            if drill5axes_BM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BM
                            initht5x_BM = refht$
                           #xprint_BM = 0
                            #yprint_BM = 0
                            percage_helicoido_spiral_2_BM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                             ]
           else, percage_helicoido_spiral_2_BM
           old_dest_ret_5x_BM = dest_ret_5x_BM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_CM    # Canned Misc #2 Cycle
            pprint_CM
            typcycle_CM = 1
            if drill5axes_CM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CM
                            initht5x_CM = refht$
                           #xprint_CM = 0
                            #yprint_CM = 0
                            percage_helicoido_spiral_2_CM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                             ]
           else, percage_helicoido_spiral_2_CM
           old_dest_ret_5x_CM = dest_ret_5x_CM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_DM    # Canned Misc #2 Cycle
            pprint_DM
            typcycle_DM = 1
            if drill5axes_DM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_DM
                            initht5x_DM = refht$
                           #xprint_DM = 0
                            #yprint_DM = 0
                            percage_helicoido_spiral_2_DM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DM, *old_zinitht_DM, e$
                             ]
           else, percage_helicoido_spiral_2_DM
           old_dest_ret_5x_DM = dest_ret_5x_DM
            !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pcanceldc
pcanceldc$
            pchange_AG
            pcanceldc_AG

            pchange_AM
            pcanceldc_AM

            pchange_BG
            pcanceldc_BG

            pchange_BM
            pcanceldc_BM

            pchange_CG
            pcanceldc_CG

            pchange_CM
            pcanceldc_CM

            pchange_DG
            pcanceldc_DG

            pchange_DM
            pcanceldc_DM

pcanceldc_AG   # Cancel canned drill cycle
            pprint_AG
            zinitht_AG = initht$
            if cycle_heli_spiral_AG = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AG = 0
                 if drill5axes_AG = 0, pnumligne, pgcode_AG, *zinitht_AG,e$
                  pnumligne, sdcom_par, " FIN CYCLE CAQ ", sfcom_par, e$
                ]
            if drill5axes_AG = 0 & typcycle_AG = 1, pnumligne, "G80", *zinitht_AG,e$
            typcycle_AG = 0

            pdmodalxyz_AG

pcanceldc_BG   # Cancel canned drill cycle
            pprint_BG
           # "voir les Z=", *refht$, *initht$, *initht5x_BG, e$ 
            zinitht_BG = initht$
            if cycle_heli_spiral_BG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BG = 0
                 gcode$ = 0
                 if drill5axes_BG = 0, pnumligne, pgcode_force_BG, *zinitht_BG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BG = 0 & typcycle_BG = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BG,e$
                  ]
            typcycle_BG = 0
            pdmodalxyz_BG

pcanceldc_CG   # Cancel canned drill cycle
            pprint_CG
           # "voir les Z=", *refht$, *initht$, *initht5x_CG, e$ 
            zinitht_CG = initht$
            if cycle_heli_spiral_CG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CG = 0
                 gcode$ = 0
                 if drill5axes_CG = 0, pnumligne, pgcode_force_CG, *zinitht_CG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CG = 0 & typcycle_CG = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht_CG,e$
                    if drill5axes_CG = 0 & typcycle_CG = 1, pnumligne, *zinitht_CG,e$
                  ]
            typcycle_CG = 0
            pdmodalxyz_CG

pcanceldc_DG   # Cancel canned drill cycle
            pprint_DG
           # "voir les Z=", *refht$, *initht$, *initht5x_DG, e$ 
            zinitht_DG = initht$
            if cycle_heli_spiral_DG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_DG = 0
                 gcode$ = 0
                 if drill5axes_DG = 0, pnumligne, pgcode_force_DG, *zinitht_DG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_DG = 0 & typcycle_DG = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht_DG,e$
                    if drill5axes_DG = 0 & typcycle_DG = 1, pnumligne, *zinitht_DG,e$
                  ]
            typcycle_DG = 0
            pdmodalxyz_DG

pcanceldc_AM   # Cancel canned drill cycle
            pprint_AM
            zinitht_AM = initht$
            if cycle_heli_spiral_AM = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AM = 0
                 if drill5axes_AM = 0, pnumligne, pgcode_AM, *zinitht_AM,e$
                  pnumligne, sdcom_par, " FIN CYCLE CAQ ", sfcom_par, e$
                ]
            if drill5axes_AM = 0 & typcycle_AM = 1, pnumligne, "G80", *zinitht_AM,e$
            typcycle_AM = 0

            pdmodalxyz_AM

pcanceldc_BM   # Cancel canned drill cycle
            pprint_BM
           # "voir les Z=", *refht$, *initht$, *initht5x_BM, e$ 
            zinitht_BM = initht$
            if cycle_heli_spiral_BM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BM = 0
                 gcode$ = 0
                 if drill5axes_BM = 0, pnumligne, pgcode_force_BM, *zinitht_BM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BM = 0 & typcycle_BM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BM,e$
                  ]
            typcycle_BM = 0
            pdmodalxyz_BM

pcanceldc_CM   # Cancel canned drill cycle
            pprint_CM
           # "voir les Z=", *refht$, *initht$, *initht5x_CM, e$ 
            zinitht_CM = initht$
            if cycle_heli_spiral_CM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CM = 0
                 gcode$ = 0
                 if drill5axes_CM = 0, pnumligne, pgcode_force_CM, *zinitht_CM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CM = 0 & typcycle_CM = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht_CM,e$
                    if drill5axes_CM = 0 & typcycle_CM = 1, pnumligne, *zinitht_CM,e$
                  ]
            typcycle_CM = 0
            pdmodalxyz_CM

pcanceldc_DM   # Cancel canned drill cycle
            pprint_DM
           # "voir les Z=", *refht$, *initht$, *initht5x_DM, e$ 
            zinitht_DM = initht$
            if cycle_heli_spiral_DM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_DM = 0
                 gcode$ = 0
                 if drill5axes_DM = 0, pnumligne, pgcode_force_DM, *zinitht_DM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_DM = 0 & typcycle_DM = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht_DM,e$
                    if drill5axes_DM = 0 & typcycle_DM = 1, pnumligne, *zinitht_DM,e$
                  ]
            typcycle_DM = 0
            pdmodalxyz_DM
#endregion
#region pcancelcc
pcancelcc$
            pchange_AG
            pcancelcc_AG

            pchange_AM
            pcancelcc_AM

            pchange_BG
            pcancelcc_BG

            pchange_BM
            pcancelcc_BM

            pchange_CG
            pcancelcc_CG

            pchange_CM
            pcancelcc_CM

            pchange_DG
            pcancelcc_DG

            pchange_DM
            pcancelcc_DM

pcancelcc_AG   # Cancel canned drill cycle
            pprint_AG
           if cycle_heli_spiral_AG = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AG = 0
                 if drill5axes_AG = 0, pnumligne, pgcode_AG, *zinitht_AG,e$
                  pnumligne, sdcom_par, " FIN CYCLE CAQ ", sfcom_par, e$
                ]
            if drill5axes_AG = 0 & typcycle_AG = 1, pnumligne, "G80", *zinitht_AG,e$
            typcycle_AG = 0
              # Define string variables to hold 'sparameter' string data

pcancelcc_BG   # Cancel canned drill cycle
            pprint_BG
             if cycle_heli_spiral_BG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BG = 0
                  gcode$ = 0
                 if drill5axes_BG = 0, pnumligne, pgcode_force_BG, *zinitht_BG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BG = 0 & typcycle_BG = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BG,e$
                  ]
            typcycle_BG = 0

pcancelcc_CG   # Cancel canned drill cycle
            pprint_CG
             if cycle_heli_spiral_CG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CG = 0
                  gcode$ = 0
                 if drill5axes_CG = 0, pnumligne, pgcode_force_CG, *zinitht_CG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CG = 0 & typcycle_CG = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_CG,e$
                  ]
            typcycle_CG = 0

pcancelcc_DG   # Cancel canned drill cycle
            pprint_DG
             if cycle_heli_spiral_DG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_DG = 0
                  gcode$ = 0
                 if drill5axes_DG = 0, pnumligne, pgcode_force_DG, *zinitht_DG,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_DG = 0 & typcycle_DG = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_DG,e$
                  ]
            typcycle_DG = 0

pcancelcc_AM   # Cancel canned drill cycle
            pprint_AM
           if cycle_heli_spiral_AM = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AM = 0
                 if drill5axes_AM = 0, pnumligne, pgcode_AM, *zinitht_AM,e$
                  pnumligne, sdcom_par, " FIN CYCLE CAQ ", sfcom_par, e$
                ]
            if drill5axes_AM = 0 & typcycle_AM = 1, pnumligne, "G80", *zinitht_AM,e$
            typcycle_AM = 0
              # Define string variables to hold 'sparameter' string data

pcancelcc_BM   # Cancel canned drill cycle
            pprint_BM
             if cycle_heli_spiral_BM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BM = 0
                  gcode$ = 0
                 if drill5axes_BM = 0, pnumligne, pgcode_force_BM, *zinitht_BM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BM = 0 & typcycle_BM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BM,e$
                  ]
            typcycle_BM = 0

pcancelcc_CM   # Cancel canned drill cycle
            pprint_CM
             if cycle_heli_spiral_CM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CM = 0
                  gcode$ = 0
                 if drill5axes_CM = 0, pnumligne, pgcode_force_CM, *zinitht_CM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CM = 0 & typcycle_CM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_CM,e$
                  ]
            typcycle_CM = 0

pcancelcc_DM   # Cancel canned drill cycle
            pprint_DM
             if cycle_heli_spiral_DM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_DM = 0
                  gcode$ = 0
                 if drill5axes_DM = 0, pnumligne, pgcode_force_DM, *zinitht_DM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_DM = 0 & typcycle_DM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_DM,e$
                  ]
            typcycle_DM = 0
#endregion
#region pnumop

pnumop_AG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_AG, numop_AG = numop_AG + 1
pnumop_BG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_BG, numop_BG = numop_BG + 1
pnumop_CG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_CG, numop_CG = numop_CG + 1

pnumop_DG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_DG, numop_DG = numop_DG + 1

pnumop_AM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_AM, numop_AM = numop_AM + 1
pnumop_BM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_BM, numop_BM = numop_BM + 1
pnumop_CM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_CM, numop_CM = numop_CM + 1

pnumop_DM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_DM, numop_DM = numop_DM + 1
#endregion
#endregion

#region   CYCLE SPECIAL HELICOIDO-SPIRAL #OK
#region variables CYCLE SPECIAL HELICOIDO-SPIRAL
# ----------------------- DEBUT CYCLE SPECIAL HELICOIDO-SPIRAL ------------------------
#------------- DECLARATION DES VARIABLES via le cycle  ------------
fmt "Aval ou OPP=" 4 ava_opp                        # Détermine si la fraise travail en avalant ou opposition
fmt "Diametre final=" 2 dia_final                   # diametre du trou programmé 
fmt "Diametre ebauche=" 2 dia_ebauche               # diametre d'ebauche
fmt "Pas maximum en Z=" 2 pas_max_z                 # Pas maximum en Z
fmt "Pas maximum en XY=" 2 pas_max_xy               # Pas maximum en XY pour la spiral en fond de trou
fmt "Nb Tr de finition=" 4 nbe_tr_fin               # Nombre de tour pour passe de finition
fmt "F" 5 f_ent_cir   #OK                              # avance en entree ciculaire au debut de l'helicoide
fmt "F" 5 f_int_hel   #OK                               # avance de l'helicoide 
fmt "F" 5 f_spiral    #OK                               # avance de la spiral
fmt "F" 5 f_int_fin   #OK                               # avance sur la finition du trou
fmt "F" 5 f_sor_cir   #OK                               # avance sur la sortie de la finition du trou
fmt "F" 5 f_base      #OK                               # avance de base du cycle
fmt "Dis. entre perp=" 2 ent_perp                   # distance d'entree perpendiculaire au debut du cycle pour le G41
fmt "Gestion usure=" 4 cor_ray                      # ativation d'un G41 ou G42 suivant besoins
fmt "Nb Tr de finition de retour=" 4 nbe_tr_retour  # Nombre de tour pour la deuxieme passe de finition a l'opposer du sens de la premiere
fmt  "OPERATION "  5 numop                          # NUMERO D'OPERATION
fmt "Drl_prm1=" 2 drl_prm1$
fmt "Drl_prm2=" 2 drl_prm2$
fmt "Drl_prm3=" 2 drl_prm3$
fmt "Drl_prm4=" 2 drl_prm4$
fmt "Drl_prm5=" 2 drl_prm5$
fmt "Drl_prm6=" 2 drl_prm6$
fmt "Drl_prm7=" 2 drl_prm7$
fmt "Drl_prm8=" 2 drl_prm8$
fmt "Drl_prm9=" 2 drl_prm9$
fmt "Drl_prm10=" 2 drl_prm10$
#------------- DECLARATION DES VARIABLES pour calcul interne  ------------
fmt "X" 2 x_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Y" 2 y_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Z" 2 z_plan_securite                       # coordonee Z du plan de securite
fmt "Z" 2 z_profondeur                          # coordonee Z du fond du trou
fmt "X" 2 x_ent_cir                             # coordonee X du point du centre du cercle pour l'entre circulaire
fmt "R" 2 ray_ent_cir                           # rayon du cercle de l'entree circulaire
fmt "Nb pas Z =" 4 nbe_pas_z                    # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Nb de pas actuel" 4 nbe_pas_actu           # nombre de pas actuel
fmt "Pas Z=" 2 pas_z                            # valeur reel du pas de l'helice
fmt "Nb pas XY =" 2 nbe_pas_xy                  # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Pas XY=" 2 pas_xy                          # valeur reel du pas de la spiral
fmt "Nb de cercle" 2 nbe_demi_cercle            # nombre de demi cercle que constitue la spiral
fmt "R" 2 ray_sor_cir                           # rayon pour la sortie de la spiral
fmt "X" 2 x_sor_cir                             # coordonee X du point du centre du cercle pour la sortie circulaire
fmt "R" 2 ray_ebauche                           # rayon d'ebauche 
fmt "Sens" 4 sens_usi                           # sens de l'usinage, -1 = avalant, 1 = opposition et depend de la reponce: Avalant=0 Oppositon = 1
fmt "X" 2 old_xp_chs                            # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "I" 2 i_eb_cir                              # coordonee I centre du cercle de l'helicoide en relatif point de depart
fmt "J" 2 j_eb_cir                              # coordonee J centre du cercle en relatif point de depart
fmt "Diam" 2 diam_cercle                        # diametre du cercle d'un demi tours de spiral
fmt "X max dans le trou" 2 xp_chs_max           # coordoonee maxi dans le centre du trou
fmt "Ray_sortie" 2 ray_cercle_sortie            # Rayon de sortie sur la finition 
fmt "rap_ray_sortie=" 1 rapport_ray_sortie      # rapport muliplicateur du rayon de sortie
fmt "angle_ray_sortie" 1 angle_ray_sortie       # angle de balayage de la portion de cercle de la sortie
fmt "Nb spiral debut " 4 nb_tr_debut " tr"      # Nombre de spiral en debut
fmt "Nb spiral fin " 4 nb_tr_fin    " tr"       # Nombre de spiral en fin
fmt "Pas spiral debut-fin " 2 pas_Z_deb_fin " mm"       # Pas de la spiral d'entree et de fin  
fmt "haut spi debut" 2 prof_z_deb_spi           # calcul de la hauteur de la spiral de debut en ebauche
fmt "haut spi fin" 2 prof_z_fin_spi             # calcul de la hauteur de la spiral de fin en ebauche
fmt "helice total = " 2 hauteur_hel " mm"               # hauteur total de l'helicoide
fmt "Le cumul helice debut et fin = " 2 hauteur_hel_debfin " mm"
fmt "Ray_cercle ebauche" 2 ray_cercle_ebauche   # Rayon de sortie sur la finition 

#------------------ DECLARATIONS DE MESSAGE SI VALEURS NON CONFORMES-----------

sdcom : ";"
sfcom : ""
sdcom_par : "("
sfcom_par : ")"
#endregion
#region percage_helicoido_spiral_2

percage_helicoido_spiral_2_AG  # ecriture générale du cycle spécial helicoédo-spiral trou suivant
                                gcode$ = 0

                                xabs_AG = xprint_AG
                                yabs_AG = yprint_AG
                                zabs_AG = initht$

                                pnumligne, pgcode_force_AG, *zabs_AG, e$
                                pnumligne, sdcom_par, " POSITIONEMENT TROU SUIVANT", sfcom_par, e$
                                pnumligne, *xabs_AG, *yabs_AG, e$
                                percage_helicoido_spiral_AG

percage_helicoido_spiral_2_BG      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_BG = xprint_BG
                                yabs_BG = yprint_BG
                                zabs_BG = initht$
                                pnumligne, pgcode_force_BG, *zabs_BG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BG, *yabs_BG, e$
                                percage_helicoido_spiral_BG

percage_helicoido_spiral_2_CG      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_CG = xprint_CG
                                yabs_CG = yprint_CG
                                zabs_CG = initht$
                                pnumligne, pgcode_force_CG, *zabs_CG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CG, *yabs_CG, e$
                                percage_helicoido_spiral_CG

percage_helicoido_spiral_2_DG      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_DG = xprint_DG
                                yabs_DG = yprint_DG
                                zabs_DG = initht$
                                pnumligne, pgcode_force_DG, *zabs_DG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_DG, *yabs_DG, e$
                                percage_helicoido_spiral_DG

percage_helicoido_spiral_2_AM  # ecriture générale du cycle spécial helicoédo-spiral trou suivant
                                gcode$ = 0

                                xabs_AM = xprint_AM
                                yabs_AM = yprint_AM
                                zabs_AM = initht$

                                pnumligne, pgcode_force_AM, *zabs_AM, e$
                                pnumligne, sdcom_par, " POSITIONEMENT TROU SUIVANT", sfcom_par, e$
                                pnumligne, *xabs_AM, *yabs_AM, e$
                                percage_helicoido_spiral_AM

percage_helicoido_spiral_2_BM      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_BM = xprint_BM
                                yabs_BM = yprint_BM
                                zabs_BM = initht$
                                pnumligne, pgcode_force_BM, *zabs_BM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BM, *yabs_BM, e$
                                percage_helicoido_spiral_BM

percage_helicoido_spiral_2_CM      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_CM = xprint_CM
                                yabs_CM = yprint_CM
                                zabs_CM = initht$
                                pnumligne, pgcode_force_CM, *zabs_CM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CM, *yabs_CM, e$
                                percage_helicoido_spiral_CM

percage_helicoido_spiral_2_DM      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_DM = xprint_DM
                                yabs_DM = yprint_DM
                                zabs_DM = initht$
                                pnumligne, pgcode_force_DM, *zabs_DM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_DM, *yabs_DM, e$
                                percage_helicoido_spiral_DM
#endregion
#region percage_helicoido_spiral

percage_helicoido_spiral_AG   # ecriture générale du cycle spécial helicoédo-spiral

                            pcalcule_variable_AG
                            #pvoir_variable_AG
                            #ptest_variable_AG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_AG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_AG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom_par, "DEBUT EBAUCHE HELICOIDALE", sfcom_par, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_AG - prof_z_deb_spi
                                phase_2_AG                                         # debut ebauche helicoide

                                z_dessus_brut_AG = z_dessus_brut_AG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_AG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_AG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_AG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom_par, "FIN EBAUCHE HELICOIDALE", sfcom_par, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_AG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_AG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_AG         # premiere serie de passes de finition 
                                    ]
                                phase_5_AG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_AG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_AG         # premiere serie de passes de deuxieme finition 
                                    phase_8_AG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_AG           # premiere serie de passes de finition 
                                phase_5_2_AG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_AG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_AG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_AG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_BG   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_BG
                            #pvoir_variable_BG
                            #ptest_variable_BG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_BG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_BG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_BG - prof_z_deb_spi
                                phase_2_BG                                         # debut ebauche helicoide

                                z_dessus_brut_BG = z_dessus_brut_BG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_BG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_BG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_BG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_BG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_BG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_BG         # premiere serie de passes de finition 
                                    ]
                                phase_5_BG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_BG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_BG         # premiere serie de passes de deuxieme finition 
                                    phase_8_BG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_BG           # premiere serie de passes de finition 
                                phase_5_2_BG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_BG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_BG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_BG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_CG   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_CG
                            #pvoir_variable_CG
                            #ptest_variable_CG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_CG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_CG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_CG - prof_z_deb_spi
                                phase_2_CG                                         # debut ebauche helicoide

                                z_dessus_brut_CG = z_dessus_brut_CG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_CG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_CG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_CG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_CG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_CG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_CG         # premiere serie de passes de finition 
                                    ]
                                phase_5_CG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_CG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_CG         # premiere serie de passes de deuxieme finition 
                                    phase_8_CG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_CG           # premiere serie de passes de finition 
                                phase_5_2_CG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_CG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_CG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_CG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_DG   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_DG
                            #pvoir_variable_DG
                            #ptest_variable_DG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_DG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_DG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_DG - prof_z_deb_spi
                                phase_2_DG                                         # debut ebauche helicoide

                                z_dessus_brut_DG = z_dessus_brut_DG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_DG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_DG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_DG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_DG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_DG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_DG         # premiere serie de passes de finition 
                                    ]
                                phase_5_DG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_DG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_DG         # premiere serie de passes de deuxieme finition 
                                    phase_8_DG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_DG           # premiere serie de passes de finition 
                                phase_5_2_DG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_DG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_DG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_DG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_AM   # ecriture générale du cycle spécial helicoédo-spiral

                            pcalcule_variable_AM
                            #pvoir_variable_AM
                            #ptest_variable_AM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_AM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_AM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom_par, "DEBUT EBAUCHE HELICOIDALE", sfcom_par, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_AM - prof_z_deb_spi
                                phase_2_AM                                         # debut ebauche helicoide

                                z_dessus_brut_AM = z_dessus_brut_AM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_AM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_AM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_AM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom_par, "FIN EBAUCHE HELICOIDALE", sfcom_par, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_AM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_AM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_AM         # premiere serie de passes de finition 
                                    ]
                                phase_5_AM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_AM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_AM         # premiere serie de passes de deuxieme finition 
                                    phase_8_AM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_AM           # premiere serie de passes de finition 
                                phase_5_2_AM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_AM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_AM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_AM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_BM   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_BM
                            #pvoir_variable_BM
                            #ptest_variable_BM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_BM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_BM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_BM - prof_z_deb_spi
                                phase_2_BM                                         # debut ebauche helicoide

                                z_dessus_brut_BM = z_dessus_brut_BM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_BM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_BM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_BM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_BM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_BM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_BM         # premiere serie de passes de finition 
                                    ]
                                phase_5_BM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_BM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_BM         # premiere serie de passes de deuxieme finition 
                                    phase_8_BM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_BM           # premiere serie de passes de finition 
                                phase_5_2_BM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_BM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_BM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_BM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_CM   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_CM
                            #pvoir_variable_CM
                            #ptest_variable_CM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_CM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_CM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_CM - prof_z_deb_spi
                                phase_2_CM                                         # debut ebauche helicoide

                                z_dessus_brut_CM = z_dessus_brut_CM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_CM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_CM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_CM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_CM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_CM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_CM         # premiere serie de passes de finition 
                                    ]
                                phase_5_CM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_CM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_CM         # premiere serie de passes de deuxieme finition 
                                    phase_8_CM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_CM           # premiere serie de passes de finition 
                                phase_5_2_CM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_CM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_CM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_CM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_DM   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_DM
                            #pvoir_variable_DM
                            #ptest_variable_DM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_DM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_DM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_DM - prof_z_deb_spi
                                phase_2_DM                                         # debut ebauche helicoide

                                z_dessus_brut_DM = z_dessus_brut_DM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_DM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_DM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_DM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_DM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_DM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_DM         # premiere serie de passes de finition 
                                    ]
                                phase_5_DM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_DM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_DM         # premiere serie de passes de deuxieme finition 
                                    phase_8_DM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_DM           # premiere serie de passes de finition 
                                phase_5_2_DM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_DM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_DM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_DM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
#endregion
#region pvoir_variable

pvoir_variable_AG         # juste pour voir si tout OK
                            "voir variable drl:",e$

                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_AG = ",z_retraction_AG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir rayon ebauche = ", ray_ebauche, e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_AG =", z_dessus_brut_AG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir rapport_ray_sortie=", rapport_ray_sortie, e$
                            " angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_BG        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_BG = ",z_retraction_BG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_BG =", z_dessus_brut_BG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_CG        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_CG = ",z_retraction_CG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_CG =", z_dessus_brut_CG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_DG        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_DG = ",z_retraction_DG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_DG =", z_dessus_brut_DG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_AM         # juste pour voir si tout OK
                            "voir variable drl:",e$

                            f_ent_cir_AM , e$
                            f_int_hel_AM, e$
                            f_spiral_AM, e$
                            f_int_fin_AM, e$
                            f_sor_cir_AM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_AM = ",z_retraction_AM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir rayon ebauche = ", ray_ebauche, e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_AM = ",f_base_AM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_AM =", z_dessus_brut_AM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir rapport_ray_sortie=", rapport_ray_sortie, e$
                            " angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_BM        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir_BM , e$
                            f_int_hel_BM, e$
                            f_spiral_BM, e$
                            f_int_fin_BM, e$
                            f_sor_cir_BM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_BM = ",z_retraction_BM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_BM = ",f_base_BM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_BM =", z_dessus_brut_BM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_CM        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir_CM , e$
                            f_int_hel_CM, e$
                            f_spiral_CM, e$
                            f_int_fin_CM, e$
                            f_sor_cir_CM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_CM = ",z_retraction_CM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_CM = ",f_base_CM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_CM =", z_dessus_brut_CM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_DM        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir_DM , e$
                            f_int_hel_DM, e$
                            f_spiral_DM, e$
                            f_int_fin_DM, e$
                            f_sor_cir_DM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_DM = ",z_retraction_DM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_DM = ",f_base_DM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_DM =", z_dessus_brut_DM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$
#endregion
#region pcalcule_variable

pcalcule_variable_AG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_AG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_AG = 1, z_dessus_brut_AG = drl_sel_tos$
                            else, z_dessus_brut_AG = tosz$
                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin


                            abs_inc = 1 # defini si les cercle sont incremental ou absolue



                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_AG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin
                            #"voir hauteur_hel=", hauteur_hel, e$
                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_AG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_AG = 1
                            xabs_AG = xprint_AG         # reprendre les positions xyz avant le dégagement
                            yabs_AG = yprint_AG
                            zabs_AG = zprint_AG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                           # pas_z = hauteur_hel/nbe_pas_z
                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_AG

pcalcule_variable_BG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_BG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_BG = 1, z_dessus_brut_BG = drl_sel_tos$
                            else, z_dessus_brut_BG = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_BG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_BG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_BG = 1
                            xabs_BG = xprint_BG
                            yabs_BG = yprint_BG
                            zabs_BG = zprint_BG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_BG = xabs_BG + ent_perp
                                #x_ent_cir = x_perp_BG - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_BG = ray_ent_cir * -1 # + x_perp_BG  # si I en ABS
                                x_sor_cir = xabs_BG + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_BG = xabs_BG - ent_perp
                                #x_ent_cir = x_perp_BG +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_BG = ray_ent_cir # + x_perp_BG  # si I en ABS
                                x_sor_cir = xabs_BG - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_BG

pcalcule_variable_CG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_CG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_CG = 1, z_dessus_brut_CG = drl_sel_tos$
                            else, z_dessus_brut_CG = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_CG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_CG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_CG = 1
                            xabs_CG = xprint_CG
                            yabs_CG = yprint_CG
                            zabs_CG = zprint_CG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_CG = xabs_CG + ent_perp
                                #x_ent_cir = x_perp_CG - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_CG = ray_ent_cir * -1 # + x_perp_CG  # si I en ABS
                                x_sor_cir = xabs_CG + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_CG = xabs_CG - ent_perp
                                #x_ent_cir = x_perp_CG +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_CG = ray_ent_cir # + x_perp_CG  # si I en ABS
                                x_sor_cir = xabs_CG - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_CG                          

pcalcule_variable_DG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_DG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_DG = 1, z_dessus_brut_DG = drl_sel_tos$
                            else, z_dessus_brut_DG = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_DG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_DG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_DG = 1
                            xabs_DG = xprint_DG
                            yabs_DG = yprint_DG
                            zabs_DG = zprint_DG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_DG = xabs_DG + ent_perp
                                #x_ent_cir = x_perp_DG - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_DG = ray_ent_cir * -1 # + x_perp_DG  # si I en ABS
                                x_sor_cir = xabs_DG + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_DG = xabs_DG - ent_perp
                                #x_ent_cir = x_perp_DG +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_DG = ray_ent_cir # + x_perp_DG  # si I en ABS
                                x_sor_cir = xabs_DG - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_DG 

pcalcule_variable_AM       # mise a jour des variables 
                            f_ent_cir_AM = drl_prm1$
                            f_int_hel_AM = drl_prm2$
                            f_spiral_AM  = drl_prm3$
                            f_int_fin_AM = drl_prm4$
                            f_sor_cir_AM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_AM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_AM = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_AM = 1, z_dessus_brut_AM = drl_sel_tos$
                            else, z_dessus_brut_AM = tosz$
                            if f_ent_cir_AM = 0, f_ent_cir_AM = f_base_AM
                            if f_int_hel_AM = 0, f_int_hel_AM = f_ent_cir_AM
                            if f_spiral_AM  = 0, f_spiral_AM = f_int_hel_AM
                            if f_int_fin_AM = 0, f_int_fin_AM = f_spiral_AM
                            if f_sor_cir_AM = 0, f_sor_cir_AM = f_int_fin_AM


                            abs_inc = 1 # defini si les cercle sont incremental ou absolue



                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_AM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin
                            #"voir hauteur_hel=", hauteur_hel, e$
                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_AM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_AM = 1
                            xabs_AM = xprint_AM         # reprendre les positions xyz avant le dégagement
                            yabs_AM = yprint_AM
                            zabs_AM = zprint_AM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                           # pas_z = hauteur_hel/nbe_pas_z
                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_AM

pcalcule_variable_BM       # mise a jour des variables 
                            f_ent_cir_BM = drl_prm1$
                            f_int_hel_BM = drl_prm2$
                            f_spiral_BM  = drl_prm3$
                            f_int_fin_BM = drl_prm4$
                            f_sor_cir_BM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_BM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_BM = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_BM = 1, z_dessus_brut_BM = drl_sel_tos$
                            else, z_dessus_brut_BM = tosz$

                            if f_ent_cir_BM = 0, f_ent_cir_BM = f_base_BM
                            if f_int_hel_BM = 0, f_int_hel_BM = f_ent_cir_BM
                            if f_spiral_BM  = 0, f_spiral_BM = f_int_hel_BM
                            if f_int_fin_BM = 0, f_int_fin_BM = f_spiral_BM
                            if f_sor_cir_BM = 0, f_sor_cir_BM = f_int_fin_BM





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_BM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_BM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_BM = 1
                            xabs_BM = xprint_BM
                            yabs_BM = yprint_BM
                            zabs_BM = zprint_BM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_BM = xabs_BM + ent_perp
                                #x_ent_cir = x_perp_BM - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_BM = ray_ent_cir * -1 # + x_perp_BM  # si I en ABS
                                x_sor_cir = xabs_BM + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_BM = xabs_BM - ent_perp
                                #x_ent_cir = x_perp_BM +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_BM = ray_ent_cir # + x_perp_BM  # si I en ABS
                                x_sor_cir = xabs_BM - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_BM

pcalcule_variable_CM       # mise a jour des variables 
                            f_ent_cir_CM = drl_prm1$
                            f_int_hel_CM = drl_prm2$
                            f_spiral_CM  = drl_prm3$
                            f_int_fin_CM = drl_prm4$
                            f_sor_cir_CM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_CM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_CM = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_CM = 1, z_dessus_brut_CM = drl_sel_tos$
                            else, z_dessus_brut_CM = tosz$

                            if f_ent_cir_CM = 0, f_ent_cir_CM = f_base_CM
                            if f_int_hel_CM = 0, f_int_hel_CM = f_ent_cir_CM
                            if f_spiral_CM  = 0, f_spiral_CM = f_int_hel_CM
                            if f_int_fin_CM = 0, f_int_fin_CM = f_spiral_CM
                            if f_sor_cir_CM = 0, f_sor_cir_CM = f_int_fin_CM





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_CM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_CM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_CM = 1
                            xabs_CM = xprint_CM
                            yabs_CM = yprint_CM
                            zabs_CM = zprint_CM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_CM = xabs_CM + ent_perp
                                #x_ent_cir = x_perp_CM - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_CM = ray_ent_cir * -1 # + x_perp_CM  # si I en ABS
                                x_sor_cir = xabs_CM + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_CM = xabs_CM - ent_perp
                                #x_ent_cir = x_perp_CM +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_CM = ray_ent_cir # + x_perp_CM  # si I en ABS
                                x_sor_cir = xabs_CM - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_CM

pcalcule_variable_DM       # mise a jour des variables 
                            f_ent_cir_DM = drl_prm1$
                            f_int_hel_DM = drl_prm2$
                            f_spiral_DM  = drl_prm3$
                            f_int_fin_DM = drl_prm4$
                            f_sor_cir_DM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_DM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_DM = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes_DM = 1, z_dessus_brut_DM = drl_sel_tos$
                            else, z_dessus_brut_DM = tosz$

                            if f_ent_cir_DM = 0, f_ent_cir_DM = f_base_DM
                            if f_int_hel_DM = 0, f_int_hel_DM = f_ent_cir_DM
                            if f_spiral_DM  = 0, f_spiral_DM = f_int_hel_DM
                            if f_int_fin_DM = 0, f_int_fin_DM = f_spiral_DM
                            if f_sor_cir_DM = 0, f_sor_cir_DM = f_int_fin_DM





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_DM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable_DM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_DM = 1
                            xabs_DM = xprint_DM
                            yabs_DM = yprint_DM
                            zabs_DM = zprint_DM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_DM = xabs_DM + ent_perp
                                #x_ent_cir = x_perp_DM - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_DM = ray_ent_cir * -1 # + x_perp_DM  # si I en ABS
                                x_sor_cir = xabs_DM + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_DM = xabs_DM - ent_perp
                                #x_ent_cir = x_perp_DM +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_DM = ray_ent_cir # + x_perp_DM  # si I en ABS
                                x_sor_cir = xabs_DM - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_DM                          
#endregion
#region ptest_variable
#region ptest_variable_AG OK
ptest_variable_AG     # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur1_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur2_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur20_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur3_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur4_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur5_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur24_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [ 
                            #   if prog_AG = 1, [
                            #   subout$ = 4
                            #   serreur_visu_AG = serreur6_AG + no2str(numop_AG) 
                            #   *serreur_visu_AG, e$
                            #   result = mprint(serreur_visu_AG)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_AG = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur7_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur8_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur9_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if f_ent_cir < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur10_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if f_int_hel < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur11_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if f_spiral < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur12_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if f_int_fin < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur13_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if f_sor_cir < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur14_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur15_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur16_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur17_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur18_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur19_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if z_dessus_brut_AG > z_retraction_AG,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur21_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if z_retraction_AG > z_plan_securite,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur21_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                        if drl_prm9$ < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur25_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur26_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur27_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur à l'", hauteur_hel, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]


                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_AG = 0 ,
                                [
                                if prog_AG = 1, [
                                serreur_visu_AG = serreur23_AG + no2str(numop_AG)
                                result = mprint(serreur_visu_AG,2)
                                if result = 1,  pnumligne, sdcom_par, "ATTENTION : RISQUE DE CAROTTE", sfcom_par, e$
                                if result = 2, subout$ = 4, *serreur_visu_AG, subout$ = 3, erreur_AG = 1#, exitpost$ # abandonner 
                                                ]
                                ]
#endregion
#region ptest_variable_BG OK
ptest_variable_BG        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur1_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur2_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur20_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur3_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur4_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur5_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur24_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_BG = 1, [
                            #   subout$ = 4
                            #   serreur_visu_BG = serreur6_BG + no2str(numop_BG) 
                            #   *serreur_visu_BG, e$
                            #   result = mprint(serreur_visu_BG)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_BG = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur7_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur8_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur9_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if f_ent_cir < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur10_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if f_int_hel < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur11_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if f_spiral < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur12_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if f_int_fin < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur13_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if f_sor_cir < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur14_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur15_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur16_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur17_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur18_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur19_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if z_dessus_brut_BG > z_retraction_BG,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur21_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if z_retraction_BG > z_plan_securite,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur21_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur25_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur26_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur27_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_BG = 0 ,
                                [
                                if prog_BG = 1, [
                                serreur_visu_BG = serreur23_BG + no2str(numop_BG)
                                result = mprint(serreur_visu_BG,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_BG, subout$ = 3, erreur_BG = 1#, exitpost$ # abandonner
                                                ]
                                ]
#endregion
#region ptest_variable_CG OK
ptest_variable_CG        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur1_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur2_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur20_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur3_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur4_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur5_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur24_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_CG = 1, [
                            #   subout$ = 4
                            #   serreur_visu_CG = serreur6_CG + no2str(numop_CG) 
                            #   *serreur_visu_CG, e$
                            #   result = mprint(serreur_visu_CG)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_CG = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur7_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur8_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur9_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if f_ent_cir < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur10_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if f_int_hel < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur11_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if f_spiral < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur12_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if f_int_fin < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur13_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if f_sor_cir < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur14_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur15_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur16_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur17_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur18_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur19_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if z_dessus_brut_CG > z_retraction_CG,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur21_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if z_retraction_CG > z_plan_securite,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur21_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur25_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur26_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur27_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_CG = 0 ,
                                [
                                if prog_CG = 1, [
                                serreur_visu_CG = serreur23_CG + no2str(numop_CG)
                                result = mprint(serreur_visu_CG,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_CG, subout$ = 3, erreur_CG = 1#, exitpost$ # abandonner
                                                ]
                                ]
#endregion
#region ptest_variable_DG OK
ptest_variable_DG        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur1_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur2_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur20_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur3_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur4_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur5_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur24_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_DG = 1, [
                            #   subout$ = 4
                            #   serreur_visu_DG = serreur6_DG + no2str(numop_DG) 
                            #   *serreur_visu_DG, e$
                            #   result = mprint(serreur_visu_DG)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_DG = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur7_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur8_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur9_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if f_ent_cir < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur10_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if f_int_hel < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur11_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if f_spiral < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur12_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if f_int_fin < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur13_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if f_sor_cir < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur14_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur15_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur16_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur17_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur18_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur19_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if z_dessus_brut_DG > z_retraction_DG,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur21_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if z_retraction_DG > z_plan_securite,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur21_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur25_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur26_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur27_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_DG = 0 ,
                                [
                                if prog_DG = 1, [
                                serreur_visu_DG = serreur23_DG + no2str(numop_DG)
                                result = mprint(serreur_visu_DG,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_DG, subout$ = 3, erreur_DG = 1#, exitpost$ # abandonner
                                                ]
                                ]
#endregion
#region ptest_variable_AM OK
ptest_variable_AM       # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur1_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur2_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur20_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur3_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur4_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur5_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur24_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [ 
                            #   if prog_AM = 1, [
                            #   subout$ = 4
                            #   serreur_visu_AM = serreur6_AM + no2str(numop_AM) 
                            #   *serreur_visu_AM, e$
                            #   result = mprint(serreur_visu_AM)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_AM = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur7_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur8_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur9_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if f_ent_cir_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur10_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if f_int_hel_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur11_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if f_spiral_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur12_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if f_int_fin_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur13_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if f_sor_cir_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur14_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur15_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur16_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur17_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur18_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur19_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if z_dessus_brut_AM > z_retraction_AM,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur21_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if z_retraction_AM > z_plan_securite,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur21_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                        if drl_prm9$ < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur25_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur26_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur27_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur à l'", hauteur_hel, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]


                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_AM = 0 ,
                                [
                                if prog_AM = 1, [
                                serreur_visu_AM = serreur23_AM + no2str(numop_AM)
                                result = mprint(serreur_visu_AM,2)
                                if result = 1,  pnumligne, sdcom_par, "ATTENTION : RISQUE DE CAROTTE", sfcom_par, e$
                                if result = 2,  subout$ = 4, *serreur_visu_AM, subout$ = 3, erreur_AM = 1#, exitpost$ # abandonner   
                                                ]
                                ]
#endregion
#region ptest_variable_BM OK
ptest_variable_BM        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur1_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur2_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur20_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur3_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur4_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur5_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur24_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_BM = 1, [
                            #   subout$ = 4
                            #   serreur_visu_BM = serreur6_BM + no2str(numop_BM) 
                            #   *serreur_visu_BM, e$
                            #   result = mprint(serreur_visu_BM)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_BM = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur7_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur8_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur9_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if f_ent_cir_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur10_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if f_int_hel_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur11_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if f_spiral_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur12_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if f_int_fin_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur13_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if f_sor_cir_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur14_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur15_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur16_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur17_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur18_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur19_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if z_dessus_brut_BM > z_retraction_BM,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur21_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if z_retraction_BM > z_plan_securite,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur21_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur25_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur26_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur27_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_BM = 0 ,
                                [
                                if prog_BM = 1, [
                                serreur_visu_BM = serreur23_BM + no2str(numop_BM)
                                result = mprint(serreur_visu_BM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_BM, subout$ = 3, erreur_BM = 1#, exitpost$ # abandonner  
                                                ]
                                ]
#endregion
#region ptest_variable_CM OK
ptest_variable_CM        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur1_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur2_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur20_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur3_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur4_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur5_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur24_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_CM = 1, [
                            #   subout$ = 4
                            #   serreur_visu_CM = serreur6_CM + no2str(numop_CM) 
                            #   *serreur_visu_CM, e$
                            #   result = mprint(serreur_visu_CM)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_CM = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur7_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur8_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur9_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if f_ent_cir_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur10_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if f_int_hel_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur11_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if f_spiral_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur12_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if f_int_fin_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur13_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if f_sor_cir_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur14_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur15_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur16_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur17_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur18_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur19_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if z_dessus_brut_CM > z_retraction_CM,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur21_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if z_retraction_CM > z_plan_securite,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur21_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur25_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur26_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur27_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_CM = 0 ,
                                [
                                if prog_CM = 1, [
                                serreur_visu_CM = serreur23_CM + no2str(numop_CM)
                                result = mprint(serreur_visu_CM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_CM, subout$ = 3, erreur_CM = 1#, exitpost$ # abandonner 
                                                ]
                                ]
#endregion
#region ptest_variable_DM OK
ptest_variable_DM        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur1_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                         if dia_final <=0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur2_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                         if hauteur_hel <= 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur20_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                         if dia_ebauche <= 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur3_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]
                        if dia_ebauche > dia_final,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur4_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if dia_final < tldia$,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur5_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur24_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   if prog_DM = 1, [
                            #   subout$ = 4
                            #   serreur_visu_DM = serreur6_DM + no2str(numop_DM) 
                            #   *serreur_visu_DM, e$
                            #   result = mprint(serreur_visu_DM)
                            #    exitpost$ # abandonner 
                            #   subout$ = 3
                            #   erreur_DM = 1
                            #                   ]
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur7_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur8_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if nbe_tr_fin < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur9_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if f_ent_cir_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur10_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if f_int_hel_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur11_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if f_spiral_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur12_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if f_int_fin_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur13_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if f_sor_cir_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur14_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur15_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur16_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur17_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if nbe_tr_retour < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur18_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if dia_ebauche < tldia$,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur19_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if z_dessus_brut_DM > z_retraction_DM,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur21_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if z_retraction_DM > z_plan_securite,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur21_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]
                        if drl_prm9$ < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur25_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]
                        if drl_prm10$ < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur26_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur27_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_DM = 0 ,
                                [
                                if prog_DM = 1, [
                                serreur_visu_DM = serreur23_DM + no2str(numop_DM)
                                result = mprint(serreur_visu_DM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  subout$ = 4, *serreur_visu_DM, subout$ = 3, erreur_DM = 1#, exitpost$ # abandonner 
                                                ]
                                ]
#endregion
#endregion
#region PF

pf_base_AG             # ecriture que si sup a 0
                        if f_base > 0, avance_AG = f_base, avance_AG

pf_base_BG             # ecriture que si sup a 0
                        if f_base > 0, avance_BG = f_base, avance_BG

pf_base_CG             # ecriture que si sup a 0
                        if f_base > 0,  [
                                        if gfr_CG = 1, avance_CG = f_base/POURCENTAGE_AVANCE_CG
                                        else, avance_CG = f_base*POURCENTAGE_AVANCE_CG
                                        avance_CG
                                        ]
pf_base_DG             # ecriture que si sup a 0
                        if f_base > 0,  [
                                        if gfr_DG = 1, avance_DG = f_base/POURCENTAGE_AVANCE_DG
                                        else, avance_DG = f_base*POURCENTAGE_AVANCE_DG
                                        avance_DG
                                        ]
pf_base_AM             # ecriture que si sup a 0
                        if f_base_AM > 0, avance_AM = f_base_AM, avance_AM

pf_base_BM             # ecriture que si sup a 0
                        if f_base_BM > 0, avance_BM = f_base_BM, avance_BM

pf_base_CM             # ecriture que si sup a 0
                        if f_base_CM > 0,   [
                                            if gfr_CM = 1, avance_CM = f_base_CM/POURCENTAGE_AVANCE_CM
                                            else, avance_CM = f_base_CM*POURCENTAGE_AVANCE_CM
                                            avance_CM
                                            ]
pf_base_DM             # ecriture que si sup a 0
                        if f_base_DM > 0,   [
                                            if gfr_DM = 1, avance_DM = f_base_DM/POURCENTAGE_AVANCE_DM
                                            else, avance_DM = f_base_DM*POURCENTAGE_AVANCE_DM
                                            avance_DM
                                            ]
######################################################                      

pf_ent_cir_AG          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance_AG = f_ent_cir, avance_AG

pf_ent_cir_BG          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance_BG = f_ent_cir, avance_BG

pf_ent_cir_CG          # ecriture que si sup a 0
                        if f_ent_cir > 0,   [
                                            if gfr_CG = 1, avance_CG = f_ent_cir/POURCENTAGE_AVANCE_CG
                                            else, avance_CG = f_ent_cir*POURCENTAGE_AVANCE_CG
                                            avance_CG
                                            ]
pf_ent_cir_DG          # ecriture que si sup a 0
                        if f_ent_cir > 0,   [
                                            if gfr_DG = 1, avance_DG = f_ent_cir/POURCENTAGE_AVANCE_DG
                                            else, avance_DG = f_ent_cir*POURCENTAGE_AVANCE_DG
                                            avance_DG
                                            ]
pf_ent_cir_AM          # ecriture que si sup a 0
                        if f_ent_cir_AM > 0, avance_AM = f_ent_cir_AM, avance_AM

pf_ent_cir_BM          # ecriture que si sup a 0
                        if f_ent_cir_BM > 0, avance_BM = f_ent_cir_BM, avance_BM

pf_ent_cir_CM          # ecriture que si sup a 0
                        if f_ent_cir_CM > 0,    [
                                                if gfr_CM = 1, avance_CM = f_ent_cir_CM/POURCENTAGE_AVANCE_CM
                                                else, avance_CM = f_ent_cir_CM*POURCENTAGE_AVANCE_CM
                                                avance_CM
                                                ]
pf_ent_cir_DM          # ecriture que si sup a 0
                        if f_ent_cir_DM > 0,    [
                                                if gfr_DM = 1, avance_DM = f_ent_cir_DM/POURCENTAGE_AVANCE_DM
                                                else, avance_DM = f_ent_cir_DM*POURCENTAGE_AVANCE_DM
                                                avance_DM
                                                ]
######################################################

pf_int_hel_AG          # ecriture que si sup a 0
                        if f_int_hel > 0, avance_AG = f_int_hel, avance_AG

pf_int_hel_BG          # ecriture que si sup a 0
                        if f_int_hel > 0, avance_BG = f_int_hel, avance_BG

pf_int_hel_CG          # ecriture que si sup a 0
                        if f_int_hel > 0,   [
                                            if gfr_CG = 1, avance_CG = f_int_hel/POURCENTAGE_AVANCE_CG
                                            else, avance_CG = f_int_hel*POURCENTAGE_AVANCE_CG
                                            avance_CG
                                            ]
pf_int_hel_DG          # ecriture que si sup a 0
                        if f_int_hel > 0,   [
                                            if gfr_DG = 1, avance_DG = f_int_hel/POURCENTAGE_AVANCE_DG
                                            else, avance_DG = f_int_hel*POURCENTAGE_AVANCE_DG
                                            avance_DG
                                            ]
pf_int_hel_AM          # ecriture que si sup a 0
                        if f_int_hel_AM > 0, avance_AM = f_int_hel_AM, avance_AM

pf_int_hel_BM          # ecriture que si sup a 0
                        if f_int_hel_BM > 0, avance_BM = f_int_hel_BM, avance_BM

pf_int_hel_CM          # ecriture que si sup a 0
                        if f_int_hel_CM > 0,    [
                                                if gfr_CM = 1, avance_CM = f_int_hel_CM/POURCENTAGE_AVANCE_CM
                                                else, avance_CM = f_int_hel_CM*POURCENTAGE_AVANCE_CM
                                                avance_CM
                                                ]
pf_int_hel_DM          # ecriture que si sup a 0
                        if f_int_hel_DM > 0,    [
                                                if gfr_DM = 1, avance_DM = f_int_hel_DM/POURCENTAGE_AVANCE_DM
                                                else, avance_DM = f_int_hel_DM*POURCENTAGE_AVANCE_DM
                                                avance_DM
                                                ]
######################################################

pf_spiral_AG           # ecriture que si sup a 0
                        if f_spiral > 0, avance_AG = f_spiral, avance_AG

pf_spiral_BG           # ecriture que si sup a 0
                        if f_spiral > 0, avance_BG = f_spiral, avance_BG

pf_spiral_CG           # ecriture que si sup a 0
                        if f_spiral > 0,    [
                                            if gfr_CG = 1, avance_CG = f_spiral/POURCENTAGE_AVANCE_CG
                                            else, avance_CG = f_spiral*POURCENTAGE_AVANCE_CG
                                            avance_CG
                                            ]
pf_spiral_DG           # ecriture que si sup a 0
                        if f_spiral > 0,    [
                                            if gfr_DG = 1, avance_DG = f_spiral/POURCENTAGE_AVANCE_DG
                                            else, avance_DG = f_spiral*POURCENTAGE_AVANCE_DG
                                            avance_DG
                                            ]
pf_spiral_AM           # ecriture que si sup a 0
                        if f_spiral_AM > 0, avance_AM = f_spiral_AM, avance_AM

pf_spiral_BM           # ecriture que si sup a 0
                        if f_spiral_BM > 0, avance_BM = f_spiral_BM, avance_BM

pf_spiral_CM           # ecriture que si sup a 0
                        if f_spiral_CM > 0,     [
                                                if gfr_CM = 1, avance_CM = f_spiral_CM/POURCENTAGE_AVANCE_CM
                                                else, avance_CM = f_spiral_CM*POURCENTAGE_AVANCE_CM
                                                avance_CM
                                                ]
pf_spiral_DM           # ecriture que si sup a 0
                        if f_spiral_DM > 0,     [
                                                if gfr_DM = 1, avance_DM = f_spiral_DM/POURCENTAGE_AVANCE_DM
                                                else, avance_DM = f_spiral_DM*POURCENTAGE_AVANCE_DM
                                                avance_DM
                                                ]
######################################################

pf_int_fin_AG          # ecriture que si sup a 0
                        if f_int_fin > 0, avance_AG = f_int_fin, avance_AG

pf_int_fin_BG          # ecriture que si sup a 0
                        if f_int_fin > 0, avance_BG = f_int_fin, avance_BG

pf_int_fin_CG          # ecriture que si sup a 0
                        if f_int_fin > 0,   [
                                            if gfr_CG = 1, avance_CG = f_int_fin/POURCENTAGE_AVANCE_CG
                                            else, avance_CG = f_int_fin*POURCENTAGE_AVANCE_CG
                                            avance_CG
                                            ]
pf_int_fin_DG          # ecriture que si sup a 0
                        if f_int_fin > 0,   [
                                            if gfr_DG = 1, avance_DG = f_int_fin/POURCENTAGE_AVANCE_DG
                                            else, avance_DG = f_int_fin*POURCENTAGE_AVANCE_DG
                                            avance_DG
                                            ]
pf_int_fin_AM          # ecriture que si sup a 0
                        if f_int_fin_AM > 0, avance_AM = f_int_fin_AM, avance_AM

pf_int_fin_BM          # ecriture que si sup a 0
                        if f_int_fin_BM > 0, avance_BM = f_int_fin_BM, avance_BM

pf_int_fin_CM          # ecriture que si sup a 0
                        if f_int_fin_CM > 0,    [
                                                if gfr_CM = 1, avance_CM = f_int_fin_CM/POURCENTAGE_AVANCE_CM
                                                else, avance_CM = f_int_fin_CM*POURCENTAGE_AVANCE_CM
                                                avance_CM
                                                ]
pf_int_fin_DM          # ecriture que si sup a 0
                        if f_int_fin_DM > 0,    [
                                                if gfr_DM = 1, avance_DM = f_int_fin_DM/POURCENTAGE_AVANCE_DM
                                                else, avance_DM = f_int_fin_DM*POURCENTAGE_AVANCE_DM
                                                avance_DM
                                                ]
######################################################

pf_sor_cir_AG         # ecriture que si sup a 0
                        if f_sor_cir > 0, avance_AG = f_sor_cir, avance_AG

pf_sor_cir_BG          # ecriture que si sup a 0
                        if f_sor_cir > 0, avance_BG = f_sor_cir, avance_BG

pf_sor_cir_CG          # ecriture que si sup a 0
                        if f_sor_cir > 0,   [
                                            if gfr_CG = 1, avance_CG = f_sor_cir/POURCENTAGE_AVANCE_CG
                                            else, avance_CG = f_sor_cir*POURCENTAGE_AVANCE_CG
                                            avance_CG
                                            ]
pf_sor_cir_DG          # ecriture que si sup a 0
                        if f_sor_cir > 0,   [
                                            if gfr_DG = 1, avance_DG = f_sor_cir/POURCENTAGE_AVANCE_DG
                                            else, avance_DG = f_sor_cir*POURCENTAGE_AVANCE_DG
                                            avance_DG
                                            ]
pf_sor_cir_AM         # ecriture que si sup a 0
                        if f_sor_cir_AM > 0, avance_AM = f_sor_cir_AM, avance_AM

pf_sor_cir_BM          # ecriture que si sup a 0
                        if f_sor_cir_BM > 0, avance_BM = f_sor_cir_BM, avance_BM

pf_sor_cir_CM          # ecriture que si sup a 0
                        if f_sor_cir_CM > 0,    [
                                                if gfr_CM = 1, avance_CM = f_sor_cir_CM/POURCENTAGE_AVANCE_CM
                                                else, avance_CM = f_sor_cir_CM*POURCENTAGE_AVANCE_CM
                                                avance_CM
                                                ]
pf_sor_cir_DM          # ecriture que si sup a 0
                        if f_sor_cir_DM > 0,    [
                                                if gfr_DM = 1, avance_DM = f_sor_cir_DM/POURCENTAGE_AVANCE_DM
                                                else, avance_DM = f_sor_cir_DM*POURCENTAGE_AVANCE_DM
                                                avance_DM
                                                ]
#endregion
#region pcor_ray

pcor_ray_on_AG         # ecriture d'un G41 ou G42 si besoin
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G42"
                        else, "G41"
                        ]

pcor_ray_on_BG         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]

pcor_ray_on_CG         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]
pcor_ray_on_DG         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]
pcor_ray_on_AM         # ecriture d'un G41 ou G42 si besoin
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G42"
                        else, "G41"
                        ]

pcor_ray_on_BM         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]

pcor_ray_on_CM         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]
pcor_ray_on_DM         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]
######################################################

pcor_ray_on_inv_AG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G41"
                        else, "G42"
                        ]

pcor_ray_on_inv_BG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]

pcor_ray_on_inv_CG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]
pcor_ray_on_inv_DG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]
pcor_ray_on_inv_AM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G41"
                        else, "G42"
                        ]

pcor_ray_on_inv_BM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]

pcor_ray_on_inv_CM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]
pcor_ray_on_inv_DM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]
######################################################

pcor_ray_off_AG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, "G40"

pcor_ray_off_BG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$

pcor_ray_off_CG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$

pcor_ray_off_DG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$
pcor_ray_off_AM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, "G40"

pcor_ray_off_BM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$

pcor_ray_off_CM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$

pcor_ray_off_DM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$
#endregion
#region phase_1

phase_1_AG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        yp_chs_AG = yabs_AG
                        yinc_abs = yp_chs_AG * abs_inc
                        jp_chs_AG = yinc_abs

                        gcode$ = 0
                        pnumligne, sdcom_par, "MOUVEMENT APPROCHE", sfcom_par, e$
                        pnumligne, pgcode_AG, *z_retraction_AG, e$
                        gcode$ = 1
                        pnumligne, pgcode_AG, *z_dessus_brut_AG, pf_base_AG,  e$

                        if sens_usi = 1,
                                [
                                xp_chs_AG = xabs_AG + ent_perp
                                pnumligne, pgcode_AG, *xp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,  e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - (ray_ent_cir * 2)
                                ip_chs_AG = (ray_ent_cir * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposiion
                                pnumligne, pgcode_AG,xp_chs_AG,yp_chs_AG, ip_chs_AG, jp_chs_AG, e$
                                ]
                        else,
                                [
                                xp_chs_AG = xabs_AG - ent_perp
                                pnumligne, pgcode_AG, *xp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,  e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + (ray_ent_cir*2)
                                ip_chs_AG = (ray_ent_cir) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposiion
                                pnumligne, pgcode_AG,xp_chs_AG,yp_chs_AG, ip_chs_AG, jp_chs_AG, e$
                                ]

phase_1_BG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_BG, *z_retraction_BG, e$
                        gcode$ = 1
                        pnumligne, pgcode_BG, *z_dessus_brut_BG, pf_base_BG,  e$
                        pcor_ray_on_BG
                        pnumligne, pgcode_BG, *x_perp_BG, pf_ent_cir_BG, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BG = x_perp_BG - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_BG = x_perp_BG + (ray_ent_cir*2)
                                ]
                        yp_chs_BG = yabs_BG
                        j_ent_cir_BG = 0 # si J en INC
                        #j_ent_cir_BG = y$ # si J en ABS                   
                        pnumligne, pgcode_BG,xp_chs_BG,yp_chs_BG, i_ent_cir_BG, j_ent_cir_BG, e$

phase_1_CG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_CG, *z_retraction_CG, e$
                        gcode$ = 1
                        pnumligne, pgcode_CG, *z_dessus_brut_CG, pf_base_CG,  e$
                        pcor_ray_on_CG
                        pnumligne, pgcode_CG, *x_perp_CG, pf_ent_cir_CG, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CG = x_perp_CG - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_CG = x_perp_CG + (ray_ent_cir*2)
                                ]
                        yp_chs_CG = yabs_CG
                        j_ent_cir_CG = 0 # si J en INC
                        #j_ent_cir_CG = y$ # si J en ABS                   
                        pnumligne, pgcode_CG,xp_chs_CG,yp_chs_CG, i_ent_cir_CG, j_ent_cir_CG, e$

phase_1_DG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_DG, *z_retraction_DG, e$
                        gcode$ = 1
                        pnumligne, pgcode_DG, *z_dessus_brut_DG, pf_base_DG,  e$
                        pcor_ray_on_DG
                        pnumligne, pgcode_DG, *x_perp_DG, pf_ent_cir_DG, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_DG = x_perp_DG - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_DG = x_perp_DG + (ray_ent_cir*2)
                                ]
                        yp_chs_DG = yabs_DG
                        j_ent_cir_DG = 0 # si J en INC
                        #j_ent_cir_DG = y$ # si J en ABS                   
                        pnumligne, pgcode_DG,xp_chs_DG,yp_chs_DG, i_ent_cir_DG, j_ent_cir_DG, e$

phase_1_AM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        yp_chs_AM = yabs_AM
                        yinc_abs = yp_chs_AM * abs_inc
                        jp_chs_AM = yinc_abs

                        gcode$ = 0
                        pnumligne, sdcom_par, "MOUVEMENT APPROCHE", sfcom_par, e$
                        pnumligne, pgcode_AM, *z_retraction_AM, e$
                        gcode$ = 1
                        pnumligne, pgcode_AM, *z_dessus_brut_AM, pf_base_AM,  e$

                        if sens_usi = 1,
                                [
                                xp_chs_AM = xabs_AM + ent_perp
                                pnumligne, pgcode_AM, *xp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,  e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - (ray_ent_cir * 2)
                                ip_chs_AM = (ray_ent_cir * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposiion
                                pnumligne, pgcode_AM,xp_chs_AM,yp_chs_AM, ip_chs_AM, jp_chs_AM, e$
                                ]
                        else,
                                [
                                xp_chs_AM = xabs_AM - ent_perp
                                pnumligne, pgcode_AM, *xp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,  e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + (ray_ent_cir*2)
                                ip_chs_AM = (ray_ent_cir) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposiion
                                pnumligne, pgcode_AM,xp_chs_AM,yp_chs_AM, ip_chs_AM, jp_chs_AM, e$
                                ]

phase_1_BM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_BM, *z_retraction_BM, e$
                        gcode$ = 1
                        pnumligne, pgcode_BM, *z_dessus_brut_BM, pf_base_BM,  e$
                        pcor_ray_on_BM
                        pnumligne, pgcode_BM, *x_perp_BM, pf_ent_cir_BM, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BM = x_perp_BM - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_BM = x_perp_BM + (ray_ent_cir*2)
                                ]
                        yp_chs_BM = yabs_BM
                        j_ent_cir_BM = 0 # si J en INC
                        #j_ent_cir_BM = y$ # si J en ABS                   
                        pnumligne, pgcode_BM,xp_chs_BM,yp_chs_BM, i_ent_cir_BM, j_ent_cir_BM, e$

phase_1_CM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_CM, *z_retraction_CM, e$
                        gcode$ = 1
                        pnumligne, pgcode_CM, *z_dessus_brut_CM, pf_base_CM,  e$
                        pcor_ray_on_CM
                        pnumligne, pgcode_CM, *x_perp_CM, pf_ent_cir_CM, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CM = x_perp_CM - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_CM = x_perp_CM + (ray_ent_cir*2)
                                ]
                        yp_chs_CM = yabs_CM
                        j_ent_cir_CM = 0 # si J en INC
                        #j_ent_cir_CM = y$ # si J en ABS                   
                        pnumligne, pgcode_CM,xp_chs_CM,yp_chs_CM, i_ent_cir_CM, j_ent_cir_CM, e$

phase_1_DM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_DM, *z_retraction_DM, e$
                        gcode$ = 1
                        pnumligne, pgcode_DM, *z_dessus_brut_DM, pf_base_DM,  e$
                        pcor_ray_on_DM
                        pnumligne, pgcode_DM, *x_perp_DM, pf_ent_cir_DM, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_DM = x_perp_DM - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_DM = x_perp_DM + (ray_ent_cir*2)
                                ]
                        yp_chs_DM = yabs_DM
                        j_ent_cir_DM = 0 # si J en INC
                        #j_ent_cir_DM = y$ # si J en ABS                   
                        pnumligne, pgcode_DM,xp_chs_DM,yp_chs_DM, i_ent_cir_DM, j_ent_cir_DM, e$
#endregion
#region phase_1_2

phase_1_2_AG               #   ecriture mouvement d'entre du cycle soit l'approche en Z, ligne en goute d'eau
                            gcode$ = 0
                            pnumligne, pgcode_AG, *z_retraction_AG, e$
                            gcode$ = 1
                            pnumligne, pgcode_AG, *z_dessus_brut_AG, pf_base_AG,  e$
                            #pcor_ray_on_AG
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom_par, e$
                            jp_chs_AG = 0
                            zp_chs_AG = z_dessus_brut_AG
                            if sens_usi = 1,
                                [

                                xp_chs_AG = xabs_AG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_AG = (ray_cercle_ebauche * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AG = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_ent_cir_AG , e$
                                ]
                            else,
                                [

                                xp_chs_AG = xabs_AG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + (( dia_ebauche - tldia$) /2)
                                ip_chs_AG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )+ xinc_abs
                                jp_chs_AG = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_ent_cir_AG , e$
                                ]

phase_1_2_BG              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_BG, *z_retraction_BG, e$
                            gcode$ = 1
                            pnumligne, pgcode_BG, *z_dessus_brut_BG, pf_base_BG,  e$
                            #pcor_ray_on_BG
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_dessus_brut_BG
                            if sens_usi = 1,
                                [

                                xp_chs_BG = xabs_BG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_ent_cir_BG,pcor_ray_on_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_BG = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_ent_cir_BG , e$
                                ]
                            else,
                                [

                                xp_chs_BG = xabs_BG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_ent_cir_BG, pcor_ray_on_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + (( dia_ebauche - tldia$) /2)
                                ip_chs_BG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_BG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_ent_cir_BG , e$
                                ]

phase_1_2_CG              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_CG, *z_retraction_CG, e$
                            gcode$ = 1
                            pnumligne, pgcode_CG, *z_dessus_brut_CG, pf_base_CG,  e$
                            #pcor_ray_on_CG
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_dessus_brut_CG
                            if sens_usi = 1,
                                [

                                xp_chs_CG = xabs_CG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_ent_cir_CG,pcor_ray_on_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_CG = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_ent_cir_CG , e$
                                ]
                            else,
                                [

                                xp_chs_CG = xabs_CG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_ent_cir_CG, pcor_ray_on_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + (( dia_ebauche - tldia$) /2)
                                ip_chs_CG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_CG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_ent_cir_CG , e$
                                ]

phase_1_2_DG              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_DG, *z_retraction_DG, e$
                            gcode$ = 1
                            pnumligne, pgcode_DG, *z_dessus_brut_DG, pf_base_DG,  e$
                            #pcor_ray_on_DG
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_DG = 0
                            zp_chs_DG = z_dessus_brut_DG
                            if sens_usi = 1,
                                [

                                xp_chs_DG = xabs_DG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_ent_cir_DG,pcor_ray_on_DG, e$
                                gcode$ = 2
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_DG = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_DG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, *zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_ent_cir_DG , e$
                                ]
                            else,
                                [

                                xp_chs_DG = xabs_DG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_ent_cir_DG, pcor_ray_on_DG, e$
                                gcode$ = 3
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG + (( dia_ebauche - tldia$) /2)
                                ip_chs_DG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_DG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_ent_cir_DG , e$
                                ]
phase_1_2_AM               #   ecriture mouvement d'entre du cycle soit l'approche en Z, ligne en goute d'eau
                            gcode$ = 0
                            pnumligne, pgcode_AM, *z_retraction_AM, e$
                            gcode$ = 1
                            pnumligne, pgcode_AM, *z_dessus_brut_AM, pf_base_AM,  e$
                            #pcor_ray_on_AM
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom_par, e$
                            jp_chs_AM = 0
                            zp_chs_AM = z_dessus_brut_AM
                            if sens_usi = 1,
                                [

                                xp_chs_AM = xabs_AM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_AM = (ray_cercle_ebauche * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AM = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_ent_cir_AM , e$
                                ]
                            else,
                                [

                                xp_chs_AM = xabs_AM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + (( dia_ebauche - tldia$) /2)
                                ip_chs_AM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )+ xinc_abs
                                jp_chs_AM = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_ent_cir_AM , e$
                                ]

phase_1_2_BM              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_BM, *z_retraction_BM, e$
                            gcode$ = 1
                            pnumligne, pgcode_BM, *z_dessus_brut_BM, pf_base_BM,  e$
                            #pcor_ray_on_BM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_dessus_brut_BM
                            if sens_usi = 1,
                                [

                                xp_chs_BM = xabs_BM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_ent_cir_BM,pcor_ray_on_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_BM = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_ent_cir_BM , e$
                                ]
                            else,
                                [

                                xp_chs_BM = xabs_BM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_ent_cir_BM, pcor_ray_on_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + (( dia_ebauche - tldia$) /2)
                                ip_chs_BM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_BM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_ent_cir_BM , e$
                                ]

phase_1_2_CM              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_CM, *z_retraction_CM, e$
                            gcode$ = 1
                            pnumligne, pgcode_CM, *z_dessus_brut_CM, pf_base_CM,  e$
                            #pcor_ray_on_CM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_dessus_brut_CM
                            if sens_usi = 1,
                                [

                                xp_chs_CM = xabs_CM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_ent_cir_CM,pcor_ray_on_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_CM = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_ent_cir_CM , e$
                                ]
                            else,
                                [

                                xp_chs_CM = xabs_CM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_ent_cir_CM, pcor_ray_on_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + (( dia_ebauche - tldia$) /2)
                                ip_chs_CM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_CM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_ent_cir_CM , e$
                                ]
phase_1_2_DM              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_DM, *z_retraction_DM, e$
                            gcode$ = 1
                            pnumligne, pgcode_DM, *z_dessus_brut_DM, pf_base_DM,  e$
                            #pcor_ray_on_DM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_DM = 0
                            zp_chs_DM = z_dessus_brut_DM
                            if sens_usi = 1,
                                [

                                xp_chs_DM = xabs_DM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_ent_cir_DM,pcor_ray_on_DM, e$
                                gcode$ = 2
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_DM = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_DM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, *zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_ent_cir_DM , e$
                                ]
                            else,
                                [

                                xp_chs_DM = xabs_DM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_ent_cir_DM, pcor_ray_on_DM, e$
                                gcode$ = 3
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM + (( dia_ebauche - tldia$) /2)
                                ip_chs_DM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_DM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_ent_cir_DM , e$
                                ]
#endregion
#region phase_2

phase_2_AG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom_par, "EBAUCHE HELICOIDALE", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_dessus_brut_AG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ( ray_ebauche * 2 )
                                ip_chs_AG = i_eb_cir + xinc_abs
                                zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue   
                                xp_chs_AG = xp_chs_AG - ( ray_ebauche * 2 )
                                ip_chs_AG = (i_eb_cir * -1) + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AG = z_profondeur
                                else, zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                xp_chs_AG = xp_chs_AG - ( ray_ebauche * 2 )
                                ip_chs_AG = (i_eb_cir * -1) + xinc_abs
                                zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ( ray_ebauche * 2 )
                                ip_chs_AG = i_eb_cir + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AG = z_profondeur
                                else, zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                ]
                            ]

phase_2_BG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_dessus_brut_BG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BG = xp_chs_BG + ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir
                                zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                xp_chs_BG = xp_chs_BG - ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BG = z_profondeur
                                else, zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_BG = xp_chs_BG - ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir * -1
                                zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                xp_chs_BG = xp_chs_BG + ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BG = z_profondeur
                                else, zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                ]
                            ]

phase_2_CG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_dessus_brut_CG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CG = xp_chs_CG + ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir
                                zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                xp_chs_CG = xp_chs_CG - ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CG = z_profondeur
                                else, zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_CG = xp_chs_CG - ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir * -1
                                zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                xp_chs_CG = xp_chs_CG + ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CG = z_profondeur
                                else, zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                ]
                            ]

phase_2_DG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_dessus_brut_DG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_DG = xp_chs_DG + ( ray_ebauche * 2 )
                                ip_chs_DG = i_eb_cir
                                zp_chs_DG = zp_chs_DG - ( pas_z / 2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_hel_DG, e$
                                xp_chs_DG = xp_chs_DG - ( ray_ebauche * 2 )
                                ip_chs_DG = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_DG = z_profondeur
                                else, zp_chs_DG = zp_chs_DG - ( pas_z / 2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_hel_DG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_DG = xp_chs_DG - ( ray_ebauche * 2 )
                                ip_chs_DG = i_eb_cir * -1
                                zp_chs_DG = zp_chs_DG - ( pas_z / 2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_hel_DG, e$
                                xp_chs_DG = xp_chs_DG + ( ray_ebauche * 2 )
                                ip_chs_DG = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_DG = z_profondeur
                                else, zp_chs_DG = zp_chs_DG - ( pas_z / 2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_hel_DG, e$
                                ]
                            ]
phase_2_AM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom_par, "EBAUCHE HELICOIDALE", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_dessus_brut_AM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ( ray_ebauche * 2 )
                                ip_chs_AM = i_eb_cir + xinc_abs
                                zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue   
                                xp_chs_AM = xp_chs_AM - ( ray_ebauche * 2 )
                                ip_chs_AM = (i_eb_cir * -1) + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AM = z_profondeur
                                else, zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                xp_chs_AM = xp_chs_AM - ( ray_ebauche * 2 )
                                ip_chs_AM = (i_eb_cir * -1) + xinc_abs
                                zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ( ray_ebauche * 2 )
                                ip_chs_AM = i_eb_cir + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AM = z_profondeur
                                else, zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                ]
                            ]

phase_2_BM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_dessus_brut_BM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BM = xp_chs_BM + ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir
                                zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                xp_chs_BM = xp_chs_BM - ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BM = z_profondeur
                                else, zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_BM = xp_chs_BM - ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir * -1
                                zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                xp_chs_BM = xp_chs_BM + ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BM = z_profondeur
                                else, zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                ]
                            ]

phase_2_CM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_dessus_brut_CM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CM = xp_chs_CM + ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir
                                zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                xp_chs_CM = xp_chs_CM - ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CM = z_profondeur
                                else, zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_CM = xp_chs_CM - ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir * -1
                                zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                xp_chs_CM = xp_chs_CM + ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CM = z_profondeur
                                else, zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                ]
                            ]

phase_2_DM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_dessus_brut_DM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_DM = xp_chs_DM + ( ray_ebauche * 2 )
                                ip_chs_DM = i_eb_cir
                                zp_chs_DM = zp_chs_DM - ( pas_z / 2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_hel_DM, e$
                                xp_chs_DM = xp_chs_DM - ( ray_ebauche * 2 )
                                ip_chs_DM = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_DM = z_profondeur
                                else, zp_chs_DM = zp_chs_DM - ( pas_z / 2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_hel_DM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_DM = xp_chs_DM - ( ray_ebauche * 2 )
                                ip_chs_DM = i_eb_cir * -1
                                zp_chs_DM = zp_chs_DM - ( pas_z / 2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_hel_DM, e$
                                xp_chs_DM = xp_chs_DM + ( ray_ebauche * 2 )
                                ip_chs_DM = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_DM = z_profondeur
                                else, zp_chs_DM = zp_chs_DM - ( pas_z / 2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_hel_DM, e$
                                ]
                            ]
#endregion
#region phase_3

phase_3_AG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom_par, "EBAUCHE SPIRALE", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue     
                                xp_chs_max = xabs_AG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_AG-xp_chs_AG)*2) + (pas_xy)
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_max = xabs_AG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) + (pas_xy)
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour 
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) #+ (pas_xy/2)
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                        # deuxieme demi-tour
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_AG-xp_chs_AG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AG
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                if xp_chs_AG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_AG = xp_chs_max
                                    ]
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            else,
                                [
                                # premier demi-tour 
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_AG- xp_chs_AG)*2) #+ (pas_xy/2)
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                # deuxieme demi-tour
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AG
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                if xp_chs_AG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_AG = xp_chs_max
                                    ]
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            ]

phase_3_BG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_BG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_BG-xp_chs_BG)*2) + (pas_xy)
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_BG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) + (pas_xy)
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) #+ (pas_xy/2)
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_BG-xp_chs_BG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BG
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                if xp_chs_BG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_BG = xp_chs_max
                                    ]
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_BG- xp_chs_BG)*2) #+ (pas_xy/2)
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BG
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                if xp_chs_BG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_BG = xp_chs_max
                                    ]
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            ]

phase_3_CG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_CG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_CG-xp_chs_CG)*2) + (pas_xy)
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_CG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) + (pas_xy)
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) #+ (pas_xy/2)
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_CG-xp_chs_CG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CG
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                if xp_chs_CG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_CG = xp_chs_max
                                    ]
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_CG- xp_chs_CG)*2) #+ (pas_xy/2)
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CG
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                if xp_chs_CG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_CG = xp_chs_max
                                    ]
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            ]

phase_3_DG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_DG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_DG-xp_chs_DG)*2) + (pas_xy)
                                xp_chs_DG = xp_chs_DG + diam_cercle
                                ip_chs_DG = (diam_cercle/2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_DG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_DG-xabs_DG)*2) + (pas_xy)
                                xp_chs_DG = xp_chs_DG - diam_cercle
                                ip_chs_DG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_DG-xabs_DG)*2) #+ (pas_xy/2)
                                xp_chs_DG = xp_chs_DG - diam_cercle
                                ip_chs_DG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_DG-xp_chs_DG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_DG
                                xp_chs_DG = xp_chs_DG + diam_cercle
                                if xp_chs_DG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_DG = xp_chs_max
                                    ]
                                ip_chs_DG = (diam_cercle/2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_DG- xp_chs_DG)*2) #+ (pas_xy/2)
                                xp_chs_DG = xp_chs_DG + diam_cercle
                                ip_chs_DG = (diam_cercle/2)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_DG-xabs_DG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_DG
                                xp_chs_DG = xp_chs_DG - diam_cercle
                                if xp_chs_DG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_DG = xp_chs_max
                                    ]
                                ip_chs_DG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_spiral_DG, e$
                                ]
                            ]

phase_3_AM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom_par, "EBAUCHE SPIRALE", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue     
                                xp_chs_max = xabs_AM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_AM-xp_chs_AM)*2) + (pas_xy)
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_max = xabs_AM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) + (pas_xy)
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour 
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) #+ (pas_xy/2)
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                        # deuxieme demi-tour
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_AM-xp_chs_AM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AM
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                if xp_chs_AM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_AM = xp_chs_max
                                    ]
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            else,
                                [
                                # premier demi-tour 
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_AM- xp_chs_AM)*2) #+ (pas_xy/2)
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                # deuxieme demi-tour
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AM
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                if xp_chs_AM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_AM = xp_chs_max
                                    ]
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            ]

phase_3_BM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_BM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_BM-xp_chs_BM)*2) + (pas_xy)
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_BM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) + (pas_xy)
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) #+ (pas_xy/2)
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_BM-xp_chs_BM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BM
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                if xp_chs_BM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_BM = xp_chs_max
                                    ]
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_BM- xp_chs_BM)*2) #+ (pas_xy/2)
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BM
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                if xp_chs_BM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_BM = xp_chs_max
                                    ]
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            ]

phase_3_CM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_CM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_CM-xp_chs_CM)*2) + (pas_xy)
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_CM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) + (pas_xy)
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) #+ (pas_xy/2)
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_CM-xp_chs_CM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CM
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                if xp_chs_CM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_CM = xp_chs_max
                                    ]
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_CM- xp_chs_CM)*2) #+ (pas_xy/2)
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CM
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                if xp_chs_CM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_CM = xp_chs_max
                                    ]
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            ]

phase_3_DM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_DM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_DM-xp_chs_DM)*2) + (pas_xy)
                                xp_chs_DM = xp_chs_DM + diam_cercle
                                ip_chs_DM = (diam_cercle/2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_DM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_DM-xabs_DM)*2) + (pas_xy)
                                xp_chs_DM = xp_chs_DM - diam_cercle
                                ip_chs_DM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_DM-xabs_DM)*2) #+ (pas_xy/2)
                                xp_chs_DM = xp_chs_DM - diam_cercle
                                ip_chs_DM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_DM-xp_chs_DM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_DM
                                xp_chs_DM = xp_chs_DM + diam_cercle
                                if xp_chs_DM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_DM = xp_chs_max
                                    ]
                                ip_chs_DM = (diam_cercle/2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_DM- xp_chs_DM)*2) #+ (pas_xy/2)
                                xp_chs_DM = xp_chs_DM + diam_cercle
                                ip_chs_DM = (diam_cercle/2)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_DM-xabs_DM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_DM
                                xp_chs_DM = xp_chs_DM - diam_cercle
                                if xp_chs_DM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_DM = xp_chs_max
                                    ]
                                ip_chs_DM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_spiral_DM, e$
                                ]
                            ]
#endregion
#region phase_4

phase_4_AG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom_par, "1ERE SERIE DE FINITION", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_4_BG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_4_CG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]
phase_4_DG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                        ]
phase_4_AM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom_par, "1ERE SERIE DE FINITION", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_4_BM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_4_CM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]

phase_4_DM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                        ]
#endregion
#region phase_4_2

phase_4_2_AG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2)  + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_4_2_BG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_4_2_CG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]
phase_4_2_DG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                        ]
phase_4_2_AM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2)  + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_4_2_BM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_4_2_CM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]

phase_4_2_DM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                        ]
#endregion
#region phase_5

phase_5_AG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom_par, "1ERE SORTIE GOUTTE D EAU", sfcom_par, e$


                            zp_chs_AG = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie  + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]

phase_5_BG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]

phase_5_CG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]

phase_5_DG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_DG = xp_chs_DG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xp_chs_DG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                ]

phase_5_AM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom_par, "1ERE SORTIE GOUTTE D EAU", sfcom_par, e$


                            zp_chs_AM = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie  + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]

phase_5_BM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]

phase_5_CM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]

phase_5_DM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_DM = xp_chs_DM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xp_chs_DM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                ]
#endregion
#region phase_5_2

phase_5_2_AG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$


                            zp_chs_AG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]

phase_5_2_BG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]

phase_5_2_CG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]

phase_5_2_DG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_DG = xp_chs_DG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xp_chs_DG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                ]
phase_5_2_AM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$


                            zp_chs_AM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]

phase_5_2_BM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]

phase_5_2_CM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
phase_5_2_DM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_DM = xp_chs_DM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xp_chs_DM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                ]
#endregion
#region phase_6

phase_6_AG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU", sfcom_par, e$

                            zp_chs_AG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2)
                                ip_chs_AG = ((ray_cercle_sortie * cos(angle_ray_sortie))) + xinc_abs
                                jp_chs_AG = ((ray_cercle_sortie * sin(angle_ray_sortie)) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]
                            else,
                                [
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]

phase_6_BG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]

phase_6_CG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
phase_6_DG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_DG = xabs_DG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DG
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                gcode$ = 3
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG - ( (dia_final - tldia$) /2)
                                ip_chs_DG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_DG = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, *zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DG
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                gcode$ = 2
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG + ( (dia_final - tldia$) /2)
                                ip_chs_DG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_DG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                ]
phase_6_AM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU", sfcom_par, e$

                            zp_chs_AM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2)
                                ip_chs_AM = ((ray_cercle_sortie * cos(angle_ray_sortie))) + xinc_abs
                                jp_chs_AM = ((ray_cercle_sortie * sin(angle_ray_sortie)) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]
                            else,
                                [
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]

phase_6_BM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]

phase_6_CM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]

phase_6_DM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_DM = xabs_DM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DM
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                gcode$ = 3
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM - ( (dia_final - tldia$) /2)
                                ip_chs_DM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_DM = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, *zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DM
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                gcode$ = 2
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM + ( (dia_final - tldia$) /2)
                                ip_chs_DM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_DM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                ]
#endregion
#region phase_6_2

phase_6_2_AG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$

                            zp_chs_AG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AG = (ray_cercle_sortie * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]
                            else,
                                [
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AG = ((ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]

phase_6_2_BG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]

phase_6_2_CG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
phase_6_2_DG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_DG = xabs_DG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DG
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                gcode$ = 2
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG - ( (dia_final - tldia$) /2)
                                ip_chs_DG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_DG = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, *zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DG
                                pnumligne, pgcode_force_DG, *xp_chs_DG,*yp_chs_DG, zp_chs_DG, pf_sor_cir_DG, e$
                                gcode$ = 3
                                yp_chs_DG = yabs_DG
                                xp_chs_DG = xabs_DG + ( (dia_final - tldia$) /2)
                                ip_chs_DG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_DG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                ]
phase_6_2_AM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom_par, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$

                            zp_chs_AM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AM = (ray_cercle_sortie * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]
                            else,
                                [
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AM = ((ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]

phase_6_2_BM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]

phase_6_2_CM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]

phase_6_2_DM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_DM = xabs_DM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DM
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                gcode$ = 2
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM - ( (dia_final - tldia$) /2)
                                ip_chs_DM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_DM = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, *zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_DM
                                pnumligne, pgcode_force_DM, *xp_chs_DM,*yp_chs_DM, zp_chs_DM, pf_sor_cir_DM, e$
                                gcode$ = 3
                                yp_chs_DM = yabs_DM
                                xp_chs_DM = xabs_DM + ( (dia_final - tldia$) /2)
                                ip_chs_DM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_DM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                ]
#endregion
#region phase_7

phase_7_AG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom_par, "2EME SERIE DE FINITION", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs

                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_7_BG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_7_CG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]
phase_7_DG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                        ]
phase_7_AM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom_par, "2EME SERIE DE FINITION", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs

                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_7_BM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_7_CM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]
phase_7_DM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                        ]
#endregion
#region phase_7_2

phase_7_2_AG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom_par, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom_par, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2)* -1) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs

                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1 ) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_7_2_BG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_7_2_CG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]
phase_7_2_DG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_DG = yabs_DG
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                            else,
                                [
                                xp_chs_DG = xabs_DG + ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                xp_chs_DG = xabs_DG - ((dia_final - tldia$)/2)
                                ip_chs_DG = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_int_fin_DG, e$
                                ]
                        ]
phase_7_2_AM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom_par, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom_par, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2)* -1) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs

                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1 ) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_7_2_BM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_7_2_CM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]

phase_7_2_DM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_DM = yabs_DM
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                            else,
                                [
                                xp_chs_DM = xabs_DM + ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                xp_chs_DM = xabs_DM - ((dia_final - tldia$)/2)
                                ip_chs_DM = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_int_fin_DM, e$
                                ]
                        ]
#endregion
#region phase_8

phase_8_AG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom_par, "2EME SORTIE GOUTTE D EAU", sfcom_par, e$

                            zp_chs_AG = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue     
                                gcode$ = 3   # G03 car on est en opposition
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie  + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue     
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]

phase_8_BG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]

phase_8_CG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]

phase_8_DG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_DG = xp_chs_DG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_DG = xp_chs_DG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$

                                ]
phase_8_AM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom_par, "2EME SORTIE GOUTTE D EAU", sfcom_par, e$

                            zp_chs_AM = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue     
                                gcode$ = 3   # G03 car on est en opposition
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie  + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue     
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]

phase_8_BM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]

phase_8_CM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]

phase_8_DM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_DM = xp_chs_DM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_DM = xp_chs_DM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$

                                ]
#endregion
#region phase_8_2

phase_8_2_AG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom_par, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$

                            zp_chs_AG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]

phase_8_2_BG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]

phase_8_2_CG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]


phase_8_2_DG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_DG = 0
                            zp_chs_DG = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_DG = xp_chs_DG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_DG = xp_chs_DG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DG = yabs_DG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DG,xp_chs_DG,yp_chs_DG, zp_chs_DG, *ip_chs_DG, *jp_chs_DG, pf_sor_cir_DG , e$
                                gcode$ = 1
                                pcor_ray_off_DG
                                pnumligne, pgcode_force_DG, *xabs_DG,*yabs_DG, zp_chs_DG, pf_sor_cir_DG, e$

                                ]

phase_8_2_AM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom_par, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom_par, e$

                            zp_chs_AM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]

phase_8_2_BM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]

phase_8_2_CM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]

phase_8_2_DM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_DM = 0
                            zp_chs_DM = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_DM = xp_chs_DM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_DM = xp_chs_DM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_DM = yabs_DM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_DM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_DM,xp_chs_DM,yp_chs_DM, zp_chs_DM, *ip_chs_DM, *jp_chs_DM, pf_sor_cir_DM , e$
                                gcode$ = 1
                                pcor_ray_off_DM
                                pnumligne, pgcode_force_DM, *xabs_DM,*yabs_DM, zp_chs_DM, pf_sor_cir_DM, e$

                                ]
#endregion
# ------------------------ FIN CYCLE SPECIAL HELICOIDO-SPIRAL -------------------------
#endregion

#region   CYCLE SPECIAL percage decompose #OK
#region variables CYCLE SPECIAL percage decompose
# ------------------------ debut  CYCLE SPECIAL percage decompose -------------------------

#-------- ecriture des format -------------

fmt "F" 4 avance_1 #OK
fmt "F" 4 avance_2 #OK
fmt "F" 4 avance_3 #OK
fmt "F" 4 avance_4 #OK
fmt "F" 4 avance_5 #OK
fmt "ABS_REL" 4 abso_rel
fmt "sortie" 4 sortie_cycle_prof
#endregion
#region pvoirvariable_2

pvoirvariable_2_AG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_AG = ",prof_1_AG, e$
                            "voir prof_2_AG = ",prof_2_AG, e$
                            "voir prof_3_AG = ",prof_3_AG, e$
                            "voir prof_4_AG = ",prof_4_AG, e$
                            "voir prof_5_AG = ",prof_5_AG, e$
                            "voir tempo_1_AG = ",*tempo_1_AG, e$
                            "voir tempo_2_AG = ",*tempo_2_AG, e$
                            "voir tempo_3_AG = ",*tempo_3_AG, e$
                            "voir tempo_4_AG = ",*tempo_4_AG, e$
                            "voir tempo_5_AG = ",*tempo_5_AG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_AG = ",z_retraction_AG, e$

pvoirvariable_2_BG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_BG = ",prof_1_BG, e$
                            "voir prof_2_BG = ",prof_2_BG, e$
                            "voir prof_3_BG = ",prof_3_BG, e$
                            "voir prof_4_BG = ",prof_4_BG, e$
                            "voir prof_5_BG = ",prof_5_BG, e$
                            "voir tempo_1_BG = ",*tempo_1_BG, e$
                            "voir tempo_2_BG = ",*tempo_2_BG, e$
                            "voir tempo_3_BG = ",*tempo_3_BG, e$
                            "voir tempo_4_BG = ",*tempo_4_BG, e$
                            "voir tempo_5_BG = ",*tempo_5_BG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_BG = ",z_retraction_BG, e$

pvoirvariable_2_CG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_CG = ",prof_1_CG, e$
                            "voir prof_2_CG = ",prof_2_CG, e$
                            "voir prof_3_CG = ",prof_3_CG, e$
                            "voir prof_4_CG = ",prof_4_CG, e$
                            "voir prof_5_CG = ",prof_5_CG, e$
                            "voir tempo_1_CG = ",*tempo_1_CG, e$
                            "voir tempo_2_CG = ",*tempo_2_CG, e$
                            "voir tempo_3_CG = ",*tempo_3_CG, e$
                            "voir tempo_4_CG = ",*tempo_4_CG, e$
                            "voir tempo_5_CG = ",*tempo_5_CG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_CG = ",z_retraction_CG, e$

pvoirvariable_2_DG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_DG = ",prof_1_DG, e$
                            "voir prof_2_DG = ",prof_2_DG, e$
                            "voir prof_3_DG = ",prof_3_DG, e$
                            "voir prof_4_DG = ",prof_4_DG, e$
                            "voir prof_5_DG = ",prof_5_DG, e$
                            "voir tempo_1_DG = ",*tempo_1_DG, e$
                            "voir tempo_2_DG = ",*tempo_2_DG, e$
                            "voir tempo_3_DG = ",*tempo_3_DG, e$
                            "voir tempo_4_DG = ",*tempo_4_DG, e$
                            "voir tempo_5_DG = ",*tempo_5_DG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_DG = ",z_retraction_DG, e$

pvoirvariable_2_AM   # voir les varialble apres mise a jour
                            "voir avance_1_AM = ",avance_1_AM, e$
                            "voir avance_2_AM = ",avance_2_AM, e$
                            "voir avance_3_AM  = ",avance_3_AM, e$
                            "voir avance_4_AM = ",avance_4_AM, e$
                            "voir avance_5_AM = ",avance_5_AM, e$
                            "voir prof_1_AM = ",prof_1_AM, e$
                            "voir prof_2_AM = ",prof_2_AM, e$
                            "voir prof_3_AM = ",prof_3_AM, e$
                            "voir prof_4_AM = ",prof_4_AM, e$
                            "voir prof_5_AM = ",prof_5_AM, e$
                            "voir tempo_1_AM = ",*tempo_1_AM, e$
                            "voir tempo_2_AM = ",*tempo_2_AM, e$
                            "voir tempo_3_AM = ",*tempo_3_AM, e$
                            "voir tempo_4_AM = ",*tempo_4_AM, e$
                            "voir tempo_5_AM = ",*tempo_5_AM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_AM = ",z_retraction_AM, e$

pvoirvariable_2_BM   # voir les varialble apres mise a jour
                            "voir avance_1_BM = ",avance_1_BM, e$
                            "voir avance_2_BM = ",avance_2_BM, e$
                            "voir avance_3_BM  = ",avance_3_BM, e$
                            "voir avance_4_BM = ",avance_4_BM, e$
                            "voir avance_5_BM = ",avance_5_BM, e$
                            "voir prof_1_BM = ",prof_1_BM, e$
                            "voir prof_2_BM = ",prof_2_BM, e$
                            "voir prof_3_BM = ",prof_3_BM, e$
                            "voir prof_4_BM = ",prof_4_BM, e$
                            "voir prof_5_BM = ",prof_5_BM, e$
                            "voir tempo_1_BM = ",*tempo_1_BM, e$
                            "voir tempo_2_BM = ",*tempo_2_BM, e$
                            "voir tempo_3_BM = ",*tempo_3_BM, e$
                            "voir tempo_4_BM = ",*tempo_4_BM, e$
                            "voir tempo_5_BM = ",*tempo_5_BM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_BM = ",z_retraction_BM, e$

pvoirvariable_2_CM   # voir les varialble apres mise a jour
                            "voir avance_1_CM = ",avance_1_CM, e$
                            "voir avance_2_CM = ",avance_2_CM, e$
                            "voir avance_3_CM  = ",avance_3_CM, e$
                            "voir avance_4_CM = ",avance_4_CM, e$
                            "voir avance_5_CM = ",avance_5_CM, e$
                            "voir prof_1_CM = ",prof_1_CM, e$
                            "voir prof_2_CM = ",prof_2_CM, e$
                            "voir prof_3_CM = ",prof_3_CM, e$
                            "voir prof_4_CM = ",prof_4_CM, e$
                            "voir prof_5_CM = ",prof_5_CM, e$
                            "voir tempo_1_CM = ",*tempo_1_CM, e$
                            "voir tempo_2_CM = ",*tempo_2_CM, e$
                            "voir tempo_3_CM = ",*tempo_3_CM, e$
                            "voir tempo_4_CM = ",*tempo_4_CM, e$
                            "voir tempo_5_CM = ",*tempo_5_CM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_CM = ",z_retraction_CM, e$

pvoirvariable_2_DM   # voir les varialble apres mise a jour
                            "voir avance_1_DM = ",avance_1_DM, e$
                            "voir avance_2_DM = ",avance_2_DM, e$
                            "voir avance_3_DM  = ",avance_3_DM, e$
                            "voir avance_4_DM = ",avance_4_DM, e$
                            "voir avance_5_DM = ",avance_5_DM, e$
                            "voir prof_1_DM = ",prof_1_DM, e$
                            "voir prof_2_DM = ",prof_2_DM, e$
                            "voir prof_3_DM = ",prof_3_DM, e$
                            "voir prof_4_DM = ",prof_4_DM, e$
                            "voir prof_5_DM = ",prof_5_DM, e$
                            "voir tempo_1_DM = ",*tempo_1_DM, e$
                            "voir tempo_2_DM = ",*tempo_2_DM, e$
                            "voir tempo_3_DM = ",*tempo_3_DM, e$
                            "voir tempo_4_DM = ",*tempo_4_DM, e$
                            "voir tempo_5_DM = ",*tempo_5_DM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_DM = ",z_retraction_DM, e$
#endregion
#region pcalcule_variable_2

pcalcule_variable_2_AG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_AG = drl_prm1$
                            prof_2_AG = drl_prm2$
                            prof_3_AG = drl_prm3$
                            prof_4_AG = drl_prm4$
                            prof_5_AG = drl_prm5$
                            tempo_1_AG = (frac(drl_prm6$)) * 10
                            tempo_2_AG = (frac(drl_prm7$)) * 10
                            tempo_3_AG = (frac(drl_prm8$)) * 10
                            tempo_4_AG = (frac(drl_prm9$)) * 10
                            tempo_5_AG = (frac(drl_prm10$)) * 10
                            abso_rel = peck1$
                            zabs_AG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_AG =  prof_1_AG + tosz$
                            prof_2_rel_AG = prof_2_AG + prof_1_rel_AG
                            prof_3_rel_AG = prof_3_AG + prof_2_rel_AG
                            prof_4_rel_AG = prof_4_AG + prof_3_rel_AG
                            prof_5_rel_AG = prof_5_AG + prof_4_rel_AG

                            #pvoirvariable_2_AG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur100_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur101_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                               ]

                            if prof_1_AG = 9999,
                                [
                                if prog_AG = 1, [
                                subout$ = 4
                                serreur_visu_AG = serreur102_AG + no2str(numop_AG)
                                *serreur_visu_AG, e$
                                result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AG = 1
                                                ]
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5

pcalcule_variable_2_BG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_BG = drl_prm1$
                            prof_2_BG = drl_prm2$
                            prof_3_BG = drl_prm3$
                            prof_4_BG = drl_prm4$
                            prof_5_BG = drl_prm5$
                            tempo_1_BG = (frac(drl_prm6$)) * 10
                            tempo_2_BG = (frac(drl_prm7$)) * 10
                            tempo_3_BG = (frac(drl_prm8$)) * 10
                            tempo_4_BG = (frac(drl_prm9$)) * 10
                            tempo_5_BG = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_BG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_BG =  prof_1_BG + tosz$
                            prof_2_rel_BG = prof_2_BG + prof_1_rel_BG
                            prof_3_rel_BG = prof_3_BG + prof_2_rel_BG
                            prof_4_rel_BG = prof_4_BG + prof_3_rel_BG
                            prof_5_rel_BG = prof_5_BG + prof_4_rel_BG

                            #pvoirvariable_2_BG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur100_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur101_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                               ]

                            if prof_1_BG = 9999,
                                [
                                if prog_BG = 1, [
                                subout$ = 4
                                serreur_visu_BG = serreur102_BG + no2str(numop_BG)
                                *serreur_visu_BG, e$
                                result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_BG = 1
                                                ]
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5

pcalcule_variable_2_CG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_CG = drl_prm1$
                            prof_2_CG = drl_prm2$
                            prof_3_CG = drl_prm3$
                            prof_4_CG = drl_prm4$
                            prof_5_CG = drl_prm5$
                            tempo_1_CG = (frac(drl_prm6$)) * 10
                            tempo_2_CG = (frac(drl_prm7$)) * 10
                            tempo_3_CG = (frac(drl_prm8$)) * 10
                            tempo_4_CG = (frac(drl_prm9$)) * 10
                            tempo_5_CG = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_CG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_CG =  prof_1_CG + tosz$
                            prof_2_rel_CG = prof_2_CG + prof_1_rel_CG
                            prof_3_rel_CG = prof_3_CG + prof_2_rel_CG
                            prof_4_rel_CG = prof_4_CG + prof_3_rel_CG
                            prof_5_rel_CG = prof_5_CG + prof_4_rel_CG

                            #pvoirvariable_2_CG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur100_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                               if prog_CG = 1,  [
                                subout$ = 4
                                serreur_visu_CG = serreur101_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                               ]

                            if prof_1_CG = 9999,
                                [
                                if prog_CG = 1, [
                                subout$ = 4
                                serreur_visu_CG = serreur102_CG + no2str(numop_CG)
                                *serreur_visu_CG, e$
                                result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CG = 1
                                                ]
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5
pcalcule_variable_2_DG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_DG = drl_prm1$
                            prof_2_DG = drl_prm2$
                            prof_3_DG = drl_prm3$
                            prof_4_DG = drl_prm4$
                            prof_5_DG = drl_prm5$
                            tempo_1_DG = (frac(drl_prm6$)) * 10
                            tempo_2_DG = (frac(drl_prm7$)) * 10
                            tempo_3_DG = (frac(drl_prm8$)) * 10
                            tempo_4_DG = (frac(drl_prm9$)) * 10
                            tempo_5_DG = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_DG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_DG =  prof_1_DG + tosz$
                            prof_2_rel_DG = prof_2_DG + prof_1_rel_DG
                            prof_3_rel_DG = prof_3_DG + prof_2_rel_DG
                            prof_4_rel_DG = prof_4_DG + prof_3_rel_DG
                            prof_5_rel_DG = prof_5_DG + prof_4_rel_DG

                            #pvoirvariable_2_DG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur100_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                               if prog_DG = 1,  [
                                subout$ = 4
                                serreur_visu_DG = serreur101_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                               ]

                            if prof_1_DG = 9999,
                                [
                                if prog_DG = 1, [
                                subout$ = 4
                                serreur_visu_DG = serreur102_DG + no2str(numop_DG)
                                *serreur_visu_DG, e$
                                result = mprint(serreur_visu_DG)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DG = 1
                                                ]
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5
pcalcule_variable_2_AM       # mise a jour des variables 
                            avance_1_AM = int(drl_prm6$)
                            avance_2_AM = int(drl_prm7$)
                            avance_3_AM  = int(drl_prm8$)
                            avance_4_AM = int(drl_prm9$)
                            avance_5_AM = int(drl_prm10$)
                            prof_1_AM = drl_prm1$
                            prof_2_AM = drl_prm2$
                            prof_3_AM = drl_prm3$
                            prof_4_AM = drl_prm4$
                            prof_5_AM = drl_prm5$
                            tempo_1_AM = (frac(drl_prm6$)) * 10
                            tempo_2_AM = (frac(drl_prm7$)) * 10
                            tempo_3_AM = (frac(drl_prm8$)) * 10
                            tempo_4_AM = (frac(drl_prm9$)) * 10
                            tempo_5_AM = (frac(drl_prm10$)) * 10
                            abso_rel = peck1$
                            zabs_AM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_AM =  prof_1_AM + tosz$
                            prof_2_rel_AM = prof_2_AM + prof_1_rel_AM
                            prof_3_rel_AM = prof_3_AM + prof_2_rel_AM
                            prof_4_rel_AM = prof_4_AM + prof_3_rel_AM
                            prof_5_rel_AM = prof_5_AM + prof_4_rel_AM

                            #pvoirvariable_2_AM


                            @avance_1_AM, @avance_2_AM, @avance_3_AM, @avance_4_AM, @avance_5_AM

                            if avance_1_AM < 0 | avance_2_AM < 0 | avance_3_AM < 0 | avance_4_AM < 0 | avance_5_AM < 0,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur100_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                               if prog_AM = 1,  [
                                subout$ = 4
                                serreur_visu_AM = serreur101_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                               ]

                            if prof_1_AM = 9999,
                                [
                                if prog_AM = 1, [
                                subout$ = 4
                                serreur_visu_AM = serreur102_AM + no2str(numop_AM)
                                *serreur_visu_AM, e$
                                result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_AM = 1
                                                ]
                                ]

                                if avance_1_AM = 0, avance_1_AM = frplunge$
                                @avance_1_AM
                                if avance_2_AM = 0, avance_2_AM = avance_1_AM
                                @avance_2_AM
                                if avance_3_AM = 0, avance_3_AM = avance_2_AM
                                @avance_3_AM
                                if avance_4_AM = 0, avance_4_AM = avance_3_AM
                                @avance_4_AM
                                if avance_5_AM = 0, avance_5_AM = avance_4_AM
                                @avance_5_AM

pcalcule_variable_2_BM       # mise a jour des variables 
                            avance_1_BM = int(drl_prm6$)
                            avance_2_BM = int(drl_prm7$)
                            avance_3_BM  = int(drl_prm8$)
                            avance_4_BM = int(drl_prm9$)
                            avance_5_BM = int(drl_prm10$)
                            prof_1_BM = drl_prm1$
                            prof_2_BM = drl_prm2$
                            prof_3_BM = drl_prm3$
                            prof_4_BM = drl_prm4$
                            prof_5_BM = drl_prm5$
                            tempo_1_BM = (frac(drl_prm6$)) * 10
                            tempo_2_BM = (frac(drl_prm7$)) * 10
                            tempo_3_BM = (frac(drl_prm8$)) * 10
                            tempo_4_BM = (frac(drl_prm9$)) * 10
                            tempo_5_BM = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_BM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_BM =  prof_1_BM + tosz$
                            prof_2_rel_BM = prof_2_BM + prof_1_rel_BM
                            prof_3_rel_BM = prof_3_BM + prof_2_rel_BM
                            prof_4_rel_BM = prof_4_BM + prof_3_rel_BM
                            prof_5_rel_BM = prof_5_BM + prof_4_rel_BM

                            #pvoirvariable_2_BM


                            @avance_1_BM, @avance_2_BM, @avance_3_BM, @avance_4_BM, @avance_5_BM

                            if avance_1_BM < 0 | avance_2_BM < 0 | avance_3_BM < 0 | avance_4_BM < 0 | avance_5_BM < 0,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur100_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur101_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                               ]

                            if prof_1_BM = 9999,
                                [
                                if prog_BM = 1, [
                                subout$ = 4
                                serreur_visu_BM = serreur102_BM + no2str(numop_BM)
                                *serreur_visu_BM, e$
                                result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_BM = 1
                                                ]
                                ]

                                if avance_1_BM = 0, avance_1_BM = frplunge$
                                @avance_1_BM
                                if avance_2_BM = 0, avance_2_BM = avance_1_BM
                                @avance_2_BM
                                if avance_3_BM = 0, avance_3_BM = avance_2_BM
                                @avance_3_BM
                                if avance_4_BM = 0, avance_4_BM = avance_3_BM
                                @avance_4_BM
                                if avance_5_BM = 0, avance_5_BM = avance_4_BM
                                @avance_5_BM

pcalcule_variable_2_CM       # mise a jour des variables 
                            avance_1_CM = int(drl_prm6$)
                            avance_2_CM = int(drl_prm7$)
                            avance_3_CM  = int(drl_prm8$)
                            avance_4_CM = int(drl_prm9$)
                            avance_5_CM = int(drl_prm10$)
                            prof_1_CM = drl_prm1$
                            prof_2_CM = drl_prm2$
                            prof_3_CM = drl_prm3$
                            prof_4_CM = drl_prm4$
                            prof_5_CM = drl_prm5$
                            tempo_1_CM = (frac(drl_prm6$)) * 10
                            tempo_2_CM = (frac(drl_prm7$)) * 10
                            tempo_3_CM = (frac(drl_prm8$)) * 10
                            tempo_4_CM = (frac(drl_prm9$)) * 10
                            tempo_5_CM = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_CM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_CM =  prof_1_CM + tosz$
                            prof_2_rel_CM = prof_2_CM + prof_1_rel_CM
                            prof_3_rel_CM = prof_3_CM + prof_2_rel_CM
                            prof_4_rel_CM = prof_4_CM + prof_3_rel_CM
                            prof_5_rel_CM = prof_5_CM + prof_4_rel_CM

                            #pvoirvariable_2_CM


                            @avance_1_CM, @avance_2_CM, @avance_3_CM, @avance_4_CM, @avance_5_CM

                            if avance_1_CM < 0 | avance_2_CM < 0 | avance_3_CM < 0 | avance_4_CM < 0 | avance_5_CM < 0,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur100_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur101_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                               ]

                            if prof_1_CM = 9999,
                                [
                                if prog_CM = 1, [
                                subout$ = 4
                                serreur_visu_CM = serreur102_CM + no2str(numop_CM)
                                *serreur_visu_CM, e$
                                result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_CM = 1
                                                ]
                                ]

                                if avance_1_CM = 0, avance_1_CM = frplunge$
                                @avance_1_CM
                                if avance_2_CM = 0, avance_2_CM = avance_1_CM
                                @avance_2_CM
                                if avance_3_CM = 0, avance_3_CM = avance_2_CM
                                @avance_3_CM
                                if avance_4_CM = 0, avance_4_CM = avance_3_CM
                                @avance_4_CM
                                if avance_5_CM = 0, avance_5_CM = avance_4_CM
                                @avance_5_CM

pcalcule_variable_2_DM       # mise a jour des variables 
                            avance_1_DM = int(drl_prm6$)
                            avance_2_DM = int(drl_prm7$)
                            avance_3_DM  = int(drl_prm8$)
                            avance_4_DM = int(drl_prm9$)
                            avance_5_DM = int(drl_prm10$)
                            prof_1_DM = drl_prm1$
                            prof_2_DM = drl_prm2$
                            prof_3_DM = drl_prm3$
                            prof_4_DM = drl_prm4$
                            prof_5_DM = drl_prm5$
                            tempo_1_DM = (frac(drl_prm6$)) * 10
                            tempo_2_DM = (frac(drl_prm7$)) * 10
                            tempo_3_DM = (frac(drl_prm8$)) * 10
                            tempo_4_DM = (frac(drl_prm9$)) * 10
                            tempo_5_DM = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_DM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_DM =  prof_1_DM + tosz$
                            prof_2_rel_DM = prof_2_DM + prof_1_rel_DM
                            prof_3_rel_DM = prof_3_DM + prof_2_rel_DM
                            prof_4_rel_DM = prof_4_DM + prof_3_rel_DM
                            prof_5_rel_DM = prof_5_DM + prof_4_rel_DM

                            #pvoirvariable_2_DM


                            @avance_1_DM, @avance_2_DM, @avance_3_DM, @avance_4_DM, @avance_5_DM

                            if avance_1_DM < 0 | avance_2_DM < 0 | avance_3_DM < 0 | avance_4_DM < 0 | avance_5_DM < 0,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur100_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur101_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                               ]

                            if prof_1_DM = 9999,
                                [
                                if prog_DM = 1, [
                                subout$ = 4
                                serreur_visu_DM = serreur102_DM + no2str(numop_DM)
                                *serreur_visu_DM, e$
                                result = mprint(serreur_visu_DM)
                                #exitpost$ # abandonner 
                                subout$ = 3
                                erreur_DM = 1
                                                ]
                                ]

                                if avance_1_DM = 0, avance_1_DM = frplunge$
                                @avance_1_DM
                                if avance_2_DM = 0, avance_2_DM = avance_1_DM
                                @avance_2_DM
                                if avance_3_DM = 0, avance_3_DM = avance_2_DM
                                @avance_3_DM
                                if avance_4_DM = 0, avance_4_DM = avance_3_DM
                                @avance_4_DM
                                if avance_5_DM = 0, avance_5_DM = avance_4_DM
                                @avance_5_DM
#endregion
#region percage_avance_controle_2

percage_avance_controle_2_AG

                                gcode$ = 0

                                xabs_AG = xprint_AG
                                yabs_AG = yprint_AG
                                zabs_AG = initht$
                                if drill5axes_AG <> 1,
                                [
                                pnumligne, pgcode_force_AG, *zabs_AG, e$
                                pnumligne, sdcom_par, " POSITIONEMENT TROU SUIVANT", sfcom_par, e$
                                pnumligne, *xabs_AG, *yabs_AG, e$
                                ]
                                percage_avance_controle_AG

percage_avance_controle_2_BG

                                gcode$ = 0

                                xabs_BG = xprint_BG
                                yabs_BG = yprint_BG
                                zabs_BG = initht$
                                if drill5axes_BG <> 1,
                                [
                                pnumligne, pgcode_force_BG, *zabs_BG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BG, *yabs_BG, e$
                                ]
                                percage_avance_controle_BG

percage_avance_controle_2_CG

                                gcode$ = 0

                                xabs_CG = xprint_CG
                                yabs_CG = yprint_CG
                                zabs_CG = initht$
                                if drill5axes_CG <> 1,
                                [
                                pnumligne, pgcode_force_CG, *zabs_CG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CG, *yabs_CG, e$
                                ]
                                percage_avance_controle_CG
percage_avance_controle_2_DG

                                gcode$ = 0

                                xabs_DG = xprint_DG
                                yabs_DG = yprint_DG
                                zabs_DG = initht$
                                if drill5axes_DG <> 1,
                                [
                                pnumligne, pgcode_force_DG, *zabs_DG, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_DG, *yabs_DG, e$
                                ]
                                percage_avance_controle_DG
percage_avance_controle_2_AM

                                gcode$ = 0

                                xabs_AM = xprint_AM
                                yabs_AM = yprint_AM
                                zabs_AM = initht$
                                if drill5axes_AM <> 1,
                                [
                                pnumligne, pgcode_force_AM, *zabs_AM, e$
                                pnumligne, sdcom_par, " POSITIONEMENT TROU SUIVANT", sfcom_par, e$
                                pnumligne, *xabs_AM, *yabs_AM, e$
                                ]
                                percage_avance_controle_AM

percage_avance_controle_2_BM

                                gcode$ = 0

                                xabs_BM = xprint_BM
                                yabs_BM = yprint_BM
                                zabs_BM = initht$
                                if drill5axes_BM <> 1,
                                [
                                pnumligne, pgcode_force_BM, *zabs_BM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BM, *yabs_BM, e$
                                ]
                                percage_avance_controle_BM

percage_avance_controle_2_CM

                                gcode$ = 0

                                xabs_CM = xprint_CM
                                yabs_CM = yprint_CM
                                zabs_CM = initht$
                                if drill5axes_CM <> 1,
                                [
                                pnumligne, pgcode_force_CM, *zabs_CM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CM, *yabs_CM, e$
                                ]
                                percage_avance_controle_CM

percage_avance_controle_2_DM

                                gcode$ = 0

                                xabs_DM = xprint_DM
                                yabs_DM = yprint_DM
                                zabs_DM = initht$
                                if drill5axes_DM <> 1,
                                [
                                pnumligne, pgcode_force_DM, *zabs_DM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_DM, *yabs_DM, e$
                                ]
                                percage_avance_controle_DM
#endregion
#region percage_avance_controle

percage_avance_controle_AG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_AG = 1

                            pnumligne, sdcom_par, "APPROCHE DESSUS DU TROU", sfcom_par, e$
                            pcalcule_variable_2_AG
                            gcode$ = 0
                            pnumligne, pgcode_AG, zabs_AG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom_par, "PREMIERE PROFONDEUR", sfcom_par, e$
                                fr$ = avance_1
                                pnumligne, pgcode_AG, prof_1_AG, pfr_AG,  e$
                                if tempo_1_AG > 0, pnumligne, *tempo_1_AG, e$

                                if prof_2_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "DEUXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_AG, prof_2_AG, pfr_AG,  e$
                                        if tempo_2_AG > 0, pnumligne, *tempo_2_AG, e$
                                        ]
                                if prof_3_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "TROIXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_AG, prof_3_AG, pfr_AG,  e$
                                        if tempo_3_AG > 0, pnumligne, *tempo_3_AG, e$
                                        ]
                                if prof_4_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "QUATRIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_AG, prof_4_AG, pfr_AG,  e$
                                        if tempo_4_AG > 0, pnumligne, *tempo_4_AG, e$
                                        ]
                                if prof_5_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "CINQUIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_AG, prof_5_AG, pfr_AG,  e$
                                        if tempo_5_AG > 0, pnumligne, *tempo_5_AG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom_par, "PREMIERE PROFONDEUR", sfcom_par, e$
                                fr$ = avance_1

                                pnumligne, pgcode_AG, prof_1_rel_AG, pfr_AG,  e$
                                if tempo_1_AG > 0, pnumligne, *tempo_1_AG, e$

                                if prof_2_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "DEUXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_AG, prof_2_rel_AG, pfr_AG,  e$
                                        if tempo_2_AG > 0, pnumligne, *tempo_2_AG, e$
                                        ]
                                if prof_3_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "TROIXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_AG, prof_3_rel_AG, pfr_AG,  e$
                                        if tempo_3_AG > 0, pnumligne, *tempo_3_AG, e$
                                        ]
                                if prof_4_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "QUATRIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_AG, prof_4_rel_AG, pfr_AG,  e$
                                        if tempo_4_AG > 0, pnumligne, *tempo_4_AG, e$
                                        ]
                                if prof_5_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "CINQUIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_AG, prof_5_rel_AG, pfr_AG,  e$
                                        if tempo_5_AG > 0, pnumligne, *tempo_5_AG, e$
                                        ]

                                 ]

percage_avance_controle_BG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_BG = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_BG
                            gcode$ = 0
                            pnumligne, pgcode_BG, zabs_BG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                pnumligne, pgcode_BG, prof_1_BG, pfr_BG,  e$
                                if tempo_1_BG > 0, pnumligne, *tempo_1_BG, e$

                                if prof_2_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_BG, prof_2_BG, pfr_BG,  e$
                                        if tempo_2_BG > 0, pnumligne, *tempo_2_BG, e$
                                        ]
                                if prof_3_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_BG, prof_3_BG, pfr_BG,  e$
                                        if tempo_3_BG > 0, pnumligne, *tempo_3_BG, e$
                                        ]
                                if prof_4_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_BG, prof_4_BG, pfr_BG,  e$
                                        if tempo_4_BG > 0, pnumligne, *tempo_4_BG, e$
                                        ]
                                if prof_5_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_BG, prof_5_BG, pfr_BG,  e$
                                        if tempo_5_BG > 0, pnumligne, *tempo_5_BG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                pnumligne, pgcode_BG, prof_1_rel_BG, pfr_BG,  e$
                                if tempo_1_BG > 0, pnumligne, *tempo_1_BG, e$

                                if prof_2_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_BG, prof_2_rel_BG, pfr_BG,  e$
                                        if tempo_2_BG > 0, pnumligne, *tempo_2_BG, e$
                                        ]
                                if prof_3_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_BG, prof_3_rel_BG, pfr_BG,  e$
                                        if tempo_3_BG > 0, pnumligne, *tempo_3_BG, e$
                                        ]
                                if prof_4_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_BG, prof_4_rel_BG, pfr_BG,  e$
                                        if tempo_4_BG > 0, pnumligne, *tempo_4_BG, e$
                                        ]
                                if prof_5_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_BG, prof_5_rel_BG, pfr_BG,  e$
                                        if tempo_5_BG > 0, pnumligne, *tempo_5_BG, e$
                                        ]

                                 ]
percage_avance_controle_CG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_CG = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_CG
                            gcode$ = 0
                            pnumligne, pgcode_CG, zabs_CG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                pnumligne, pgcode_CG, prof_1_CG, pfr_CG,  e$
                                if tempo_1_CG > 0, pnumligne, *tempo_1_CG, e$

                                if prof_2_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_CG, prof_2_CG, pfr_CG,  e$
                                        if tempo_2_CG > 0, pnumligne, *tempo_2_CG, e$
                                        ]
                                if prof_3_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_CG, prof_3_CG, pfr_CG,  e$
                                        if tempo_3_CG > 0, pnumligne, *tempo_3_CG, e$
                                        ]
                                if prof_4_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_CG, prof_4_CG, pfr_CG,  e$
                                        if tempo_4_CG > 0, pnumligne, *tempo_4_CG, e$
                                        ]
                                if prof_5_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_CG, prof_5_CG, pfr_CG,  e$
                                        if tempo_5_CG > 0, pnumligne, *tempo_5_CG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                pnumligne, pgcode_CG, prof_1_rel_CG, pfr_CG,  e$
                                if tempo_1_CG > 0, pnumligne, *tempo_1_CG, e$

                                if prof_2_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_CG, prof_2_rel_CG, pfr_CG,  e$
                                        if tempo_2_CG > 0, pnumligne, *tempo_2_CG, e$
                                        ]
                                if prof_3_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_CG, prof_3_rel_CG, pfr_CG,  e$
                                        if tempo_3_CG > 0, pnumligne, *tempo_3_CG, e$
                                        ]
                                if prof_4_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_CG, prof_4_rel_CG, pfr_CG,  e$
                                        if tempo_4_CG > 0, pnumligne, *tempo_4_CG, e$
                                        ]
                                if prof_5_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_CG, prof_5_rel_CG, pfr_CG,  e$
                                        if tempo_5_CG > 0, pnumligne, *tempo_5_CG, e$
                                        ]

                                 ]
percage_avance_controle_DG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_DG = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_DG
                            gcode$ = 0
                            pnumligne, pgcode_DG, zabs_DG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                pnumligne, pgcode_DG, prof_1_DG, pfr_DG,  e$
                                if tempo_1_DG > 0, pnumligne, *tempo_1_DG, e$

                                if prof_2_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_DG, prof_2_DG, pfr_DG,  e$
                                        if tempo_2_DG > 0, pnumligne, *tempo_2_DG, e$
                                        ]
                                if prof_3_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_DG, prof_3_DG, pfr_DG,  e$
                                        if tempo_3_DG > 0, pnumligne, *tempo_3_DG, e$
                                        ]
                                if prof_4_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_DG, prof_4_DG, pfr_DG,  e$
                                        if tempo_4_DG > 0, pnumligne, *tempo_4_DG, e$
                                        ]
                                if prof_5_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_DG, prof_5_DG, pfr_DG,  e$
                                        if tempo_5_DG > 0, pnumligne, *tempo_5_DG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                pnumligne, pgcode_DG, prof_1_rel_DG, pfr_DG,  e$
                                if tempo_1_DG > 0, pnumligne, *tempo_1_DG, e$

                                if prof_2_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, pgcode_DG, prof_2_rel_DG, pfr_DG,  e$
                                        if tempo_2_DG > 0, pnumligne, *tempo_2_DG, e$
                                        ]
                                if prof_3_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, pgcode_DG, prof_3_rel_DG, pfr_DG,  e$
                                        if tempo_3_DG > 0, pnumligne, *tempo_3_DG, e$
                                        ]
                                if prof_4_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, pgcode_DG, prof_4_rel_DG, pfr_DG,  e$
                                        if tempo_4_DG > 0, pnumligne, *tempo_4_DG, e$
                                        ]
                                if prof_5_DG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, pgcode_DG, prof_5_rel_DG, pfr_DG,  e$
                                        if tempo_5_DG > 0, pnumligne, *tempo_5_DG, e$
                                        ]

                                 ]
percage_avance_controle_AM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_AM = 1

                            pnumligne, sdcom_par, "APPROCHE DESSUS DU TROU", sfcom_par, e$
                            pcalcule_variable_2_AM
                            gcode$ = 0
                            pnumligne, pgcode_AM, zabs_AM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom_par, "PREMIERE PROFONDEUR", sfcom_par, e$
                                fr$ = avance_1_AM
                                pnumligne, pgcode_AM, prof_1_AM, pfr_AM,  e$
                                if tempo_1_AM > 0, pnumligne, *tempo_1_AM, e$

                                if prof_2_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "DEUXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_2_AM
                                        pnumligne, pgcode_AM, prof_2_AM, pfr_AM,  e$
                                        if tempo_2_AM > 0, pnumligne, *tempo_2_AM, e$
                                        ]
                                if prof_3_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "TROIXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_3_AM
                                        pnumligne, pgcode_AM, prof_3_AM, pfr_AM,  e$
                                        if tempo_3_AM > 0, pnumligne, *tempo_3_AM, e$
                                        ]
                                if prof_4_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "QUATRIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_4_AM
                                        pnumligne, pgcode_AM, prof_4_AM, pfr_AM,  e$
                                        if tempo_4_AM > 0, pnumligne, *tempo_4_AM, e$
                                        ]
                                if prof_5_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "CINQUIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_5_AM
                                        pnumligne, pgcode_AM, prof_5_AM, pfr_AM,  e$
                                        if tempo_5_AM > 0, pnumligne, *tempo_5_AM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom_par, "PREMIERE PROFONDEUR", sfcom_par, e$
                                fr$ = avance_1_AM

                                pnumligne, pgcode_AM, prof_1_rel_AM, pfr_AM,  e$
                                if tempo_1_AM > 0, pnumligne, *tempo_1_AM, e$

                                if prof_2_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "DEUXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_2_AM
                                        pnumligne, pgcode_AM, prof_2_rel_AM, pfr_AM,  e$
                                        if tempo_2_AM > 0, pnumligne, *tempo_2_AM, e$
                                        ]
                                if prof_3_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "TROIXIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_3_AM
                                        pnumligne, pgcode_AM, prof_3_rel_AM, pfr_AM,  e$
                                        if tempo_3_AM > 0, pnumligne, *tempo_3_AM, e$
                                        ]
                                if prof_4_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "QUATRIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_4_AM
                                        pnumligne, pgcode_AM, prof_4_rel_AM, pfr_AM,  e$
                                        if tempo_4_AM > 0, pnumligne, *tempo_4_AM, e$
                                        ]
                                if prof_5_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom_par, "CINQUIEME PROFONDEUR", sfcom_par, e$
                                        fr$ = avance_5_AM
                                        pnumligne, pgcode_AM, prof_5_rel_AM, pfr_AM,  e$
                                        if tempo_5_AM > 0, pnumligne, *tempo_5_AM, e$
                                        ]

                                 ]

percage_avance_controle_BM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_BM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_BM
                            gcode$ = 0
                            pnumligne, pgcode_BM, zabs_BM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_BM
                                pnumligne, pgcode_BM, prof_1_BM, pfr_BM,  e$
                                if tempo_1_BM > 0, pnumligne, *tempo_1_BM, e$

                                if prof_2_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_BM
                                        pnumligne, pgcode_BM, prof_2_BM, pfr_BM,  e$
                                        if tempo_2_BM > 0, pnumligne, *tempo_2_BM, e$
                                        ]
                                if prof_3_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_BM
                                        pnumligne, pgcode_BM, prof_3_BM, pfr_BM,  e$
                                        if tempo_3_BM > 0, pnumligne, *tempo_3_BM, e$
                                        ]
                                if prof_4_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_BM
                                        pnumligne, pgcode_BM, prof_4_BM, pfr_BM,  e$
                                        if tempo_4_BM > 0, pnumligne, *tempo_4_BM, e$
                                        ]
                                if prof_5_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_BM
                                        pnumligne, pgcode_BM, prof_5_BM, pfr_BM,  e$
                                        if tempo_5_BM > 0, pnumligne, *tempo_5_BM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_BM

                                pnumligne, pgcode_BM, prof_1_rel_BM, pfr_BM,  e$
                                if tempo_1_BM > 0, pnumligne, *tempo_1_BM, e$

                                if prof_2_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_BM
                                        pnumligne, pgcode_BM, prof_2_rel_BM, pfr_BM,  e$
                                        if tempo_2_BM > 0, pnumligne, *tempo_2_BM, e$
                                        ]
                                if prof_3_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_BM
                                        pnumligne, pgcode_BM, prof_3_rel_BM, pfr_BM,  e$
                                        if tempo_3_BM > 0, pnumligne, *tempo_3_BM, e$
                                        ]
                                if prof_4_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_BM
                                        pnumligne, pgcode_BM, prof_4_rel_BM, pfr_BM,  e$
                                        if tempo_4_BM > 0, pnumligne, *tempo_4_BM, e$
                                        ]
                                if prof_5_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_BM
                                        pnumligne, pgcode_BM, prof_5_rel_BM, pfr_BM,  e$
                                        if tempo_5_BM > 0, pnumligne, *tempo_5_BM, e$
                                        ]

                                 ]
percage_avance_controle_CM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_CM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_CM
                            gcode$ = 0
                            pnumligne, pgcode_CM, zabs_CM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_CM
                                pnumligne, pgcode_CM, prof_1_CM, pfr_CM,  e$
                                if tempo_1_CM > 0, pnumligne, *tempo_1_CM, e$

                                if prof_2_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_CM
                                        pnumligne, pgcode_CM, prof_2_CM, pfr_CM,  e$
                                        if tempo_2_CM > 0, pnumligne, *tempo_2_CM, e$
                                        ]
                                if prof_3_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_CM
                                        pnumligne, pgcode_CM, prof_3_CM, pfr_CM,  e$
                                        if tempo_3_CM > 0, pnumligne, *tempo_3_CM, e$
                                        ]
                                if prof_4_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_CM
                                        pnumligne, pgcode_CM, prof_4_CM, pfr_CM,  e$
                                        if tempo_4_CM > 0, pnumligne, *tempo_4_CM, e$
                                        ]
                                if prof_5_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_CM
                                        pnumligne, pgcode_CM, prof_5_CM, pfr_CM,  e$
                                        if tempo_5_CM > 0, pnumligne, *tempo_5_CM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_CM

                                pnumligne, pgcode_CM, prof_1_rel_CM, pfr_CM,  e$
                                if tempo_1_CM > 0, pnumligne, *tempo_1_CM, e$

                                if prof_2_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_CM
                                        pnumligne, pgcode_CM, prof_2_rel_CM, pfr_CM,  e$
                                        if tempo_2_CM > 0, pnumligne, *tempo_2_CM, e$
                                        ]
                                if prof_3_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_CM
                                        pnumligne, pgcode_CM, prof_3_rel_CM, pfr_CM,  e$
                                        if tempo_3_CM > 0, pnumligne, *tempo_3_CM, e$
                                        ]
                                if prof_4_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_CM
                                        pnumligne, pgcode_CM, prof_4_rel_CM, pfr_CM,  e$
                                        if tempo_4_CM > 0, pnumligne, *tempo_4_CM, e$
                                        ]
                                if prof_5_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_CM
                                        pnumligne, pgcode_CM, prof_5_rel_CM, pfr_CM,  e$
                                        if tempo_5_CM > 0, pnumligne, *tempo_5_CM, e$
                                        ]

                                 ]

percage_avance_controle_DM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_DM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_DM
                            gcode$ = 0
                            pnumligne, pgcode_DM, zabs_DM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_DM
                                pnumligne, pgcode_DM, prof_1_DM, pfr_DM,  e$
                                if tempo_1_DM > 0, pnumligne, *tempo_1_DM, e$

                                if prof_2_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_DM
                                        pnumligne, pgcode_DM, prof_2_DM, pfr_DM,  e$
                                        if tempo_2_DM > 0, pnumligne, *tempo_2_DM, e$
                                        ]
                                if prof_3_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_DM
                                        pnumligne, pgcode_DM, prof_3_DM, pfr_DM,  e$
                                        if tempo_3_DM > 0, pnumligne, *tempo_3_DM, e$
                                        ]
                                if prof_4_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_DM
                                        pnumligne, pgcode_DM, prof_4_DM, pfr_DM,  e$
                                        if tempo_4_DM > 0, pnumligne, *tempo_4_DM, e$
                                        ]
                                if prof_5_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_DM
                                        pnumligne, pgcode_DM, prof_5_DM, pfr_DM,  e$
                                        if tempo_5_DM > 0, pnumligne, *tempo_5_DM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_DM

                                pnumligne, pgcode_DM, prof_1_rel_DM, pfr_DM,  e$
                                if tempo_1_DM > 0, pnumligne, *tempo_1_DM, e$

                                if prof_2_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_DM
                                        pnumligne, pgcode_DM, prof_2_rel_DM, pfr_DM,  e$
                                        if tempo_2_DM > 0, pnumligne, *tempo_2_DM, e$
                                        ]
                                if prof_3_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_DM
                                        pnumligne, pgcode_DM, prof_3_rel_DM, pfr_DM,  e$
                                        if tempo_3_DM > 0, pnumligne, *tempo_3_DM, e$
                                        ]
                                if prof_4_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_DM
                                        pnumligne, pgcode_DM, prof_4_rel_DM, pfr_DM,  e$
                                        if tempo_4_DM > 0, pnumligne, *tempo_4_DM, e$
                                        ]
                                if prof_5_DM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_DM
                                        pnumligne, pgcode_DM, prof_5_rel_DM, pfr_DM,  e$
                                        if tempo_5_DM > 0, pnumligne, *tempo_5_DM, e$
                                        ]

                                 ]
#endregion
#endregion

#region   CYCLE de palpage de bague #OK
#region palpage de bague
# ------------------------ debut  CYCLE de palpage de bague -------------------------

#-------- ecriture des format -------------

fmt "R10=" 2 R10
fmt "R11=" 2 R11
fmt "R12=" 2 R12
fmt "R15=" 2 R15
fmt "R16=" 2 R16
fmt "R17=" 2 R17
fmt "R18=" 2 R18
fmt "Z=R12+" 2 zdecpalp

palpagebague_BG  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_BG, psortie8_BG
                gcode$ = 0
                R10 = xprint_BG
                R11 = yprint_BG
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_BG = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA A0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_BG, *zaproche_BG, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$

palpagebague_CG  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_CG, psortie8_CG
                gcode$ = 0
                R10 = xprint_CG
                R11 = yprint_CG
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_CG = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA B0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_CG, *zaproche_CG, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$                

palpagebague_DG  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_DG, psortie8_DG
                gcode$ = 0
                R10 = xprint_DG
                R11 = yprint_DG
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_DG = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA B0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_DG, *zaproche_DG, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$
palpagebague_BM  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_BM, psortie8_BM
                gcode$ = 0
                R10 = xprint_BM
                R11 = yprint_BM
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_BM = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA A0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_BM, *zaproche_BM, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$

palpagebague_CM  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_CM, psortie8_CM
                gcode$ = 0
                R10 = xprint_CM
                R11 = yprint_CM
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_CM = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA B0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_CM, *zaproche_CM, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$

palpagebague_DM  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_DM, psortie8_DM
                gcode$ = 0
                R10 = xprint_DM
                R11 = yprint_DM
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_DM = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA B0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_DM, *zaproche_DM, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$             
#endregion              
#region pdrlcst
pdrlcst$
            pchange_AG
            pdrlcst_AG

            pchange_AM
            pdrlcst_AM

            pchange_BG
            pdrlcst_BG

            pchange_BM
            pdrlcst_BM

            pchange_CG
            pdrlcst_CG

            pchange_CM
            pdrlcst_CM

            pchange_DG
            pdrlcst_DG

            pchange_DM
            pdrlcst_DM

pdrlcst_AG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                        pnumligne, sdcom_par, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom_par, e$
                        if tete_rev_AG = 1, psortie_AG
                        pprint_AG
                        typcycle_AG = 1
                        if drill5axes_AG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_AG
                         initht5x_AG = refht$
                         percage_avance_controle_AG
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AG, *old_zinitht_AG, e$
                         ]
                        else, percage_avance_controle_AG
                        old_dest_ret_5x_AG = dest_ret_5x_AG
                ]
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_BG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_BG = 1, psortie_BG
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_BG
                         initht5x_BG = refht$
                         percage_avance_controle_BG
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BG, *old_zinitht_BG, e$
                  ]
                    else, percage_avance_controle_BG
                    old_dest_ret_5x_BG = dest_ret_5x_BG
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_BG = 1, psortie_BG
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1, psortie6_BG
                        palpagebague_BG
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_CG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_CG = 1, psortie_CG
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_CG
                         initht5x_CG = refht$
                         percage_avance_controle_CG
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CG, *old_zinitht_CG, e$
                  ]
                    else, percage_avance_controle_CG
                    old_dest_ret_5x_CG = dest_ret_5x_CG
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_CG = 1, psortie_CG
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1, psortie6_CG
                        palpagebague_CG
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_DG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_DG, psortie7_DG  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_DG = 1, psortie_DG
                        pprint_DG
                        typcycle_DG = 1
                        if drill5axes_DG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_DG
                         initht5x_DG = refht$
                         percage_avance_controle_DG
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DG, *old_zinitht_DG, e$
                  ]
                    else, percage_avance_controle_DG
                    old_dest_ret_5x_DG = dest_ret_5x_DG
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_DG = 1, psortie_DG
                        pprint_DG
                        typcycle_DG = 1
                        if drill5axes_DG = 1, psortie6_DG
                        palpagebague_DG
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_AM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                        pnumligne, sdcom_par, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom_par, e$
                        if tete_rev_AM = 1, psortie_AM
                        pprint_AM
                        typcycle_AM = 1
                        if drill5axes_AM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_AM
                         initht5x_AM = refht$
                         percage_avance_controle_AM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                         ]
                        else, percage_avance_controle_AM
                        old_dest_ret_5x_AM = dest_ret_5x_AM
                ]
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_BM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_BM = 1, psortie_BM
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_BM
                         initht5x_BM = refht$
                         percage_avance_controle_BM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                  ]
                    else, percage_avance_controle_BM
                    old_dest_ret_5x_BM = dest_ret_5x_BM
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_BM = 1, psortie_BM
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1, psortie6_BM
                        palpagebague_BM
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_CM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_CM = 1, psortie_CM
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_CM
                         initht5x_CM = refht$
                         percage_avance_controle_CM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                  ]
                    else, percage_avance_controle_CM
                    old_dest_ret_5x_CM = dest_ret_5x_CM
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_CM = 1, psortie_CM
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1, psortie6_CM
                        palpagebague_CM
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_DM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_DM, psortie7_DM  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_DM = 1, psortie_DM
                        pprint_DM
                        typcycle_DM = 1
                        if drill5axes_DM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_DM
                         initht5x_DM = refht$
                         percage_avance_controle_DM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DM, *old_zinitht_DM, e$
                  ]
                    else, percage_avance_controle_DM
                    old_dest_ret_5x_DM = dest_ret_5x_DM
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_DM = 1, psortie_DM
                        pprint_DM
                        typcycle_DM = 1
                        if drill5axes_DM = 1, psortie6_DM
                        palpagebague_DM
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pdrlcst_2
pdrlcst_2$
            pchange_AG
            pdrlcst_2_AG

            pchange_AM
            pdrlcst_2_AM

            pchange_BG
            pdrlcst_2_BG

            pchange_BM
            pdrlcst_2_BM

            pchange_CG
            pdrlcst_2_CG

            pchange_CM
            pdrlcst_2_CM

            pchange_DG
            pdrlcst_2_DG

            pchange_DM
            pdrlcst_2_DM

pdrlcst_2_AG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_AG
                        typcycle_AG = 1
                        if drill5axes_AG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AG
                            initht5x_AG = refht$
                            percage_avance_controle_2_AG
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AG, *old_zinitht_AG, e$
                         ]
                else, percage_avance_controle_2_AG
                old_dest_ret_5x_AG = dest_ret_5x_AG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_2_BG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BG
                            initht5x_BG = refht$
                            percage_avance_controle_2_BG
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BG, *old_zinitht_BG, e$
                         ]
                else, percage_avance_controle_2_BG
                old_dest_ret_5x_BG = dest_ret_5x_BG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_BG

pdrlcst_2_CG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CG
                            initht5x_CG = refht$
                            percage_avance_controle_2_CG
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CG, *old_zinitht_CG, e$
                         ]
                else, percage_avance_controle_2_CG
                old_dest_ret_5x_CG = dest_ret_5x_CG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_CG

pdrlcst_2_DG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_DG
                        typcycle_DG = 1
                        if drill5axes_DG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_DG
                            initht5x_DG = refht$
                            percage_avance_controle_2_DG
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DG, *old_zinitht_DG, e$
                         ]
                else, percage_avance_controle_2_DG
                old_dest_ret_5x_DG = dest_ret_5x_DG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_DG

pdrlcst_2_AM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_AM
                        typcycle_AM = 1
                        if drill5axes_AM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AM
                            initht5x_AM = refht$
                            percage_avance_controle_2_AM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                         ]
                else, percage_avance_controle_2_AM
                old_dest_ret_5x_AM = dest_ret_5x_AM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_2_BM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BM
                            initht5x_BM = refht$
                            percage_avance_controle_2_BM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                         ]
                else, percage_avance_controle_2_BM
                old_dest_ret_5x_BM = dest_ret_5x_BM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_BM

pdrlcst_2_CM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CM
                            initht5x_CM = refht$
                            percage_avance_controle_2_CM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                         ]
                else, percage_avance_controle_2_CM
                old_dest_ret_5x_CM = dest_ret_5x_CM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_CM

pdrlcst_2_DM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_DM
                        typcycle_DM = 1
                        if drill5axes_DM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_DM
                            initht5x_DM = refht$
                            percage_avance_controle_2_DM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_DM, *old_zinitht_DM, e$
                         ]
                else, percage_avance_controle_2_DM
                old_dest_ret_5x_DM = dest_ret_5x_DM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_DM
#endregion
#endregion

#region   psouf_imp #OK
#region psouf
#----------------------------cycle fixes----------------------------------------------


fmt "" 4 retard_enclenchement
fmt "" 4 duree_enclenchement

psouf_imp_BG       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_BG = 1, [
                                    subout$ = 4
                                    serreur_visu_BG = serreur201_BG + no2str(numop_BG)
                                    *serreur_visu_BG, e$
                                    result = mprint(serreur_visu_BG)
                                    #exitpost$ # abandonner                 
                                    subout$ = 3
                                    erreur_BG = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_CG       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_CG = 1, [
                                    subout$ = 4
                                    serreur_visu_CG = serreur201_CG + no2str(numop_CG)
                                    *serreur_visu_CG, e$
                                    result = mprint(serreur_visu_CG)
                                    #exitpost$ # abandonner                 
                                    subout$ = 3
                                    erreur_CG = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]
psouf_imp_DG       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_DG = 1, [
                                    subout$ = 4
                                    serreur_visu_DG = serreur201_DG + no2str(numop_DG)
                                    *serreur_visu_DG, e$
                                    result = mprint(serreur_visu_DG)
                                    #exitpost$ # abandonner                 
                                    subout$ = 3
                                    erreur_DG = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]
psouf_imp_BM       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_BM = 1, [
                                    subout$ = 4
                                    serreur_visu_BM = serreur201_BM + no2str(numop_BM)
                                    *serreur_visu_BM, e$
                                    result = mprint(serreur_visu_BM)
                                    #exitpost$ # abandonner
                                    subout$ = 3
                                    erreur_BM = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_CM       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_CM = 1, [
                                    subout$ = 4
                                    serreur_visu_CM = serreur201_CM + no2str(numop_CM)
                                    *serreur_visu_CM, e$
                                    result = mprint(serreur_visu_CM)
                                    #exitpost$ # abandonner                 
                                    subout$ = 3
                                    erreur_CM = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_DM       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    if prog_DM = 1, [
                                    subout$ = 4
                                    serreur_visu_DM = serreur201_DM + no2str(numop_DM)
                                    *serreur_visu_DM, e$
                                    result = mprint(serreur_visu_DM)
                                    #exitpost$ # abandonner                 
                                    subout$ = 3
                                    erreur_DM = 1
                                                    ]
                                    ]
                                    spaces$ = 0
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]
#endregion                                  
#region pvoir
stl_mfg_com : ""       # 'tool mfg comment' from tool
stl_chuck_com : ""     # 'tool chuck comment' from tool
snomoutil : ""          # nom outil suite bug que strtool prend pas les points

pvoir_AG     # voir les position de percage


            vec_reel_x = tox4print_AG - drl_init_x$
            vec_reel_y = toy4print_AG - drl_init_y$
            vec_reel_z = toz4print_AG - drl_init_z$

            dest_ret_5x_AG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_AG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
            #"-------------->",voir dest_ret_5x_AG", *dest_ret_5x_AG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_AG, *toy4print_AG, *toz4print_AG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$

pvoir_BG     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_BG", *tox4print_BG, *toy4print_BG,*toz4print_BG, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_BG - drl_init_x$
            vec_reel_y = toy4print_BG - drl_init_y$
            vec_reel_z = toz4print_BG - drl_init_z$

            dest_ret_5x_BG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_BG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_BG", *dest_ret_5x_BG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_BG, *toy4print_BG, *toz4print_BG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_CG     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_CG", *tox4print_CG, *toy4print_CG,*toz4print_CG, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_CG - drl_init_x$
            vec_reel_y = toy4print_CG - drl_init_y$
            vec_reel_z = toz4print_CG - drl_init_z$

            dest_ret_5x_CG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_CG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_CG", *dest_ret_5x_CG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_CG, *toy4print_CG, *toz4print_CG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data              

pvoir_DG     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_DG", *tox4print_DG, *toy4print_DG,*toz4print_DG, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_DG - drl_init_x$
            vec_reel_y = toy4print_DG - drl_init_y$
            vec_reel_z = toz4print_DG - drl_init_z$

            dest_ret_5x_DG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_DG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_DG", *dest_ret_5x_DG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_DG, *toy4print_DG, *toz4print_DG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_AM     # voir les position de percage


            vec_reel_x = tox4print_AM - drl_init_x$
            vec_reel_y = toy4print_AM - drl_init_y$
            vec_reel_z = toz4print_AM - drl_init_z$

            dest_ret_5x_AM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_AM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
            #"-------------->",voir dest_ret_5x_AM", *dest_ret_5x_AM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_AM, *toy4print_AM, *toz4print_AM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$

pvoir_BM     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_BM", *tox4print_BM, *toy4print_BM,*toz4print_BM, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_BM - drl_init_x$
            vec_reel_y = toy4print_BM - drl_init_y$
            vec_reel_z = toz4print_BM - drl_init_z$

            dest_ret_5x_BM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_BM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_BM", *dest_ret_5x_BM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_BM, *toy4print_BM, *toz4print_BM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_CM     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_CM", *tox4print_CM, *toy4print_CM,*toz4print_CM, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_CM - drl_init_x$
            vec_reel_y = toy4print_CM - drl_init_y$
            vec_reel_z = toz4print_CM - drl_init_z$

            dest_ret_5x_CM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_CM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_CM", *dest_ret_5x_CM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_CM, *toy4print_CM, *toz4print_CM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_DM     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_DM", *tox4print_DM, *toy4print_DM,*toz4print_DM, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_DM - drl_init_x$
            vec_reel_y = toy4print_DM - drl_init_y$
            vec_reel_z = toz4print_DM - drl_init_z$

            dest_ret_5x_DM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_DM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_DM", *dest_ret_5x_DM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_DM, *toy4print_DM, *toz4print_DM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data              
#endregion
#endregion

#region   PPARAMETER #OK
#region pwrttparam
pwrttparam$
            pchange_AG
            pwrttparam_AG

            pchange_AM
            pwrttparam_AM

            pchange_BG
            pwrttparam_BG

            pchange_BM
            pwrttparam_BM

            pchange_CG
            pwrttparam_CG

            pchange_CM
            pwrttparam_CM

            pchange_DG
            pwrttparam_DG

            pchange_DM
            pwrttparam_DM

pwrttparam_AG     #Pre-read parameter data
               #"pwrttparam", ~prmcode$, ~sparameter$, e$ 
pwrttparam_BG   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pwrttparam_CG   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pwrttparam_DG   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pwrttparam_AM     #Pre-read parameter data
               #"pwrttparam", ~prmcode$, ~sparameter$, e$ 
			   if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pwrttparam_BM   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pwrttparam_CM   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pwrttparam_DM   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$     
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	     
#endregion
#region pparameter
pparameter$
            pchange_AG
            pparameter_AG

            pchange_AM
            pparameter_AM

            pchange_BG
            pparameter_BG

            pchange_BM
            pparameter_BM

            pchange_CG
            pparameter_CG

            pchange_CM
            pparameter_CM

            pchange_DG
            pparameter_DG

            pchange_DM
            pparameter_DM

pparameter_AG   # Read in the 20000 series 'additional parameters' from OPS file
                #if prmcode$ = 15557, " la on y est ", e$

                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
             #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres
             # 20002 = tool definition - 'manufacturer' data
          if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 12727 = tool definition - 'chuck name' data
          if (prmcode$ = 12727),stl_chuck_com = sparameter$ #Save string for output later
            if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pparameter_BG   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pparameter_CG   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation              
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	

pparameter_DG   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation              
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pparameter_AM   # Read in the 20000 series 'additional parameters' from OPS file
                #if prmcode$ = 15557, " la on y est ", e$

                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
             #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres
             # 20002 = tool definition - 'manufacturer' data
          if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 12727 = tool definition - 'chuck name' data
          if (prmcode$ = 12727),stl_chuck_com = sparameter$ #Save string for output later
            if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pparameter_BM   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pparameter_CM   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
pparameter_DM   # Read in the 20000 series 'additional parameters' from OPS file
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
            if prmcode$ = 20010, scsplane = sparameter$
            if prmcode$ = 20012, stlplane = sparameter$
            if prmcode$ = 20014, swcsplane = sparameter$
			if prmcode$ = 10030, av_travail = rpar(sparameter$, 1)
			if prmcode$ = 10031, av_plonge = rpar(sparameter$, 1)
			if prmcode$ = 15140, av_retract = rpar(sparameter$, 1)	
#endregion
#region pecriture_bl_master

pecriture_bl_master_BG   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              
            if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                   " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
           else,
                                    [
                                    spaces$ = 0
                                   " ; BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
             spaces$ = 1

pecriture_bl_master_CG   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              

pecriture_bl_master_DG   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain 

pecriture_bl_master_BM   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              
            if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                   " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
           else,
                                    [
                                    spaces$ = 0
                                   " ; BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
             spaces$ = 1

pecriture_bl_master_CM   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain 

pecriture_bl_master_DM   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain          
#endregion
#region pwrtt
pwrtt$
            subout$ = 0
            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, " - ",t$,snomoutil, stl_chuck_com, e$
            if t$ > 0, lastopid = op_id$

            pchange_AG
            pwrtt_AG

            pchange_AM
            pwrtt_AM

            pchange_BG
            pwrtt_BG

            pchange_BM
            pwrtt_BM

            pchange_CG
            pwrtt_CG

            pchange_CM
            pwrtt_CM

            pchange_DG
            pwrtt_DG

            pchange_DM
            pwrtt_DM

pwrtt_AG       #  
            strtool$ = ucase(strtool$)
            if t$ > 0, "(", t$, strtool$,stl_chuck_com,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_BG       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_BG, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_CG       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_CG, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_DG       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_DG, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_AM       #  
            strtool$ = ucase(strtool$)
            #enlevé pour concat#if t$ > 0, "(", t$, strtool$,stl_chuck_com,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_BM       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            #enlevé pour concat#if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_BM, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_CM       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            pecriture_bl_master_CM
            #enlevé pour concat#if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_CM, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_DM       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            pecriture_bl_master_DM
            #enlevé pour concat#if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_DM, 34,")", e$

            if t$ > 0, lastopid = op_id$
#endregion  
#region ptransreal
fmt 2 trans_num_prg
trans_num_prg : 0
fmt 2 prem_passage_ptrans
prem_passage_ptrans : 0
fmt 2 compteur_passage_trans
compteur_passage_trans : 0
ptransreal$

        if prem_passage_ptrans = 0, trans_num_prg = trans_mr1$, prem_passage_ptrans = 1
        compteur_passage_trans = compteur_passage_trans + 1
#endregion
#endregion

#[ENDBIN]

#region   VALEURS OPTIONNELLES
# --------------------------------------------------------------------------
# Numbered questions for Mastercam --  Used by Mill 7
# --------------------------------------------------------------------------
38. Rapid feedrate? 20000.0
1538. Rapid feedrate (metric)? 10000.0

80. Communications port number for receive and transmit (1 or 2) ? 2
81. Data rate (110,150,300,600,1200,2400,4800,9600,14400,19200,38400)? 9600
82. Parity (E/O/N)? E
83. Data bits (7 or 8)? 7
84. Stop bits (1 or 2)? 2
85. Strip line feeds? N
86. Delay after end of line (seconds)? 0
87. Ascii, Eia, or Binary (A/E/B)? A
88. Echo keyboard to screen in terminal emulation? n
89. Strip carriage returns? N
90. Drive and subdirectory for NC files?
91. Name of executable post processor? MP
92. Name of reverse post processor? RP
93. Reverse post PST file name?
100. Number of places BEFORE the decimal point for sequence numbers? 3
101. Number of places AFTER the decimal point for sequence numbers? 0
103. Maximum spindle speed? 5000
107. Average time for tool change (seconds)? 2.0

159. Show first and last position as fully compensated in simulation? n

160. Display first and last entity in toolpath when simulating cutter compensation in control? y
161. Enable Home Position button? y
162. Enable Reference Point button? N
163. Enable Misc. Values button? Y
164. Enable Rotary Axis button? N
165. Enable Tool Plane button? N
166. Enable Construction Plane button? Y
167. Enable Tool Display button? N

# --------------------------------------------------------------------------
# Default Miscellaneous Real Values
# --------------------------------------------------------------------------
201. valeur de recul en 5 axes cont (mr1)? 199.0
202. plan de retournement en 5 axes cont (mr2)? 1500.0
203. Default miscellaneous real variable 3 (mr3)? 1500.0
204. Default miscellaneous real variable 4 (mr4)? 0.0
205. Default miscellaneous real variable 5 (mr5)? 0.0
206. Default miscellaneous real variable 6 (mr6)? 0.0
207. Default miscellaneous real variable 7 (mr7)? 180.0
208. DECALAGE X                            (mr8)? 0.0
209. DECALAGE Y                            (mr9)? 0.0
210. DECALAGE Z                            (mr10)? 0.0

# --------------------------------------------------------------------------
# Valeurs réelles par défaut (METRIQUE)
# --------------------------------------------------------------------------
1601. Default miscellaneous real variable 1 (mr1) (metric)? 199.0
1602. Default miscellaneous real variable 2 (mr2) (metric)? 1500.0
1603. Default miscellaneous real variable 3 (mr3) (metric)? 1500.0
1604. Default miscellaneous real variable 4 (mr4) (metric)? 0.0
1605. Default miscellaneous real variable 5 (mr5) (metric)? 0.0
1606. Default miscellaneous real variable 6 (mr6) (metric)? 0.0
1607. Default miscellaneous real variable 7 (mr7) (metric)? 180.0
1608. Default miscellaneous real variable 8 (mr8) (metric)? 0.0
1609. Default miscellaneous real variable 9 (mr9) (metric)? 0.0
1610. Default miscellaneous real variable 10 (mr10) (metric)? 0.0

# --------------------------------------------------------------------------
# Activer/désactiver les commutateurs de variables réelles
# --------------------------------------------------------------------------
1611. Enable miscellaneous real variable 1? y
1612. Enable miscellaneous real variable 2? y
1613. Enable miscellaneous real variable 3? y
1614. Enable miscellaneous real variable 4? y
1615. Enable miscellaneous real variable 5? y
1616. Enable miscellaneous real variable 6? y
1617. Enable miscellaneous real variable 7? y
1618. Enable miscellaneous real variable 8? y
1619. Enable miscellaneous real variable 9? y
1620. Enable miscellaneous real variable 10? y


# --------------------------------------------------------------------------
# Default Miscellaneous Integer Values
# --------------------------------------------------------------------------
301. tour de plus en 5 axes continue 1 ou -1 (mi1)? 0
302. commance en A- en 5 axes continue (mi2)? 0
303. Miscellaneous integer variable 4 (mi3)? 1
304. Miscellaneous integer variable 4 (mi4)? 0
305. Miscellaneous integer variable 5 (mi5)? 0
306. Miscellaneous integer variable 6 (mi6)? 0
307. Miscellaneous integer variable 7 (mi7)? 0
308. decalage en x (mi8)? 0
309. decalage en y (mi9)? 0
310. decalage en z (mi10)? 0

# --------------------------------------------------------------------------
# Activer/désactiver les commutateurs de variables entiéres
# --------------------------------------------------------------------------
1621. Enable miscellaneous integer variable 1? y
1622. Enable miscellaneous integer variable 2? y
1623. Enable miscellaneous integer variable 3? y
1624. Enable miscellaneous integer variable 4? y
1625. Enable miscellaneous integer variable 5? y
1626. Enable miscellaneous integer variable 6? y
1627. Enable miscellaneous integer variable 7? y
1628. Enable miscellaneous integer variable 8? y
1629. Enable miscellaneous integer variable 9? y
1630. Enable miscellaneous integer variable 10? y


# --------------------------------------------------------------------------
# Configuration File association parameters (default is "y")
# --------------------------------------------------------------------------
#400. Name of associated cfg file? 
401. Read SYSTEM COLORS section? y
402. Read ALLOCATIONS section? y
403. Read TOLERANCES section? y
404. Read DATA PATHS section? y
405. Read COMMUNICATIONS section? y
406. Read DRAFT SETTINGS section? y
407. Read MISCELLANEOUS section? y
408. Read NC SETTINGS section? y
409. Read DIALOG SCRIPTS section? y
410. Read DESIGN SETTINGS section? y
411. Read PLOTTER SETTINGS section? y
412. Read ALT-KEY ASSIGNMENTS section? y
413. Read CAD section? Y
414. Read START/EXIT section? Y
415. Read SCREEN section? Y
416. Read FILE NAMES section? Y

1500. Chook to execute from 'Misc. values' button?
1501. Insert parameter information in the ascii NCI? n
1502. Write operation information to binary file (.ops)? n
1503. Write transform operations (0=transform ops, 1=source ops, 2=both)? 1

1520. Display a warning when cutter compensation in control simulation finds an error? n

1521. Number of controller look-ahead blocks for CDC in control? 2

1530. Ignore work offset numbers when processing subprograms? y
1531. Ignore contour flags when processing subprograms? y

# Do NOT manually change the answer for Q.1999 !
1999. Product major version number that post supports? 9

3001. Machine acceleration? 2
3002. timing size? .1

[CTRL_MILL|MULTI_PP_2017_03]
[misc integers]
1. "MI1: Tour sur C positif ou négatif."
2. "MI2: A ou B positif ou négatif."
3. "MI3: Filtrage Angle 5X 0° en °/10000."//1
4. "MI4: n° de cloche."
5. "MI5: Type de mode de transfert du PRG."
6. "MI6: * Période cor° log nb blocs (5X-pas)."
7. "MI7: * 1=fonc° sin. ; 2=fonc° dent de scie."
8. "MI8: Dynamique de la machine."
9. "MI9: Shunt sécurité Axe Z (STC9103)."
10. "MI10: Arrêt avant opération."
[misc reals]
1. "MR1: N° de PRG (%XXXX)."//8999.//8999.
2. "MR2: Altitude de retournement (-1 sans)."//1500.//1500.
3. "MR3: Altitude de chgmt outil (STC9101)."//1500.//1500.
4. "MR4: Correcteur dyn de long outil."
5. "MR5: Valeur de filtrage 5X."
6. "MR6: * Hauteur de Varia° (mm - 5X-pas)."
7. "MR7: Angle Maximum avec G9 (-1 = sans)."//-1.//-1.
8. "MR8: Décalage en X."
9. "MR9: Décalage en Y."
10. "MR10: Décalage en Z."
[simple drill]
1. "PERCAGE SIMPLE"
2. "Avance"
3. ""
4. "Plan de sécurité"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "PERCAGE DEBOURRAGE"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[chip break]
1. "PERCAGE BRISE COPEAU"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[tap]
1. "TARAUDAGE (9101)"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Pas spécial"
11. ""
[bore1]
1. "ALESAGE (9101)"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "ALESAGE INDEXE (9101)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Nombre de passes"
11. ""
[misc1]
1. "PERCAGE/ALESAGE (RETOUR ARRETE)"
2. "Avance"
3. "Tempo DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. ""
8. ""
9. "Avance retour RFF "
10. ""
11. ""
[misc2]
1. "PERCAGE CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
7. "Avalant=0 Oppo=1"
8. "Diamétre final"
9. "Diamétre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "PERCAGE DECOMPOSE"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 12]
1. "PALPAGE BAGUE (9103 + 9110 + STEMA01)"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Diam Inter Bague"
8. "Décalage Palp. Ray."
9. "Décalage angulaire"
10. "Profondeur de palpage "
11. ""
[drill cycle 13]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 14]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 15]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 16]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 17]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 18]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 19]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 20]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[simple drill custom parameters]
1. "Paramètres percage G81"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[peck drill custom parameters]
1. "Paramètres debourage G83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[chip break drill custom parameters]
1. "Paramètres de brise copeau 83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[tap custom parameters]
1. "Non Utilisé"
[bore1 custom parameters]
1. "Paramètres Percage/alesage G85"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle spécial 7"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoido-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoidale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
7. "Divers 1"
8. "Divers 2"
9. "Cycle #9"
10. "Percage decomposé"
11. "Cycle #11"
12. "Palpage bague"
13. "Cycle #13"
14. "Cycle #14"
15. "Cycle #15"
16. "Cycle #16"
17. "Cycle #17"
18. "Cycle #18"
19. "Cycle #19"
20. "Cycle #20"
[canned text]
1. "BRIDER LA PIECE AVEC VIS"
2. "OTER LES VIS"
3. "BRIDER LA PIECE AVEC SERRE-JOINTS"
4. "OTER SERRE-JOINTS"
5. "OTER LES CHUTES"
6. "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
7. "NETTOYER LES PORTEES DES RENVOIS"
8. "-"
9. "-"
10. "-"
11. "-"
12. "-"
13. "-"
14. "-"
15. "-"
16. "-"
17. "-"
18. "-"
19. "-"
20. "-"
21. "-"
22. "-"
23. "-"
24. "-"
25. "-"
26. "-"
27. "-"
28. "-"
29. "-"
30. "-"
31. "-"
32. "-"
33. "-"
34. "-"
35. "-"
36. "-"
37. "-"
[tool parameters]
9. "Eau - Air - Aspi"
[transform operation]
1. " "
2. " "
3. " "
4. " "
5. "MR1: N° de PRG (%XXXX)."
6. " "
7. " "
8. " "
[CTRL_TEXT_END]
#endregion
