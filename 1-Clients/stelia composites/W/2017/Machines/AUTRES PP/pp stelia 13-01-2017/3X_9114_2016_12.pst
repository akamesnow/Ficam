[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V19.00 P0 E1 W19.00 T1411558494 M19.00 I0 O0
#[STARTBIN]
#property of ficam, Eric Dauvilliers, e.dauvilliers@ficam.com, +332 37 26 28 10
#region   DEBUT PST
#============================================================================
# -	PP FRAISAGE 5X
#============================================================================
# -	MASTERCAM 2017 F.I.CAM
#============================================================================
# -	PEALISE PAR 	: Jocelyn VALIERE
# -	POUR LA SOCIETE : F.I.CAM
# -	ARMOIRE CN      : SIEMENS
# -	NON MACHINE     : TOUTES
#============================================================================
# POST-PROCESSEUR 5X SIEMENS TETE TWIST B porte par C + tete renvois d'angle 
#                              "
# axe C               90       "  axe A                  x
# vu de dessus                 "  vu de cote             "
#                180       0   "                 -90     "    90
#                              "						 "                         
#                     270      "                         0
#============================================================================
type_axe = 1 #1=AC 2=BC 3=AB
type_machine = 1 #1=CMS ARES 2=NORMA1513 3=NORMA3820 4=BRETON 5=DMC
#============================================================================
#endregion
#region   REGLAGES DU PST
#region STRINGS
cone_mini = 0.001  # valeur angulaire a partir duquel on fais du A0 C0, evite le bruit 
srattrap : "ATTENTION OPERATION DE RETOURNEMENT EN 5 AXES "
sderoul : ""
senroul : ""
sderoul_aff : " - Sortie du post-processeur suite buttee axe C plus, dernieres valeurs : "
senroul_aff : " - Sortie du post-processeur suite buttee axe C moins, dernieres valeurs : "
slettreA : "A"
slettreB : "B"
slettreC : "C"
space : " "
sopration : "Operation n°"
sra : ""
fmt "" 4 nbcaracter
srenvoi : ""
srenvoi_droite : "RA1"
srenvoi_gauche : "RA2"
smachine : ""
# Changer les valeurs entre "" pour chois entre 0 et 6 sur parametre valeur optionnel cycle 832
scycle832_a : "CYCLE832(0.2,11112101)"
scycle832_b : "CYCLE832(0.2,11112101)"
scycle832_c : "CYCLE832(0.2,11112101)"
scycle832_d : "CYCLE832(0.2,11112101)"
scycle832_e : "CYCLE832(0.2,11112101)"
scycle832_f : "CYCLE832(0.2,11112101)"
scycle832_anul : "CYCLE832 ()"

susure_outil_1 : ""
susure_outil_2 : ""
susure_outil_3 : ""
susure_outil_4 : ""
susure_outil_5 : ""
susure_outil_6 : ""
susure_outil_7 : ""
susure_outil_8 : ""
susure_outil_9 : ""
susure_outil_10 : ""
susure_outil_11 : ""
susure_outil_12 : ""
susure_outil_13 : ""
susure_outil_14 : ""
susure_outil_15 : ""
susure_outil_16 : ""
susure_outil_17 : ""
susure_outil_18 : ""
susure_outil_19 : ""
susure_outil_20 : ""
susure_outil_21 : ""
susure_outil_22 : ""
susure_outil_23 : ""
susure_outil_24 : ""
susure_outil_25 : ""
susure_outil_26 : ""
susure_outil_27 : ""
susure_outil_28 : ""
susure_outil_29 : ""
susure_outil_30 : ""
sdim_outillage : ""
scsplane: ""
stlplane : ""
swcsplane : ""
#endregion
#region FS
fs  1  1.9
fs  2  1.3n
fs  3  1 0n
fs  4  1 0
fs  5  1.0n
fs  6  5 0
fs  7  1.4n
fs  8  1.3
fs  9  1 3t
fs 10  1.2
fs 11  1.6
fs 12  1.4
fs 13 +1.4ln
fs 14  3.2ltn
fs 15  1.2ltn
fs 17  1.1  #quotient mi1
fs 18  1.1  #reste decimale quotient mi1
fs 19  1.3lt
fs 20  4 0
fs 21  3 0n
fs 22  1.3ln
#endregion
#region FMT
fmt 1 type_axe
fmt 1 type_machine
fmt  ""  1 cycle_800
fmt  "X" 1 xr$
fmt  "Y" 1 yr$
fmt  "Z" 1 zr$
fmt  "ZR" 2 oldzr
fmt    2 mr3$
fmt "" 3 tete_rev_ang_droite
fmt "" 3 tete_rev_ang_gauche
fmt "val dec tete=" 8 dec_axe_tete
fmt  "X" 2 xdep
fmt  "Y" 2 ydep
fmt  "Z" 2 zdep
fmt  "X" 1 x$
fmt  "Y" 1 y$
fmt  "Z" 1 z$
fmt "X" 1 drl_init_x$
fmt "Y" 1 drl_init_y$
fmt "Z" 1 drl_init_z$
fmt "Z" 1 drl_sel_ref$
fmt "VX" 1 vec_reel_x
fmt "VY" 1 vec_reel_y
fmt "VZ" 1 vec_reel_z
fmt "NX" 2 nextx$
fmt "NU" 2 nextu$
fmt "ret" 2 retplangarde

fmt  "X" 1 xcal
fmt  "Y" 1 ycal
fmt  "Z" 1 zcal
fmt  "Z" 1 zrcal
fmt  "X" 2 tox4$
fmt  "Y" 2 toy4$
fmt  "Z" 2 toz4$
fmt "LP12=" 1 long_p12
fmt "LP23=" 1 long_p23
fmt "LP13=" 1 long_p13
fmt "Angle5x=" 1 ang5x
fmt "cone_mini" 1 cone_mini

fmt  "difc" 8 difanglec
fmt  "difa" 8 difanglea
fmt      1 new_m7
fmt      1 new_m8
fmt      1 new_m9
fmt "M1=" 1 m1$
fmt "M2=" 1 m2$
fmt "M3=" 1 m3$
fmt "M4=" 1 m4$
fmt "M5=" 1 m5$
fmt "M6=" 1 m6$
fmt "M7=" 1 m7$
fmt "M8=" 1 m8$
fmt "M9=" 1 m9$
fmt      7 mini_a_reel
fmt      7 sortie
fmt  ""  3 mod5xcont
fmt  "Tourne=" 1 tourne
fmt "cal du plan =" 1 calculduplan
fmt "5 axes horizontal" 2 vertical_z

fmt  "NB" 8 nbt
fmt  "DC" 12 dep_axe_c

fmt  "DAC" 12 dif_axe_c
fmt  "DAC" 12 dif_axe_c2
fmt  "ABSD" 8 absdif
fmt  "ABSD" 8 absdif2
fmt  "DEB" 4 debut
fmt  "X" 1 old_x_5x
fmt  "Y" 1 old_y_5x
fmt  "Z" 1 old_z_5x
fmt  "X" 1 xdeg1
fmt  "Y" 1 ydeg1
fmt  "Z" 1 zdeg1
fmt  "X" 1 xdeg2
fmt  "Y" 1 ydeg2
fmt  "X" 1 xdeg3
fmt  "Y" 1 ydeg3
fmt  "Z" 1 zdeg3
fmt  "X" 2 xdegrap
fmt  "Y" 2 ydegrap
fmt  "Z" 2 zdegrap
fmt  "X" 1 xdegrap1
fmt  "Y" 1 ydegrap1
fmt  "Z" 1 zdegrap1
fmt  "X" 1 xdegrap2
fmt  "Y" 1 ydegrap2
fmt  "Z" 1 zdegrap2
fmt  "X" 1 xdegrap3
fmt  "Y" 1 ydegrap3
fmt  "Z" 1 zdegrap3
fmt  "X" 1 xdegvec
fmt  "Y" 1 ydegvec
fmt  "Z" 1 zdegvec
fmt "sav_x_pmx" 1 sav_x_pmx
fmt "sav_y_pmx" 1 sav_y_pmx
fmt "sav_z_pmx" 1 sav_z_pmx
fmt "sav_u_pmx" 1 sav_u_pmx
fmt "sav_v_pmx" 1 sav_v_pmx
fmt "sav_w_pmx" 1 sav_w_pmx
fmt  "OLV" 8 old_longvec
fmt  "Z" 8 lastz
fmt "R" 1 result
fmt "Z" 2 zsecuprint
fmt "" 1 m1print
fmt "" 1 m2print
fmt "" 1 m3print
fmt "" 1 m4print
fmt "" 1 m5print
fmt "" 1 m6print
fmt "" 1 m7print
fmt "" 1 m8print
fmt "" 1 m9print
fmt  "X" 1 u$
fmt  "Y" 1 v$
fmt  "Z" 1 w$
fmt  "X" 1 ucal
fmt  "Y" 1 vcal
fmt  "Z" 1 wcal
fmt  "U" 1 old_u
fmt  "V" 1 old_v
fmt  "W" 1 old_w
fmt  2 Du
fmt  2 Dv
fmt  2 Dw
fmt "D" 2 deltaUVW
fmt  2 Dx
fmt  2 Dy
fmt  2 Dz
fmt "D" 2 deltaXYZ
fmt "LV" 2 longvec
fmt  "Vx" 1 Vx
fmt  "Vy" 1 Vy
fmt  "Vz" 1 Vz
fmt  "X" 1 xcor
fmt  "Y" 1 ycor
fmt  "Z" 1 zcor
fmt  "I" 2 i$
fmt  "J" 2 j$
fmt  "K" 2 k$
fmt  "F" 4 fr$
fmt  "S" 3 old_ss
fmt  "L" 2 lubrif
fmt  "L" 2 lubrif_m7
fmt  "L" 2 lubrif_m8
fmt  "L" 2 lubrif_m207
fmt  "L" 2 lubrif_m200
fmt  "L" 2 old_lubrif_m7
fmt  "L" 2 old_lubrif_m8
fmt  "L" 2 old_lubrif_m207
fmt  "L" 2 old_lubrif_m200
fmt  "L" 2 coolant$
fmt     3 opcode$
fmt  "G" 4 gcode$
fmt  "%" 6 progno$
fmt     3 spdlon
fmt  "T" 3 t$
fmt  "T" 3 next_tool$
fmt  "D" 3 tloffno$
fmt  "D" 4 tlngno$
fmt  "G" 3 cc$
fmt     2 tldia$
fmt     2 tlrad$
fmt  "OP" 3 op_id$
fmt  "LOP" 3 lastopid
fmt  "M" 3 lstation$
fmt  "M" 3 oldstation
fmt  "T" 1 typepercage
fmt  "" 8 depth$
fmt  "" 8 refht$
fmt  "" 8 initht$
fmt  "" 2 dwell$
fmt  "" 2 peckclr$
fmt  "" 2 peck1$
fmt  "" 2 peck2$
fmt  ""  2 shftdrl$
fmt  ""  2 retr$
fmt  "F" 3 frplunge$
fmt "" 8 avance_plonge
fmt "" 8 tosz$
fmt     3 mi1$
fmt     3 mi4$
fmt     3 mi8$
fmt "old_mi8" 3 oldmi8
fmt     3 old_mi1
fmt  "G" 3 mi2$
fmt  "P" 2 passe
fmt  "Z" 2 mr2$
fmt  ""   3 trans_mi1$
fmt  ""   3 trans_mi2$
fmt  "OP" 3 operation
fmt  "LUB" 8 lub
fmt  "PPR" 8 ppr
fmt  "X" 1 x1
fmt  "Y" 1 y1
fmt  "X" 1 x2
fmt  "Y" 1 y2
fmt  "Z" 1 z2
fmt  "X" 1 x3
fmt  "Y" 1 y3
fmt  "Z" 1 z3
fmt  "X" 1 x4
fmt  "Y" 1 y4
fmt  "Z" 1 z4
fmt  "X" 8 xaproche
fmt  "Y" 8 yaproche
fmt  "Z" 8 zaproche
fmt  "aCAl" 12 axeacal
fmt  "CCAl" 12 axeccal
fmt  "Pl" 2 plinc5a
fmt  "XV" 2 vieuxx
fmt  "YV" 2 vieuxy
fmt  "ZV" 2 vieuxz
fmt  "dx" 2 deltax
fmt  "dy" 2 deltay
fmt  "dz" 2 deltaz
fmt  "E" 3 e53
fmt     3 e40
fmt     8 vale53
fmt  "P" 2 pasmi7
fmt  "P" 2 pasn
fmt  "ANG" 2 move_ang3$
fmt "" 4 oscilliation
fmt "" 4 paquet_mi4
fmt "" 4 paquet_mi5
fmt "" 4 paquet_mi8
fmt "compteur_descrip" 2 compteur_descrip
compteur_descrip : 0
fmt 2 rattrapage_angle
cycle_800 = 0
fmt 2 delta_rot_C
delta_rot_C = 175
#endregion
#region FQ
fmt  8 vectdeg
fq   2 vectdeg "Limite angle atteint! Longeur du vecteur de recul"
snomprog : ""
fq   3 snomprog "ENTREZ LE NOM DU PROGRAMMEUR"
fmt "hops" 4 HOPS
srefpiec : ""
fq 7 srefpiec "REFERENCE PIECE ? ( 15 characteres maxi )"
smesage : ""
fq 10 smesage "Commentaire operateur pour arret programme ?"
fq 15 trplus " Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"
fq 21 axeC " L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

sindice : ""
fq 23 sindice "ENTREZ LE PN+INDICE+MACHINE"
snompiece : ""
fq 24 snompiece "ENTREZ LE NOM DE LA PIECE"
sarticle : ""
fq 25 sarticle "ENTREZ LE NUMERO D'ARTICLE"
#endregion
#region Le reste (LUB, GCODE, usecandrill, etc,...)
#-----------------------------Variable pour OUTILS----------------------------------------
fmt   2 paramT1         # Ne outil
fmt   2 paramT2         # Type d'outil
fmt   2 paramT3         # longeur sorti outil 
fmt   2 paramT4         # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt   3 paramT5         # Diametre
fmt   3 paramT6         # Rayon de bout
fmt   3 paramT7         # Nombre de filet par mm
fmt   3 paramT8         # Angle de bout
fmt   5 paramT9         # Ne de correcteur de rayon
fmt   5 paramT10        # Ne de correcteur de longeur
fmt   3 paramT11        # Avance travail
fmt   3 paramT12        # Avance plongee
fmt   3 paramT13        # Avance retraction
fmt   5 paramT14        # Vitesse de broche
fmt   5 paramT15        # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt   5 paramT16    " DENTS" # Nombre de dents
#---------------------------------------------------------------------------
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
#---------------------------------------------------------------------------
rattrapage_angle = 0  #permettre ou non le rattrapage d'angle 0 pour non 1 pour oui
mrg_subfile$
auxprg$ = 2
extprg$ = 2
lccprg$ = 2
subprg$    : yes$
mergesub$  : 0
getnextop$ : 1
mill      : 1
spaces$    : 1
no$        = 0
seqmax$    = 32000
omitseq$   : no$
frrapid   : 300
frmax     : 300
ssmax     : 34000
breakarcs$ : 0       #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arctype$   : 1       # Arc center 1=abs, 2=inc, 3=st-cen, 4=unsigned inc.
do_full_arc$ : 0     #Allow full circle output? 0=no, 1=yes
helix_arc$   : 2     #Support helix arc output, 0=no, 1=all planes, 2=XY plane only
ncldr$     : 20      # No. of leader characters
ldrcode$   : 65      # Leader character dec. equiv.
bldnxtool$ : yes$    # Build next tool table
tooltable$ : yes$
opcode$    : 1
nobrk$     : yes$    # Omit breakup of rapid linear motion? yes/no(xy,z or z,xy)
x$         : 9999
y$         : 9999
z$         : 9999
i$         : 0
j$         : 0
k$         : 0
gcode$     :   -1
strtool_v7$ : 1
rotaxtyp$   : 3
nbr_cht    : 0
gfr        : 1
asp		   : 0
pat		   : 0
operation   : 0
sx_label : ""
sy_label : ""
sz_label : ""
si_label : ""
sj_label : ""
sk_label : ""
sxr_label : ""
syr_label : ""
szr_label : ""
smr2_label : ""
soutil : ""
svide : ""
oldmi8 : 0
smi4_str : ""
smi5_str : ""
smi8_str : ""
#---------------------------------------------------------------------
usecandrill$ : yes$
usecanpeck$  : yes$
usecanchip$  : yes$
usecantap$   : no$
usecanbore1$ : yes$
usecanbore2$ : no$
usecanmisc1$ : yes$
usecanmisc2$ : no$
#----------------------------------------------------------------------
fastmode$  : 1
bug1$   : 5           # 1 = Output post to screen - 2 = output leader to screen
bug2$   : 40           # Add postline label to each line at column 'bug2'
bug3$   : 50           # Add whatline to each line
bug4$   : 60           # Add nci no
whatno$ : yes$         # Ignore whatline branches to plin1 etc.?
linktolvar$    : 1     # Associer les variables de tolerance X aux variables V9-
linkplnvar$    : 1     # Associer les variables specifiques plan X aux variables V9-?
linklvar$      : 1     # Associer les variables specifiques X Tournage aux variables V9-
cant_tlchng$   : 1     # Ignorer entree de texte programme au changement avec tlchng_aft?
newglobal$     : 0     # Activer la verification d'erreur pour les variables globales?
#----------------------------------------------------------------------------

sp01 : "PATIN_OFF"
sp02 : "PATIN_AUTO"
spat : ""

fstrsel  sp01 pat spat 2 -1

sa01 : "M211 ; ARRET ASPI"
sa02 : "M210 ; MARCHE ASPI"
sasp : ""

fstrsel  sa01 asp sasp 2 -1

sm93 : "G93"
sm94 : "G94"
sgfr : ""

fstrsel  sm93 gfr sgfr 2 -1

sg00    : "G0"
sg01    : "G1"
sg02    : "G2"
sg03    : "G3"
sg04    : "G1"
sgcode : ""

fstrsel  sg00 gcode$ sgcode 5 -1

spl00    : "G17"
spl01    : "G19"
spl02    : "G18"
spl03 : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1

sm00    : "M4"
sm01    : "M5"
sm02    : "M3"
spdlon ??

spdlsel = fsg3(ss$)

fstrsel  sm00 spdlsel spdlon 3 -1
#endregion
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE
fmt      7 mini_a
fmt      7 maxi_a
fmt      7 mini_c
fmt      7 maxi_c
fmt      7 mini_c_sans_cloche
fmt      7 maxi_c_sans_cloche
fmt      7 mini_c_avec_cloche
fmt      7 maxi_c_avec_cloche
fmt "Z" 2 zsecu
fmt  "X" 2 x3dprint
fmt  "Y" 2 y3dprint
fmt  "Z" 2 z3dprint


fmt  "X=" 7 axeApos
fmt  "Z=" 7 axeCpos
fmt  "X=" 7 axeApos2
fmt  "Z=" 7 axeCpos2
fmt  "" 7 axeApos_cycle800
fmt  "" 7 axeCpos_cycle800
fmt "X" 2 tox4print
fmt "Y" 2 toy4print
fmt "Z" 2 toz4print
fmt  "I" 2 iprint
fmt  "J" 2 jprint
fmt  "K" 2 kprint
fmt "X" 2 xrprint
fmt "Y" 2 yrprint
fmt "Z" 2 zrprint
fmt "X" 2 xrprintrap
fmt "Y" 2 yrprintrap
fmt "Z" 2 zrprintrap
fmt "Y" 2 depthprint
fmt "Y" 2 refhtprint
fmt "Y" 2 inithtprint
fmt "Z" 2 mr2print
fmt "S" 3 ssprint
fmt "G04 F" 2 tempo " ; temporisation "
fmt  "T" 3 tprint
fmt  "" 3 tprint2
fmt "E80004=" 2 vale84
fmt  "N" 3 nplus
fmt  "Z" 1 z1
fmt  "Z" 2 prvmr2
fmt "X" 2 xprint
fmt "Y" 2 yprint
fmt "Z" 2 zprint
fmt "Z" 2 zcloche_on
fmt "Z" 2 zcloche
fmt "Z" 2 zcloche_inc
fmt "Z" 2 zbrut
fmt "Z" 2 zbrut_inc
fmt "X" 8 xgarde
fmt "Y" 8 ygarde
fmt "Z" 8 zgarde
fmt  "F" 4 avance
fmt  "F" 10 fr5axe
fmt  "F" 10 frbase
fmt  "F" 4 fr
fmt  "K" 2 pas
fmt  "X" 2 xdeg
fmt  "Y" 2 ydeg
fmt  "Z" 2 zdeg
fmt  "Z" 1 zdeg2

fmt  "X" 2 old_x
fmt  "Y" 2 old_y
fmt  "Z" 2 old_z
fmt  "X" 2 old_x_print
fmt  "Y" 2 old_y_print
fmt  "Z" 2 old_z_print


fmt  "Z" 2 old_zinitht
fmt "Z" 2 dest_ret_5x
fmt "Z" 2 old_dest_ret_5x
fmt  "" 8 initht5x
fmt  "Z" 8 zinitht
fmt  "" 2 sdis
fmt  "X" 2 xabs         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs
fmt  "Z" 2 zabs
fmt "Z" 2 z_retraction                          # coordonee Z du plan de retraction 
fmt "Z" 2 z_dessus_brut                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs                                # ecriture d'un X dans le cycle Helicoedo-Spiral
fmt "Y" 2 yp_chs                                # ecriture d'un Y dans le cycle Helicoedo-Spiral
fmt "Z" 2 zp_chs                                # ecriture d'un Y dans le cycle Helicoedo-Spiral
fmt "I" 2 ip_chs                                # ecriture d'un X dans le cycle Helicoedo-Spiral
fmt "J" 2 jp_chs                                # ecriture d'un Y dans le cycle Helicoedo-Spiral
fmt "Z" 3 prof_1
fmt "Z" 3 prof_2
fmt "Z" 3 prof_3
fmt "Z" 3 prof_4
fmt "Z" 3 prof_5
fmt "Z" 3 prof_1_rel
fmt "Z" 3 prof_2_rel
fmt "Z" 3 prof_3_rel
fmt "Z" 3 prof_4_rel
fmt "Z" 3 prof_5_rel
fmt "G4 F" 15 tempo_1
fmt "G4 F" 15 tempo_2
fmt "G4 F" 15 tempo_3
fmt "G4 F" 15 tempo_4
fmt "G4 F" 15 tempo_5
fmt  "X," 13 mr8
fmt  "Y," 13 mr9
fmt  "Z," 13 mr10
fmt  "USURE_L(" 2 mr1$ ")"
fmt  "op" 1 prvop_id
fmt  "OPERATION "  5 numop
fmt 2 erreur
fmt     3 mi4
fmt     3 mi5
fmt  "M" 3 oldmi5
fmt     3 mi8
fmt "DEC_X " 2 DEC_X
fmt "DEC_Y " 2 DEC_Y
fmt "DEC_Z " 2 DEC_Z
fmt "prog" 2 prog
fmt "DEC X = "  2 mr8AF
fmt "DEC Y = "  2 mr9AF
fmt "DEC Z = "  2 mr10AF
fmt "Mi2 pour A base =" 4 mi2_A_base
fmt "Mi1 pour C base =" 4 mi1_C_base
fmt  "TR" 4 trplus
fmt  "I" 7 invers
fmt  "D" 1 deja
fmt  "VX" 1 old_vx
fmt  "VY" 1 old_vy
fmt  "VZ" 1 old_vz
fmt  "F" 3 frplunge
fmt     2 typcycle
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes
fmt "old_sub_trnstyp" 4 old_sub_trnstyp
fmt "old_sub_totl_no" 4 old_sub_totl_no
fmt 4 blocaxe
fmt  "CT" 4 cont_axe_c     #compte tour axe c
fmt  ""  3 changop
fmt  "F" 4 fretrait
fmt "LONG_MAX=" 15 LONG_MAX
fmt "LONG_MIN=" 15 LONG_MIN
fmt  "num garage" 12 garage
fmt  "X" 2 old_tox4
fmt  "Y" 2 old_toy4
fmt  "Z" 2 old_toz4
fmt  "EC" 7 old_axeCpos
fmt  "EA" 7 old_axeApos
fmt      7 oldreel_axeCpos
fmt      7 reel_axeCpos
fmt      7 difaxecpos
fmt      7 comptour
fmt      7 naxecpos
fmt "renv angle on off=" 4 tete_rev
fmt 2 usedelta

usedelta = 0 #utilisation du delta C 175°
fretrait : 500
nbt = 1            # nombre de tour possible pour retournement
old_sub_trnstyp : -1
old_sub_totl_no : -1
prog : -1
drill5axes  : 0

zsecu = 800   # valeur altitude de securite en Z
dec_tete = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x : 100
SDEC_X : ""
SDEC_Y : ""
SDEC_Z : ""
SCLOCHE_ACTIVE : ""
STRING_CLOCHE_ACTIVE : "Autre Info n°  2 : cloche montee OUI"
STRING_CLOCHE_DESACTIVE : "Autre Info n°  2 : cloche montee NON"
sprog_complet : ""

stringtxt1 : "BRIDER LA PIECE AVEC VIS"
stringtxt2 : "OTER LES VIS"
stringtxt3 : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4 : "OTER LES SERRE-JOINTS"
stringtxt5 : "OTER LES CHUTES"
stringtxt6 : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7 : "NETTOYER LES PORTEES DES RENVOIS"
stringtxt8 : "TEXTE8"
stringtxt9 : "TEXTE9"
stringtxt10 : "TEXTE10"
spalpeur : "PALPEUR_3D"

#endregion
#region   VARIABLES SIMULATION
#region variables générales
fmt "X" 2 xaff
fmt "Y" 2 yaff
fmt "Z" 2 zaff
fmt "A" 2 aaff
fmt "C" 2 caff
fmt "R" 2 raff
fmt "N" 4 n2
fmt "N" 4 n$
fmt  "B" 3 axeB5xsimu
fmt  "C" 3 axeC5xsimu
fmt 8 m1simu
fmt 8 m2simu
fmt 8 m3simu
fmt 8 tox4simu
fmt 8 m4simu
fmt 8 m5simu
fmt 8 m6simu
fmt 8 toy4simu
fmt 8 m7simu
fmt 8 m8simu
fmt 8 m9simu
fmt 8 toz4simu
fmt "Z" 2 drl_depth_z$
fmt "plinc" 2 plinc
fmt "old_xabs_simu" 1 old_xabs_simu
fmt "old_yabs_simu" 1 old_yabs_simu
fmt "old_zabs_simu" 1 old_zabs_simu
fmt "planperc" 1 planperc
fmt "conttour" 1 conttour
fmt "X" 3 x_inter
fmt "Y" 3 y_inter
fmt "Z" 3 z_inter
fmt "delta_c" 1 delta_c
fmt "delta_b" 1 delta_b
fmt "C" 3 c_inter
fmt "A" 3 b_inter
fmt 2 old_initht
fmt 2 old_refht
fmt 2 old_depth

#endregion
#region variables
fmt "v_delta_x" 1 v_delta_x
fmt "v_delta_y" 1 v_delta_y
fmt "v_delta_z" 1 v_delta_z
fmt "v_delta_xyz" 1 v_delta_xyz
fmt "v_sindir_x" 1 v_sindir_x
fmt "v_sindir_y" 1 v_sindir_y
fmt "v_sindir_z" 1 v_sindir_z
fmt "v_delta_div" 1 v_delta_div
fmt "v_abs_plus_x" 1 v_abs_plus_x
fmt "v_abs_plus_y" 1 v_abs_plus_y
fmt "v_abs_plus_z" 1 v_abs_plus_z
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec
fmt "old_v_abs_plus_z_sec" 1 old_v_abs_plus_z_sec
fmt "old_v_abs_plus_x_sec" 1 old_v_abs_plus_x_sec
fmt "old_v_abs_plus_y_sec" 1 old_v_abs_plus_y_sec
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_fin
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_fin
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_fin
fmt "old_opcode" 1 old_opcode
fmt "X" 2 xprintcorg
fmt "Y" 2 yprintcorg
fmt "Z" 2 zprintcorg
fmt 19 old_corg_x
fmt 19 old_corg_y
fmt 19 old_corg_z
fmt 19 dif_old_corg_x
fmt 19 dif_old_corg_y
fmt 19 dif_old_corg_z
fmt 1 premperc
fmt  "R" 3 rayon
fmt 2 flag_cloche
fmt 2 flag_chargement_cloche
fmt 2 old_tool
fmt "T_C" 2 scchangeur
fmt  "C" 12 axe_C_garage
fmt  "B" 12 axe_A_garage

garage : 0
flag_cloche : 0
flag_chargement_cloche : 0
flag_changement_outil : 0
premperc : 0
old_opcode : 0
#endregion
#region strings générales


string_B : ""
sxzero : "X+0.000"
sxtete : "X+0.000"
sytete : "Y+310.000"
sztete : "Z-540.000"
sfsimurapid : "F10000"
stype_arc : ""
sdegageZ    : "Z0."
snumligne : ""

sr : "MW_RELMOVE RAPID" # mouvement rapide par rapport a la piece
sl : "MW_RELMOVE FEED" # mouvement ligne travail par rapport a la piece
sc : "MW_RELARCMOVE FEED"  # mouvement par rapport a la piece
sm : "MW_MACHMOVE RAPID"    # MOUVEMENT par rapport au repere de la machine
sf : "MW_OP_END"      # fin d'une operation 

space_aff : "" # "<EOC>"     # <EOC> pour un affichage avec tabulation, "" sans 

paf_cal_aff

                                xaff = xprint
                                yaff = yprint
                                zaff = zprint
                                aaff = axeA
                                caff = axeC

paf_xyzac    # ici on gere l'affichage en bout de ligne X Y Z A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*aaff,space_aff,*caff

paf_xy    # ici on gere l'affichage en bout de ligne X Y 
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff

paf_xyz    # ici on gere l'affichage en bout de ligne X Y Z 
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,sgcode,*xaff,*yaff,*zaff

paf_xyac    # ici on gere l'affichage en bout de ligne X Y A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*aaff,space_aff,*caff

paf_zac    # ici on gere l'affichage en bout de ligne Z A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*zaff,space_aff,*aaff,space_aff,*caff

paf_xyzr    # ici on gere l'affichage en bout de ligne X Y Z R
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*raff

paf_ac    # ici on gere l'affichage en bout de ligne A C
                paf_cal_aff
                pnumligne,35, no_spc$,*n2,*sgcode,space_aff,*aaff,space_aff,*caff

paf
                paf_cal_aff
                pnumligne,35,no_spc$,*n2
pafcom
                paf_cal_aff
                35,no_spc$
#endregion
#region strings
sxmag : ""
symag : ""
symag2 : ""
symag3 : ""
szmag : ""
szmag_2 : ""
sxchangeur : ""
sychangeur : ""
sychangeur_2 : ""

sxmag_Z1 : ""
symag_Z1 : "Y+1352.000"
szmag_Z1 : "Z+1142.795"
szmag_Z1_2 : "Z+649.805"

sxmag_Z2 : ""
symag_Z2 : "Y+792.000"
szmag_Z2 : "Z+1142.795"
szmag_Z2_2 : "Z+650.495"

sxchangeur_Z1 : ""
sychangeur_Z1 : "X_changeur_un+210.000"
sychangeur_2_Z1 : "X_changeur_un+0.000"

sxchangeur_Z2 : ""
sychangeur_Z2 : "X_changeur_deux+210.000"
sychangeur_2_Z2 : "X_changeur_deux+0.000"

souverture_porte : ""
souverture_porte_Z1 : "B_changeur_un-180.000"
souverture_porte_Z2 : "B_changeur_deux-180.000"

sfermeture_porte : ""
sfermeture_porte_Z1 : "B_changeur_un+0.000"
sfermeture_porte_Z2 : "B_changeur_deux+0.000"

ssortie_changeur : ""
sentree_changeur : ""
							
sxmach : ""
symach : ""
szmach : ""

sxmach_Z1 : "X+4420.000"
symach_Z1 : "Y+0.000"
szmach_Z1 : "Z+1242.795"

sxmach_Z2 : "X+0.000"
symach_Z2 : "Y+0.000"
szmach_Z2 : "Z+1242.795"

sxmach_Z3 : "X+0.000"
symach_Z3 : "Y+0.000"
szmach_Z3 : "Z+1152.000"

sxmach_Z4 : "X+0.000"
symach_Z4 : "Y+0.000"
szmach_Z4 : "Z+1496.139"

sxmach_garage : ""
symach_garage : ""
szmach_garage : ""

sxmach_garage_Z1 : "X+4610.646"
symach_garage_Z1 : "Y+1255.818"
szmach_garage_Z1 : "Z+1242.795"

sxmach_garage_Z2 : "X+0.000"
symach_garage_Z2 : "Y+1255.818"
szmach_garage_Z2 : "Z+1242.795"

sxcloche : "X1500.000"
sycloche : "Y0.000"
szcloche : "Z1500.000"
souverture_cloche : "Cl_B_UNE-180.000 Cl_B_DEUX+180.000"
sfermeture_cloche : "Cl_B_UNE+0.000 Cl_B_DEUX+0.000"

sentre_cloche  : ""
#endregion
#endregion
#region   Mouvements habillage machsim

#region chargement cloche
pchargement_cloche
    sm, szmach, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szmach, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szcloche, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szmach, sbzero, sczero
    flag_cloche = 1
	flag_chargement_cloche = 1
#endregion

#region déchargement cloche
pdechargement_cloche
    sm, szmach, sbzero, sczero, pafcom,"DECHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szmach, sbzero, sczero, pafcom, "DECHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szcloche, sbzero, sczero, pafcom, "DECHARGEMENT CLOCHE", e$
    sm, sxcloche, sycloche, szmach, sbzero, sczero, sentre_cloche, paf, "M170",e$
    flag_cloche = 1
#endregion

#region chargement premier outil
pdebut_chagement_outil
							if ((mi5 = 1) | (mi5 = 9)),	[
														sxmag = sxmag_Z1
														symag = symag_Z1
														szmag = szmag_Z1
														szmag_2 = szmag_Z1_2
														sxchangeur = sxchangeur_Z1
														sychangeur = sychangeur_Z1
														sychangeur_2 = sychangeur_2_Z1
														souverture_porte = souverture_porte_Z1
														sfermeture_porte = sfermeture_porte_Z1
														]
					
												else,	[
														sxmag = sxmag_Z2
														symag = symag_Z2
														szmag = szmag_Z2
														szmag_2 = szmag_Z2_2
														sxchangeur = sxchangeur_Z2
														sychangeur = sychangeur_Z1
														sychangeur_2 = sychangeur_2_Z1
														souverture_porte = souverture_porte_Z2
														sfermeture_porte = sfermeture_porte_Z2					
														]					
							scchangeur = t$ * 22.5

    						sm, szmach, sbzero, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
							sm, symag, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT CHANGEUR)", e$
							sm, sb_soixante, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
							sm, souverture_cloche, pafcom, "CHANGEMENT D'OUTIL (OUVERTURE CLOCHE)", e$
							sm, souverture_porte, pafcom, "CHANGEMENT D'OUTIL (OUVERTURE PORTE CHANGEUR)", e$
							sm, sb_quatre_vingt_dix, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
							sm, sychangeur, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR ET PRISE D'OUTIL)", e$
							sm, szmag, pafcom,"CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
							sm, sb_soixante, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
							sm, sychangeur_2, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
							sm, sfermeture_porte, sbzero, pafcom, "CHANGEMENT D'OUTIL (FERMETURE CHANGEUR ET ROTATION TETE)", e$					
#endregion

#region changement d'outil

ppreptete

		if t$ = 1,	[
					"MW_MOUNTING head_adapter BROCHE_1", e$
					"MW_TOOL_NAME tool1 USE_DEFAULT", e$
					"MW_OP_POST_NAME BROCHE_1", e$
					]
					
		if t$ = 2,	[
					"MW_MOUNTING head_adapter BROCHE_2", e$
					"MW_TOOL_NAME tool2 USE_DEFAULT", e$
					"MW_OP_POST_NAME BROCHE_2", e$
					]
					
		if t$ = 3,	[
					"MW_MOUNTING head_adapter BROCHE_3", e$
					"MW_TOOL_NAME tool3 USE_DEFAULT", e$
					"MW_OP_POST_NAME BROCHE_3", e$
					]
					
		if t$ = 4,	[
					"MW_MOUNTING head_adapter BROCHE_4", e$
					"MW_TOOL_NAME tool4 USE_DEFAULT", e$
					"MW_OP_POST_NAME BROCHE_4", e$
					]					
					
					
					
		if t$ = 5,
					[
					"MW_TOOL_NAME tool USE_DEFAULT", e$
					"MW_OP_POST_NAME SANS_TETE", e$
					]
					
fmt 2 	old_outil_simu
old_outil_simu : 0

pchagement_outil
							sm, szmag, sbzero, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
							sm, symag, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT CHANGEUR)", e$
							sm, sczero, sb_soixante, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
							sm, souverture_cloche, pafcom, "CHANGEMENT D'OUTIL (OUVERTURE CLOCHE)", e$
							sm, souverture_porte, pafcom, "CHANGEMENT D'OUTIL (OUVERTURE PORTE CHANGEUR)", e$
							sm, sychangeur, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
							sm, sb_quatre_vingt_dix, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
							sm, szmach, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z ET DEPOSE OUTIL)", e$
							sm, sychangeur_2, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
							if symag = symag_Z1, symag = symag_Z2
							else, symag = symag_Z1
							sm, symag, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT CHANGEUR)", e$
							sm, sychangeur, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR ET PRISE D'OUTIL)", e$						
	if symag = symag_Z1, symag = symag_Z2
	else, symag = symag_Z1
	sf, e$
    old_corg_x = tox4$, old_corg_y = toy4$, old_corg_z = toz4$
    spaces$ = 0
	"MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	sm, szmag, pafcom,"CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, sb_soixante, pafcom,"CHANGEMENT D'OUTIL (ROTATION TETE)", e$
	sm, sychangeur_2, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
	sm, sfermeture_porte, sbzero, pafcom, "CHANGEMENT D'OUTIL (FERMETURE CHANGEUR ET ROTATION TETE)", e$						
#endregion

#region garage

#endregion

#region prtcp_simu
conttour : 0
delta : 45
fmt "dif_c" 1 dif_c
fmt "dif_a" 1 dif_a
fmt "delta" 1 delta
fmt "old_axeC_simu" 1 old_axeC_simu
fmt "old_axeA_simu" 1 old_axeA_simu
fmt "old_xprint_simu" 1 old_xprint_simu
fmt "old_yprint_simu" 1 old_yprint_simu
fmt "old_zprint_simu" 1 old_zprint_simu
fmt "v_delta_x_simu" 1 v_delta_x_simu
fmt "v_delta_y_simu" 1 v_delta_y_simu
fmt "v_delta_z_simu" 1 v_delta_z_simu
fmt "v_delta_xyz_simu" 1 v_delta_xyz_simu
fmt "v_sindir_x_simu" 1 v_sindir_x_simu
fmt "v_sindir_y_simu" 1 v_sindir_y_simu
fmt "v_sindir_z_simu" 1 v_sindir_z_simu
fmt "v_delta_div_simu" 1 v_delta_div_simu
fmt "v_abs_plus_x_simu" 1 v_abs_plus_x_simu
fmt "v_abs_plus_y_simu" 1 v_abs_plus_y_simu
fmt "v_abs_plus_z_simu" 1 v_abs_plus_z_simu
fmt 1 flag_outil
flag_outil : 0
prtcp_simu

							dif_c = abs(axeC - old_axeC_simu)
							dif_a = abs(axeA - old_axeA_simu)
							if dif_c >= delta | dif_a >= delta,
							[						
							v_delta_x_simu = xprint - old_xprint_simu 
							v_delta_y_simu = yprint - old_yprint_simu 
							v_delta_z_simu = zprint - old_zprint_simu 
							if drill5axes <> 1,	[
												if mr2print <> -1, old_zprint_simu = mr2print, v_delta_z_simu = 0
												]
							v_delta_xyz_simu = sqrt(v_delta_x_simu^2 + v_delta_y_simu^2 + v_delta_z_simu^2)
							v_sindir_x_simu = v_delta_x_simu/v_delta_xyz_simu
							v_sindir_y_simu = v_delta_y_simu/v_delta_xyz_simu
							v_sindir_z_simu = v_delta_z_simu/v_delta_xyz_simu
							v_delta_div_simu = v_delta_xyz_simu / 10
							v_abs_plus_x_simu = v_delta_div_simu * v_sindir_x_simu
							v_abs_plus_y_simu = v_delta_div_simu * v_sindir_y_simu
							v_abs_plus_z_simu = v_delta_div_simu * v_sindir_z_simu
							while conttour < 9,
							 					[
												conttour = 1 + conttour
												x_inter = old_xprint_simu + (v_abs_plus_x_simu * conttour)
												y_inter = old_yprint_simu + (v_abs_plus_y_simu * conttour)
												z_inter = old_zprint_simu + (v_abs_plus_z_simu * conttour)
												delta_c = (old_axeC_simu - axeC) / 10
												delta_b = (old_axeA_simu - axeA) / 10
												c_inter = (old_axeC_simu - delta_c * conttour)
												b_inter = (old_axeA_simu - delta_b * conttour)
												sr,*x_inter, *y_inter, *z_inter, *b_inter, *c_inter, pfr,paf, "(MOUVEMENT RTCP)",e$
												]
							]	

	old_axeC_simu = axeC
	old_axeA_simu = axeA
	old_xprint_simu = xprint
	old_yprint_simu = yprint
	old_zprint_simu = zprint
	conttour = 0

prtcp_simu_ratrap

							while conttour < 19,
							 					[
												conttour = 1 + conttour
												delta_c = (old_axeC_simu - axeC) / 20
												c_inter = (old_axeC_simu - delta_c * conttour)
												sr,*xdeg, *ydeg, *zdeg2,pfr, paf, "(MOUVEMENT RTCP)",e$
												]
												conttour = 0
#endregion

#endregion
#region   REPERTOIRES
#region pgestion_prog
pgestion_valeur_C_CLOCHE

								if SCLOCHE_ACTIVE = STRING_CLOCHE_ACTIVE,	[
																				mini_c = mini_c_avec_cloche
																				maxi_c = maxi_c_avec_cloche
																				axeA_cloche_moins = -60
																				axeA_cloche_plus = 60
																				]
								if SCLOCHE_ACTIVE = STRING_CLOCHE_DESACTIVE,	[
																					mini_c = mini_c_sans_cloche
																					maxi_c = maxi_c_sans_cloche
																					axeA_cloche_moins = -120.001
																					axeA_cloche_plus = 120.001
																					]
#endregion
#region pdecomposition_mi1
fmt "mi1_trans " 17 mi1_trans
fmt "mi1_mirro " 17 mi1_mirro
fmt "mi1_rotat " 17 mi1_rotat

pdecomposition_mi1
                        mi1_trans = mi1$
                        mi1_mirro = mi1$
                        mi1_rotat = mi1$                 
#endregion
#region pdecomposition_mi2
fmt "mi2_trans " 17 mi2_trans
fmt "mi2_mirro " 17 mi2_mirro
fmt "mi2_rotat " 17 mi2_rotat

pdecomposition_mi2
                        mi2_trans = mi2$
                        mi2_mirro = mi2$
                        mi2_rotat = mi2$
#endregion
#region pdecomposition_mi4
pdecomposition_mi4    # sortie des parties d'une chaine numerique
					mi4 = mi4$			
#endregion
#region pdecomposition_mi5
pdecomposition_mi5    # sortie des parties d'une chaine numerique
                    mi5 = mi5$
#endregion
#region pdecomposition_mi8
pdecomposition_mi8    # sortie des parties d'une chaine numerique
                    mi8 = mi8$
#endregion
#region pnumligne
pnumligne
		n$
		n2 = n$
#endregion
#endregion
#region   ERREURS
#region   Strings erreur
serreur_visu_descripteur : "ATTENTION ARRET POST-PRO : Soit la case (sortir descripteur de fichier MCX) est decochee, soit le fichier programme ne contient pas de descripteur d'usinage !!!"
serreur_visu_descripteur_erreur : "ATTENTION ARRET POST-PRO : Le descripteur est une ancienne version, il convient de le remplacer et inserer le numero de programme dans la case MR1 des valeurs optionnelles !!!"
serreur_visu_transformation : "ATTENTION ARRET POST-PRO : La case (sous programmme, absolu) dans l'operation de transformation est decochee !!!"
serreur_mi1 : "ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle C ne doit pas etre inferieure e 0 dans Valeurs optionnelles et/ou parametres speciaux - Operation n°"
serreur_mi2 : "ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle B ne doit pas etre inferieure e 0 dans Valeurs optionnelles et/ou parametres speciaux - Operation n°"
serreurtest_outil : "ATTENTION ARRET POST-PRO : La case (Code outil du fournisseur) doit etre remplie - Operation n°"
serreurplan5X : "ATTENTION ARRET POST-PRO : Les plans de construtions et d'usinages autres que le plan de dessus e 0,0,0 en usinage 5X sont interdits - Operation n°"
serreur3X : "ATTENTION ARRET POST-PRO : Impossible d'utiliser un plan autre que dessus, vous ne travaillez pas sur une machine 5 axes - Operation n°"
serreur5X : "ATTENTION ARRET POST-PRO : Impossible d'utiliser les cycles 5 axes autres que l'usinage de courbe 5 axes dans le plan de dessus - Operation n°"
serreur_visu_general : ""
#region erreurs
serreur_delta_rot_C : " -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C superieur e 175e entre deux points d'usinage, Operation n°"
serreur : " -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporte avec renvoi d'angle "
serreurss : " -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle : " -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporte sur cette machine "
serreurcloche : " -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub : " -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil : " -  ATTENTION ARRET POST-PRO : Definition des parametres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil : " -  ATTENTION ARRET POST-PRO : Definition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation n°"
serreurblum1  : " -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2  : " -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3  : " -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4  : " -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre applique qu'a un seul point et pas e un groupe de points (voir percage cycle palpage bague) "
serreuraxeA   : " -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110e, Operation n°"
serreurimp   : " -  ATTENTION ARRET POST-PRO : Operation impropre e regenerer, Operation n°"
serreuroscil : " -  ATTENTION ARRET POST-PRO : Il y  un choix e faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation n°"
serreurpolarA : " -  ATTENTION ARRET POST-PRO : Altitude de retournement desactivee sur la 1er operation, entrez une valeur"
serreurarretprog : " -  ATTENTION ARRET POST-PRO : Interdiction de desactiver l'altitude de retournement lors d'un arret programme, Operation n°"
serreumr : " -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 e l'altitude de retournement, Operation n°"
serreur100 : " -  Erreur dans le cycle de perçage decompose e avance contrelee, il ne faut pas entrer de valeur negative sur les avances - Operation n°"
serreur101 : " -  Erreur dans le cycle de perçage decompose e avance contrelee, il faut entrer 0 ou 1 sur le parametre Absolu(0) - Relatif(1) - Operation n°"
serreur102 : " -  Erreur dans le cycle de perçage decompose e avance contrelee, bon... le, il faut etre tres con pour mettre 9999 des la premiere profondeur ! :-) - Operation n°"
serreur200 : " -  Erreur, il faut choisir entre Soufflage M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Operation n°"
serreur201 : " -  Erreur, on ne peut utiliser Soufflage M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Operation n°"
serreur203 : " -  Erreur, on ne peut utiliser arrosage exterieur M8 ou Soufflage M7 avec aspiration (mettre 9 dans Num cloche MI4) - Operation n°"
serreur300 : " -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou parametres speciaux - Operation n°"
serreur301 : " -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou parametres speciaux - Operation n°"
serreur1 : " -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Operation n°"
serreur2 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diametre final - Operation n°"
serreur3 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diametre ebauche - Operation n°"
serreur4 : " -  Erreur dans cycle CAQ, il faut entrer une valeur inferieure au diametre final pour le choix : Diametre ebauche - Operation n°"
serreur5 : " -  Erreur dans cycle CAQ, il faut entrer une valeur superieure au diametre outil pour le choix : Diametre final - Operation n°"
serreur6 : " -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi helice en Z - Operation n°"
serreur7 : " -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi helice en Z - Operation n°"
serreur8 : " -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Operation n°"
serreur9 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiere pour le choix : Nbe de tours finition - Operation n°"
serreur10 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entree circulaire - Operation n°"
serreur11 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. helicoedale - Operation n°"
serreur12 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Operation n°"
serreur13 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Operation n°"
serreur14 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Operation n°"
serreur15 : " -  Erreur dans cycle CAQ, la valeur : Dis. Entree Perp. est incompatible avec les valeurs du diametre de l'ebauche et de l'outil - Operation n°"
serreur16 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandee pour le choix : Dist. Entree perp. - Operation n°"
serreur17 : " -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Operation n°"
serreur18 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiere pour le choix : Nbe tours de retour - Operation n°"
serreur19 : " -  Erreur dans cycle CAQ, il faut entrer une valeur superieure au diametre outil pour le choix : Diametre ebauche - Operation n°"
serreur20 : " -  Erreur dans cycle CAQ, incoherence entre le dessus du brut et profondeur du trou : Verifiez vos plans Z - Operation n°"
serreur21 : " -  Erreur dans cycle CAQ, incoherence entre la garde et le dessus du brut : Verifiez vos plans Z - Operation n°"
serreur22 : " -  Erreur dans cycle CAQ, incoherence entre le plan de securite et la garde : Verifiez vos plans Z - Operation n°"
serreur23 : " -  ATTENTION : Le rayon d'ebauche est superieur au diametre de l'outil, il restera theoriquement une carotte! OK pour continuer, Annuler pour arret post-processeur - Operation n°"
serreur24 : " -  Erreur dans cycle CAQ, il faut entrer une valeur superieure au diametre outil pour le choix : Diametre ebauche - Operation n°"
serreur25 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Operation n°"
serreur26 : " -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Operation n°"
serreur27 : " -  Erreur dans cycle CAQ, les valeurs rentrees pour le Pas en Z debut/fin et le Nb tours debut/fin creent une spirale trop importante - Operation n°"
serreur_visu : ""
#endregion
#endregion
#region   pbloc sortie
psortie5X
           serreur_visu_general = serreur5X + no2str(numop)
            result = mprint(serreur_visu_general)
            erreur = 1
			if type_pp = 1,	[
							*serreur_visu_general, e$
							peof$, exitpost$ # abandonner
							]
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu_general, e$
psortie3X
            serreur_visu_general = serreur3X + no2str(numop)
            result = mprint(serreur_visu_general)
            erreur = 1
			if type_pp = 1,	[
							*serreur_visu_general, e$
							peof$, exitpost$ # abandonner
							]
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu_general, e$
			
psortieplan5X
			numop = numop + 1
            serreur_visu_general = serreurplan5X + no2str(numop)
            result = mprint(serreur_visu_general)
            erreur = 1
			if type_pp = 1,	[
							*serreur_visu_general, e$
							peof$, exitpost$ # abandonner
							]
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu_general, e$
######################################################
psortie_axeC_5X
            serreur_visu = serreur_delta_rot_C + no2str(numop)
            result = mprint(serreur_visu)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu, e$
							exitpost$ 
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
			
###################################################### 
psortie_ratrap_enroul
			#senroul = senroul_aff + slettreC + no2str(axeC) + space + slettreA + no2str(axeA) + space + sopration + no2str(numop)
			#result = mprint(senroul)
			#if type_pp = 1,	[
			#				*senroul, e$
			#				exitpost$
			#				]
			#if type_pp = 2,	"MW_OP_COMMENT", *senroul, e$				
###################################################### 
psortie_ratrap_planinc_enroul
			#senroul = senroul_aff + slettreC + no2str(axeCpos1) + space + slettreA + no2str(axeApos1) + space + sopration + no2str(numop)
			#result = mprint(senroul)
			#if type_pp = 1,	[
			#				*senroul, e$
			#				exitpost$
			#				]
			#if type_pp = 2,	"MW_OP_COMMENT", *senroul, e$				
psortie_ratrap_planinc_deroul
			#sderoul = sderoul_aff + slettreC + no2str(axeCpos1) + space + slettreA + no2str(axeApos1) + space + sopration + no2str(numop)
			#result = mprint(sderoul)
			#if type_pp = 1,	[
			#				*sderoul, e$
			#				exitpost$
			#				]
			#if type_pp = 2,	"MW_OP_COMMENT", *sderoul, e$				
###################################################### 
psortie_ratrap_deroul
			#sderoul = sderoul_aff + slettreC + no2str(axeC) + space + slettreA + no2str(axeA) + space + sopration + no2str(numop)	
			#result = mprint(sderoul)
			#if type_pp = 1,	[
			#				*sderoul, e$
			#				exitpost$	
			#				]
			#if type_pp = 2,	"MW_OP_COMMENT", *sderoul, e$				
######################################################
psortie_mi1
            serreur_visu_general = serreur_mi1 + no2str(numop + 1)
            result = mprint(serreur_visu_general)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu_general, e$
							peof$, exitpost$
							]
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu_general, e$				
######################################################
psortie_mi2
            serreur_visu_general = serreur_mi2 + no2str(numop + 1)
            result = mprint(serreur_visu_general)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu_general, e$
							peof$, exitpost$  
							]
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu_general, e$
			
######################################################						
psortie15
			serreur_visu = serreumr + no2str(numop)
            result = mprint(serreur_visu)
			erreur = 1
			if type_pp = 1,	[
							*serreur_visu, e$
            				exitpost$	
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
######################################################                          							
psortie14
            serreur_visu = serreurarretprog + no2str(numop)
            result = mprint(serreur_visu)
            erreur = 1
			if type_pp = 1,	[
							*serreur_visu, e$
            				exitpost$
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$				
######################################################                  						
psortie13   # avertissement si osciliation double 
            serreur_visu = serreurpolarA
            result = mprint(serreur_visu)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu, e$
							exitpost$	
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
######################################################                      						
psortie12
            serreur_visu = serreuroscil + no2str(numop)
            result = mprint(serreur_visu)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu, e$
							exitpost$	
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$    						
######################################################                      							
psortie11   # avertissement si angle A impossible
            serreur_visu = serreurimp + no2str(numop)
            result = mprint(serreur_visu)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu, e$
							exitpost$	
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$		
######################################################                  							
psortie10
			serreur_visu = serreuraxeA + no2str(numop)
            result = mprint(serreur_visu)
            erreur = 1
            if type_pp = 1,	[
							*serreur_visu, e$
							exitpost$	
							]
			if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$				
######################################################                      						
psortie9  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
			result = mprint(serreurblum4, 3)
            erreur = 1
			if type_pp = 1,	serreurblum4 , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurblum4 , e$
######################################################                  
psortie8  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
			result = mprint(serreurblum3, 3)
            erreur = 1			
			if type_pp = 1,	serreurblum3 , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurblum3 , e$
######################################################                  							
psortie7  # avertisement et arret du post pro quand incompatibilite outil cycle palpage
			result = mprint(serreurblum2, 3)
            erreur = 1
			if type_pp = 1,	serreurblum2 , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurblum2 , e$
######################################################                  
psortie6  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes
			result = mprint(serreurblum1, 3)
            erreur = 1
			if type_pp = 1,	serreurblum1 , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurblum1 , e$
######################################################                  
psortie5  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification
			result = mprint(serreuroutil, 3)
            erreur = 1
			if type_pp = 1, serreuroutil , e$, "Il y a", *long_string,"caracteres au lieu de 22 attendus !",e$,  exitpost$
			if type_pp = 2, "MW_OP_COMMENT", serreuroutil , "Il y a", *long_string,"caracteres au lieu de 22 attendus !",e$
######################################################                  
psortie4  # avertissement et arret du post pro quand incompatibilite cloche avec lubrification
			result = mprint(serreurlub, 3)
            erreur = 1
			if type_pp = 1,	serreurlub , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurlub , e$
######################################################                  
psortie3  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle
			result = mprint(serreurcloche, 3)
            erreur = 1
			if type_pp = 1,	serreurcloche , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurcloche , e$
######################################################          
psortie2  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
			result = mprint(serreurcycle, 3)
            erreur = 1
			if type_pp = 1,	serreurcycle , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreurcycle , e$
######################################################          
psortie  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
			result = mprint(serreur, 3)
            erreur = 1
			if type_pp = 1,	serreur , e$, exitpost$
			if type_pp = 2,	"MW_OP_COMMENT", serreur , e$
######################################################
#endregion
#endregion 
#region   Gestion de cloche
fmt "gestion cloche " 1 gestion_cloche	
fmt "change cloche "  1 change_cloche


fmt "flagmr2" 1 flagmr2
fmt "old_opcode_cloche" 1 old_opcode_cloche
serreumrcloche : " -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'etat de cloche, Operation n°"
pgarage
		if type_pp = 1,	[
		if (old_opcode_cloche = 13) | (old_opcode_cloche = 14) | (old_opcode_cloche = 17) | (old_opcode_cloche = 18),[		
		if ((mi5 = 1) | (mi5 = 9)),	[
											if axeA > 0 & axeC > 0, garage = 1
											if axeA > 0 & axeC < 0, garage = 2
											if axeA < 0,	garage = 3
											if axeA = 0 & axeC > 0, garage = 4
											if axeA = 0 & axeC < 0, garage = 5
											if axeA = 0 & axeC = 0, garage = 6		
											]
						
									else,	[
											if axeA > 0, garage = 7
											if axeA < 0 & axeC > 0, garage = 8
											if axeA < 0 & axeC < 0, garage = 9
											if axeA = 0, garage = 10
											]
																																]
																																
		else,	[		
		if ((mi5 = 1) | (mi5 = 9)),	[
											if axeApos1_cloche > 0 & axeCpos1_cloche > 0, garage = 1
											if axeApos1_cloche > 0 & axeCpos1_cloche < 0, garage = 2
											if axeApos1_cloche < 0,	garage = 3
											if axeApos1_cloche = 0 & axeCpos1_cloche > 0, garage = 4
											if axeApos1_cloche = 0 & axeCpos1_cloche < 0, garage = 5
											if axeApos1_cloche = 0 & axeCpos1_cloche = 0, garage = 6		
											]
						
									else,	[
											if axeApos1_cloche > 0, garage = 7
											if axeApos1_cloche < 0 & axeCpos1_cloche > 0, garage = 8
											if axeApos1_cloche < 0 & axeCpos1_cloche < 0, garage = 9
											if axeApos1_cloche = 0, garage = 10
											]
				]
				
				]
				
		if type_pp = 2,	[

		if ((mi5 = 1) | (mi5 = 9)),	[
						sxmach_garage = sxmach_garage_Z1
						symach_garage = symach_garage_Z1
						szmach_garage = szmach_garage_Z1
						sm, szmach_garage, paf,"GARAGE (DEGAGEMENT EN Z)", e$
						if axe_A_garage > 0 & axe_C_garage > 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 1
						if axe_A_garage > 0 & axe_C_garage < 0, sm, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 2
						if axe_A_garage < 0,	sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 3
						if axe_A_garage = 0 & axe_C_garage > 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 4
						if axe_A_garage = 0 & axe_C_garage < 0, sm, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 5
						if axe_A_garage = 0 & axe_C_garage = 0, sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$	, garage = 6		
						if axe_A_garage > 0 & axe_C_garage = 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 7
						sm, sxmach_garage, symach_garage, paf, "GARAGE (POSITIONNEMENT AXES LINEAIRES)", e$
						old_axeC_simu = 0
						old_axeA_simu = 0
						old_xprint_simu = 4550
						old_yprint_simu = 1255.818
						old_zprint_simu = mr2print
						]
						
				else,	[
						sxmach_garage = sxmach_garage_Z2
						symach_garage = symach_garage_Z2
						szmach_garage = szmach_garage_Z2
						sm, szmach_garage, paf,"GARAGE (DEGAGEMENT EN Z)", e$
						if axe_A_garage > 0,	sm, sb_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 8
						if axe_A_garage < 0 & axe_C_garage > 0, sm, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 9
						if axe_A_garage < 0 & axe_C_garage < 0, sm, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 10
						if axe_A_garage = 0, sm, sb_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 11
						if axe_A_garage < 0 & axe_C_garage = 0, sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage = 12
						sm, sxmach_garage, symach_garage, paf, "GARAGE (POSITIONNEMENT AXES LINEAIRES)", e$
						old_axeC_simu = 0
						old_axeA_simu = 0
						old_xprint_simu = 250
						old_yprint_simu = 1255.818
						old_zprint_simu = mr2print
						]
						]

pgestionduB_cloche
			if gestion_cloche = 0,	[
										if (old_opcode_cloche = 13) | (old_opcode_cloche = 14) | (old_opcode_cloche = 17) | (old_opcode_cloche = 18),[
																if (change_cloche = 1) & (axeA > axeA_cloche_plus), axeA_cloche = 60
																if (change_cloche = 1) & (axeA < axeA_cloche_moins), axeA_cloche = -60
																]
														else,	[
																if (change_cloche = 1) & (axeApos1_cloche > axeA_cloche_plus), axeA_cloche = 60
																if (change_cloche = 1) & (axeApos1_cloche < axeA_cloche_moins), axeA_cloche = -60
																]
										if (change_cloche = 1) & garage <> 0,	[
																					if garage = 1, axeA_cloche = 60
																					if garage = 2, axeA_cloche = 60
																					if garage = 3, axeA_cloche = -60
																					if garage = 4, axeA_cloche = 60
																					if garage = 5, axeA_cloche = 60
																					if garage = 6, axeA_cloche = 60
																					if garage = 7, axeA_cloche = 60
																					if garage = 8, axeA_cloche = -60
																					if garage = 9, axeA_cloche = -60
																					if garage = 10, axeA_cloche = 60
																					garage = 0
																					]						
										gestion_cloche = 1
										]		
										
psortie_cloche
            serreur_visu = serreumrcloche + no2str(numop)
            if type_pp = 1, *serreur_visu, e$
			if type_pp = 2, "MW_OP_COMMENT", *serreur_visu, e$
            result = mprint(serreur_visu)
            erreur = 1	
pprep_cloche
			flagmr2 = 0
			axeApos1_cloche = axeApos1
			axeCpos1_cloche = axeCpos1
			axeA_cloche = 0
			if oldstation <> mi4, change_cloche = 1
			else, change_cloche = 0
			gestion_cloche = 0
			
			if (mi4 >= 0) & (mi4 <> 9), mini_c = mini_c_avec_cloche, maxi_c = maxi_c_avec_cloche
			else, mini_c = mini_c_sans_cloche, maxi_c = maxi_c_sans_cloche	
#endregion
#region   PPRINT
pprint_debut  # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle 1 er point de passage pour percage            
#region PPRINT
pprint   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle
		old_x=xprint
        old_y=yprint
        old_z=zprint
        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint = ss$ * 1

            if ssprint > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                result = mprint(serreurss, 3)
                if type_pp = 1, serreurss , e$, exitpost$ # abandonner
				if type_pp = 2, "MW_OP_COMMENT", serreurss , e$
                erreur = 1
                ]
            tete_rev = 1
            dec_axe_tete = dec_tete + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx = u$ - x$
                Vy = v$ - y$
                Vz = w$ - z$
                @Vx,@Vy,@Vz
                longvec=sqrt(Vx * Vx + Vy * Vy + Vz * Vz)

                xdegvec  = (Vx / longvec) * dec_axe_tete
                ydegvec  = (Vy / longvec) * dec_axe_tete
                zdegvec  = (Vz / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC cal", axeCcalra

                xdeg = xdegvec  + x$
                ydeg = ydegvec  + y$
                zdeg = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1 = z$
                xdeg1 = xdeg * cos(axeccalra) - ydeg * sin(axeccalra)
                ydeg1 = xdeg * sin(axeccalra) + ydeg * cos(axeccalra)
                zdeg1 = zdeg

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1 * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1 * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2 = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg - xdeg3)
                y4 = y3 + (ydeg - ydeg3)
                z4 = z3 + (zdeg - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint = xdeg
                yprint = ydeg
                zprint = zdeg

                xcal = xdeg
                ycal = ydeg
                zcal = zdeg

                xrprint = xdegvec + xr$
                yrprint = ydegvec + yr$
                zrprint = zdegvec + zr$

                mr2print = mr2$
                zsecuprint = zsecu

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #pnumligne, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx = u$ - x$
                Vy = v$ - y$
                Vz = w$ - z$
                @Vx,@Vy,@Vz
                longvec=sqrt(Vx * Vx + Vy * Vy + Vz * Vz)

                xdegvec = (Vx / longvec) * dec_axe_tete
                ydegvec = (Vy / longvec) * dec_axe_tete
                zdegvec = (Vz / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC cal", axeCcalra


                xdeg = xdegvec + x$
                ydeg = ydegvec + y$
                zdeg = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1 = z$
                xdeg1 = xdeg * cos(axeccalra) - ydeg * sin(axeccalra)
                ydeg1 = xdeg * sin(axeccalra) + ydeg * cos(axeccalra)
                zdeg1 = zdeg

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1 * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1 * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2 = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg - xdeg3)
                y4 = y3 + (ydeg - ydeg3)
                z4 = z3 + (zdeg - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint = xdeg
                yprint = ydeg
                zprint = zdeg

                xcal = xdeg
                ycal = ydeg
                zcal = zdeg

                xrprint = xdegvec + drl_init_x$
                yrprint = ydegvec + drl_init_y$
                zrprint = zdegvec + drl_init_z$
                xrprintrap = xdegvec + sav_x_pmx
                yrprintrap = ydegvec + sav_y_pmx
                zrprintrap = zdegvec + sav_z_pmx

                xgarde = xdegvec + u$
                ygarde = ydegvec + v$
                zgarde = zdegvec + w$


                mr2print = mr2$
                zsecuprint = zsecu


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #pnumligne, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint = x$ * -1
                        yprint = y$
                        zprint = z$ + dec_axe_tete

                        iprint = i$ * -1
                        jprint = j$
                        kprint = k$ + dec_axe_tete

                        xrprint = xr$ * -1
                        yrprint = yr$
                        zrprint = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint = y$*cos(tourne) - x$*sin(tourne)
                        zprint = z$ + dec_axe_tete

                        iprint = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint = (j$*cos(tourne) - i$*sin(tourne))
                        kprint = k$ + dec_axe_tete

                        xrprint = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print = tox4$
                toy4print = toy4$
                toz4print = toz4$

                depthprint = depth$ + dec_axe_tete
                refhtprint = refht$ + dec_axe_tete
                inithtprint = initht$ + dec_axe_tete

                mr2print = mr2$
                zsecuprint = zsecu

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint = ss$
          tprint =  t$
          tete_rev = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint = x$
          yprint = y$
          zprint = z$

          xrprint = xr$
          yrprint = yr$
          zrprint = zr$

          iprint = i$
          jprint = j$
          kprint = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint = y$*sin(tourne) + x$*cos(tourne)
          yprint = y$*cos(tourne) - x$*sin(tourne)
          zprint = z$

          xrprint = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint = zr$

          iprint = j$*sin(tourne) + i$*cos(tourne)
          jprint = j$*cos(tourne) - i$*sin(tourne)
          kprint = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print = tox4$
          toy4print = toy4$
          toz4print = toz4$


          mr2print = mr2$
          zsecuprint = zsecu
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
			
			
#endregion
#endregion
#region   PG9
fmt  "cosangle" 11 cosangle
#region pg9_5x
pg9_5x       # calcul et ajout de code G9 en 5 axes continue
                long_p12 = sqrt((old_x_5x - x$)^2 + (old_y_5x - y$)^2 + (old_z_5x - z$)^2)
                long_p23 = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13 = sqrt((old_x_5x - nextx$)^2 + (old_y_5x - nexty$)^2 + (old_z_5x - nextz$)^2)
                if long_p12 <> 0 & long_p23 <> 0,
                [
                cosangle = (long_p23^2 + long_p12^2 - long_p13^2)/(2*long_p12*long_p23)
                !cosangle
                if cosangle <= 1 & cosangle >= -1,
                [
                ang5x = acos(cosangle)
                if mr7$ = 0, mr7$ = 45
                if ang5x <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
#endregion      
#region pg9
pg9           #ajout du code G9 en 2d
                long_p12 = sqrt((old_x - x$)^2 + (old_y - y$)^2)
                long_p23 = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13 = sqrt((old_x - nextx$)^2 + (old_y - nexty$)^2)

                if long_p12 <> 0 & long_p23 <> 0,
                [
                cosangle = (long_p23^2 + long_p12^2 - long_p13^2)/(2*long_p12*long_p23)
                !cosangle
                if cosangle <= 1 & cosangle >= -1,
                [
                ang5x = acos(cosangle)
                if mr7$ = 0, mr7$ = 45
                if ang5x <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
#endregion              
#endregion
#region   COMMMENTAIRES, PFR, PMODAL, COMPTEUR
#region PCOMMENT
pcomment$

           if gcode$ = 1005, strcom = strmsg + sentre_cote + scomm$ + sentre_cote + strparf
           if gcode$ = 1006, strcom = scomm$
           if gcode$ = 1007, strcom = strmsg + sentre_cote + scomm$ + sentre_cote + strparf
           if gcode$ = 1008, strcom = strmsg + sentre_cote + scomm$ + sentre_cote + strparf

#endregion   
#region strings multi comment
strcom : ""
sold_strcom : ""
strparo : "("
strparf : ")"
strparodeux : "(2"
strmsg : "MSG("
strcroch : ""
sentre_cote = no2asc(34)
sunderscore = "_"
#endregion         
#region PFR
fmt 2 old_fr
old_fr : 0
fmt 2 ecrit
ecrit : 0
pfr        # avance

            if gfr = 1, fr = fr$
            else, fr = fr$
			
            if fr$ >= 0, fr	
            if fr$ >= 0, avance = fr
			
#endregion         
#region PFR5AXE
pfr5axe  # avance en 3
           if fr5axe >= 0, *fr5axe
#endregion
#region PDMODALXYZ
pdmodalxyz   # demodalise temporairement xyz
        vieuxx = xprint
        vieuxy = yprint
        vieuxz = zprint
        @vieuxx, @vieuxy, @vieuxz
        xprint = 999999
        yprint = 999999
        zprint = 999999
        !xprint,!yprint,!zprint
        xprint = vieuxx
        yprint = vieuxy
        zprint = vieuxz
         @xprint,@yprint,@zprint
#endregion
#region PESSAICOMPTEUR
pessaicompteur
        difaxecpos = axeCpos - oldreel_axeCpos
        if difaxecpos <   -180,comptour= comptour + 360
        if difaxecpos > 180,  comptour = comptour - 360
        naxecpos = axeCpos + comptour
        @maxi_c,@mini_c
        if naxecpos < mini_c, comptour = comptour + 360
        if naxecpos > maxi_c, comptour = comptour - 360
        axeCpos = axeCpos + comptour
#endregion
prot0$
prot$
#endregion
#region   CALCUL PLANS
#region panul_plan_inc
panul_plan_inc   # annulation plan incliner							
#endregion
#region pafichecala
pafichecala   # routine pour trouver bonne angle a
                axeApos = atan2(new_m8,m9print)
                "voir axeC solution1=",*axeApos, e$
                axeApos = atan2(-new_m8,m9print)
                "voir axeC solution2=",*axeApos, e$
                axeApos = atan2(new_m8,-m9print)
                "voir axeC solution3=",*axeApos, e$
                axeApos = atan2(-new_m8,-m9print)
                "voir axeC solution4=",*axeApos, e$
                axeApos = atan2(m9print,new_m8)
                "voir axeC solution5=",*axeApos, e$
                axeApos = atan2(-m9print,new_m8)
                "voir axeC solution6=",*axeApos, e$
                axeApos = atan2(m9print,-new_m8)
                "voir axeC solution7=",*axeApos, e$
                axeApos = atan2(-m9print,-new_m8)
                "voir axeC solution8=",*axeApos, e$
#endregion  
#region pafichecalc
pafichecalc
                " voir solution de base = ",axeCpos, e$
                "-----------------------", e$
                axeCpos = atan2(m7print,m8print)
                "voir axeC solution1=",*axeCpos, e$
                axeCpos = atan2(m7print,-m8print)
                "voir axeC solution2=",*axeCpos, e$
                axeCpos = atan2(-m7print,m8print)
                "voir axeC solution3=",*axeCpos, e$
                axeCpos = atan2(-m7print,-m8print)
                "voir axeC solution4=",*axeCpos, e$
                axeCpos = atan2(m8print,m7print)
                "voir axeC solution5=",*axeCpos, e$
                axeCpos = atan2(-m8print,m7print)
                "voir axeC solution6=",*axeCpos, e$
                axeCpos = atan2(m8print,-m7print)
                "voir axeC solution7=",*axeCpos, e$
                axeCpos = atan2(-m8print,-m7print)
                "voir axeC solution8=",*axeCpos, e$
                "-----------------------", e$
#endregion
#region prot1
prot1     # Calcul des angles
				#"MATRICES", *m1$, *m2$, *m3$, *m4$, *m5$, *m6$, *m7$, *m8$, *m9$, e$
				if m1$ = 1 & m5$ = 1 & m9$ = 1, #tout va bien
				else, psortie3X
                @mini_a, @maxi_a, @mini_c, @maxi_c, @nbt, !calculduplan     # mise a jour des butees machine ecrit au debut pst 
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else,	[
						if type_axe = 1, axeCpos = atan2(m7print,-m8print)
						if type_axe = 2, axeCpos = atan2(m7print,-m8print)
						if type_axe = 3, axeCpos = atan2(m7print,-m8print)
						#if type_axe = 3, axeCpos = atan2(m7print,m9print)
						]
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos = 0
                ]
                reel_axeCpos = axeCpos
                new_m8 = m8print * cos(axeCpos) - m7print * sin(axeCpos)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
				
				if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos = atan2(-new_m8,-m9print) # pafichecala #      #calcul axe A avec renvoie d'angle
                else,
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos = 90 # pas d'angle sur a
                else, 	[
						if type_axe = 1, axeApos = atan2(m9print,new_m8)
						if type_axe = 2, axeApos = atan2(m9print,new_m8)
						if type_axe = 3, axeApos = atan2(m9print,new_m8)
						#if type_axe = 3, axeApos = (atan2(m8print,new_m9)) * -1
						]
                ]
               !axeApos
               if axeApos > 270, axeApos = axeApos - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos = axeApos - 90              #retire 90 deg car 0 pour cette machine = - 90
               
			   if type_axe = 1,	[
			   					axeCpos1 = axeCpos
			   					axeApos1 = axeApos
			   					]
			   if type_axe = 2,	[
			   					axeCpos1 = axeCpos - 90
			   					axeApos1 = axeApos
			   					if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos = 0, axeCpos1 = 0
								]
			   if type_axe = 3,	[
			   					axeCpos1 = atan2(m7print,m9print)
			   					new_m9 = m7print * sin(axeCpos1) + m9print * cos(axeCpos1)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
			  					axeApos1 = (atan2(-m8print,new_m9))
								if axeApos1 > 270, axeApos1 = axeApos1 - 360
								]

               if tete_rev_ang_droite = 1, invers = 0  # pas de choix sens A si tete a renvoi d'angle
               if tete_rev_ang_gauche = 1, invers = 1  # inversion de A si 2 em broche des tete a renvoi d'angle
               if invers = 1,
               [
                axeApos1 = axeApos1 *  -1
                if axeCpos1 >= 180, axeCpos1 = axeCpos1 - 180
                else, axeCpos1 = axeCpos1 + 180
               ]
               if mi1_C_base =  2, axeCpos1 = axeCpos1 - 360
               !axeApos, !new_m8, !new_m9, !axeCpos         #actualise les variable
               if axeApos > maxi_a | axeApos < mini_a, psortie10 # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1   
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 				
#endregion
pmiscparam$
#region pcalxyz3d_renvoi
pcalxyz3d_renvoi #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle
        if type_axe = 1, axeCpos = atan2(m7$,-m8$)
		if type_axe = 2, axeCpos = atan2(m7$,-m8$)
		if type_axe = 3, axeCpos = atan2(m7$,-m8$)
		#if type_axe = 3, axeCpos = atan2(m7$,m9$)
		
        new_m8 = m8$ * cos(axeCpos) - m7$ * sin(axeCpos)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        new_m9 = m7$ * sin(axeCpos) + m9$ * cos(axeCpos)
		
		if type_axe = 1, axeApos = atan2(m9$,new_m8)
		if type_axe = 2, axeApos = atan2(m9$,new_m8)
		if type_axe = 3, axeApos = atan2(m9$,new_m8)
		#if type_axe = 3, axeApos = (atan2(m8$,new_m9)) * -1
		
        if axeApos > 270, axeApos = axeApos - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos = axeApos - 90
        axeacal = (90 - axeApos)
        axeccal = axeCpos + 270
        #"voir les rapide", *xprint, *yprint, *zprint, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1 =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1 =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint = x1 + tox4print
        y3dprint = y2 + toy4print
        z3dprint = z1 + toz4print
        prot1   # remise a jour des angles 
#endregion
#region pcalxyz3d_normal
pcalxyz3d_normal #calcul de x y z dans la repere origine piece 3 D
        axeacal = (90 - axeApos)
        axeccal = axeCpos + 270
        y1 =   zrprint * cos(axeacal) - yrprint * sin(axeacal)
        z1 =   zrprint * sin(axeacal) + yrprint * cos(axeacal)
        x1 =  y1 * cos(axeccal) - xrprint * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint * cos(axeccal )
        x3dprint = x1 + tox4print
        y3dprint = y2 + toy4print
        z3dprint = z1 + toz4print
		
pcaldrilxyzsimu  # calcul des point dans le plan de l'axe outil
            #"voir xyz", *x$ ," ", *y$," ", *z$," ", *u$," ", *v$," ", *w$," ", *initht$, " ",*refht$," ", *depth$,   e$ 

            v_delta_x = x$ - u$
            v_delta_y = y$ - v$
            v_delta_z = z$ - w$
            v_delta_xyz = sqrt(v_delta_x^2 + v_delta_y^2 + v_delta_z^2)
            v_sindir_x = v_delta_x/v_delta_xyz
            v_sindir_y = v_delta_y/v_delta_xyz
            v_sindir_z = v_delta_z/v_delta_xyz

            v_abs_plus_x = u$#x$ - (initht$ * v_sindir_x)
            v_abs_plus_y = v$#y$ - (initht$ * v_sindir_y)
            v_abs_plus_z = w$#z$ - (initht$ * v_sindir_z)

            v_abs_plus_x_sec = x$ - ((depth$ * -1 + initht$) * v_sindir_x)
            v_abs_plus_y_sec = y$ - ((depth$ * -1 + initht$) * v_sindir_y)
            v_abs_plus_z_sec = z$ - ((depth$ * -1 + initht$) * v_sindir_z)
            #"voir v_abs_plus_x", " ",*v_abs_plus_x," ", *v_abs_plus_y," ", *v_abs_plus_z, e$
            v_abs_plus_x_sec_fin = x$ - ((depth$ * -1 + old_zinitht) * v_sindir_x)
            v_abs_plus_y_sec_fin = y$ - ((depth$ * -1 + old_zinitht) * v_sindir_y)
            v_abs_plus_z_sec_fin = z$ - ((depth$ * -1 + old_zinitht) * v_sindir_z)

            #axeccalsimu = axeC5xsimu
            #axeacalsimu = axeB5xsimu

            xprint = x$
            yprint = y$
            zprint = z$ # + ( depth$ * -1 + initht$ ) 		
#endregion
#region pcalxyz3d
pcalxyz3d #calcul de x y z dans la repere origine piece 3 d
        if tete_rev = 1, pcalxyz3d_renvoi
        else, pcalxyz3d_normal
#endregion
#region prot2
prot2      # Affichage des angles pour changement d'outil
            gcode$ = 0
            pcalxyz3d
			
			if type_pp = 1,	[
            				if mr2print < z3dprint & mr2print <>   -1,pnumligne, *sgcode, z3dprint, e$
            				if nextop$ <> 11, panul_plan_inc
							if opcode$ < 16,	[
												if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        										if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
												]
            				if nextop$ <> 11, pnumligne, *sgcode, *x3dprint,*y3dprint, e$
            				if axeCpos1 <> 0 | axeApos1 <> 0, plinc5a = 1 # Flag pour plan incline actif
            				else, plinc5a = 0
            				if zprint = 9999, zprint = zrprint
            				if nextop$ <> 11, pnumligne, *sgcode,xrprint,yrprint,zrprint, e$
							]
							
			if type_pp = 2,	[
            				if mr2print < z3dprint & mr2print <>   -1,sr, *z3dprint, paf, sgcode, *z3dprint, e$
            				if nextop$ <> 11, panul_plan_inc
							if opcode$ < 16,	[
												if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        										if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
												]
							
            				if nextop$ <> 11, sr, *xrprint,*yrprint, paf, *sgcode, *x3dprint,*y3dprint, e$
            				if axeCpos1 <> 0 | axeApos1 <> 0, plinc5a = 1 # Flag pour plan incline actif
            				else, plinc5a = 0
            				if zprint = 9999, zprint = zrprint
            				if nextop$ <> 11, sr, *xrprint,*yrprint,*zrprint, paf,*sgcode,*xrprint,*yrprint,*zrprint, e$
							]							
							
							
							
            old_tox4 = tox4print    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4 = toy4print
            old_toz4 = toz4print
            old_axeCpos = axeCpos
            old_axeApos = axeApos
            oldreel_axeCpos = reel_axeCpos
			old_x=xrprint
           old_y=yrprint
           old_z=zrprint
#endregion
#region prot3
prot3      # Affichage des angles pour changement d'outil nul
         gcode$ = 0
         panul_plan_inc
         if mr2print = 0, mr2print =zsecuprint
         pcalxyz3d
		 
		 if type_pp = 1,	[
         					if mr2print < z3dprint & mr2print <>   -1,pnumligne, *sgcode, z3dprint, e$
		 					if opcode$ < 16,	[
												if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
         										if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
												]
         					if mr2print <>   -1,pnumligne,*sgcode, *x3dprint,*y3dprint,e$
         					else, pnumligne, *sgcode, *x3dprint,*y3dprint,*z3dprint,e$
             				if opcode$ = 3, pnumligne, *sgcode, xrprint,yrprint,zrprint, e$
							]
							
		 if type_pp = 2,	[
         					if mr2print < z3dprint & mr2print <>   -1,sr, *z3dprint, paf, *sgcode, *z3dprint, e$
		 					if opcode$ < 16,	[
												if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
         										if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
												]
         					if mr2print <>   -1,sr, *xrprint,*yrprint,paf,sgcode, *x3dprint,*y3dprint,e$
             				else, sr, *xrprint,*yrprint,*zrprint,paf, sgcode, *x3dprint,*y3dprint,*z3dprint,e$
             				if opcode$ = 3, sr, *xrprint,*yrprint,*zrprint, paf, *sgcode, *xrprint,*yrprint,*zrprint, e$
							]							
           old_tox4 = tox4print    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4 = toy4print
           old_toz4 = toz4print
           old_axeCpos = axeCpos
           old_axeApos = axeApos
           oldreel_axeCpos = reel_axeCpos
		   old_x=xrprint
           old_y=yrprint
           old_z=zrprint
#endregion
#endregion
#region   PSOF PHEADER OPTIONS
#region premx
premx     # remonte pour transition entre usinage 5 axes continue
            
			gcode$ = 0
            panul_plan_inc
            if mr2print = 0, mr2print =zsecuprint
			pgestionduB_cloche
			if axeA_cloche <> 0 & mr2print = -1, psortie_cloche
			
			if type_pp = 1, 	[
								]
			if type_pp = 2, 	[	
								if garage <> 0,	[
								if change_cloche = 1, axeA_cloche = 1
								if mr2print <> -1 & axeA_cloche = 0, 	[
                                        									sr,
																			if garage = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			if garage = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			if garage = 3, sb_moins_quatre_vingt_dix, sczero
																			if garage = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			if garage = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			if garage = 6, sb_moins_quatre_vingt_dix, sczero
																			if garage = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			if garage = 8, sb_quatre_vingt_dix, sczero
																			if garage = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																			if garage = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			if garage = 11, sb_quatre_vingt_dix, sczero	
																			if garage = 12, sb_moins_quatre_vingt_dix, sczero
																			paf, *sgcode,sm, sxmach_garage, symach_garage, e$
																			garage = 0
																			]
														
								if mr2print <> -1 & axeA_cloche <> 0, [
                                        									sr, 
																			if garage = 1, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																			if garage = 2, sb_soixante, sc_moins_cent_quatre_vingt, string_B = sb_soixante
																			if garage = 3, sb_moins_soixante, sczero, string_B = sb_moins_soixante
																			if garage = 4, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																			if garage = 5, sb_soixante, sc_moins_cent_quatre_vingt, string_B = sb_soixante
																			if garage = 6, sb_moins_soixante, sczero, string_B = sb_moins_soixante
																			if garage = 7, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																			if garage = 8, sb_soixante, sczero, string_B = sb_soixante
																			if garage = 9, sb_moins_soixante, sc_cent_quatre_vingt, string_B = sb_moins_soixante
																			if garage = 10, sb_moins_soixante, sc_moins_cent_quatre_vingt, string_B = sb_moins_soixante
																			if garage = 11, sb_soixante, sczero, string_B = sb_soixante				
																			if garage = 12, sb_moins_soixante, sczero, string_B = sb_moins_soixante
																			paf, *sgcode,  string_B, sm, sxmach_garage, symach_garage, e$
																			garage = 0
																			]								
								]
			else,	[
            		if mr2print <> -1 & axeA_cloche = 0, 	sr, *xprint, *yprint, paf,*sgcode, ,e$								
					if mr2print <> -1 & axeA_cloche <> 0, sr, *xprint, *yprint, paf,*sgcode, e$                    						
					]
			
			
								]
			flagmr2 = 1
            axeCpos = 0
            axeApos = 0
            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
#endregion          
#region pcord
pcord      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"
#endregion
#region plubrifon_old
plubrifon_old
           lubrif = coolant$
		   if type_pp = 1, 	[
           					if lubrif = 1, pnumligne, "M7 ; Arrosage centre ",e$
           					if lubrif = 2, pnumligne, "M8 ; Arrosage ext", e$
           					if lubrif = 3, pnumligne, "M8 ; Arrosage ext", e$, pnumligne, "M7 ; Arrosage centre", e$
							]
		   if type_pp = 1, 	[
           					if lubrif = 1, sm,paf, "M7 ; Arrosage centre ",e$
           					if lubrif = 2, sm,paf, "M8 ; Arrosage ext", e$
           					if lubrif = 3, sm,paf, "M8 ; Arrosage ext", e$, sm,paf, "M7 ; Arrosage centre", e$
							]				
           if lubrif > 0, lub = 1
           else, lub = 0
#endregion
#region pcontrol_lubrif
pcontrol_lubrif  # 1er passage pour controler si pas de changement
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1
                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1
#endregion
#region plubrifon
plubrifon   # gestion des commande air eau aspi
                
				if type_pp = 1, 	[
				
				lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0
                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$
                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$
                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$
                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, "M7 ; Soufflage", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Contrele du Vide", e$

                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                serreur_visu = serreur200 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                erreur = 1
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
							]
				if type_pp = 2, 	[
				lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Soufflage", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                serreur_visu = serreur200 + no2str(numop)
                                "MW_OP_COMMENT", *serreur_visu, e$
                                result = mprint(serreur_visu)
                                erreur = 1
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
				]
#endregion
#region plubrifoff
plubrifoff
		   if type_pp = 1, 	[
           					if lub <> 0, pnumligne, "M9 ; ARRET", e$
							]
		   if type_pp = 2, 	[
           					if lub <> 0, sm, paf, "M9 ; ARRET", e$
							]				
           lub = 0
           lubrif = 0
#endregion
#region ptempo
ptempo      # tempo suivant mi10$
			if type_pp = 1,	[
							if mi10$ < -1, asp = 0, pnumligne, sasp, e$
            				tempo = mi10$ / 10
            				pnumligne,tempo,e$
							]
			if type_pp = 2,	[
							if mi10$ < -1, asp = 0, sm, paf, sasp, e$
            				tempo = mi10$ / 10
            				sm,paf, tempo,e$
							]							
#endregion
#region parretprog
parretprog    # arret machine programmer avant op quand mi10 = 1
        if type_pp = 1,	pnumligne,"M5 ;(ARRET BROCHE)",e$
		if type_pp = 2,sm, paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc
        plubrifoff
		if type_pp = 1,	[ 
						pgarage
						pnumligne, "REPLI ; CYCLE DE DEGAGEMENT OUTIL", e$
						]					
		if type_pp = 2,	[
						pgarage
						sm, paf, "REPLI ; CYCLE DE DEGAGEMENT OUTIL", e$
						]			
		if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            q10
			if type_pp = 1, pnumligne,"MSG(",34, smesage,34,")",e$
			if type_pp = 2, sm, paf, "MSG(",34, smesage,34,")",e$
            ]
        if type_pp = 1,	[
						pcantext
        				pnumligne, "M0", e$
            			pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
						pnumligne, *spdlon, ssprint,e$			
						]
		if type_pp = 2,	[
        				sm, paf, "M0", e$
            			sm, paf, "D1 ; PRISE DE CORRECTEUR", e$
						sm, paf, *spdlon, ssprint,e$											
						]				    
#endregion
#region parretprog2
parretprog2    # arret machine programmer avant op quand mi10 = 1 et changement outil
        if type_pp = 1,	pnumligne,"M5 ;(ARRET BROCHE)",e$
		if type_pp = 2,sm, paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc
        plubrifoff
		if type_pp = 1,	[
        				if mi10$ = -1, asp = 0, pnumligne, sasp, e$ 
						pgarage
						pnumligne, "REPLI ; CYCLE DE DEGAGEMENT OUTIL", e$
						]
		if type_pp = 2,	[
        				if mi10$ = -1, asp = 0, sm, paf, sasp, e$
						pgarage
						sm, paf, "REPLI ; CYCLE DE DEGAGEMENT OUTIL", e$
						]
		if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            q10
			if type_pp = 1, pnumligne,"MSG(",34, smesage,34,")",e$
			if type_pp = 2, sm, paf, "MSG(",34, smesage,34,")",e$
            ]
        if type_pp = 1,	[
						pcantext
        				pnumligne, "M0", e$  
						]
		if type_pp = 2,	[
        				sm, paf, "M0", e$  			
						]
#endregion
#region pprep

fmt  "" 2 move_ang$
fmt  "" 12 prvaxea
fmt  "" 7 axeApos1
fmt  "" 12 axeA
fmt  "" 12 axeA2
fmt  "" 12 axeA_cloche
fmt  "" 12 axeA_cloche_moins
fmt  "" 12 axeA_cloche_plus
fmt  "" 7 axeApos1_cloche
fmt  "" 1 axeccalra
fmt  "" 7 axeCpos1
fmt  "" 12 prvaxec
fmt  "" 12 axeC
fmt  "" 12 axeC2
fmt  "" 7 axeCpos1_cloche
spath : ""
spathnc_original : ""
sbzero : ""
sczero : ""
sb_quatre_vingt_dix : ""
sb_moins_quatre_vingt_dix : ""
sb_soixante : ""
sb_moins_soixante : ""
sc_moins_quatre_vingt_dix : ""
sc_moins_cent_quatre_vingt : ""
sc_cent_quatre_vingt : ""
sctete : ""
fmt 1 type_pp
type_pp : 0
sext : "CL"         # extention pour le programme de simulation 
sblk : "BLK"
spath_local1 : "c:\users\blane\appdata\local\temp\"
spath_local2 : "c:\users\aserapio\appdata\local\te"
spath_local3 : "c:\users\rvrosier\appdata\local\te"
spath_local4 : "c:\users\jocelyn\appdata\local\tem"
spath_local5 : "c:\users\morgan\appdata\local\temp"
pprep$
        #err_file$ = 4
		spathnc_original = spathnc$
		spath = brksps(35,spathnc_original)
		if (spathnc_original = spath_local1) | (spathnc_original = spath_local2) | (spathnc_original = spath_local3) | (spathnc_original = spath_local4) | (spathnc_original = spath_local5), type_pp = 2
		else, type_pp = 1

    	if type_pp = 1, [
						rotaxtyp$ = 3
						calculduplan = 1
						]
		if type_pp = 2,	[
						rotaxtyp$ = 4
						sextnc$ = sext
						result = nwadrs(sblk, n$)
						result = nwadrs(svide, tox4$)
						result = nwadrs(svide, toy4$)
						result = nwadrs(svide, toz4$)
						result = newfs (19,	tox4$)
						result = newfs (19,	toy4$)
						result = newfs (19,	toz4$)
						omitseq$ = 0
        				breakarcs$ = 1
						calculduplan = 0
						]
		
        seqno$ = 5
        seqinc$ = 5
        n$ = 5
        clearaux$
        clearext$
        clearlcc$
        newaux$
		if type_axe = 1,	[
							result = nwadrs(slettreA, move_ang$)
							result = nwadrs(slettreA, prvaxea)
							result = nwadrs(slettreA, axeApos1)
							result = nwadrs(slettreA, axeA)
							result = nwadrs(slettreA, axeA_cloche)
							result = nwadrs(slettreA, axeA_cloche_moins)
							result = nwadrs(slettreA, axeA_cloche_plus)
							result = nwadrs(slettreA, axeApos1_cloche)
							result = nwadrs(slettreC, axeccalra)
							result = nwadrs(slettreC, axeCpos1)
							result = nwadrs(slettreC, prvaxec)
							result = nwadrs(slettreC, axeC)
							result = nwadrs(slettreC, axeCpos1_cloche)
							sbzero = ""
							sczero = ""
							sb_quatre_vingt_dix = ""
							sb_moins_quatre_vingt_dix = ""
							sb_soixante = ""
							sb_moins_soixante = ""
							sc_moins_quatre_vingt_dix = ""
							sc_moins_cent_quatre_vingt = ""
							sc_cent_quatre_vingt = ""
							sctete = ""
							]
								mini_a = -120.001
								maxi_a = 120.001
								mini_c = -185.001
								maxi_c = 185.001
								mini_c_sans_cloche = -271.001
								maxi_c_sans_cloche = 271.001
								mini_c_avec_cloche = -185.001
								maxi_c_avec_cloche = 185.001								
#endregion
#region ppost
ppost$
#endregion
#region pheader
spaspayé : "Contact F.i.cam for this problem at +33 2 37 26 28 10."
sclefpasbonne : "Your Mastercam Key is not compatible with this Post-Processor."
pheader$
        
		
		if progno$ = 0, progno$ = 8999
        !ppr
        @gfr
        if type_pp = 1,	[
		q3
		pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        pnumligne,";(",34,"MECANUMERIC 3 AXES",34,")",e$
        pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$
						]				
		if type_pp = 2,	[
						"MW_CL_VERSION 1.2", e$
                    	" ", e$
                    	if type_axe = 1, "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>A<EOC>C<EOC>",34,e$
						if type_axe = 2, "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>B<EOC>C<EOC>",34,e$
						if type_axe = 3, "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>A<EOC>B<EOC>",34,e$
                    	spaces$ = 0
                    	"MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                    	spaces$ = 1
                    	old_corg_x = tox4$, old_corg_y = toy4$, old_corg_z = toz4$
						if mi5 = 1,	[
									sxmach = sxmach_Z1
									symach = symach_Z1
									szmach = szmach_Z1
									]
							else,	[
									sxmach = sxmach_Z2
									symach = symach_Z2
									szmach = szmach_Z2
									]				
						sm, sxmach, symach, szmach, sbzero, sczero,pafcom, spaces$ = 0,*snamenc$,"                                                                           ",e$, spaces$ = 1 
						sm, paf,";(",34,"STELIA COMPOSITES",34,")",e$
        				sm, paf,";(",34,"MECANUMERIC 3 AXES",34,")",e$
        				sm, paf,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        				sm, paf,";(",34,"PROG PAR ",snomprog,34,")",e$
						]
#endregion
#region pcycle832
pcycle832   # gestion du cycle 832 lissage 
		if type_pp = 1,	[
        if (mi8 > 0) & (mi8 <> 9) & mi8 <> oldmi8,
                    [
                    if mi8 = 1, pnumligne, scycle832_a, e$
                    if mi8 = 2, pnumligne, scycle832_b, e$
                    if mi8 = 3, pnumligne, scycle832_c, e$
                    if mi8 = 4, pnumligne, scycle832_d, e$
                    if mi8 = 5, pnumligne, scycle832_e, e$
                    if mi8 = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8 <= 0) | (mi8 = 9)) & mi8 <> oldmi8, pnumligne, scycle832_anul, e$
						]
        oldmi8 = mi8
		
#endregion
#region ptestrenvoi_angle
fmt "outil=" 2 outil_complet
fmt "Num RA=" 4 num_ra
fmt "Num outil=" 4 num_outil
fmt 2 userenvoie
userenvoie : 0
ptestrenvoi_angle  # voir si on est avec outil a renvoie d'angle
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2 = t$
                    if userenvoie = 1,	[
					if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
					
                    if num_ra = 1,
                                            [
                                            if type_pp = 1, pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2,"demande",34,")",e$
                                            if type_pp = 2, sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2,"demandé",34,")",e$
											tete_rev_ang_droite = 1
                                            if mi4 > 0,psortie3
                                            if coolant$ > 0, psortie4
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            if type_pp = 1, pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2,"demande",34,")",e$
                                            if type_pp = 2, sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2,"demandé",34,")",e$
											tete_rev_ang_gauche = 1
                                            if mi4 > 0,psortie3
                                            if coolant$ > 0, psortie4
                                            ]
                    else, tete_rev_ang_gauche = 0
										]
#endregion
#region ptestcloche
ptestcloche # test si num de cloche possible
                if mi4 <> 1 & mi4 <> 2 & mi4 <> 3 & mi4 <> 4 & mi4 <> 11 & mi4 <> 12 & mi4 <> 13 & mi4 <> 14 & mi4 <> 21 & mi4 <> 22 & mi4 <> 23 & mi4 <> 24 & mi4 > 0   , mi4 = 0
#endregion
#region ptlngno
ptlngno      # gestion des cloches
	if type_pp = 1,	[
					if mi4 = 9 | strtool$ = spalpeur, asp = 0, pnumligne, sasp, e$
          			else, asp = 1, pnumligne, sasp, e$
					]	
	if type_pp = 2,	[
          			if mi4 = 9 | strtool$ = spalpeur, asp = 0, sm, paf, sasp, e$
          			else, asp = 1, sm, paf, sasp, e$
					]					
#endregion
#region ptlngno2
fmt 1 mr4
mr4 : 0
ptlngno2   # gestion cloche quand pas de nouvel outil
			if type_pp = 1,	[
							if (mi4 = 0) | (mi4 = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
							if mi4$ > 0,	[
											if strtool$ = spalpeur | (mi4 = 9), pat = 0, pnumligne, spat, e$
											else,	[
													pat = 1
													mr4 = mr4$
													pnumligne, "COR_PATIN=", *mr4, e$
													pnumligne, spat, e$
													]
											]
            				else, pat = 0, pnumligne, spat, e$
							]
			if type_pp = 2,	[
							if (mi4 = 0) | (mi4 = 9), sm,paf, "MSG(",34,"PAS DE CLOCHE",34,")",e$
							if mi4$ > 0,	[
											if strtool$ = spalpeur | (mi4 = 9), pat = 0, sm, paf, spat, e$
											else,	[
													pat = 1
													mr4 = mr4$
													sm, paf, "COR_PATIN=", *mr4, e$
													sm, paf, spat, e$
													]
											]
            				else, pat = 0, sm, paf, spat, e$
							]				
#endregion
#region psof0
psof0$
            psof$
#endregion
#region pstring
fmt "valeur de string" 1 valstring
pstring    # valeur de la string
			
             spaces$=1
			 if type_pp = 1,	[
			 if valstring <> 0, pnumligne, "M0", e$
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10,34,")", e$
			 					]
             #spaces$ = 0               
#endregion
#region pcantext
pcantext   # ecriture de texte avant 
             if cantext$ > 0,
             [
			 
             if cant_val1$ > 0, valstring = cant_val1$, pstring
             if cant_val2$ > 0, valstring = cant_val2$, pstring
             if cant_val3$ > 0, valstring = cant_val3$, pstring
             if cant_val4$ > 0, valstring = cant_val4$, pstring
             if cant_val5$ > 0, valstring = cant_val5$, pstring
             if cant_val6$ > 0, valstring = cant_val6$, pstring
             if cant_val7$ > 0, valstring = cant_val7$, pstring
             if cant_val8$ > 0, valstring = cant_val8$, pstring
             if cant_val9$ > 0, valstring = cant_val9$, pstring
             if cant_val10$ > 0, valstring = cant_val10$, pstring
             ]
#endregion
#region pappeloutil
smoins : "-"
stringdebut : ""
stringfin : ""
fmt "Nb=" 4 long_string
fmt "" 15 var_1
fmt "" 15 var_2
fmt "" 15 var_3
fmt "" 15 var_4
fmt "" 15 var_5
fmt "" 15 var_6
fmt "" 15 var_7
var_1 : 0
var_2 : 0
var_3 : 0
var_4 : 0
var_5 : 0
var_6 : 0
var_7 : 0
fmt "" 2 longeur_outil
fmt "" 2 rayon_outil
fmt "" 2 dec_rayon
fmt "" 2 rayon_coin_outil
fmt "Nb" 4 nb_digit_outil
fmt "" 3 vartool_1
fmt "" 3 vartool_2
vartool_1 : 0
vartool_2 : 0
svartool_1 : ""
fmt "R1=" 4 paramR1
fmt "R2=" 4 paramR2
fmt "R3=" 4 paramR3
fmt "R5=" 4 paramR5

pappeloutil
	if type_pp = 1,	[
            if strtool$ = spalpeur,
            [
            spaces$ = 1
			pat = 0, pnumligne, spat, e$
			pnumligne, *tprint, e$
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint = 0
            if opcode$ <> 3, psortie7
            ]
            else,
            [
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
			spaces$ = 1
			pat = 0, pnumligne, spat, e$
			pnumligne, *tprint, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
			spaces$ = 0
																
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
						LONG_MAX = var_2 + var_3
						LONG_MIN = var_2 - var_3
						if var_1 <> 0,pnumligne, "MESURE_OUTIL ; MESURE D'OUTIL", e$
                    ]
            pnumligne, *LONG_MIN, e$
			pnumligne, *LONG_MAX, e$
			pnumligne, "TEST_LONG", e$
			]
					]

	if type_pp = 2,	[
            if strtool$ = spalpeur,
            [
			spaces$ = 1 
			pat = 0, sm, paf, spat, e$
            sm, paf, *tprint, e$
            sm, paf, "MSG(",34, t$, strtool$,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint = 0
            if opcode$ <> 3, psortie7
            ]
            else,
            [
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
			spaces$ = 1
			pat = 0, sm, paf, spat, e$
			sm, paf, *tprint, e$
            sm, paf, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    	[
                     	rayon_outil = tldia$/2
                     	longeur_outil = paramT3 + paramT7
                     	var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain
						LONG_MAX = var_2 + var_3
						LONG_MIN = var_2 - var_3
						if var_1 <> 0, sm, paf, "MESURE_OUTIL ; MESURE D'OUTIL", e$
                    	]
            sm, paf, *LONG_MIN, e$
			sm, paf, *LONG_MAX, e$
			sm, paf, "TEST_LONG", e$
			]
					]
					
#endregion
#region sous programme
psub_call_s$
psub_st_s$
psub_end_s$
psub_call_mm$
psub_call_m$
psub_end_m_r$
psub_st_m$
#endregion
#region ptrans_option
fmt 17 transform
transform : -1

ptrans_option   # dev pour gerer les transformations avec les options 
                    mi1_C_base = 0
                    mi2_A_base = 0
                    if op_id$ <> xform_op_id$,
                    [
                    if transform = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp
					transform = 1
                    if sub_trnstyp$ = 3, mi1_C_base = mi1_trans, mi2_A_base = mi2_trans
                    if sub_trnstyp$ = 0, mi1_C_base = mi1_mirro, mi2_A_base = mi2_mirro
                    if sub_trnstyp$ = 1, mi1_C_base = mi1_rotat, mi2_A_base = mi2_rotat
                    ]
                    else,
                    [
					transform = 0
                    mi1_C_base = mi1_trans
                    mi2_A_base = mi2_trans
                    ]
                    old_sub_trnstyp = sub_trnstyp$
                    old_sub_totl_no = sub_totl_no$
#endregion
fmt  "G" 4 origine      # origine d'usinage G54 a G59 pour NC
fmt  "G54.1P"  4 originebis # origine d'usinage G60 a G9999 pour NC
poriusi
		if workofs$ >=0,[                  # ne pas afficher de G54 si le decalage < 0     
    					if workofs$ = 0, workofs$ = 54
						origine = workofs$                 # origine de  54 a 59
        				originebis = origine - 59               # origine > 59
						*origine
      					]
poriusinul	
    	if workofs$ >=0,[                  # ne pas afficher de G54 si le decalage < 0     
    					if workofs$ = 0, workofs$ = 54
						origine = workofs$                 # origine de  54 a 59
    					originebis = origine - 59               # origine > 59
						*origine
            			]	   
#region psof
fmt 2 numpp
fmt  "" 21 vt
fmt "compensation_rayon" 2 compensation_rayon
compensation_rayon : -1
fmt 2 debut_prog
fmt 2 debut_prog_nc
debut_prog : 0
debut_prog_nc : 1
fmt  "X,ORI_X" 13 mr8$
fmt  "Y,ORI_Y" 13 mr9$
fmt  "Z,ORI_Z" 13 mr10$
fmt 2 flag_coiffe
flag_coiffe : 0
psof$
			flag_coiffe = 1
			flag_outil = 1
			if type_pp = 2,	[
							if opcode$ = 4, linarc$ = 1
							else, linarc$ = 0
							]
			vt = t$
			if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")),	[
																							if (opcode$ > 16) & (opcode$ < 19),	[
																																psortieplan5X
																																]
																							]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8

			garage = 0
			flagmr2 = 0
			old_opcode_cloche = opcode$ 
			flag_changement_outil = 1
			flag_cloche = 0
			flag_chargement_cloche = 0
			flag_cloche = 0
			old_tool = tlngno$
			if (mi4 >= 0) & (mi4 <> 9), mini_c = mini_c_avec_cloche, maxi_c = maxi_c_avec_cloche
            else, mini_c = mini_c_sans_cloche, maxi_c = maxi_c_sans_cloche
            pnumop
            ptrans_option
            pcantext
            if oscilliation = 1 & mi7$ <> 0, psortie12
            if opcode$ = 16, drill5axes = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint
            #ptestcloche
          gcode$ = 0
          spaces$ = 0
          mr8 = DEC_X + mr8$
          mr9 = DEC_Y + mr9$
          mr10 = DEC_Z + mr10$
		  if type_pp = 1,	[
          					pnumligne, " INIT_DEBUT ; MACRO DEBUT DE PROG", e$
							pnumligne, " $P_UIFR[1]=CTRANS(",mr8$,","mr9$,","mr10$,")",e$
          					pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          					pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
          					spaces$ = 1
          					prvop_id = op_id$
          					pnumligne, "M5 ; ARRET BROCHE",e$
							]
		  if type_pp = 2,	[	
							spaces$ = 1
							sm, paf, " INIT_DEBUT ; MACRO DEBUT DE PROG", e$
							sm, paf, " $P_UIFR[1]=CTRANS(",mr8$,","mr9$,","mr10$,")",e$
          					sm, paf, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          					sm, paf, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
          					prvop_id = op_id$
          					sm,paf, "M5 ; ARRET BROCHE",e$
							]							
          tlngno$ = 1
          ptestrenvoi_angle
		  if type_pp = 2, pdebut_chagement_outil
          spaces$ = 0
          pappeloutil
          if mr1$ > 0,	[
		  				if type_pp = 1, pnumligne, mr1$, e$
						if type_pp = 2, sm,paf, mr1$, e$
						]
          ptlngno
          spaces$ = 1
		  if type_pp = 1,	pnumligne, *spdlon, ssprint,e$
		  if type_pp = 2,	sm,paf, *spdlon, ssprint,e$		  
          old_ss = ssprint
          if type_pp = 1, plubrifon
          numpp = 3
          comment$
          if type_pp = 1, pnumligne, strcom, e$
		  if type_pp = 2, "MW_OP_COMMENT", *strcom, e$
          if mi2_A_base = 0, invers = 0
          if mi2_A_base = 2, invers = 1
            pcycle832
			if type_pp = 1,	[
							pnumligne, poriusi," ; SELECTION NUMERO ORIGINE", e$
            				pnumligne, "D1 ; PRISE DE CORRECTEUR", e$			
							]
			if type_pp = 2,	[
							sm,paf, poriusi," ; SELECTION NUMERO ORIGINE", e$
            				sm,paf, "D1 ; PRISE DE CORRECTEUR", e$			
							]							
            if opcode$ = 16, ex$
            prot1
            pprint
            if mr2print = 0, mr2print =zsecuprint
            prvmr2 = mr2print
            pcalxyz3d								
           prot2
           old_x=xrprint
           old_y=yrprint
           old_z=zrprint
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation = mi4
       frbase = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop = 1
       retplangarde = 0
	   old_outil_simu = t$
	   
#endregion
#region plansecu2
plansecu2    # retour au plan de retournement 
       pcalxyz3d
#endregion
#region plansecu
plansecu    # voir si pas deja passer dans premx
		if type_pp = 1,	[
        pcalxyz3d
        if prvop_id <> op_id$,
        [
            panul_plan_inc
			pgestionduB_cloche
			if axeA_cloche <> 0 & mr2print = -1, psortie_cloche
			
            if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche = 0 , 	[
																		
																			]
																			
			if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche <> 0 ,	[
																		
																			]
            if opcode$ = 16 & mr2print <> -1 & axeA_cloche = 0, pnumligne, *sgcode, zrprint, e$
			if opcode$ = 16 & mr2print <> -1 & axeA_cloche <> 0, pnumligne, *sgcode, zrprint, e$
					
            if nextop$ <> 11,
                         [
						 if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        				 if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
                         if mr2print = -1,   pnumligne, *sgcode, *x3dprint, *y3dprint, *z3dprint,e$
                         else, pnumligne, *sgcode, *x3dprint, *y3dprint,e$
                         ]
           else,
                        [
                         if mr2print = -1,  pnumligne, *sgcode, *x3dprint,*y3dprint,*z3dprint, e$
                         else,  pnumligne, *sgcode, *x3dprint,*y3dprint,e$
                        ]
        ]
				]
				
				
		if type_pp = 2,	[
		pcalxyz3d
        if prvop_id <> op_id$,
        [
            panul_plan_inc
			pgestionduB_cloche
			if axeA_cloche <> 0 & mr2print = -1, psortie_cloche

			if garage <> 0,	[
								if change_cloche = 1, axeA_cloche = 1
			            		if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche = 0 , 	[
																								if flagmr2 = 2,	[
																													sr,
																													if garage = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 3, sb_moins_quatre_vingt_dix, sczero
																													if garage = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 6, sb_moins_quatre_vingt_dix, sczero
																													if garage = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 8, sb_quatre_vingt_dix, sczero
																													if garage = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 11, sb_quatre_vingt_dix, sczero	
																													if garage = 12, sb_moins_quatre_vingt_dix, sczero																											
																													paf, sgcode, sm, sxmach_garage, symach_garage, e$
																													garage = 0
																													]

																											else,	[
																													sr, 
																													if garage = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 3, sb_moins_quatre_vingt_dix, sczero
																													if garage = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 6, sb_moins_quatre_vingt_dix, sczero
																													if garage = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 8, sb_quatre_vingt_dix, sczero
																													if garage = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 11, sb_quatre_vingt_dix, sczero	
																													if garage = 12, sb_moins_quatre_vingt_dix, sczero
																													paf, sgcode, sm, sxmach_garage, symach_garage, e$
																													garage = 0
																													
																													]
																								]
																								
								if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche <> 0 ,	[
																								if flagmr2 = 2,	[
																													sr,
																													if garage = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 3, sb_moins_quatre_vingt_dix, sczero
																													if garage = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 6, sb_moins_quatre_vingt_dix, sczero
																													if garage = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 8, sb_quatre_vingt_dix, sczero
																													if garage = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													if garage = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													if garage = 11, sb_quatre_vingt_dix, sczero	
																													if garage = 12, sb_moins_quatre_vingt_dix, sczero
																													paf, sgcode, sm, sxmach_garage, symach_garage, e$
																													garage = 0
																													]
																											else,	[
																													sr, 
																													if garage = 1, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																													if garage = 2, sb_soixante, sc_moins_cent_quatre_vingt, string_B = sb_soixante
																													if garage = 3, sb_moins_soixante, sczero, string_B = sb_moins_soixante
																													if garage = 4, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																													if garage = 5, sb_soixante, sc_moins_cent_quatre_vingt, string_B = sb_soixante
																													if garage = 6, sb_moins_soixante, sczero, string_B = sb_moins_soixante
																													if garage = 7, sb_soixante, sc_cent_quatre_vingt, string_B = sb_soixante
																													if garage = 8, sb_soixante, sczero, string_B = sb_soixante
																													if garage = 9, sb_moins_soixante, sc_cent_quatre_vingt, string_B = sb_moins_soixante
																													if garage = 10, sb_moins_soixante, sc_moins_cent_quatre_vingt, string_B = sb_moins_soixante
																													if garage = 11, sb_soixante, sczero, string_B = sb_soixante				
																													if garage = 12, sb_moins_soixante, sczero, string_B = sb_moins_soixante	
																													paf, sgcode, string_B, sm, sxmach_garage, symach_garage, e$
																													garage = 0
																													
																													]
																								]			
								]
		
						else,	[				
			            		if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche = 0 , 	[
																							
																								]
																								
								if  opcode$ <> 16  & mr2print <> -1 & axeA_cloche <> 0 ,	[
																							
																								]
								]						
																			
           	if opcode$ = 16 & mr2print <> -1 & axeA_cloche = 0, sr, *zrprint, paf, sgcode,*zrprint,e$
			if opcode$ = 16 & mr2print <> -1 & axeA_cloche <> 0, sr, *zrprint, paf, sgcode,*zrprint, e$		
			
			if nextop$ <> 11,
                         [
						 if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        				 if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
                         if mr2print = -1,   [
						 						if opcode$ <> 3, sr, *xprint, *yprint, *zprint, paf, sgcode, *x3dprint, *y3dprint, *z3dprint, e$
												]
                         else,  [
                                sr, *xrprint, *yrprint, paf, sgcode, *x3dprint, *y3dprint, e$
                                if opcode$ = 3 & m1$ = 1 & m5$ = 1 & m9$ = 1, sr, *xrprint, *yrprint, paf, sgcode, *x3dprint, *y3dprint, e$
                                ]
                         ]
           else,
                        [
                         if mr2print = -1,  sr, *x3dprint,*y3dprint,*z3dprint, paf, sgcode, *x3dprint,*y3dprint,*z3dprint, e$
                         else,  sr, *x3dprint,*y3dprint, paf, sgcode, *x3dprint,*y3dprint,e$
                        ]
        ]
		]
		old_x=xrprint
            old_y=yrprint
            old_z=zrprint
#endregion      
#endregion
#region   PTLCHG PEOF
#region ptlchg0
ptlchg0$
			if op_id$ <> prvop_id, flag_coiffe = 1
			if mi4$ <= 0, ptlngno2, flag_coiffe = 0
			flag_outil = 0
			if type_pp = 2,	[
							if opcode$ = 4, linarc$ = 1
							else, linarc$ = 0
							]
			if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")),	[
																							if (opcode$ > 16) & (opcode$ < 19),	[
																																psortieplan5X
																																]
																							]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8

			garage = 0
			flag_changement_outil = 0
            flag_cloche = 0
            premperc = 1
				
	if type_pp = 2,	[
            if op_id$ <> prvop_id,
                                    [
                                    sf, e$
                                    spaces$ = 0
                                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                                    spaces$ = 1
                                    @tox4$,@toy4$,@toz4$, @old_corg_x, @old_corg_y,@old_corg_z
                                    if (tox4$ = old_corg_x) & (toy4$ = old_corg_y)  & (toz4$ = old_corg_z),
                                                                        [
                                                                        xprintcorg = xprint
                                                                        yprintcorg = yprint
                                                                        zprintcorg = zprint
                                                                        ]
                                                                        else,
                                                                        [
                                                                        dif_old_corg_x = old_corg_x - tox4$
																		dif_old_corg_y = old_corg_y - toy4$
																		dif_old_corg_z = old_corg_z - toz4$
                                                                        xprintcorg = xprint + dif_old_corg_x
                                                                        yprintcorg = yprint + dif_old_corg_y
                                                                        zprintcorg = zprint + dif_old_corg_z
                                                                        ]
												"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
                                                if old_opcode > 16,	[
																		sr, *xprintcorg, *yprintcorg, *zprintcorg, paf, *xprint, *yprint, *zprint, e$
                                                						old_axeC_simu = axeC
																		old_axeA_simu = axeA
																		old_xprint_simu = xprintcorg
																		old_yprint_simu = yprintcorg
																		old_zprint_simu = zprintcorg
																		]
																else,	[
																		sr, *xprintcorg, *yprintcorg, *zprintcorg,paf, *xprint, *yprint, *zprint, e$
                                                						old_axeC_simu = axeCpos1
																		old_axeA_simu = axeApos1
																		old_xprint_simu = xprintcorg
																		old_yprint_simu = yprintcorg
																		old_zprint_simu = zprintcorg
																		]
												old_opcode = 0
												old_corg_x = tox4$, old_corg_y = toy4$, old_corg_z = toz4$
                                                ]
					]
				pprep_cloche
				
                pnumop
                if oscilliation = 1 & mi7$ <> 0, psortie12
                ptrans_option 
               cycle_heli_spiral = 0
                if op_id$ <> prvop_id & mi10$ <> 1 & mi10$ <> -1, pcantext

            if opcode$ = 16, drill5axes = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint
            #ptestcloche

        if operation = 11,[
            gfr = 1

            #if type_pp = 1, pnumligne,*sgfr,*fretrait,e$
			#if type_pp = 2, sm, paf, *sgfr,*fretrait,e$
        ]
        pdmodalxyz
        if mr2print = 0, mr2print =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id,
        [
         pcontrol_lubrif
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes = 1 | opcode$ = 3, panul_plan_inc, pgestionduB_cloche
		if ((drill5axes = 1)|(opcode$ = 3)) & axeA_cloche <> 0 & mr2print = -1, psortie_cloche
        if ((drill5axes = 1)|(opcode$ = 3)) & mr2print <> -1,	[				
																flagmr2 = 1
																]
        drill5axes = 0
            typcycle = 0
            if op_id$ <> prvop_id,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog
										]
            if op_id$ <> prvop_id & ((mi10$ > 1) | (mi10$ < -1)), ptempo

        prvmr2 = mr2print
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base = 0, invers = 0
        if mi2_A_base = 2, invers = 1
        if operation = 11 & nextop$ = 11 & op_id$ <> prvop_id, premx
		
		if op_id$ <> prvop_id, ptlngno 
								
        if (oldstation = mi4) & (ssprint <> old_ss),	[
														if type_pp = 1,	pnumligne, *spdlon, ssprint,e$
		  												if type_pp = 2,	sm,paf, *spdlon, ssprint,e$
		  												]
        old_ss = ssprint
        oldstation = mi4
        if op_id$ <> prvop_id, plubrifon
        pcycle832
            if opcode$ = 16,
            [
                 drill5axes = 1
                 panul_plan_inc
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,	[
								comment$
								if type_pp = 1,	[
												if op_id$ <> prvop_id, pnumligne, strcom, e$
												]
								if type_pp = 2,	[
												if sold_strcom = strcom, strcom = svide 
            									"MW_OP_COMMENT", *strcom, e$
												sold_strcom = strcom
												]				
								old_opcode_cloche = 16, ex$
								]
            prot1
            pprint        
            !old_axeCpos, !axeCpos, !old_axeApos, !axeApos, !old_tox4, !old_toy4, !old_toz4, !tox4print, !toy4print, !toz4print
            if drill5axes <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos <> axeCpos) | (old_axeApos <> axeApos) | (old_tox4 <> tox4print) | (old_toy4 <> toy4print) | (old_toz4 <> toz4print), prot3,e$
                 else,
                [
                if operation <> 11 | nextop$ <> 11, plansecu
                ]
            ]
            if operation <> 11 & nextop$ = 11, operation = 1
            else, operation = 0

        if prvop_id <> op_id$, changop = 1
        else, changop = 0
		comment$
		if type_pp = 1,	[
            			if op_id$ <> prvop_id, pnumligne, strcom, e$
						]
		if type_pp = 2,	[
            			if sold_strcom = strcom, strcom = svide 
            			"MW_OP_COMMENT", *strcom, e$
						sold_strcom = strcom
						]
			prvop_id = op_id$			
            numpp = 3
            
        frbase = fr$
        debut = 0
        retplangarde = 0
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
				old_opcode_cloche = opcode$
				old_opcode = opcode$
#endregion
#region ptlchg
ptlchg$
			flag_coiffe = 1
			flag_outil = 1
			if type_pp = 2,	[
							if opcode$ = 4, linarc$ = 1
							else, linarc$ = 0
							]
			vt = t$
			if ((scsplane <> "Dessus") | (stlplane <> "Dessus") | (swcsplane <> "Dessus")),	[
																							if (opcode$ > 16) & (opcode$ < 19),	[
																																psortieplan5X
																																]
																							]
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8

				garage = 0
				flagmr2 = 0
				old_opcode_cloche = opcode$
                flag_changement_outil = 1
                old_tool = tlngno$
                flag_cloche = 0
				flag_chargement_cloche = 0
                premperc = 0
				if (mi4 >= 0) & (mi4 <> 9), mini_c = mini_c_avec_cloche, maxi_c = maxi_c_avec_cloche
                else, mini_c = mini_c_sans_cloche, maxi_c = maxi_c_sans_cloche
                
				pnumop
                if oscilliation = 1 & mi7$ <> 0, psortie12
                ptrans_option  # on est dans le cas d'une transformation 
                cycle_heli_spiral = 0

            if mi10$ <> 1 & mi10$ <> -1, pcantext
            if opcode$ = 16, drill5axes = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint
        #ptestcloche

        if operation = 11,
            [
            gfr = 1
			#if type_pp = 1, pnumligne,*sgfr,*fretrait,e$
			#if type_pp = 2, sm, paf, *sgfr,*fretrait,e$
            ]
        pdmodalxyz
        drill5axes = 0
        gcode$ = 0
        panul_plan_inc
        if (mi10$ = 1) | (mi10$ = -1), parretprog2
        else,
            [
                if  mr2print <> -1 & prvmr2 <> -1,	[
													]
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo
            ]
        plubrifoff
		if type_pp = 1,	pnumligne, "M5 ; ARRET BROCHE",e$
		if type_pp = 2,	sm,paf, "M5 ; ARRET BROCHE",e$
        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0

        ptestrenvoi_angle
		if type_pp = 2, pchagement_outil
        pappeloutil
        if type_pp = 1,	[
						if mr1$ > 0, mr1$, e$
						]
		if type_pp = 2,	[
						if mr1$ > 0, sm,pafcom,mr1$, e$
						]
        ptlngno
        frbase = fr$
		if type_pp = 1,	pnumligne, *spdlon, ssprint,e$
		if type_pp = 2,	sm,paf,*spdlon, ssprint,e$					
        old_ss = ssprint
        plubrifon

        pcycle832
		if type_pp = 1,	pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
		if type_pp = 2,	sm,paf "D1 ; PRISE DE CORRECTEUR", e$		
            numpp = 3
            comment$
            if type_pp = 1, pnumligne, strcom, e$
			if type_pp = 2, "MW_OP_COMMENT", strcom, e$
            debut = 0
            prvop_id = op_id$
            if mi2_A_base = 0, invers = 0
            if mi2_A_base = 2, invers = 1
            if opcode$ = 16, drill5axes = 1
            if opcode$ = 16, ex$
            prot1
            pprint
            gcode$ = 0
        if mr2print = 0, mr2print =zsecuprint
        prvmr2 = mr2print
        pcalxyz3d
            prot2
            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
                operation = 0
        oldstation = mi4
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0
               changop = 1
               vale53 = 0
               sens_pas = -1
               debutvar = 0
			   old_outil_simu = t$
#endregion
#region peof0
peof0$
            peof$
#endregion
#region peof
peof$
                pprint
            gcode$ = 0
			if type_pp = 1,	[
            				if typcycle = 1, pnumligne, "MCALL", e$, pnumligne, sgcode, initht$,e$
            				typcycle = 0
            				if operation = 11,	[
             										gfr = 1
			 										#pnumligne,*sgfr,*fretrait,e$
            										]
							panul_plan_inc
            				spaces$ = 0
            				spaces$ = 1
            				pnumligne, "M9 ; ARRET LUBRIFIANT",e$
            				pnumligne, "M5 ; ARRET BROCHE",e$
            				pnumligne, "INIT_FIN ; MACRO FIN DE PROG", e$
							asp = 0, pnumligne, sasp, e$
            				pnumligne, "M30 ; FIN DE PROGRAMME", e$
							"%", e$							
							]
			if type_pp = 2,	[
            				if typcycle = 1, sm,paf, "MCALL", e$, sr, *initht$, paf, sgcode, *initht$,e$
            				typcycle = 0
            				if operation = 11,	[
             										gfr = 1
			 										#sm,paf,*sgfr,*fretrait,e$
            										]
            				panul_plan_inc
            				spaces$ = 0
            				spaces$ = 1
            				sm,paf,"M9 ; ARRET LUBRIFIANT",e$
            				sm,paf,"M5 ; ARRET BROCHE",e$
							sm, paf, "INIT_FIN ; MACRO FIN DE PROG", e$
							sm,  "Z1093.500", paf, "SUPA G90 G0 Z-150.", e$
							asp = 0, sm, paf, sasp, e$
							sm, paf, "M30 ; FIN DE PROGRAMME", e$
							sm, paf, "%", e$ 	
							sf, e$
							]							
			clearext$
            mergelcc$
			clearext$
#endregion
#endregion
#region   PLIN, PCIR
#region prapid
prepcoiffe
			if zcloche_inc = 1, zcloche_on = zcloche + zbrut
			else, zcloche_on = zcloche
			@zcloche_on
			if (zcloche_on = zprint) & (flag_coiffe = 1), ptlngno2, flag_coiffe = 0
prapid$
            
			pprint
			@xprint
		   	@yprint
			@zprint		
			if zprint = 9999, zprint = znci$
           	if type_pp = 1, [
							pnumligne, sgcode,	[
												if xprint <> old_x, xprint
												if yprint <> old_y, yprint
												if zprint <> old_z, zprint
												e$
												prepcoiffe
												]
							]
			if type_pp = 2,	[
							sr, *xprint, *yprint ,*zprint, paf, sgcode, xaff, yaff, zaff,e$
							prepcoiffe
							]
	
#endregion
#region pzrapid
pzrapid$    
			pprint
			@zprint
           	if type_pp = 1,	[
							@zprint
							pnumligne, sgcode,	[
												if zprint <> old_z, *zprint
												e$
												prepcoiffe
												]
							]
			if type_pp = 2, [
							sr, *zprint, paf, sgcode, *zprint,e$
							prepcoiffe
							]
#endregion
#region plin
plin$
			
			pprint
			@xprint
		   	@yprint
		   	@zprint
            gfr = 1
           	if type_pp = 1,	[
							pnumligne, sgfr,e$
           					pnumligne, sgcode, pcord, xprint, yprint, zprint, pfr, pg9,e$
							]
			if type_pp = 2, [
							sm, paf, sgfr,e$
		   					sl, *xprint, *yprint, *zprint, paf, sgcode, pcord, xaff, yaff, zaff, pfr, pg9,e$
							]
#endregion
#region pz
pz$
            pprint
			@zprint
           	if type_pp = 1,	[
							pnumligne, sgcode, zprint,e$
							]
			if type_pp = 2, sr, *zprint, paf, sgcode, *zprint,e$
#endregion
#region pcir
pcir$
            pprint
            gfr = 1
			@xprint
		   	@yprint
		   	@zprint
			@iprint
			@jprint  

			if type_pp = 1,	[
							pnumligne, sgfr,e$
            				if tete_rev = 1,	[
            									plane$ = 2
            									pnumligne, splcode, sgcode, *xprint, *yprint, zprint, *iprint,*jprint, pfr, pg9,  e$
            									]
            							else,	[
            									if plane$ = 0, pnumligne, splcode, *sgcode, *xprint, *yprint, zprint, *iprint,*jprint, pfr,e$
            									if plane$ = 2, pnumligne, splcode, *sgcode, *xprint, *zprint, yprint, *iprint,*kprint, pfr,e$
            									if plane$ = 1, pnumligne, splcode, *sgcode, *yprint, *zprint, xprint, *jprint,*kprint, pfr,e$
            									]
							]
			if type_pp = 2,	[
							sm,paf, sgfr,e$
            				rayon = arcrad$
            				if gcode$ = 2, stype_arc = "CW"
            				if gcode$ = 3, stype_arc = "CCW"
            				if tete_rev = 1,	[
            									plane$ = 2
            									sc, *xprint, *yprint, *zprint, rayon, stype_arc, pfr, paf, splcode, sgcode, *xaff, *yaff, zaff, *iprint,*jprint, pfr, pg9,  e$
            									]
            							else,	[
            									if plane$ = 0, sc, *xprint, *yprint, *zprint, rayon, stype_arc, pfr, paf, splcode, *sgcode, *xaff, *yaff, zaff, *iprint,*jprint, pfr,e$
            									if plane$ = 2, sc, *xprint, *zprint, *yprint, rayon, stype_arc, pfr, paf, splcode, *sgcode, *xaff, *zaff, yaff, *iprint,*kprint, pfr,e$
            									if plane$ = 1, sc, *yprint, *zprint, *xprint, rayon, stype_arc, pfr, paf, splcode, *sgcode, *yaff, *zaff, xaff, *jprint,*kprint, pfr,e$
           	 									]
							]				
#endregion         
#endregion
#region   PCONT, PMX,...
#region pcont
pcont     # ajout de plus ou moin 360 sur C
         if dif_axe_c > 0, cont_axe_c = cont_axe_c - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c = cont_axe_c + 360    # retrait de 360 deg 
		 if type_axe = 1, axeC = atan2(Vx,Vy)
		 if type_axe = 2, axeC = atan2(-Vy,Vx)
		 if type_axe = 3, axeC = atan2(Vx,Vz)
		  
		 axeC = cont_axe_c + reel_axeCpos               # actualisation de l'angle

#endregion
#region pderoul
pderoul    # retrait de 360 deg sur axeC    
		 cont_axe_c = cont_axe_c - (360 * nbt)  # retrait de 360 deg 
         prvaxec = prvaxec - (360 * nbt)    # retrait de 360 deg 
         if type_axe = 1, axeC = atan2(Vx,Vy)
		 if type_axe = 2, axeC = atan2(-Vy,Vx)
		 if type_axe = 3, axeC = atan2(Vx,Vz)
		 axeC = cont_axe_c + axeC
		 
		 if prvaxea = 0 | prvaxea = 360, prvaxec = axeC
         #q2
         #q3
        #vectdeg = mr1$
         if vectdeg = 0, vectdeg = 50
         zdeg2 = mr2print
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal

         xdeg = (deltax / old_longvec) * vectdeg
         ydeg = (deltay / old_longvec) * vectdeg
         zdeg = (deltaz / old_longvec) * vectdeg
         xdeg = xdeg + old_x
         ydeg = ydeg + old_y
         zdeg = zdeg + old_z
         gcode$ = 0
         result = mprint(srattrap, 3)
		 
		 if type_pp = 1,	[
         					if result = 3, "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         					pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         					gfr = 1
         					pnumligne,*sgfr , *frbase ,e$
         					pnumligne,sgcode, *xdeg, *ydeg, *zdeg,e$
         					if mr2print <>   -1 & mr2print > zdeg, pnumligne,*sgcode, *zdeg2,e$
         					pnumligne,sgcode, *zdeg,e$
         					gcode$ = 1
         					pnumligne,sgcode,*sgfr,*old_x, *old_y, *old_z, *frbase, e$
         					gfr = 0
		 					]
		 if type_pp = 2,	[
         					if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         					sm,paf, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         					gfr = 1
         					sm,paf, *sgfr , *frbase ,e$
         					sr, *xdeg, *ydeg, *zdeg, paf, sgcode, *xdeg, *ydeg, *zdeg,e$
         					if mr2print <>   -1 & mr2print > zdeg, sr, *zdeg2, paf, *sgcode, *zdeg2,e$
							prtcp_simu_ratrap
         					sr, *zdeg, paf, sgcode, *zdeg,e$
         					gcode$ = 1
         					sl, *old_x, *old_y, *old_z, *frbase, paf, sgcode,*sgfr,*old_x, *old_y, *old_z, *frbase, e$
         					gfr = 0
		 					]							
#endregion
#region penroul
penroul    # retrait de 360 deg sur axeC
         cont_axe_c = cont_axe_c + (360 * nbt)  # retrait de 360 deg 
         prvaxec = prvaxec + (360 * nbt)    # retrait de 360 deg 
         if type_axe = 1, axeC = atan2(Vx,Vy)
		 if type_axe = 2, axeC = atan2(-Vy,Vx)
		 if type_axe = 3, axeC = atan2(Vx,Vz)
         axeC = cont_axe_c + axeC
		 if prvaxea = 0 | prvaxea = 360, prvaxec = axeC
         #q2
         #q3
         #vectdeg = mr1$
         if vectdeg = 0, vectdeg = 50
         zdeg2 = mr2print
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal

         xdeg = (deltax / old_longvec) * vectdeg
         ydeg = (deltay / old_longvec) * vectdeg
         zdeg = (deltaz / old_longvec) * vectdeg
         xdeg = xdeg + old_x
         ydeg = ydeg + old_y
         zdeg = zdeg + old_z
         gcode$ = 0
         result = mprint(srattrap, 3)
		 
		 if type_pp = 1,	[
         					if result = 3, "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
        	 				pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         					gfr = 1
         					pnumligne, *sgfr,*frbase ,e$
							pnumligne,sgcode, *xdeg, *ydeg, *zdeg, e$
         					if mr2print <>   -1 & mr2print > zdeg, pnumligne,*sgcode, *zdeg2, e$
         					pnumligne,sgcode, *zdeg, e$
         					gcode$ = 1
         					gfr = 0
         					pnumligne, sgcode,*sgfr, *old_x, *old_y, *old_z, *frbase, e$
		 					]
			if type_pp = 2,	[
         					if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
        	 				sm, paf, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         					gfr = 1
         					sm, paf, *sgfr,*frbase ,e$
							sr, *xdeg, *ydeg, *zdeg, paf, sgcode, *xdeg, *ydeg, *zdeg, e$
         					if mr2print <>   -1 & mr2print > zdeg, sr, *zdeg2, paf, *sgcode, *zdeg2, e$
							prtcp_simu_ratrap
         					sr, *zdeg, paf ,sgcode, *zdeg, e$
         					gcode$ = 1
         					gfr = 0
         					sl, *old_x, *old_y, *old_z, *frbase, paf, sgcode,*sgfr, *old_x, *old_y, *old_z, *frbase, e$
		 					]					
#endregion
#region pdebut2
pdebut2    # retour car angle trop grand ou trop petit          
         if prog = 1, q21
         if prog = 1, q15
          cont_axe_c = 360 * trplus
		  		if type_axe = 1, axeC = atan2(Vx,Vy)
				if type_axe = 2, axeC = atan2(-Vy,Vx)
				if type_axe = 3, axeC = atan2(Vx,Vz)
                if abs(axeC) > 359.998, axeC = 0
        axeC = cont_axe_c + axeC

#endregion
#region pdebut
fmt "" 2 flagM11
flagM11 : 0
pdebut     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base = 1, trplus = 1
          if mi1_C_base = 2, trplus = -1
          if mi1_C_base = 0, trplus = 0
         !trplus
             cont_axe_c = 360 * trplus
             if Vx = 0 & Vy = 0,	[
			 						if mi9$ = -1, axeC = prvaxec
									else, axeC = mi9$
									]
                 else,	[
				 		if type_axe = 1, axeC = atan2(Vx,Vy)
						if type_axe = 2, axeC = atan2(-Vy,Vx)
						if type_axe = 3, axeC = atan2(Vx,Vz)
						]

                 if abs(axeC) > 359.998, axeC = 0
         reel_axeCpos = axeC
         axeC = cont_axe_c + axeC
			
         @maxi_c,@mini_c
         if axeC > maxi_c, axeC = axeC - 360
         if axeC < mini_c, axeC = axeC + 360
#endregion
#region pmxinvd
pmxinvd   # ecriture de axes A positif      
             Vx = ucal - xcal
             Vy = ycal - vcal
             Vz = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev = 1 & ((Vx = 0 & Vy = 0) | vertical_z) = 0 ,
            [
            axeA = 0
            Vx = x$ - u$
            Vy = v$ - y$
            if type_axe = 1, axeC = atan2(Vx,Vy)
			if type_axe = 2, axeC = atan2(-Vy,Vx)
			if type_axe = 3, axeC = atan2(Vx,Vz)
			axeC2 = atan2(Vx,Vy) 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           if abs(Vx) < cone_mini & abs(Vy) < cone_mini, Vx = 0, Vy = 0
       @Vx,@Vy,@Vz
       longvec=sqrt(Vx * Vx + Vy * Vy + Vz * Vz)
       if Vx = 0 & Vy = 0,	[
			 						if mi9$ = -1, axeC = prvaxec
									else, axeC = mi9$
									]
           else,	[
				 	if type_axe = 1, axeC = atan2(Vx,Vy)
					if type_axe = 2, axeC = atan2(-Vy,Vx)
					if type_axe = 3, axeC = atan2(Vx,Vz)
					axeC2 = atan2(Vx,Vy) 
					]

           if abs(axeC) > 359.999, axeC = 0

           reel_axeCpos = axeC
           if longvec = 0, longvec = 1
           if type_axe = 1,  axeA = acos(Vz / longvec)
		   if type_axe = 2,  axeA = acos(Vz / longvec)
		   if type_axe = 3,  axeA = asin(Vy / longvec)
		   axeA2 = acos(Vz / longvec)
           ]
           invers = 0
           deja = 1
#endregion
#region pmxinvg
pmxinvg   # ecriture de axes A negatif    
            Vx = xcal - ucal
            Vy = vcal - ycal
            Vz = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev = 1 & ((Vx = 0 & Vy = 0) | vertical_z) = 0 ,
            [
            axeA = 0
            Vx = u$ - x$
            Vy = y$ - v$
            if type_axe = 1, axeC = atan2(Vx,Vy)
			if type_axe = 2, axeC = atan2(-Vy,Vx)
			if type_axe = 3, axeC = atan2(Vx,Vz)
			axeC2 = atan2(Vx,Vy)
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           if abs(Vx) < cone_mini & abs(Vy) < cone_mini, Vx = 0, Vy = 0
            @Vx,@Vy,@Vz
            longvec=sqrt(Vx * Vx + Vy * Vy + Vz * Vz)
            if Vx = 0 & Vy = 0,	[
			 						if mi9$ = -1, axeC = prvaxec
									else, axeC = mi9$
									]
            else,	[
				 	if type_axe = 1, axeC = atan2(Vx,Vy)
					if type_axe = 2, axeC = atan2(-Vy,Vx)
					if type_axe = 3, axeC = atan2(Vx,Vz)
					axeC2 = atan2(Vx,Vy)
					]

            if abs(axeC) > 359.999, axeC = 0

            reel_axeCpos = axeC
            if longvec = 0, longvec = 1
            if type_axe = 1,  axeA = acos(Vz / longvec) *   -1
			if type_axe = 2,  axeA = acos(Vz / longvec) *   -1
			if type_axe = 3,  axeA = asin(Vy / longvec) *   -1
			axeA2 = acos(Vz / longvec) *   -1
            ]
            invers = 1
            deja = 1
#endregion
#region pmxinvgd
pmxinvgd   # droite ou gauche
        if invers = 0, pmxinvg
             else, pmxinvd
#endregion
#region pmxsens
pmxsens    # maintien de axes c quand a passe en negatif 
        if Vx >=   -0.002 & Vx <= 0.002, Vx = 0
        if Vy >=   -0.002 & Vy <= 0.002, Vy = 0
		#	"coucou", e$
        deja = 0
		
		#"voir ", " ",*deja, " ", *old_vx, " ", *Vx, " ", *old_vy, " ", *Vy, e$
        if (deja = 0 & old_vx <= 0 & Vx > 0 & old_vy = 0 & Vy = 0) |
        (deja = 0 & old_vx >= 0 & Vx < 0 & old_vy = 0 & Vy = 0) |
        (deja = 0 & old_vx = 0 & Vx = 0 & old_vy >= 0 & Vy < 0) |
        (deja = 0 & old_vx = 0 & Vx = 0 & old_vy <= 0 & Vy > 0) |

        (deja = 0 & old_vx < 0 & Vx > 0 & old_vy < 0 & Vy > 0) |
        (deja = 0 & old_vx > 0 & Vx < 0 & old_vy > 0 & Vy < 0) |
        (deja = 0 & old_vx <= 0 & Vx >= 0 & old_vy >= 0 & Vy <= 0) |
        (deja = 0 & old_vx >= 0 & Vx <= 0 & old_vy <= 0 & Vy >= 0) , 	
		[
		pmxinvgd
		]
        deja = 0
#endregion
#region pvariok
pvariok   #  ecriture de E5300xx
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53
#endregion
#region pvarioutil
fmt "demi periode" 1 moit_per
fmt "pas de base" 1 pas_base
fmt "val_pas" 1 val_pas
fmt "sens du pas" 1 sens_pas
fmt "dbut de variation" 1 debutvar
fmt "" 3 vale53abs

pvarioutil   # application d'une correction de longeur
         if mi7$ = 0 | mr6$ = 0, mi6$ = 0
         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok
         pasn = 1 + pasn
#endregion
#region pmx
pmx$
	if opcode$ <> 17, psortie5X
	if type_pp = 1,	[
            pprint
            @xprint, @yprint,@zprint
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                ex$
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr = 0
            if invers = 0, pmxinvd
            if invers = 1, pmxinvg
            if debut = 1, pmxsens
            !maxi_c, !mini_c
			if axeC = 0 & axeA = 0, #tout va bien
			else, psortie3X
           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x
           Dy = ycal - old_y
           Dz = zcal - old_z

           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)                      

             if fr$ =   -1,fr$= frbase
         if fr$ > 0, frbase = fr$

         if deltaXYZ < mr5$ & debut = 1, ex$   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0, [
                                    fr5axe = fr$ / deltaXYZ
                                    ]
        ]
            if debut = 0 & changop <> 0, cont_axe_c = 0
            if debut = 0 & changop <> 0, prvaxec = axeC
         axeC = cont_axe_c + axeC       # cumul du compteur avec c   
         dif_axe_c = axeC - prvaxec     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
         if absdif > 180,  pcont         # ajout + - 360
		 dif_axe_c2 = axeC - prvaxec
		 absdif2 = abs(dif_axe_c2)
		 if usedelta = 1,	[
		 					if absdif2 > delta_rot_C, psortie_axeC_5X
							]
        if axeC > maxi_c & debut <> 0, pderoul
        if axeC < mini_c & debut <> 0, penroul
        if debut = 0,
        [

        if axeC >= (360+mini_c) & changop <> 0, pdebut
        if axeC <= (maxi_c - 360) & changop <> 0, pdebut
         gcode$ = 0

			 if mr2print <>   -1,
            [
            if changop = 1,	[
							pnumligne, *sgcode, *xprint, *yprint, e$
							pnumligne, *sgcode, *xprint, *yprint,e$						
							pnumligne, *zprint,e$
							]
            else, pnumligne, *sgcode, *xprint, *yprint, *zprint,e$
                ]
             else,
            [
            pnumligne, *sgcode, *xprint, *yprint,*zprint,e$
            ]
			
         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        if deltaXYZ < mr5$ | gcode$ = 0, gfr = 1
        if deltaXYZ < mr5$ ,    [
                                fr5axe = fr$
                                ]
        spaces$ = 0
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil
          old_x = xcal
          old_y = ycal
          old_z = zcal
         xprint = xcor + xprint
         yprint = ycor + yprint
         zprint = zcor + zprint
        if axeA > maxi_a | axeA < mini_a, psortie10 # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11
         if gcode$ = 1 ,
                [
                if tete_rev = 1,
                    [
                    gfr = 1
                    pnumligne, sgfr, sgcode, xprint, yprint, zprint ,pfr, e$
                    ]
                else,
                    [
					gfr = 1
                    pnumligne, sgfr, sgcode, xprint, yprint, zprint, pfr, pg9_5x, e$
                    ]
                 ]
        else, pnumligne, sgcode, xprint, yprint, zprint,e$
		prepcoiffe
        debut = 1
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx = Vx
           old_vy = Vy
           old_vz = Vz
       old_longvec = longvec
       prvaxec = axeC
       prvaxea = axeA
       operation = 11
       old_x_5x = x$
       old_y_5x = y$
       old_z_5x = z$
					]
		if type_pp = 2,	[
		           pprint
            @xprint, @yprint,@zprint
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                ex$
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr = 0
            if invers = 0, pmxinvd
            if invers = 1, pmxinvg
            if debut = 1, pmxsens
         	!maxi_c, !mini_c

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x
           Dy = ycal - old_y
           Dz = zcal - old_z

           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        
			if fr$ =   -1,fr$= frbase
         	if fr$ > 0, frbase = fr$

         if deltaXYZ < mr5$ & debut = 1, ex$   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe = fr$ / deltaXYZ
        ]

            if debut = 0 & changop <> 0, cont_axe_c = 0
            if debut = 0 & changop <> 0, prvaxec = axeC

         axeC = cont_axe_c + axeC       # cumul du compteur avec c   
         dif_axe_c = axeC - prvaxec     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
         if absdif > 180,  pcont         # ajout + - 360
		 dif_axe_c2 = axeC - prvaxec
		 absdif2 = abs(dif_axe_c2)
		 if usedelta = 1,	[
		 					if absdif2 > delta_rot_C, psortie_axeC_5X
							]

        if axeC > maxi_c & debut <> 0, pderoul
        if axeC < mini_c & debut <> 0, penroul
        if debut = 0,
        [

        if axeC >= (360+mini_c) & changop <> 0, pdebut
        if axeC <= (maxi_c - 360) & changop <> 0, pdebut
		gcode$ = 0
		if flag_outil <> 1 & changop <> 1, prtcp_simu
             if mr2print <>   -1,
            [
            if changop = 1,	[
							if flag_outil <> 1, prtcp_simu
							sr, *xprint, *yprint, paf,sgcode, *xprint, *yprint, e$, sr, *xprint, *yprint,*zprint,paf,*zprint,e$
							]
            else, sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint,e$
                ]
             else,
            [
            sr, *xprint, *yprint,*zprint, paf, sgcode, *xprint, *yprint,*zprint,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        if deltaXYZ < mr5$ | gcode$ = 0, gfr = 1
        if deltaXYZ < mr5$ , fr5axe = fr$
        spaces$ = 0

          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil
          old_x = xcal
          old_y = ycal
          old_z = zcal
         xprint = xcor + xprint
         yprint = ycor + yprint
         zprint = zcor + zprint
        if axeA > maxi_a | axeA < mini_a, psortie10 # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11
         if gcode$ = 1 ,
                [
                if tete_rev = 1,
                    [
                    gfr = 1
                    sl, *xprint, *yprint, *zprint ,pfr, paf, sgfr, sgcode, *xprint, *yprint, *zprint ,pfr, e$
                    ]
                else,
                    [
                    sl, *xprint, *yprint, *zprint, *fr5axe, paf, sgfr, *fr5axe, sgcode, *xprint, *yprint, *zprint, pg9_5x, e$
                    ]
                 ]
        else, sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint,e$
        prepcoiffe
		debut = 1
		
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx = Vx
           old_vy = Vy
           old_vz = Vz
       old_longvec = longvec
       prvaxec = axeC
       prvaxea = axeA
       operation = 11
       old_x_5x = x$
       old_y_5x = y$
       old_z_5x = z$
		old_axeC_simu = axeC
		old_axeA_simu = axeA
		old_xprint_simu = xprint
		old_yprint_simu = yprint
		old_zprint_simu = zprint
        old_opcode = opcode$
		]
#endregion
#region pmx2
pmx2$
		if opcode$ = 16,  ex$
		pmx$
#endregion
#endregion
#region   PERCAGES
#region pdrl5
pdrl5   # ecriture 1 er percage en 5 axes
		if type_pp = 1, 	[
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers = 1
        if invers = 0, pmxinvd
        if invers = 1, pmxinvg
        pdebut
        Vx = u$ - x$
        Vy = v$ - y$
        Vz = w$ - z$
		
        axeCpos = axeC
        axeApos = axeA
		
		axeCpos2 = axeC2
        axeApos2 = axeA2
		
        if mi1_C_base <> 1 & mi1_C_base <> 2, pessaicompteur
        axeCpos1 = axeCpos
        axeApos1 = axeApos
		if type_axe = 1, axeCpos = axeCpos
        if type_axe = 2, axeCpos = axeCpos + 90
		if type_axe = 3, axeCpos = axeCpos
       !axeApos1,!axeCpos
       if mr2print = 0, mr2print =zsecuprint
       prvmr2 = mr2print


       gcode$ = 0

       tox4print = (((Vx/longvec) * abs(depth$)) + x$)
       toy4print = (((Vy/longvec) * abs(depth$)) + y$)
       toz4print = (((Vz/longvec) * abs(depth$)) + z$)


       if tete_rev = 1,
       [
           panul_plan_inc
		   if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
           if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
           if mr2print =  -1,pnumligne,*sgcode, *xrprintrap, *yrprintrap, *zrprintrap, e$     #orientationtete 
           else, pnumligne, *sgcode, *xrprintrap, *yrprintrap,e$, pnumligne, *zrprintrap, e$     #orientationtete
           pnumligne, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
           gcode$ = 1
           if gfr = 1, frplunge = frplunge$
           else, frplunge = frplunge$
           pnumligne, sgcode, *xprint, *yprint, *zprint,frplunge, e$                # percage
           if typepercage = 0, gcode$ = 0
            if nextop$ <> 100 | nextop$ > 1000, pnumligne,sgcode, *xrprint, *yrprint, *zrprint, e$            # retour plan de secu
            else, pnumligne, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0
           old_axeCpos = axeCpos
           old_axeApos = axeApos
           oldreel_axeCpos = reel_axeCpos
            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
        oldstation = mi4
        frbase = fr$
       ] 
       else,
       [
       pvoir
       xprint = 0
       yprint = 0
       zinitht = sqrt((sav_x_pmx - tox4print)^2 + (sav_y_pmx - toy4print)^2 + (sav_z_pmx - toz4print)^2)
       old_zinitht = zinitht
       @initht$
       @zinitht
       zprint = refht$
       panul_plan_inc
            if (x$ = u$) & (y$ = v$), [axeCpos1 = 0, axeApos1 = 0, axeCpos = 0, axeApos = 0]
            if axeApos1 > maxi_a | axeApos1 < mini_a, psortie10
			if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        	if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
           if mr2print =  -1,pnumligne,*sgcode, *xrprint, *yrprint, *zrprint, e$     #orientationtete
           else, pnumligne, *sgcode, *xrprint, *yrprint, e$     #orientationtete
            pnumligne, *sgcode, *xprint, *yprint, *zinitht,e$                         # dep au plan garde          
           old_tox4 = tox4print
           old_toy4 = toy4print
           old_toz4 = toz4print
           old_axeCpos = axeCpos
           old_axeApos = axeApos
           oldreel_axeCpos = reel_axeCpos

            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
         xprint = 0
         yprint = 0

        oldstation = mi4
        frbase = fr$
       ]
	   						]
		
		if type_pp = 2,		[
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers = 1
        if invers = 0, pmxinvd
        if invers = 1, pmxinvg
        pdebut
        Vx = u$ - x$
        Vy = v$ - y$
        Vz = w$ - z$
        axeCpos = axeC
        axeApos = axeA
		axeCpos2 = axeC2
        axeApos2 = axeA2

        if mi1_C_base <> 1 & mi1_C_base <> 2, pessaicompteur
        axeCpos1 = axeCpos
        axeApos1 = axeApos
        axeCpos = axeCpos + 90
       !axeApos1,!axeCpos
       if mr2print = 0, mr2print =zsecuprint
       prvmr2 = mr2print

       if mr2print <> -1,	[
	   							if flag_changement_outil = 1, sm, sxmag, symag ,e$
								]

       gcode$ = 0

       tox4print = (((Vx/longvec) * abs(depth$)) + x$)
       toy4print = (((Vy/longvec) * abs(depth$)) + y$)
       toz4print = (((Vz/longvec) * abs(depth$)) + z$)


       if tete_rev = 1,
       [
           panul_plan_inc
		   if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
           if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
           if mr2print =  -1,sr, *xrprintrap, *yrprintrap, *zrprintrap, paf,*sgcode, *xrprintrap, *yrprintrap, *zrprintrap, e$     #orientationtete 
           else, sr, *xrprintrap, *yrprintrap, paf, *sgcode, *xrprintrap, *yrprintrap,e$, sr, *zrprintrap, paf, *zrprintrap, e$     #orientationtete 
           sr, *xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
           gcode$ = 1
           sl, *xprint, *yprint, *zprint,*frplunge$, paf, sgcode, *xprint, *yprint, *zprint,*frplunge$, e$                # percage
           if typepercage = 0, gcode$ = 0
           if nextop$ <> 100 | nextop$ > 1000, sr, *xrprint, *yrprint, *zrprint, paf, sgcode, *xrprint, *yrprint, *zrprint, e$            # retour plan de secu
           else, sr, *xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
           if typepercage = 1, gcode$ = 0

           old_axeCpos = axeCpos
           old_axeApos = axeApos
           oldreel_axeCpos = reel_axeCpos

           old_x=xrprint
           old_y=yrprint
           old_z=zrprint

        oldstation = mi4
        frbase = fr$

       ] 
       else,
       [
       pvoir
       xprint = 0
       yprint = 0
       zinitht = sqrt((sav_x_pmx - tox4print)^2 + (sav_y_pmx - toy4print)^2 + (sav_z_pmx - toz4print)^2)
       old_zinitht = zinitht
       @initht$
       @zinitht
       zprint = refht$
       panul_plan_inc
            if (x$ = u$) & (y$ = v$), [axeCpos1 = 0, axeApos1 = 0, axeCpos = 0, axeApos = 0]
            if axeApos1 > maxi_a | axeApos1 < mini_a, psortie10
			if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        	if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
            if mr2print =  -1,sr, *xrprint, *yrprint, *zrprint, paf,*sgcode, *xrprint, *yrprint, *zrprint, e$     #orientationtete
            else, sr, *xrprint, *yrprint, paf, *sgcode, *xrprint, *yrprint, e$     #orientationtete

                        xprint = xr$
                        yprint = yr$
                        zprint = zr$
                        sr, *xprint, *yprint, *zprint, paf, *sgcode, *xprint, *yprint, *zprint,e$ #
                        pcaldrilxyzsimu
                        xprint = v_abs_plus_x_sec
                        yprint = v_abs_plus_y_sec
                        zprint = v_abs_plus_z_sec
                        sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint,e$ # dep au plan garde  
                        old_v_abs_plus_x_sec = v_abs_plus_x_sec
                        old_v_abs_plus_y_sec = v_abs_plus_y_sec
                        old_v_abs_plus_z_sec = v_abs_plus_z_sec

           old_tox4 = tox4print    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4 = toy4print
           old_toz4 = toz4print
           old_axeCpos = axeCpos
           old_axeApos = axeApos
           oldreel_axeCpos = reel_axeCpos

            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
         xprint = 0
         yprint = 0

        oldstation = mi4
        frbase = fr$
       ]
        old_opcode = opcode$
		
					]
#endregion
#region pdrl5_2
pdrl5_2   # ecriture percage suivant en 5 axes
		old_axeC_simu = axeC
		old_axeA_simu = axeA
		if type_pp = 1,	[
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers = 1
        if invers = 0, pmxinvd
        if invers = 1, pmxinvg
        pdebut
        Vx = u$ - x$
        Vy = v$ - y$
        Vz = w$ - z$
        axeCpos = axeC
        axeApos = axeA
		
		axeCpos2 = axeC2
        axeApos2 = axeA2
		
        if mi1_C_base <> 1 & mi1_C_base <> 2, pessaicompteur
        axeCpos1 = axeCpos
        axeApos1 = axeApos
		if type_axe = 1, axeCpos = axeCpos
        if type_axe = 2, axeCpos = axeCpos + 90
		if type_axe = 3, axeCpos = axeCpos
        !axeApos1,!axeCpos
        if mr2print = 0, mr2print = zsecuprint
        prvmr2 = mr2print

        if tete_rev = 1,
            [ 

            !xrprint, !xgarde, !yrprint, !ygarde, !zrprint, !zgarde

             if xrprint = xgarde & yrprint = ygarde & zrprint = zgarde,""
             else,
             [
             old_x_print = old_x
             old_y_print = old_y
             old_z_print = old_z
             if retplangarde = 0, pnumligne, sgcode, *old_x_print, *old_y_print, *old_z_print, e$
             ]
                old_z_print = old_z
				if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        		if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, sgcode, *xgarde, *ygarde, *zgarde, e$
                else,
                if nextop$ = 100, pnumligne, sgcode, *xrprint, *yrprint, *zrprint, e$     #orientationtete 
                else, pnumligne, sgcode, *xrprint, *yrprint, *old_z_print,e$     #orientationtete
            if xrprint <> xgarde | yrprint <> ygarde | zrprint <> zgarde,
            [
            if retplangarde <> 2, pnumligne, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr = 1, frplunge = frplunge$
            else, frplunge = frplunge$

            pnumligne, sgcode, *xprint, *yprint, *zprint,frplunge, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde <> zrprint, pnumligne, sgcode, *xgarde, *ygarde, *zgarde,e$
                gcode$ = 0
                pnumligne, sgcode, *xrprint, *yrprint, *zrprint, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap = xdegvec + nextx$
                yrprintrap = ydegvec + nexty$
                zrprintrap = zdegvec + nextz$
                pnumligne,sgcode, *xrprintrap, *yrprintrap, *zrprintrap, e$
                ]

            ]
            else,   pnumligne, sgcode, *xgarde, *ygarde, *zgarde,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos = axeCpos
            old_axeApos = axeApos
            oldreel_axeCpos = reel_axeCpos

            old_x=xrprint
            old_y=yrprint
            old_z=zrprint

            oldstation = mi4
            frbase = fr$

            ] 
         else,
            [
            tox4print = ((Vx/longvec) * abs(depth$)) + xprint
            toy4print = ((Vy/longvec) * abs(depth$)) + yprint
            toz4print = ((Vz/longvec) * abs(depth$)) + zprint
            pvoir

            if cycle_heli_spiral = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, sgcode, *old_dest_ret_5x,e$
            else, pnumligne, "MCALL", e$, pnumligne, sgcode, *dest_ret_5x,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, sgcode, *old_dest_ret_5x, e$
            else, pnumligne, sgcode , *dest_ret_5x,e$ # retour a plan suite dernier usinage
            ]
            if (x$ = u$) & (y$ = v$), [axeCpos1 = 0, axeApos1 = 0, axeCpos = 0, axeApos = 0]
            gcode$ = 0
								xaproche = (((Vx/longvec) * (initht$ - refht$) ) + ucal)
            					yaproche = (((Vy/longvec) * (initht$ - refht$) ) + vcal)
            					zaproche = (((Vz/longvec) * (initht$ - refht$) ) + wcal)
								if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        						if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
            					pnumligne,*sgcode, *xaproche, *yaproche, *zaproche, e$
			
			xprint = 0
            yprint = 0
            if nextop$ <> 100, zinitht = old_dest_ret_5x
            else, zinitht = dest_ret_5x
            zprint = refht$           
            if axeApos1 > maxi_a | axeApos1 < mini_a, psortie10
            pnumligne, *sgcode, *xprint, *yprint, *zinitht, e$
            old_tox4 = tox4print
            old_toy4 = toy4print
            old_toz4 = toz4print
            old_axeCpos = axeCpos
            old_axeApos = axeApos
            oldreel_axeCpos = reel_axeCpos
            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
            oldstation = mi4
            frbase = fr$
            ]
						]
						
						
		if type_pp = 2,	[
        gcode$ = 0
        if tete_rev_ang_droite = 1, invers = 0  # pas de choix sens A si tete a renvoi d'angle
        if tete_rev_ang_gauche = 1, invers = 1
        if invers = 0, pmxinvd
        if invers = 1, pmxinvg
        pdebut
        Vx = u$ - x$
        Vy = v$ - y$
        Vz = w$ - z$
        axeCpos = axeC
        axeApos = axeA
		
		axeCpos2 = axeC2
        axeApos2 = axeA2
		
        if mi1_C_base <> 1 & mi1_C_base <> 2, pessaicompteur
        axeCpos1 = axeCpos
        axeApos1 = axeApos
		if type_axe = 1, axeCpos = axeCpos
        if type_axe = 2, axeCpos = axeCpos + 90
		if type_axe = 3, axeCpos = axeCpos
        !axeApos1,!axeCpos
        if mr2print = 0, mr2print = zsecuprint
        prvmr2 = mr2print

        if tete_rev = 1,
            [ 

            !xrprint, !xgarde, !yrprint, !ygarde, !zrprint, !zgarde

             if xrprint = xgarde & yrprint = ygarde & zrprint = zgarde,""
             else,
             [
             old_x_print = old_x
             old_y_print = old_y
             old_z_print = old_z
             if retplangarde = 0, sr, *old_x_print, *old_y_print, *old_z_print, paf, sgcode, *old_x_print, *old_y_print, *old_z_print, e$
             ]
                old_z_print = old_z
				if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        		if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, sr, *xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde, e$
                else,
                if nextop$ = 100, sr, *xrprint, *yrprint, *zrprint, paf, sgcode, *xrprint, *yrprint, *zrprint, e$     #orientationtete 
                else, sr, *xrprint, *yrprint, *old_z_print, paf, sgcode, *xrprint, *yrprint, *old_z_print, e$     #orientationtete
            if xrprint <> xgarde | yrprint <> ygarde | zrprint <> zgarde,
            [
            if retplangarde <> 2, sr,*xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde,e$
            ]
            else, retplangarde = 1
            gcode$ = 1

            if gfr = 1, frplunge = frplunge$
            else, frplunge = frplunge$

            sl, *xprint, *yprint, *zprint,*frplunge$, paf, sgcode, *xprint, *yprint, *zprint,*frplunge$, e$
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde <> zrprint, sr, *xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde,e$
                gcode$ = 0
                sr, *xrprint, *yrprint, *zrprint, paf, sgcode, *xrprint, *yrprint, *zrprint, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap = xdegvec + nextx$
                yrprintrap = ydegvec + nexty$
                zrprintrap = zdegvec + nextz$
                sr, *xrprintrap, *yrprintrap, *zrprintrap, paf, sgcode, *xrprintrap, *yrprintrap, *zrprintrap, e$
                ]

            ]
            else,   sr, *xgarde, *ygarde, *zgarde, paf, sgcode, *xgarde, *ygarde, *zgarde,e$
             if typepercage = 1, gcode$ = 0
            old_axeCpos = axeCpos
            old_axeApos = axeApos
            oldreel_axeCpos = reel_axeCpos

            old_x=xrprint
            old_y=yrprint
            old_z=zrprint

            oldstation = mi4
            frbase = fr$

            ] 
         else,
            [
            tox4print = ((Vx/longvec) * abs(depth$)) + xprint
            toy4print = ((Vy/longvec) * abs(depth$)) + yprint
            toz4print = ((Vz/longvec) * abs(depth$)) + zprint
            pvoir
			
			if cycle_heli_spiral = 0,
            [
                            if planperc = 0,    [
                                                xprint = old_v_abs_plus_x_sec
                                                yprint = old_v_abs_plus_y_sec
                                                zprint = old_v_abs_plus_z_sec
                                                ]
                                        else,   [
                                                xprint = v_abs_plus_x
                                                yprint = v_abs_plus_y
                                                zprint = v_abs_plus_z
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
            else, sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$ # retour a plan suite dernier usinage           
            ]
			else,
            [
            if planperc = 0,    [
                                                xprint = old_v_abs_plus_x_sec
                                                yprint = old_v_abs_plus_y_sec
                                                zprint = old_v_abs_plus_z_sec
                                                ]
                                        else,   [
                                                xprint = v_abs_plus_x
                                                yprint = v_abs_plus_y
                                                zprint = v_abs_plus_z
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
            else, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$ # retour a plan suite dernier usinage 
            ]
			old_xprint_simu = xprint
			old_yprint_simu = yprint
			old_zprint_simu = zprint
            if (x$ = u$) & (y$ = v$), [axeCpos1 = 0, axeApos1 = 0, axeCpos = 0, axeApos = 0]
            gcode$ = 0
			xprint = 0
            yprint = 0
            if nextop$ <> 100, zinitht = old_dest_ret_5x
            else, zinitht = dest_ret_5x
            zprint = refht$
			if axeApos1 > maxi_a | axeApos1 < mini_a, psortie10
            pcaldrilxyzsimu
            xprint = v_abs_plus_x_sec
            yprint = v_abs_plus_y_sec
            zprint = v_abs_plus_z_sec
			prtcp_simu
			if axeCpos1 > maxi_c, psortie_ratrap_planinc_deroul
        	if axeCpos1 < mini_c, psortie_ratrap_planinc_enroul
            sr, *xprint, *yprint, *zprint, paf, *sgcode, *xprint, *yprint, *zprint, e$                    #orientation tete+ garde
            old_v_abs_plus_x_sec = v_abs_plus_x_sec
            old_v_abs_plus_y_sec = v_abs_plus_y_sec
            old_v_abs_plus_z_sec = v_abs_plus_z_sec

            old_tox4 = tox4print
            old_toy4 = toy4print
            old_toz4 = toz4print
            old_axeCpos = axeCpos
            old_axeApos = axeApos
            oldreel_axeCpos = reel_axeCpos
            old_x=xrprint
            old_y=yrprint
            old_z=zrprint
            oldstation = mi4
            frbase = fr$
            ]
						]						
			
#endregion
#region pdrill
pdrill$
		if type_pp = 1, [
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            pprint
            typepercage = 0
            if drill5axes = 1, pdrl5

           if tete_rev = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint , @inithtprint
                pnumligne, sgcode, xprint, yprint, inithtprint, e$
                if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
                gcode$ = 1

                if gfr = 1, frplunge = frplunge$
                else, frplunge = frplunge$

                pnumligne, sgcode, depthprint, frplunge , e$
                gcode$ = 0
                pnumligne, sgcode, inithtprint, e$
                ]
           if tete_rev = 0,
                [
                if drill5axes = 1,
                    [
                    initht5x = refht$

                    if gfr = 1, frplunge = frplunge$
                    else, frplunge = frplunge$

                    pnumligne, frplunge, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, "G0", *xprint, *yprint, e$
                    psouf_imp
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                    ]
                else,
                    [
                    if gfr = 1, frplunge = frplunge$
                    else, frplunge = frplunge$

                    pnumligne, frplunge, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, "G0", *xprint, *yprint, e$
                    psouf_imp
                    typcycle = 1
                    ]
                ]
           old_dest_ret_5x = dest_ret_5x
		   
		   		]
	if type_pp = 2,	[
           if strcom = svide, strcom = "PERCAGE SIMPLE", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            pprint
            typepercage = 0
            
            if drill5axes = 1, pdrl5

           if tete_rev = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint , @inithtprint
                sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
                if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
                gcode$ = 1
                sl, *depthprint, *frplunge$ , paf, sgcode, *depthprint, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint, paf, sgcode, *inithtprint, e$
                ]
           if tete_rev = 0,
                [
                if drill5axes = 1,
                    [
                    pcaldrilxyzsimu
                    initht5x = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                    spaces$ = 1
                    psouf_imp     
                    if  nextop$ <> 100, [
                                        xprint = old_v_abs_plus_x_sec
                                        yprint = old_v_abs_plus_y_sec
                                        zprint = old_v_abs_plus_z_sec
                                        sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                    spaces$ = 1
                    pcaldrilxyzsimu
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    gcode$ = 0
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    psouf_imp
                    typcycle = 1
                    ]
                ]
           old_dest_ret_5x = dest_ret_5x	
	
	
	
				]
#endregion
#region ppeck
ppeck$
            
	if type_pp = 1,	[		
			if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev = 1, psortie
            pprint
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100
            typcycle = 1
            if drill5axes = 1,
                            [
                            pdrl5
                            initht5x = refht$

                            if gfr = 1, frplunge = frplunge$
                            else, frplunge = frplunge$

                            pnumligne, frplunge, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                             ]
            else,
                            [
                            if gfr = 1, frplunge = frplunge$
                            else, frplunge = frplunge$

                            pnumligne, frplunge, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", *xprint, *yprint, e$
                            psouf_imp
                            ]
            old_dest_ret_5x = dest_ret_5x
					]
	if type_pp = 2,	[	
            if strcom = svide, strcom = "PERCAGE DEBOURRAGE", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev = 1, psortie
            pprint
            if drill5axes = 1, tosz$ = 0
			sdis = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle = 1
            if drill5axes = 1,
                            [
                            pdrl5
                            pcaldrilxyzsimu
                            initht5x = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0," MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, [
                                                xprint = old_v_abs_plus_x_sec
                                                yprint = old_v_abs_plus_y_sec
                                                zprint = old_v_abs_plus_z_sec
                                                sm, paf, "MCALL", e$
                                                sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                                ]
                            ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint, *yprint, e$
                            pcaldrilxyzsimu
                            xprint = v_abs_plus_x
                            yprint = v_abs_plus_y
                            zprint = v_abs_plus_z
                            gcode$ = 0
                            sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                            psouf_imp
                            ]
            old_dest_ret_5x = dest_ret_5x	
	
					]
			
#endregion
#region pchpbrk
pchpbrk$
     if type_pp = 1,	[
			if strtool$ = spalpeur, psortie7
            if tete_rev = 1, psortie
            pprint
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100
            typcycle = 1
            if drill5axes = 1,
                            [
                            pdrl5
                            initht5x = refht$
                            if gfr = 1, frplunge = frplunge$
                            else, frplunge = frplunge$

                            pnumligne, frplunge, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                             ]
            else,
                            [
                            if gfr = 1, frplunge = frplunge$
                            else, frplunge = frplunge$
                            pnumligne, frplunge, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", *xprint, *yprint, e$
                            psouf_imp
                            ]
            old_dest_ret_5x = dest_ret_5x
						]
		if type_pp = 2,	[
            if strcom = svide, strcom = "PERCAGE BRISE COPEAU", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev = 1, psortie
            pprint
            if drill5axes = 1, tosz$ = 0
			sdis = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle = 1
            if drill5axes = 1,
                            [
                            pdrl5
                            pcaldrilxyzsimu
                            initht5x = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, [
                                                xprint = old_v_abs_plus_x_sec
                                                yprint = old_v_abs_plus_y_sec
                                                zprint = old_v_abs_plus_z_sec
                                                sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                                ]
                             ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pcaldrilxyzsimu
                            xprint = v_abs_plus_x
                            yprint = v_abs_plus_y
                            zprint = v_abs_plus_z
                            gcode$ = 0
                            sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                            #sm, paf, *xprint, *yprint, e$
                            psouf_imp
                            ]
            old_dest_ret_5x = dest_ret_5x		
						]
#endregion
#region ptap

fmt 22 sst
fmt  "S" 20 ssabs
fmt 22 diam

ptap$
		if type_pp = 1, [
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
			ssabs = abs(ss$)
			sst = ssabs        #vitesse de broche
            shftdrl$ = ssabs    # vitesse de remonté
            retr$ = 0           # angle d'indexage de broche
            peckclr$ = 0        # pas en mm (PIT)
            peck2$ = tldia$      # pas en iso = diam outil
            diam = tldia$
            peck1$ = 5          # arret broche en fin
            dwell$ = 0.5        # tempo de fin de taraudage

            pprint
            typepercage = 0
            if drill5axes = 1, pdrl5

           if tete_rev = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint , @inithtprint
                pnumligne, sgcode, xprint, yprint, inithtprint, e$
                if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
                gcode$ = 1

                if gfr = 1, frplunge = frplunge$
                else, frplunge = frplunge$

                pnumligne, sgcode, depthprint, frplunge , e$
                gcode$ = 0
                pnumligne, sgcode, inithtprint, e$
                ]
           if tete_rev = 0,
                [
                if drill5axes = 1,
                    [
                    initht5x = refht$

                    if gfr = 1, frplunge = frplunge$
                    else, frplunge = frplunge$

                    pnumligne, frplunge, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE84(", *initht5x,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                    spaces$ = 1
                    pnumligne, "G0", *xprint, *yprint, e$
                    psouf_imp
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                    ]
                else,
                    [
                    if gfr = 1, frplunge = frplunge$
                    else, frplunge = frplunge$

                    pnumligne, frplunge, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE84(", *initht$,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                    spaces$ = 1
                    pnumligne, "G0", *xprint, *yprint, e$
                    psouf_imp
                    typcycle = 1
                    ]
                ]
           old_dest_ret_5x = dest_ret_5x
		   
		   		]
	if type_pp = 2,	[
           if strcom = svide, strcom = "TARAUDAGE", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
			ssabs = abs(ss$)
			sst = ssabs        #vitesse de broche
            shftdrl$ = ssabs    # vitesse de remonté
            retr$ = 0           # angle d'indexage de broche
            peckclr$ = 0        # pas en mm (PIT)
            peck2$ = tldia$      # pas en iso = diam outil
            diam = tldia$
            peck1$ = 5          # arret broche en fin
            dwell$ = 0.5        # tempo de fin de taraudage
            pprint
            typepercage = 0
            
            if drill5axes = 1, pdrl5

           if tete_rev = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint , @inithtprint
                sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
                if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
                gcode$ = 1
                sl, *depthprint, *frplunge$ , paf, sgcode, *depthprint, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint, paf, sgcode, *inithtprint, e$
                ]
           if tete_rev = 0,
                [
                if drill5axes = 1,
                    [
                    pcaldrilxyzsimu
                    initht5x = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE84(", *initht5x,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                    spaces$ = 1
                    psouf_imp     
                    if  nextop$ <> 100, [
                                        xprint = old_v_abs_plus_x_sec
                                        yprint = old_v_abs_plus_y_sec
                                        zprint = old_v_abs_plus_z_sec
                                        sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE84(", *initht$,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                    spaces$ = 1
                    pcaldrilxyzsimu
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    gcode$ = 0
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    psouf_imp
                    typcycle = 1
                    ]
                ]
           old_dest_ret_5x = dest_ret_5x	
	
	
	
				]
#endregion
#region pmisc1
pmisc1$
 
		if type_pp = 1,	[			
			if strtool$ = spalpeur, psortie7
            pprint
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            if gfr = 1, frplunge = frplunge$
            else, frplunge = frplunge$

            avance_plonge = frplunge
            typepercage = 1
            if drill5axes = 1, pdrl5

            if tete_rev = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint , @inithtprint
                                pnumligne, sgcode, xprint, yprint, inithtprint, e$
                                if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
                                gcode$ = 1
                                if gfr = 1, frplunge = frplunge$
                                else, frplunge = frplunge$

                                pnumligne, sgcode, depthprint, frplunge , e$
                                pnumligne, sgcode, refhtprint, e$
                                gcode$ = 0
                                if refhtprint <> inithtprint, pnumligne, sgcode, inithtprint, e$
                                ]
           if tete_rev = 0,
                                [
                                if drill5axes = 1,
                                                [

                                                initht5x = refht$
                                                if gfr = 1, frplunge = frplunge$
                                                else, frplunge = frplunge$
                                                pnumligne, frplunge, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x,",", *tosz$, ",",sdis,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, "G0", *xprint, *yprint, e$
                                                psouf_imp
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                                                ]
                                else,
                                                [
                                                if gfr = 1, frplunge = frplunge$
                                                else, frplunge = frplunge$
                                                pnumligne, frplunge, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, "G0", *xprint, *yprint, e$
                                                psouf_imp
                                                ]
                                typcycle = 1
                                ]
           old_dest_ret_5x = dest_ret_5x
		   					]
		if type_pp = 2,	[
            if strcom = svide, strcom = "PERCAGE/ALESAGE (RETOUR ARRETE)", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
            pprint
            if drill5axes = 1, tosz$ = 0
			sdis = refht$ - tosz$
            avance_plonge = frplunge$
            typepercage = 1
            if drill5axes = 1, pdrl5

            if tete_rev = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint , @inithtprint
                                sr, xprint, yprint, inithtprint, sgcode, *xprint, *yprint, *inithtprint, e$
                                if refhtprint <> inithtprint, sr, *refhtprint, paf,sgcode, *refhtprint, e$
                                gcode$ = 1
                                sl, *depthprint, *frplunge$, paf, sgcode, *depthprint, *frplunge$ , e$
                                sl, *refhtprint, *frplunge$, paf, sgcode, *refhtprint, e$
                                gcode$ = 0
                                if refhtprint <> inithtprint, sr, *inithtprint, paf, sgcode, *inithtprint, e$
                                ]
           if tete_rev = 0,
                                [
                                if drill5axes = 1,
                                                [
                                                pcaldrilxyzsimu
                                                initht5x = refht$
                                                sm, paf, frplunge$, e$

                                                sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0," MCALL CYCLE85(", *initht5x,",", *tosz$, ",",sdis,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                #sm, paf, *xprint, *yprint, e$
                                                psouf_imp
                                                if  nextop$ <> 100, [
                                                                    xprint = old_v_abs_plus_x_sec
                                                                    yprint = old_v_abs_plus_y_sec
                                                                    zprint = old_v_abs_plus_z_sec
                                                                    sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                                                    ]
                                                ]
                                else,
                                                [
                                                sm, paf, frplunge$, e$

                                                sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pcaldrilxyzsimu
                                                xprint = v_abs_plus_x
                                                yprint = v_abs_plus_y
                                                zprint = v_abs_plus_z
                                                gcode$ = 0
                                                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                                                #sm, paf, *xprint, *yprint, e$
                                                psouf_imp
                                                ]
                                typcycle = 1
                                ]
           old_dest_ret_5x = dest_ret_5x		
		
		
						]
		   
#endregion
#region pbore2
pbore2$
            psortie2
#endregion
#region pbore1

pbore1$
            psortie2
#endregion
#region pmisc2
pmisc2$
		if type_pp = 1,	[
            if strtool$ = spalpeur, psortie7
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev = 1, psortie
            pprint
            typcycle = 1
            if drill5axes = 1,[
                            pdrl5
                            initht5x = refht$
                            percage_helicoido_spiral

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, sgcode, *old_zinitht, e$
                             ]
           else, percage_helicoido_spiral
           old_dest_ret_5x = dest_ret_5x
            !x$, !y$, !z$, !xr$, !yr$, !zr$
						]
		if type_pp = 2,	[
            if rotaxtyp$ = 3, [
            if strcom = svide, strcom = "PERCAGE CAQ", "MW_OP_COMMENT", *strcom, e$
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!
            sm,paf, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev = 1, psortie
            pprint
            typcycle = 1
            if drill5axes = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5
                            initht5x = refht$
                            percage_helicoido_spiral

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht, paf, sgcode, *old_zinitht, e$
                             ]
           else, percage_helicoido_spiral
           old_dest_ret_5x = dest_ret_5x
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            if strcom = svide, strcom = "PERCAGE CAQ", "MW_OP_COMMENT", *strcom, e$
            pcalcule_variable
            if strtool$ = spalpeur, psortie7  # on verifie que l'on ne perce pas avec le palpeur!

            #pvoir
			if drill5axes = 1, tosz$ = 0
            sdis = refht$ - tosz$
            pprint
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes = 1, pdrl5

           if tete_rev = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint , @inithtprint
                sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
                if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
                gcode$ = 1
                sl, *depthprint, *frplunge$ , paf,sgcode, *depthprint, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint, paf, sgcode, *inithtprint, e$
                ]
           if tete_rev = 0,
                [
                if drill5axes = 1,
                    [
                    pcaldrilxyzsimu
                    initht5x = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint, *yprint, *zprint, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    #sm, paf, *xprint, *yprint, e$
                    psouf_imp
                    #sm, paf, "G81", xprint, yprint, *depth$, *refht$, *initht5x, frplunge$, e$        
                    if  nextop$ <> 100, [
                                        xprint = old_v_abs_plus_x_sec
                                        yprint = old_v_abs_plus_y_sec
                                        zprint = old_v_abs_plus_z_sec
                                        sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint, *yprint, *zprint, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    pcaldrilxyzsimu
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    gcode$ = 0
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    #sm, paf, *xprint, *yprint, e$
                    psouf_imp
                    typcycle = 1
                    ]
                ]
           old_dest_ret_5x = dest_ret_5x
                    ]		
		
		
						]
						
#endregion
#region pdrill_2
pdrill_2$
		if type_pp = 1,	[
			pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           pnumligne, sgcode, xprint, yprint, inithtprint, e$
           if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
           gcode$ = 1
           if gfr = 1, frplunge = frplunge$
           else, frplunge = frplunge$

           pnumligne, sgcode, depthprint, frplunge , e$
           gcode$ = 0
           pnumligne, sgcode, inithtprint, e$
             ]
           if tete_rev = 0,
                        [
                        if drill5axes = 1, [
						tosz$ = 0
                        initht5x = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, "G0", *xprint, *yprint, e$
                        psouf_imp
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                        ]
        else, pnumligne, "G0", xprint, yprint, e$
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
		   				]
		if type_pp = 2,	[
          pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
           if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
           gcode$ = 1
           sl, *depthprint, *frplunge$, paf, sgcode, *depthprint, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint, paf, sgcode, *inithtprint, e$
             ]
           if tete_rev = 0,
                        [
                        if drill5axes = 1, [
                        pcaldrilxyzsimu
						tosz$ = 0
                        initht5x = refht$

                        sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE81(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                        spaces$ = 1
                        
                        psouf_imp
                        if  nextop$ <> 100, [
                                    xprint = v_abs_plus_x_sec_fin
                                    yprint = v_abs_plus_y_sec_fin
                                    zprint = v_abs_plus_z_sec_fin
                                    sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                    ]
                        ]
        else,   [
                pcaldrilxyzsimu
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                gcode$ = 0
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                xprint = x$
                yprint = y$
                zprint = z$
                sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis,",", *depth$, ")",e$
                spaces$ = 1
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                ]
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
		   				]
#endregion
#region ppeck_2
ppeck_2$
		if type_pp = 1,	[ 
			pprint
            if drill5axes = 1,[
                    pdrl5_2
					tosz$ = 0
                    initht5x = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", xprint, yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                                ]
            else, pnumligne, "G0", xprint, yprint, e$ #depth$, refht$, initht$,e$
            psouf_imp
             old_dest_ret_5x = dest_ret_5x
			 			]
		if type_pp = 2,	[
           pprint
            if drill5axes = 1,[
                    pdrl5_2
                    pcaldrilxyzsimu
                    initht5x = refht$
					tosz$ = 0
					
                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint, yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, [
                                        xprint = v_abs_plus_x_sec_fin
                                        yprint = v_abs_plus_y_sec_fin
                                        zprint = v_abs_plus_z_sec_fin
                                        sm, paf, "MCALL", e$
                                        sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                        ]
                                ]
            #else, sm, paf, xprint, yprint, e$ #depth$, refht$, initht$,e$
            else,   [
                    pcaldrilxyzsimu
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    gcode$ = 0
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    xprint = x$
                    yprint = y$
                    zprint = z$
                    sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                    spaces$ = 1
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    ]
            psouf_imp
             old_dest_ret_5x = dest_ret_5x		
						]
			 
#endregion
#region pchpbrk_2
pchpbrk_2$
 		if type_pp = 1, 	[
				 pprint
            if drill5axes = 1,[
                    pdrl5_2
					tosz$ = 0
                    initht5x = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, "G0", xprint, yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                                ]
            else, pnumligne, "G0", xprint, yprint, e$ #depth$, refht$, initht$,e$
            psouf_imp
             old_dest_ret_5x = dest_ret_5x
			 
			 			]
		if type_pp = 2,	[
              pprint
            if drill5axes = 1,[
                    pdrl5_2
                    pcaldrilxyzsimu
					tosz$ = 0
                    initht5x = refht$

                            sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0," MCALL CYCLE83(", *initht5x,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint, yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, [
                                        xprint = v_abs_plus_x_sec_fin
                                        yprint = v_abs_plus_y_sec_fin
                                        zprint = v_abs_plus_z_sec_fin
                                        sm, paf, "MCALL", e$
                                        sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                        ]
                                ]
            else,   [
                                pcaldrilxyzsimu
                                xprint = v_abs_plus_x
                                yprint = v_abs_plus_y
                                zprint = v_abs_plus_z
                                gcode$ = 0
                                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                                xprint = x$
                                yprint = y$
                                zprint = z$
                                sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                                spaces$ = 1
                                xprint = v_abs_plus_x
                                yprint = v_abs_plus_y
                                zprint = v_abs_plus_z
                                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                                ]
            psouf_imp
             old_dest_ret_5x = dest_ret_5x		
						]
						
#endregion
#region ptap_2
ptap_2$
		if type_pp = 1,	[
			pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           pnumligne, sgcode, xprint, yprint, inithtprint, e$
           if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
           gcode$ = 1
           if gfr = 1, frplunge = frplunge$
           else, frplunge = frplunge$

           pnumligne, sgcode, depthprint, frplunge , e$
           gcode$ = 0
           pnumligne, sgcode, inithtprint, e$
             ]
           if tete_rev = 0,
                        [
                        if drill5axes = 1, [
						tosz$ = 0
                        initht5x = refht$
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE84(", *initht5x,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                        spaces$ = 1
                        pnumligne, "G0", *xprint, *yprint, e$
                        psouf_imp
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                        ]
        else, pnumligne, "G0", xprint, yprint, e$
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
		   				]
		if type_pp = 2,	[
          pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
           if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
           gcode$ = 1
           sl, *depthprint, *frplunge$, paf, sgcode, *depthprint, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint, paf, sgcode, *inithtprint, e$
             ]
           if tete_rev = 0,
                        [
                        if drill5axes = 1, [
                        pcaldrilxyzsimu
						tosz$ = 0
                        initht5x = refht$

                        sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE84(", *initht5x,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                        spaces$ = 1
                        
                        psouf_imp
                        if  nextop$ <> 100, [
                                    xprint = v_abs_plus_x_sec_fin
                                    yprint = v_abs_plus_y_sec_fin
                                    zprint = v_abs_plus_z_sec_fin
                                    sm, paf, "MCALL", e$, sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                    ]
                        ]
        else,   [
                pcaldrilxyzsimu
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                gcode$ = 0
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                xprint = x$
                yprint = y$
                zprint = z$
                sl, *xprint, *yprint, *zprint, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE84(", *initht$,",", *tosz$, ",", *sdis, ",", depth$, ",,0.5,5,",diam,",,0,",*sst,",",*sst, ")", e$
                spaces$ = 1
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                ]
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
		   				]
#endregion
#region pmisc1_2
pmisc1_2$
     if type_pp = 1, 	[ 
			pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           pnumligne, sgcode, xprint, yprint, inithtprint, e$
           if refhtprint <> inithtprint, pnumligne, sgcode, refhtprint, e$
           gcode$ = 1
           if gfr = 1, frplunge = frplunge$
           else, frplunge = frplunge$

           pnumligne, sgcode, depthprint, frplunge , e$
           pnumligne, sgcode, refhtprint, e$
           gcode$ = 0
           if refhtprint <> inithtprint, pnumligne, sgcode, inithtprint, e$
             ]
           if tete_rev = 0,
             [
        if drill5axes = 1,
                            [
							tosz$ = 0
                            initht5x = refht$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, "G0", *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht, e$
                            ]

        else, pnumligne, "G0", xprint, yprint, e$
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
		   		]
				
		if type_pp = 2, 	[
            pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
           if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
           gcode$ = 1
           sl, *depthprint, *frplunge$, paf, sgcode, *depthprint, *frplunge$ , e$
           sl, *refhtprint, *frplunge$, paf, sgcode, *refhtprint, e$
           gcode$ = 0
           if refhtprint <> inithtprint, sr, *inithtprint, paf sgcode, *inithtprint, e$
             ]
           if tete_rev = 0,
             [
        if drill5axes = 1,
                            [
                            pcaldrilxyzsimu
                            initht5x = refht$
							tosz$ = 0
                            sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht5x,",", *tosz$, ",",*sdis,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            #sm, paf, *xprint, *yprint, e$
                            psouf_imp
                            if  nextop$ <> 100, [
                                xprint = v_abs_plus_x_sec_fin
                                yprint = v_abs_plus_y_sec_fin
                                zprint = v_abs_plus_z_sec_fin
                                sm, paf, "MCALL", e$
                                sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                ]
                            ]

        else,   [
                    pcaldrilxyzsimu
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    gcode$ = 0
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    xprint = x$
                    yprint = y$
                    zprint = z$
                    sl, *xprint, *yprint, *zprint, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                    spaces$ = 1
                    xprint = v_abs_plus_x
                    yprint = v_abs_plus_y
                    zprint = v_abs_plus_z
                    sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                    ]
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]							
							]
#endregion
#region pbore2_2
pbore2_2$
#endregion
#region pbore1_2
pbore1_2$
#endregion
#region pmisc2_2
pmisc2_2$
		if type_pp = 1,	[ 
			pprint
            typcycle = 1
            if drill5axes = 1,[
                            pdrl5_2
                            initht5x = refht$
                            percage_helicoido_spiral_2

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, sgcode, *old_zinitht, e$
                             ]
           else, percage_helicoido_spiral_2
           old_dest_ret_5x = dest_ret_5x
            !x$, !y$, !z$, !xr$, !yr$, !zr$
			
						]
		if type_pp = 2,	[
           if rotaxtyp$ = 3, [
            pprint
            typcycle = 1
            if drill5axes = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2
                            initht5x = refht$
                           #xprint = 0
                            #yprint = 0
                            percage_helicoido_spiral_2

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht, paf, sgcode, *old_zinitht, e$
                             ]
           else, percage_helicoido_spiral_2
           old_dest_ret_5x = dest_ret_5x
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            pprint
            if drill5axes = 1, pdrl5_2
             if tete_rev = 1 & mod5xcont = 0,
              [
            @refhtprint , @inithtprint
           gcode$ = 0
           sr, *xprint, *yprint, *inithtprint, paf, sgcode, *xprint, *yprint, *inithtprint, e$
           if refhtprint <> inithtprint, sr, *refhtprint, paf, sgcode, *refhtprint, e$
           gcode$ = 1
           sl, *depthprint, *frplunge$, paf, sgcode, *depthprint, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint, paf, sgcode, *inithtprint, e$
             ]
           if tete_rev = 0,
                        [
                        if drill5axes = 1, [
                        pcaldrilxyzsimu
                        initht5x = refht$

                        sl, *xprint, *yprint, *zprint, *frplunge$, pafcom,"CYCLE CAQ", e$
                        spaces$ = 1
                        #sm, paf, *xprint, *yprint, e$
                        psouf_imp
                        if  nextop$ <> 100, [
                                    xprint = v_abs_plus_x_sec_fin
                                    yprint = v_abs_plus_y_sec_fin
                                    zprint = v_abs_plus_z_sec_fin
                                    sr, *xprint, *yprint, *zprint, paf, *xprint, *yprint, *zprint, e$
                                    ]
                        ]
        #else, sm, paf, xprint, yprint, e$, # depth$, refht$, initht$,e$
        else,   [
                pcaldrilxyzsimu
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                gcode$ = 0
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                xprint = x$
                yprint = y$
                zprint = z$
                sl, *xprint, *yprint, *zprint, *frplunge$, pafcom,"CYCLE CAQ", e$
                spaces$ = 1
                xprint = v_abs_plus_x
                yprint = v_abs_plus_y
                zprint = v_abs_plus_z
                sr, *xprint, *yprint, *zprint, paf, sgcode, *xprint, *yprint, *zprint, e$
                ]
        psouf_imp
        old_dest_ret_5x = dest_ret_5x
           ]
                    ]	
					]				
#endregion
#region pcanceldc
pcanceldc$
	if type_pp = 1,	[ 
			pprint
            zinitht = initht$
            if cycle_heli_spiral = 1, gcode$ = 0,
                [
                 cycle_heli_spiral = 0
                 gcode$ = 0
                 if drill5axes = 0, pnumligne, sgcode, *zinitht,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$
                ]
            else, [
                    if drill5axes = 0 & typcycle = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht,e$
                    if drill5axes = 0 & typcycle = 1, pnumligne, *zinitht,e$
                  ]
            typcycle = 0
            pdmodalxyz
				]
	if type_pp = 2,	[
			zinitht = initht$
            if cycle_heli_spiral = 1, gcode$ = 0,
                [
                 cycle_heli_spiral = 0
                 gcode$ = 0
                 if drill5axes = 0, sr, *zinitht, paf, sgcode, *zinitht,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes = 0 & typcycle = 1 & drillcyc$ <> 11, sm, paf, "MCALL",e$, sr, *zinitht, paf, *zinitht,e$
                    if drill5axes = 0 & typcycle = 1, sr, *zinitht, paf, *zinitht,e$
                  ]
            typcycle = 0
            pdmodalxyz	
	
					]
#endregion
#region pcancelcc
pcancelcc$
 	if type_pp = 1,	[
			pprint
             if cycle_heli_spiral = 1, gcode$ = 0,
                [
                 cycle_heli_spiral = 0
                  gcode$ = 0
                 if drill5axes = 0, pnumligne, sgcode, *zinitht,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes = 0 & typcycle = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht,e$
                  ]
            typcycle = 0
					]
	if type_pp = 2,	[
				pprint
             if cycle_heli_spiral = 1, gcode$ = 0,
                [
                 cycle_heli_spiral = 0
                  gcode$ = 0
                 if drill5axes = 0, sr, *zinitht, paf, sgcode, *zinitht,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes = 0 & typcycle = 1, sm, paf, "MCALL",e$, sr, *zinitht, paf, *zinitht, e$
                  ]
            typcycle = 0					
					]
					
#endregion
#region pnumop
pnumop      # numerotation des operations post-processees
             if op_id$ <> prvop_id, numop = numop + 1
#endregion
#endregion
#region   CYCLE SPECIAL HELICOIDO-SPIRAL
#region variables CYCLE SPECIAL HELICOIDO-SPIRAL
# ----------------------- DEBUT CYCLE SPECIAL HELICOIDO-SPIRAL ------------------------
#------------- DECLARATION DES VARIABLES via le cycle  ------------
fmt "Aval ou OPP=" 4 ava_opp                        # Determine si la fraise travail en avalant ou opposition
fmt "Diametre final=" 2 dia_final                   # diametre du trou programme 
fmt "Diametre ebauche=" 2 dia_ebauche               # diametre d'ebauche
fmt "Pas maximum en Z=" 2 pas_max_z                 # Pas maximum en Z
fmt "Pas maximum en XY=" 2 pas_max_xy               # Pas maximum en XY pour la spiral en fond de trou
fmt "Nb Tr de finition=" 4 nbe_tr_fin               # Nombre de tour pour passe de finition
fmt "F" 5 f_ent_cir                                 # avance en entree ciculaire au debut de l'helicoide
fmt "F" 5 f_int_hel                                 # avance de l'helicoide 
fmt "F" 5 f_spiral                                  # avance de la spiral
fmt "F" 5 f_int_fin                                 # avance sur la finition du trou
fmt "F" 5 f_sor_cir                                 # avance sur la sortie de la finition du trou
fmt "F" 5 f_base                                    # avance de base du cycle
fmt "Dis. entre perp=" 2 ent_perp                   # distance d'entree perpendiculaire au debut du cycle pour le G41
fmt "Gestion usure=" 4 cor_ray                      # ativation d'un G41 ou G42 suivant besoins
fmt "Nb Tr de finition de retour=" 4 nbe_tr_retour  # Nombre de tour pour la deuxieme passe de finition a l'opposer du sens de la premiere
fmt "Drl_prm1=" 2 drl_prm1$
fmt "Drl_prm2=" 2 drl_prm2$
fmt "Drl_prm3=" 2 drl_prm3$
fmt "Drl_prm4=" 2 drl_prm4$
fmt "Drl_prm5=" 2 drl_prm5$
fmt "Drl_prm6=" 2 drl_prm6$
fmt "Drl_prm7=" 2 drl_prm7$
fmt "Drl_prm8=" 2 drl_prm8$
fmt "Drl_prm9=" 2 drl_prm9$
fmt "Drl_prm10=" 2 drl_prm10$
#------------- DECLARATION DES VARIABLES pour calcul interne  ------------
fmt "X" 2 x_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Y" 2 y_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Z" 2 z_plan_securite                       # coordonee Z du plan de securite
fmt "Z" 2 z_profondeur                          # coordonee Z du fond du trou
fmt "X" 2 x_ent_cir                             # coordonee X du point du centre du cercle pour l'entre circulaire
fmt "R" 2 ray_ent_cir                           # rayon du cercle de l'entree circulaire
fmt "Nb pas Z =" 4 nbe_pas_z                    # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Nb de pas actuel" 4 nbe_pas_actu           # nombre de pas actuel
fmt "Pas Z=" 2 pas_z                            # valeur reel du pas de l'helice
fmt "Nb pas XY =" 2 nbe_pas_xy                  # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Pas XY=" 2 pas_xy                          # valeur reel du pas de la spiral
fmt "Nb de cercle" 2 nbe_demi_cercle            # nombre de demi cercle que constitue la spiral
fmt "R" 2 ray_sor_cir                           # rayon pour la sortie de la spiral
fmt "X" 2 x_sor_cir                             # coordonee X du point du centre du cercle pour la sortie circulaire
fmt "R" 2 ray_ebauche                           # rayon d'ebauche 
fmt "Sens" 4 sens_usi                           # sens de l'usinage, -1 = avalant, 1 = opposition et depend de la reponce: Avalant=0 Oppositon = 1
fmt "X" 2 old_xp_chs                            # ecriture d'un X dans le cycle Helicoedo-Spiral
fmt "I" 2 i_eb_cir                              # coordonee I centre du cercle de l'helicoide en relatif point de depart
fmt "J" 2 j_eb_cir                              # coordonee J centre du cercle en relatif point de depart
fmt "Diam" 2 diam_cercle                        # diametre du cercle d'un demi tours de spiral
fmt "X max dans le trou" 2 xp_chs_max           # coordoonee maxi dans le centre du trou
fmt "Ray_sortie" 2 ray_cercle_sortie            # Rayon de sortie sur la finition 
fmt "rap_ray_sortie=" 1 rapport_ray_sortie      # rapport muliplicateur du rayon de sortie
fmt "angle_ray_sortie" 1 angle_ray_sortie       # angle de balayage de la portion de cercle de la sortie
fmt "Nb spiral debut " 4 nb_tr_debut " tr"      # Nombre de spiral en debut
fmt "Nb spiral fin " 4 nb_tr_fin    " tr"       # Nombre de spiral en fin
fmt "Pas spiral debut-fin " 2 pas_Z_deb_fin " mm"       # Pas de la spiral d'entree et de fin  
fmt "haut spi debut" 2 prof_z_deb_spi           # calcul de la hauteur de la spiral de debut en ebauche
fmt "haut spi fin" 2 prof_z_fin_spi             # calcul de la hauteur de la spiral de fin en ebauche
fmt "helice total = " 2 hauteur_hel " mm"               # hauteur total de l'helicoide
fmt "Le cumul helice debut et fin = " 2 hauteur_hel_debfin " mm"
fmt "Ray_cercle ebauche" 2 ray_cercle_ebauche   # Rayon de sortie sur la finition 

#------------------ DECLARATIONS DE MESSAGE SI VALEURS NON CONFORMES-----------

sdcom : ";"
sfcom : ""
sdcom_par : "("
sfcom_par : ")"
#endregion
#region percage_helicoido_spiral_2
percage_helicoido_spiral_2      # ecriture generale du cycle special CAQ trou suivant
				
				if type_pp = 1,	[
								gcode$ = 0
                                xabs = xprint
                                yabs = yprint
                                zabs = initht$
                                pnumligne, *sgcode, *zabs, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs, *yabs, e$
                                percage_helicoido_spiral
								]
				if type_pp = 2,	[				
								gcode$ = 0
                                xabs = xprint
                                yabs = yprint
                                zabs = initht$
                                sr, *zabs, paf, *sgcode, *zabs, e$
                                sm, paf, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs, *yabs, paf, *xabs, *yabs, e$
                                percage_helicoido_spiral
								]
#endregion
#region percage_helicoido_spiral
percage_helicoido_spiral   # ecriture generale du cycle special CAQ        
				if type_pp = 1,	[
                            pcalcule_variable
                            #pvoir_variable
                            #ptest_variable
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut - prof_z_deb_spi
                                phase_2                                         # debut ebauche helicoide

                                z_dessus_brut = z_dessus_brut - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4         # premiere serie de passes de finition 
                                    ]
                                phase_5             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6         # entre ligne + cercle pour deuxiemme finition
                                    phase_7         # premiere serie de passes de deuxieme finition 
                                    phase_8         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2           # premiere serie de passes de finition 
                                phase_5_2           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2       # premiere serie de passes de deuxieme finition 
                                    phase_8_2       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
								]
				if type_pp = 2,	[
                            pcalcule_variable
                            #pvoir_variable
                            #ptest_variable
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut - prof_z_deb_spi
                                phase_2                                         # debut ebauche helicoide

                                z_dessus_brut = z_dessus_brut - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4         # premiere serie de passes de finition 
                                    ]
                                phase_5             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6         # entre ligne + cercle pour deuxiemme finition
                                    phase_7         # premiere serie de passes de deuxieme finition 
                                    phase_8         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2           # premiere serie de passes de finition 
                                phase_5_2           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2       # premiere serie de passes de deuxieme finition 
                                    phase_8_2       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
								]
#endregion
#region pvoir_variable
pvoir_variable        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction = ",z_retraction , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut =", z_dessus_brut, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$
#endregion
#region pcalcule_variable
pcalcule_variable       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            if drill5axes = 1, z_dessus_brut = drl_sel_tos$
                            else, z_dessus_brut = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin
                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable   # on test si toutes les variable sont OK 

                            cycle_heli_spiral = 1
                            xabs = xprint
                            yabs = yprint
                            zabs = zprint
                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp = xabs + ent_perp
                                #x_ent_cir = x_perp - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir = ray_ent_cir * -1 # + x_perp  # si I en ABS
                                x_sor_cir = xabs + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp = xabs - ent_perp
                                #x_ent_cir = x_perp +((dia_ebauche - tldia$)/2) 
                                i_ent_cir = ray_ent_cir # + x_perp  # si I en ABS
                                x_sor_cir = xabs - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable                          
#endregion
#region ptest_variable
#region ptest_variable
ptest_variable        # test sur les valeures rentrees et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                serreur_visu = serreur1 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                         if dia_final <=0,
                                [
                                serreur_visu = serreur2 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                         if hauteur_hel <= 0,
                                [
                                serreur_visu = serreur20 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                         if dia_ebauche <= 0,
                                [
                                serreur_visu = serreur3 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]
                        if dia_ebauche > dia_final,
                                [
                                serreur_visu = serreur4 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if dia_final < tldia$,
                                [
                                serreur_visu = serreur5 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if dia_ebauche < tldia$,
                                [
                                serreur_visu = serreur24 + no2str(numop)
                               result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]  

                        if pas_max_z <= 0,
                                [
                                serreur_visu = serreur7 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                serreur_visu = serreur8 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if nbe_tr_fin < 0,
                                [
                                serreur_visu = serreur9 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if f_ent_cir < 0,
                                [
                                serreur_visu = serreur10 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if f_int_hel < 0,
                                [
                                serreur_visu = serreur11 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if f_spiral < 0,
                                [
                                serreur_visu = serreur12 + no2str(numop)
                               	result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if f_int_fin < 0,
                                [
                                serreur_visu = serreur13 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if f_sor_cir < 0,
                                [
                                serreur_visu = serreur14 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                serreur_visu = serreur15 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                serreur_visu = serreur16 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                serreur_visu = serreur17 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if nbe_tr_retour < 0,
                                [
                                serreur_visu = serreur18 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if dia_ebauche < tldia$,
                                [
                                serreur_visu = serreur19 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if z_dessus_brut > z_retraction,
                                [
                                serreur_visu = serreur21 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if z_retraction > z_plan_securite,
                                [
                                serreur_visu = serreur21 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]
                        if drl_prm9$ < 0,
                                [
                                serreur_visu = serreur25 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]
                        if drl_prm10$ < 0,
                                [
                                serreur_visu = serreur26 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				exitpost$
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                serreur_visu = serreur27 + no2str(numop)
                                result = mprint(serreur_visu)
								erreur = 1
								if type_pp = 1,	[
												*serreur_visu, e$
                                				*nb_tr_debut, e$
                                				*nb_tr_fin, e$
                                				*pas_Z_deb_fin, e$
                                				*hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                				exitpost$ # abandonner
												]
                                if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral = 0 ,
                                [
                                serreur_visu = serreur23 + no2str(numop)
                                result = mprint(serreur_visu,2)
                                if result = 1,	[
												if type_pp = 1,	pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
												if type_pp = 2,	"MW_OP_COMMENT", sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
												]
                                if result = 2,  [
												if type_pp = 1,	*serreur_visu, erreur = 1, exitpost$ # abandonner
												if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, erreur = 1
												]
                                ]
#endregion                              
#endregion
#region PF
pf_base             # ecriture que si sup a 0
                        if f_base > 0,  [
                                        avance = f_base
                                        avance
                                        ]
######################################################                      
pf_ent_cir          # ecriture que si sup a 0
                        if f_ent_cir > 0,   [
                                            avance = f_ent_cir
                                            avance
                                            ]
######################################################
pf_int_hel          # ecriture que si sup a 0
                        if f_int_hel > 0,   [
                                            avance = f_int_hel
                                            avance
                                            ]
######################################################
pf_spiral           # ecriture que si sup a 0
                        if f_spiral > 0,    [
                                            avance = f_spiral
                                            avance
                                            ]
######################################################
pf_int_fin          # ecriture que si sup a 0
                        if f_int_fin > 0,   [
                                            avance = f_int_fin
                                            avance
                                            ]
######################################################
pf_sor_cir          # ecriture que si sup a 0
                        if f_sor_cir > 0,   [
                                            avance = f_sor_cir
                                            avance
                                            ]
#endregion
#region pcor_ray
pcor_ray_on         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
						if type_pp = 1,	[
                        				if sens_usi = 1, pnumligne,"G42",e$
                        				else, pnumligne,"G41",e$
										]
						if type_pp = 2,	[
                        				if sens_usi = 1, sm, paf,"G42",e$
                        				else, sm, paf,"G41",e$
										]				
                        ]
######################################################
pcor_ray_on_inv         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
						if type_pp = 1,	[
                        				if sens_usi = 1, pnumligne,"G41",e$
                        				else, pnumligne,"G42",e$
										]
                        if type_pp = 2,	[
                        				if sens_usi = 1, sm, paf,"G41",e$
                        				else, sm, paf,"G42",e$
										]
						]
######################################################
pcor_ray_off            # ecriture d'un G41 ou G42 si besoin
                        if type_pp = 1,	[
										if cor_ray = 1, pnumligne,"G40",e$
										]
						if type_pp = 2,	[
										if cor_ray = 1, sm, paf,"G40",e$
										]				
#endregion
#region phase_1
phase_1                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, sgcode, *z_retraction, e$
                        gcode$ = 1
                        pnumligne, sgcode, *z_dessus_brut, pf_base,  e$
                        pcor_ray_on
                        pnumligne, sgcode, *x_perp, pf_ent_cir, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs = x_perp - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs = x_perp + (ray_ent_cir*2)
                                ]
                        yp_chs = yabs
                        j_ent_cir = 0 # si J en INC
                        #j_ent_cir = y$ # si J en ABS                   
                        pnumligne, *sgcode,xp_chs,yp_chs, i_ent_cir, j_ent_cir, e$
#endregion
#region phase_1_2
phase_1_2              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, sgcode, *z_retraction, e$
                            gcode$ = 1
                            pnumligne, sgcode, *z_dessus_brut, pf_base,  e$
                            #pcor_ray_on
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_dessus_brut
                            if sens_usi = 1,
                                [

                                xp_chs = xabs - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_ent_cir,pcor_ray_on, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_ebauche - tldia$) /2)
                                ip_chs = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_ent_cir , e$
                                ]
                            else,
                                [

                                xp_chs = xabs + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_ent_cir, pcor_ray_on, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs + (( dia_ebauche - tldia$) /2)
                                ip_chs = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_ent_cir , e$
                                ]
#endregion
#region phase_2
phase_2                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_dessus_brut
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs = xp_chs + ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir
                                zp_chs = zp_chs - ( pas_z / 2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                xp_chs = xp_chs - ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs = z_profondeur
                                else, zp_chs = zp_chs - ( pas_z / 2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs = xp_chs - ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir * -1
                                zp_chs = zp_chs - ( pas_z / 2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                xp_chs = xp_chs + ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs = z_profondeur
                                else, zp_chs = zp_chs - ( pas_z / 2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                ]
                            ]
#endregion
#region phase_3
phase_3                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs-xp_chs)*2) + (pas_xy)
                                xp_chs = xp_chs + diam_cercle
                                ip_chs = (diam_cercle/2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs-xabs)*2) + (pas_xy)
                                xp_chs = xp_chs - diam_cercle
                                ip_chs = (diam_cercle/2) * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs-xabs)*2) #+ (pas_xy/2)
                                xp_chs = xp_chs - diam_cercle
                                ip_chs = (diam_cercle/2) * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs-xp_chs)*2) + (pas_xy)
                                old_xp_chs = xp_chs
                                xp_chs = xp_chs + diam_cercle
                                if xp_chs > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs = xp_chs_max
                                    ]
                                ip_chs = (diam_cercle/2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs- xp_chs)*2) #+ (pas_xy/2)
                                xp_chs = xp_chs + diam_cercle
                                ip_chs = (diam_cercle/2)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs-xabs)*2) + (pas_xy)
                                old_xp_chs = xp_chs
                                xp_chs = xp_chs - diam_cercle
                                if xp_chs < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs = xp_chs_max
                                    ]
                                ip_chs = (diam_cercle/2) * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            ]
#endregion
#region phase_4
phase_4             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]
#endregion
#region phase_4_2
phase_4_2               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]
#endregion
#region phase_5
phase_5             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
                            else,
                                [
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
#endregion
#region phase_5_2
phase_5_2               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
                            else,
                                [
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
#endregion
#region phase_6
phase_6                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, *sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs + ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
#endregion
#region phase_6_2
phase_6_2               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs = xabs - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, *sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e )  
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                pnumligne, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs + ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
#endregion
#region phase_7
phase_7                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1

                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)

                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]
#endregion
#region phase_7_2
phase_7_2                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)

                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]
#endregion
#region phase_8
phase_8             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
#endregion
#region phase_8_2
phase_8_2               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120e ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                pnumligne, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                pnumligne, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
#endregion
# ------------------------ FIN CYCLE SPECIAL HELICOIDO-SPIRAL -------------------------
#endregion
#region   CYCLE SPECIAL percage decompose
#region variables CYCLE SPECIAL percage decompose
# ------------------------ debut  CYCLE SPECIAL percage decompose -------------------------

#-------- ecriture des format -------------
fmt "F" 4 avance_1
fmt "F" 4 avance_2
fmt "F" 4 avance_3
fmt "F" 4 avance_4
fmt "F" 4 avance_5
fmt "ABS_REL" 4 abso_rel
fmt "sortie" 4 sortie_cycle_prof
#endregion
#region pvoirvariable_2
pvoirvariable_2   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1 = ",prof_1, e$
                            "voir prof_2 = ",prof_2, e$
                            "voir prof_3 = ",prof_3, e$
                            "voir prof_4 = ",prof_4, e$
                            "voir prof_5 = ",prof_5, e$
                            "voir tempo_1 = ",*tempo_1, e$
                            "voir tempo_2 = ",*tempo_2, e$
                            "voir tempo_3 = ",*tempo_3, e$
                            "voir tempo_4 = ",*tempo_4, e$
                            "voir tempo_5 = ",*tempo_5, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction = ",z_retraction, e$
#endregion
#region pcalcule_variable_2
pcalcule_variable_2       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1 = drl_prm1$
                            prof_2 = drl_prm2$
                            prof_3 = drl_prm3$
                            prof_4 = drl_prm4$
                            prof_5 = drl_prm5$
                            tempo_1 = (frac(drl_prm6$)) * 10
                            tempo_2 = (frac(drl_prm7$)) * 10
                            tempo_3 = (frac(drl_prm8$)) * 10
                            tempo_4 = (frac(drl_prm9$)) * 10
                            tempo_5 = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel =  prof_1 + tosz$
                            prof_2_rel = prof_2 + prof_1_rel
                            prof_3_rel = prof_3 + prof_2_rel
                            prof_4_rel = prof_4 + prof_3_rel
                            prof_5_rel = prof_5 + prof_4_rel

                            #pvoirvariable_2


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                serreur_visu = serreur100 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner
                                erreur = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                serreur_visu = serreur101 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner
                                erreur = 1
                               ]

                            if prof_1 = 9999,
                                [
                                serreur_visu = serreur102 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                erreur = 1
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5
#endregion
#region percage_avance_controle_2
percage_avance_controle_2

                                gcode$ = 0

                                xabs = xprint
                                yabs = yprint
                                zabs = initht$
                                if drill5axes <> 1,
                                [
                                pnumligne, sgcode, *zabs, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs, *yabs, e$
                                ]
                                percage_avance_controle
#endregion
#region percage_avance_controle
percage_avance_controle    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2
                            gcode$ = 0
                            pnumligne, sgcode, zabs, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                pnumligne, sgcode, prof_1, pfr,  e$
                                if tempo_1 > 0, pnumligne, *tempo_1, e$

                                if prof_2 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, sgcode, prof_2, pfr,  e$
                                        if tempo_2 > 0, pnumligne, *tempo_2, e$
                                        ]
                                if prof_3 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, sgcode, prof_3, pfr,  e$
                                        if tempo_3 > 0, pnumligne, *tempo_3, e$
                                        ]
                                if prof_4 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, sgcode, prof_4, pfr,  e$
                                        if tempo_4 > 0, pnumligne, *tempo_4, e$
                                        ]
                                if prof_5 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, sgcode, prof_5, pfr,  e$
                                        if tempo_5 > 0, pnumligne, *tempo_5, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                pnumligne, sgcode, prof_1_rel, pfr,  e$
                                if tempo_1 > 0, pnumligne, *tempo_1, e$

                                if prof_2 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        pnumligne, sgcode, prof_2_rel, pfr,  e$
                                        if tempo_2 > 0, pnumligne, *tempo_2, e$
                                        ]
                                if prof_3 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        pnumligne, sgcode, prof_3_rel, pfr,  e$
                                        if tempo_3 > 0, pnumligne, *tempo_3, e$
                                        ]
                                if prof_4 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        pnumligne, sgcode, prof_4_rel, pfr,  e$
                                        if tempo_4 > 0, pnumligne, *tempo_4, e$
                                        ]
                                if prof_5 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        pnumligne, sgcode, prof_5_rel, pfr,  e$
                                        if tempo_5 > 0, pnumligne, *tempo_5, e$
                                        ]

                                 ]
#endregion
#endregion
#region   CYCLE de palpage de bague
#region palpage de bague
# ------------------------ debut  CYCLE de palpage de bague -------------------------

#-------- ecriture des format -------------

fmt "R10=" 2 R10
fmt "R11=" 2 R11
fmt "R12=" 2 R12
fmt "R15=" 2 R15
fmt "R16=" 2 R16
fmt "R17=" 2 R17
fmt "R18=" 2 R18
fmt "Z=R12+" 2 zdecpalp

palpagebague  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur, psortie8
                gcode$ = 0
                R10 = xprint
                R11 = yprint
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche = refht$
                #pnumligne, "; Mise à zero des valeurs de decalage fin du G54", e$
                #pnumligne, "R15=-1", e$
                #pnumligne, "PALPBAGUE", e$
                #pnumligne, poriusi, e$
                #pnumligne, "; Fin de mise à zero des valeurs de decalage fin du G54", e$
                pnumligne, poriusi, e$
                pnumligne, "D1", e$
                pnumligne, R10, "; (mm) : Position theorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position theorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position theorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diametre interieur de la bague",e$
                pnumligne, R16, "; (mm) : Decalage sur diametre pour palpage en Z", e$
                pnumligne, R17, "; (e) : Decalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Decalage de profondeur e l'interieur du trou", e$
                #pnumligne, sgcode, *zaproche, e$
                pnumligne, "PALPBAGUE", e$
				pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, poriusi, e$
#endregion              
#region pdrlcst
pdrlcst$
                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur, psortie7
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev = 1, psortie
                        pprint
                        typcycle = 1
                        if drill5axes = 1,
                        [
                         pdrl5
                         initht5x = refht$
                         percage_avance_controle
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, sgcode, *old_zinitht, e$
                  ]
                    else, percage_avance_controle
                    old_dest_ret_5x = dest_ret_5x
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev = 1, psortie
                        pprint
                        typcycle = 1
                        if drill5axes = 1, psortie6
                        palpagebague
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pdrlcst_2
pdrlcst_2$
                if drl_cycle$ = 9,
                [
                        pprint
                        typcycle = 1
                        if drill5axes = 1,
                        [
                            pdrl5_2
                            initht5x = refht$
                            percage_avance_controle_2
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, sgcode, *old_zinitht, e$
                         ]
                else, percage_avance_controle_2
                old_dest_ret_5x = dest_ret_5x
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9
#endregion
#endregion
#region   psouf_imp
#region psouf
#----------------------------cycle fixes----------------------------------------------


fmt "" 4 retard_enclenchement
fmt "" 4 duree_enclenchement
psouf_imp       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    serreur_visu = serreur201 + no2str(numop)
                                    result = mprint(serreur_visu)
									erreur = 1
									if type_pp = 1,	[
													*serreur_visu, e$
                                    				exitpost$
													]
                                    if type_pp = 2,	"MW_OP_COMMENT", *serreur_visu, e$
                                    ]
                                    spaces$ = 0
                                    if type_pp = 1, pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
									if type_pp = 2, sm, paf, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]
#endregion                                  
#region pvoir
stl_mfg_com : ""       # 'tool mfg comment' from tool
stl_chuck_com : ""     # 'tool chuck comment' from tool
snomoutil : ""          # nom outil suite bug que strtool prend pas les points
pvoir     # voir les position de percage
            vec_reel_x = tox4print - drl_init_x$
            vec_reel_y = toy4print - drl_init_y$
            vec_reel_z = toz4print - drl_init_z$
            dest_ret_5x = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$
#endregion
#endregion
#region   PPARAMETER
#region pwrttparam
fmt "" 4 avance01
fmt "" 4 avance02
fmt "" 4 avance03
fmt "" 4 avance04
fmt "" 4 avance05
fmt "" 4 avance06
fmt "" 4 avance07
fmt "" 4 avance08
fmt "" 4 avance09
fmt "" 4 avance010
fmt "" 4 avance011
fmt "" 4 avance012
fmt "" 4 avance013
fmt "" 4 avance014
fmt "" 4 avance015
fmt "" 4 avance016
fmt "" 4 avance017
fmt "" 4 avance018
fmt "" 4 avance019
fmt "" 4 avance020
fmt "" 4 avance021
fmt "" 4 avance022
fmt "" 4 avance023
fmt "" 4 avance024
fmt "" 4 avance025
fmt "" 4 avance026
fmt "" 4 avance027
fmt "tol" 2 tol_usinage
fmt "tol" 2 tol_usinage_5X

ptolerance
			
			!tol_usinage
			!tol_usinage_5X
			#"voir tol_usinage", *tol_usinage, e$
			#"voir tol_usinage_5X", *tol_usinage_5X, e$
			#"voir opcode", *opcode$, e$
			#"voir nextop", *nextop$, e$
			if opcode$ = 3 | opcode$ = 16,	[
											#spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"0",sentre_cote, ")", e$, spaces$ = 1
											]
			else,	[
					if nextop$ <> 11,	[
										if tol_usinage > 0 & tol_usinage <= 0.02, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"3",sentre_cote, ")", e$, spaces$ = 1
										if tol_usinage > 0.02 & tol_usinage <= 0.05, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"2",sentre_cote, ")", e$, spaces$ = 1
										if tol_usinage > 0.05, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"1",sentre_cote, ")", e$, spaces$ = 1
										]
								else,	[				
										if tol_usinage_5X > 0 & tol_usinage_5X <= 0.02, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"3",sentre_cote, ")", e$, spaces$ = 1
										if tol_usinage_5X > 0.02 & tol_usinage_5X <= 0.05, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"2",sentre_cote, ")", e$, spaces$ = 1
										if tol_usinage_5X > 0.05, spaces$ = 0, pnumligne, " DYNSET(",sentre_cote,"1",sentre_cote, ")", e$, spaces$ = 1
										]					
					]
pwrttparam$
			#~prmcode$, "=", sparameter$, e$ 
			if prmcode$ = 1051, smachine = sparameter$
            if prmcode$ = 20007, paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
            if prmcode$ = 20001, snomoutil = sparameter$ #Save string for output later
            if prmcode$ = 20002, stl_mfg_com = sparameter$ #Save string for output later
            if prmcode$ = 12727, stl_chuck_com = sparameter$ #Save string for output laterl 
            if prmcode$ = 10006, rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
			if prmcode$ = 20004, avance01 = rpar(sparameter$, 27)
			if prmcode$ = 12553, tol_usinage = rpar(sparameter$, 1) 
			if prmcode$ = 10204, tol_usinage_5X = rpar(sparameter$, 1) 
#endregion
#region pparameter
pparameter$
			#~prmcode$, "=", sparameter$, e$                # pour afficher tous les parametres
			if prmcode$ = 15346, compensation_rayon = rpar(sparameter$, 1)
			if prmcode$ = 20007, paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
            if prmcode$ = 20001, snomoutil = sparameter$ #Save string for output later
            if prmcode$ = 20002, stl_mfg_com = sparameter$ #Save string for output later
            if prmcode$ = 12727, stl_chuck_com = sparameter$ #Save string for output later
            if prmcode$ = 10006, rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation              
			if prmcode$ = 20010, scsplane = sparameter$
			if prmcode$ = 20012, stlplane = sparameter$
			if prmcode$ = 20014, swcsplane = sparameter$
		 	if prmcode$ = 1051, smachine = sparameter$
			if prmcode$ = 20004, avance01 = rpar(sparameter$, 27) 
			if prmcode$ = 12553, tol_usinage = rpar(sparameter$, 1) 
			if prmcode$ = 10204, tol_usinage_5X = rpar(sparameter$, 1)
			if prmcode$ = 10024, zcloche = rpar(sparameter$, 1) 
			if prmcode$ = 10025, zcloche_inc = rpar(sparameter$, 1) 
			if prmcode$ = 10027, zbrut = rpar(sparameter$, 1) 
			if prmcode$ = 10028, zbrut_inc = rpar(sparameter$, 1) 
#endregion
#region pecriture_bl_master
pecriture_bl_master   # ecriture de la routine bl master en liste outil 
            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              
            if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                   	#if type_pp = 1, " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
									#if type_pp = 2, sm, paf, " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
           else,
                                    [
                                    spaces$ = 0
                                   	#if type_pp = 1, " ; BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    #if type_pp = 2, sm, paf, " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
									spaces$ = 1
                                    ]
             spaces$ = 1                                                      
#endregion
#region pwrtt
pwrtt$
            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0,	[
						if type_pp = 1,	pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, 34,")", e$								
            			if type_pp = 2, sm, paf,  "MSG(",34, t$, snomoutil, stl_chuck_com, 34,")", e$			
						]
			if t$ > 0, lastopid = op_id$	

#endregion  
#region ptransreal
fmt 2 trans_num_prg
trans_num_prg : 0
fmt 2 prem_passage_ptrans
prem_passage_ptrans : 0
fmt 2 compteur_passage_trans
compteur_passage_trans : 0
ptransreal$

		if prem_passage_ptrans = 0, trans_num_prg = trans_mr1$, prem_passage_ptrans = 1
		compteur_passage_trans = compteur_passage_trans + 1
#endregion
#endregion
#[ENDBIN]
#region   VALEURS OPTIONNELLES
# --------------------------------------------------------------------------
# Numbered questions for Mastercam --  Used by Mill 7
# --------------------------------------------------------------------------
38. Rapid feedrate? 20000.0
1538. Rapid feedrate (metric)? 10000.0

80. Communications port number for receive and transmit (1 or 2) ? 2
81. Data rate (110,150,300,600,1200,2400,4800,9600,14400,19200,38400)? 9600
82. Parity (E/O/N)? E
83. Data bits (7 or 8)? 7
84. Stop bits (1 or 2)? 2
85. Strip line feeds? N
86. Delay after end of line (seconds)? 0
87. Ascii, Eia, or Binary (A/E/B)? A
88. Echo keyboard to screen in terminal emulation? n
89. Strip carriage returns? N
90. Drive and subdirectory for NC files?
91. Name of executable post processor? MP
92. Name of reverse post processor? RP
93. Reverse post PST file name?
100. Number of places BEFORE the decimal point for sequence numbers? 3
101. Number of places AFTER the decimal point for sequence numbers? 0
103. Maximum spindle speed? 5000
107. Average time for tool change (seconds)? 2.0

159. Show first and last position as fully compensated in simulation? n

160. Display first and last entity in toolpath when simulating cutter compensation in control? y
161. Enable Home Position button? y
162. Enable Reference Point button? N
163. Enable Misc. Values button? Y
164. Enable Rotary Axis button? N
165. Enable Tool Plane button? N
166. Enable Construction Plane button? Y
167. Enable Tool Display button? N

# --------------------------------------------------------------------------
# Default Miscellaneous Real Values
# --------------------------------------------------------------------------
201. valeur de recul en 5 axes cont (mr1)? 199.0
202. plan de retournement en 5 axes cont (mr2)? 1500.0
203. Default miscellaneous real variable 3 (mr3)? 1500.0
204. Default miscellaneous real variable 4 (mr4)? 0.0
205. Default miscellaneous real variable 5 (mr5)? 0.0
206. Default miscellaneous real variable 6 (mr6)? 0.0
207. Default miscellaneous real variable 7 (mr7)? 180.0
208. DECALAGE X                            (mr8)? 0.0
209. DECALAGE Y                            (mr9)? 0.0
210. DECALAGE Z                            (mr10)? 0.0

# --------------------------------------------------------------------------
# Valeurs reelles par defaut (METRIQUE)
# --------------------------------------------------------------------------
1601. Default miscellaneous real variable 1 (mr1) (metric)? 199.0
1602. Default miscellaneous real variable 2 (mr2) (metric)? 1500.0
1603. Default miscellaneous real variable 3 (mr3) (metric)? 1500.0
1604. Default miscellaneous real variable 4 (mr4) (metric)? 0.0
1605. Default miscellaneous real variable 5 (mr5) (metric)? 0.0
1606. Default miscellaneous real variable 6 (mr6) (metric)? 0.0
1607. Default miscellaneous real variable 7 (mr7) (metric)? 180.0
1608. Default miscellaneous real variable 8 (mr8) (metric)? 0.0
1609. Default miscellaneous real variable 9 (mr9) (metric)? 0.0
1610. Default miscellaneous real variable 10 (mr10) (metric)? 0.0

# --------------------------------------------------------------------------
# Activer/desactiver les commutateurs de variables reelles
# --------------------------------------------------------------------------
1611. Enable miscellaneous real variable 1? y
1612. Enable miscellaneous real variable 2? y
1613. Enable miscellaneous real variable 3? y
1614. Enable miscellaneous real variable 4? y
1615. Enable miscellaneous real variable 5? y
1616. Enable miscellaneous real variable 6? y
1617. Enable miscellaneous real variable 7? y
1618. Enable miscellaneous real variable 8? y
1619. Enable miscellaneous real variable 9? y
1620. Enable miscellaneous real variable 10? y


# --------------------------------------------------------------------------
# Default Miscellaneous Integer Values
# --------------------------------------------------------------------------
301. tour de plus en 5 axes continue 1 ou -1 (mi1)? 0
302. commance en A- en 5 axes continue (mi2)? 0
303. Miscellaneous integer variable 4 (mi3)? 1
304. Miscellaneous integer variable 4 (mi4)? 0
305. Miscellaneous integer variable 5 (mi5)? 0
306. Miscellaneous integer variable 6 (mi6)? 0
307. Miscellaneous integer variable 7 (mi7)? 0
308. decalage en x (mi8)? 0
309. decalage en y (mi9)? 0
310. decalage en z (mi10)? 0

# --------------------------------------------------------------------------
# Activer/desactiver les commutateurs de variables entieres
# --------------------------------------------------------------------------
1621. Enable miscellaneous integer variable 1? y
1622. Enable miscellaneous integer variable 2? y
1623. Enable miscellaneous integer variable 3? y
1624. Enable miscellaneous integer variable 4? y
1625. Enable miscellaneous integer variable 5? y
1626. Enable miscellaneous integer variable 6? y
1627. Enable miscellaneous integer variable 7? y
1628. Enable miscellaneous integer variable 8? y
1629. Enable miscellaneous integer variable 9? y
1630. Enable miscellaneous integer variable 10? y


# --------------------------------------------------------------------------
# Configuration File association parameters (default is "y")
# --------------------------------------------------------------------------
#400. Name of associated cfg file? 
401. Read SYSTEM COLORS section? y
402. Read ALLOCATIONS section? y
403. Read TOLERANCES section? y
404. Read DATA PATHS section? y
405. Read COMMUNICATIONS section? y
406. Read DRAFT SETTINGS section? y
407. Read MISCELLANEOUS section? y
408. Read NC SETTINGS section? y
409. Read DIALOG SCRIPTS section? y
410. Read DESIGN SETTINGS section? y
411. Read PLOTTER SETTINGS section? y
412. Read ALT-KEY ASSIGNMENTS section? y
413. Read CAD section? Y
414. Read START/EXIT section? Y
415. Read SCREEN section? Y
416. Read FILE NAMES section? Y

1500. Chook to execute from 'Misc. values' button?
1501. Insert parameter information in the ascii NCI? n
1502. Write operation information to binary file (.ops)? n
1503. Write transform operations (0=transform ops, 1=source ops, 2=both)? 1

1520. Display a warning when cutter compensation in control simulation finds an error? n

1521. Number of controller look-ahead blocks for CDC in control? 2

1530. Ignore work offset numbers when processing subprograms? y
1531. Ignore contour flags when processing subprograms? y

# Do NOT manually change the answer for Q.1999 !
1999. Product major version number that post supports? 9

3001. Machine acceleration? 2
3002. timing size? .1

[CTRL_MILL|3X_9114_2016_12]
[misc integers]
1. ""
2. ""
3. ""
4. "MI4: Cloche=1 0=Aspi. 9=Rien."//1
5. ""
6. ""
7. ""
8. "MI8: Dynamique de la machine."
9. ""
10. "MI10: Arrêt avant opération."
[misc reals]
1. "MR1: Correcteur dyn de long outil."
2. ""
3. ""
4. "MR4: Hauteur cloche"
5. "MR5: Valeur de filtrage 5X."
6. ""
7. "MR7: Angle Maximum avec G9 (-1 = sans)."//-1.//-1.
8. "MR8: Décalage en X."
9. "MR9: Décalage en Y."
10. "MR10: Décalage en Z."
[simple drill]
1. "PERCAGE SIMPLE"
2. "Avance"
3. ""
4. "Plan de sécurité"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "PERCAGE DEBOURRAGE"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[chip break]
1. "PERCAGE BRISE COPEAU"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[tap]
1. "TARAUDAGE"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Pas spécial"
11. ""
[bore1]
1. "ALESAGE"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "ALESAGE INDEXE"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Nombre de passes"
11. ""
[misc1]
1. "PERCAGE/ALESAGE (RETOUR ARRETE)"
2. "Avance"
3. "Tempo DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. ""
8. ""
9. "Avance retour RFF "
10. ""
11. ""
[misc2]
1. "PERCAGE CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
7. "Avalant=0 Oppo=1"
8. "Diamétre final"
9. "Diamétre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "PERCAGE DECOMPOSE"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 12]
1. "PALPAGE BAGUE"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Diam Inter Bague"
8. "Décalage Palp. Ray."
9. "Décalage angulaire"
10. "Profondeur de palpage "
11. ""
[drill cycle 13]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 14]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 15]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 16]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 17]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 18]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 19]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 20]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[simple drill custom parameters]
1. "Paramètres percage G81"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[peck drill custom parameters]
1. "Paramètres debourage G83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[chip break drill custom parameters]
1. "Paramètres de brise copeau 83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[tap custom parameters]
1. "Non Utilisé"
[bore1 custom parameters]
1. "Paramètres Percage/alesage G85"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle spécial 7"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoido-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoidale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
7. "Divers 1"
8. "Divers 2"
9. "Cycle #9"
10. "Percage decomposé"
11. "Cycle #11"
12. "Palpage bague"
13. "Cycle #13"
14. "Cycle #14"
15. "Cycle #15"
16. "Cycle #16"
17. "Cycle #17"
18. "Cycle #18"
19. "Cycle #19"
20. "Cycle #20"
[canned text]
1. "BRIDER LA PIECE AVEC VIS"
2. "OTER LES VIS"
3. "BRIDER LA PIECE AVEC SERRE-JOINTS"
4. "OTER SERRE-JOINTS"
5. "OTER LES CHUTES"
6. "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
7. "NETTOYER LES PORTEES DES RENVOIS"
8. "-"
9. "-"
10. "-"
11. "-"
12. "-"
13. "-"
14. "-"
15. "-"
16. "-"
17. "-"
18. "-"
19. "-"
20. "-"
21. "-"
22. "-"
23. "-"
24. "-"
25. "-"
26. "-"
27. "-"
28. "-"
29. "-"
30. "-"
31. "-"
32. "-"
33. "-"
34. "-"
35. "-"
36. "-"
37. "-"
[tool parameters]
9. "Eau - Air - Aspi"
[transform operation]
1. " "
2. " "
3. " "
4. " "
5. "MR1: N° de PRG (%XXXX)."
6. " "
7. " "
8. " "
[CTRL_TEXT_END]
#endregion
