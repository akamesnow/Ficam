[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V19.00 P0 E1 W19.00 T1442758080 M19.00 I0 O0
# ---------------------------------------------------------------------------------------------------------
# -   POST PRO FRAISAGE 3 ET 4 AXES AUTOUR DE X OU Y                                                      -
# -   SOUS PROG EN Z en ABSOLUE et INCREMENTAL                                                            -
# ---------------------------------------------------------------------------------------------------------
# -   Version 5.0                                                                                         -
# ---------------------------------------------------------------------------------------------------------
# -   Affichage des Surep R et L et 3D                                                                    -
# -   Affichage des type de corections                                                                    -
# ---------------------------------------------------------------------------------------------------------
# -       MASTERCAM 2017 F.I.CAM                                                                          -
# ---------------------------------------------------------------------------------------------------------
# - Réalisé le      : 20/06/2011  Par : ED
# - Pour la société : composite aquitaine
# - Armoire CN      : PA8000LX/NT PoWer automation  
# - Nom MACHINE     :  Charly-pro
# ---------------------------------------------------------------------------------------------------------
# -                                           -
# ---------------------------------------------------------------------------------------------------------
# -   DESCRIPTION DES MODIFICATIONS           -
# affichage du descripteur de fichier meme si pas question entete
# ajout de l'info groupe ou non
# mi10 utilisé pour ajuster les avances sur les arc 0=NON 1=Ralentir 2=Accélérer 3=les Deux
# modification de la gestions des degagement machine en fonction des flag de reglage PST
# mi1 utilisé pour ne pas degager en Z avant rotation plateau
# mi2 utilisé pour ne pas bloquer le diviseur
# Workof (néde Décalage) de 54 a 59  (0 pour 54 1 pour 55 etc...) et 59.1P1 P2 apres
# ecriture des parametres dans NCI et du fichier OPS (pour lire les infos de surep)
# creation des bloc pour afficher les surep
# creation de l'affichage des types de correction
# gestion du pmx en 4 axes
# lecture de la def armoire pour :
#                   l'extension de l'iso
#                   les arcs 
#                   les commentaires
#                   la preparation de l'outil suivant
# Lecture de la def machine pour :
#                   Le nom de la machine
#                   Le nombre d'axes rotatif (1 seul supporté)
#                   Le sens de rotation de l'axe rotatif
#                   Le nom de l'axe rotatif (ABC)
#                   L'avance Maxi et Mini de la machine
# le 23 - 7 - 2012 => integration cycle percage Helicoido-spiral suivant CA 1603 indice A001 
# le 28 - 11 - 2012 = > revision 2 cycle caq triple spiral + debut goute d'eau 
# ---------------------------------------------------------------------------------------------------------



#---------------------------------------------------------------------------------------------------------
#            REGLAGES DU PST
#

inc_degage  : 0       # degagement machine  1 en INCREMENTAL (G91) ou 0 en ABSOLUE (G90)
sdegageZ    : "H0Z0"  # Degagement en Z pour appel outil et changement de position 4eme axe
sdegageY    : "Y0"    # Degagement en Y pour appel outil
sdegageX    : "X0"    # Degagement en X pour appel outil et changement de position 4eme axe
smodedeg    : "G53"   # Mode de degagement des axes G28 G53

deg_debut   : 0       # Degager aux debut de prog               0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY 
deg_outil   : 0       # Degager aux changement outil            0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY 
deg_4axe    : 0       # Degager aux changement position 4eme axe  0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY 
deg_fin     : 0       # Degager en fin de programme             0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY 

stringtxt1 : "$ BRIDER LA PIECE AVEC VIS"
stringtxt2 : "$ OTER LES VIS"
stringtxt3 : "$ BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4 : "$ OTER LES SERRE-JOINTS"
stringtxt5 : "$ OTER LES CHUTES"
stringtxt6 : "TEXTE6"
stringtxt7 : "TEXTE7"
stringtxt8 : "TEXTE8"
stringtxt9 : "TEXTE9"
stringtxt10 : "TEXTE10"

sdegage_z : "( la on ecrit a la ligne 73 du pp ce que l'on veut pour degager en z )"
sdegage_xy : "( la on ecrit a la ligne 74 du pp ce que l'on veut pour degager en xy )"

sdebut_prog : " ( LA on ecrit a la ligne 76 du pp ce que l'on veut en debut de programme )"
sfin_prog : " ( LA on ecrit a la ligne 77 du pp ce que l'on veut en fin de programme )"

numcoment   : 1     # Numeroter les lignes de commentaire 0 = nom 1 = oui
numsprog    : 1     # Numeroter les lignes de sous programme 0 = nom 1 = oui
info_corr   : 1     # afficher le type de correction
info_surep  : 1     # afficher les surepaisseurs xy et z
info_outil  : 1     # afficher les info sur l'outil
info_groupe : 1     # afficher les noms des groupe d'usinage
outil_apres : 0     # preparation outil suivant juste apres appel outil : 0  - preparation outil suivant avec premier placement : 1
use_progno  : 0     # Ecrire le NC sous forme O0123.nc  = 1 ou TOTO.NC = 0
entete      : 0     # Poser les question pour l'entete
tooltable$  : 1     # creation liste outil en entete 
use_bloque  : 1     # pour ecrire M10 M11 (blocage diviseur)    :0 pour ne pas ecrire M10 M11
avance_arc  : 0     # ajuster les avances sur les arcs en correction usure ou ordinateur 0 = nom 1 = oui (utilise avance mxi et mini de la def machine)
fmini       : 1     # avance mini machine en travail
fmaxi       : 5000  # avance maxi machine en travail
nbroutil    : 0     # nombre d'outil de la machine pour ajout au D (0 pour T1 D1 - 30 pour T1 D31)
#------------------------------------------------------------------------------------------------------------------
#   UTILISER LES CYCLES MACHINE ou DECOMPOSITION en G1 G0
#

usecandrill$ : yes$   # utiliser cycle percage lamage
usecanpeck$  : yes$   # utiliser cycle debourrage
usecanchip$  : yes$   # utiliser cycle brise copeaux
usecantap$   : yes$   # utiliser cycle taraudage
usecanbore1$ : yes$   # utiliser cycle alesage a l'alesoir
usecanbore2$ : yes$   # utiliser cycle alesage a la barre
usecanmisc1$ : no$    # utiliser cycle divers 1
usecanmisc2$ : no$    # utiliser cycle divers 2



#--------------------------------------------------------------------------------------------------------
#   DEBUG POST PRO   
bug1$     : 2       # 0 = pas voir le NC  1 = Visu du NC en lecture - 2 = visu du NC en edit
bug2$     : 70      # numéro de colonne pour l'affichage du bloc en cour de traitement
bug3$     : 0       # whatline 01234 etat de l'usinage0 debut prog 1 prapid 2 pzrapid 3 mouvement frplung 4 fin 
bug4$     : 1       # numero de ligne du nci traité
whatno$   : yes$    # Ignore whatline branches to plin1 etc.?

#--------------------------------------------------------------------------------------------------------
#   TOLERANCES POST PRO   
linktolvar$    : 1  #Associer les variables de tolérance X metrique au variable english
#linklvar$  :1      # ULISLIDE LES USECANDRIL POUR LES LCANDRILL
linkplnvar$    : 0  #Associer les variables spécifiques plan Xy POUR TOUS LES PLAN YZ XZ 
linklvar$      : 1  #Associer les variables spécifiques X Tournage AU FRAISAGE ULISISE LES USECANDRIL POUR LES LCANDRILL
cant_tlchng$   : 1  #Ignorer entrée de texte programmé au changement avec tlchng_aft?
newglobal$     : 1  #Activer la vérification d'erreur pour les variables globales?

#------------------------------------------------------------------------------------------------------------------
#   FORMATS DES VARIABLES
#
fs  1  1.9lt    # Format avec toute la precision pour les variable internes de mp
fs  2  1.3      # frormat d'affichage a 3 chifres max pour les variables affichées
fs  3  1.3n     # idem mais non modale
fs  4  1 0      # 1 chiffre mini avant virgule  pas de virgule pas de chiffre apres
fs  5  1 0n     # idem mais non modale
fs  6  4 0ln    # 4 chiffres avant pas de virgule pas de chiffre apres non modal force 0 de tete
fs  7  1 3t     # 1 chiffre mini avant virgule  pas de virgule 3 apres force 0 de queue non modal.
fs  8  1.3ln    # 1 chiffre avant la vigule met . 3 chiffres apres virgule non modal force 0 de tete
fs  9  1 0n     # pour liste outil
fs  10 1.3n     # pour liste outil
fs  11 1.3i     # force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental   
fs  12 1.3ni
fs  13 3 0ln


#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES FLAG
#
fmt     4 numcoment     # flag pour Numeroter les lignes de commentaire
fmt     4 numsprog      # flag pour Numeroter les lignes de sous programme
fmt     1 texte         # flag pour textes
fmt     1 nbr_car       # nombre de carracteres maxi dans les connemtaires
fmt     1 old_comm_cnt  # nombre d'enregistrement dans buffeur commentaires
fmt     1 info_corr     # flag pour correction outil
fmt     1 info_outil    # flag pour info outil
fmt     1 info_surep    # flag pour surep
fmt     1 info_groupe   # flag pour le nom des groupes
fmt     1 old_spaces    # memo de spaces
fmt     1 old_omitseq   # memo de omiseq
fmt     1 old_linarc    # memo de la decomposition des arcs
fmt     4 entete        # Variable utilisée pour générer l'entete
fmt     4 numerote      # Variable numerote utilisée pour numéroter ou non les lignes
fmt     1 outil_apres   # flag pour la position d'appel de l'outil suivant
fmt     1 avance_arc    # flag pour gerer l'avance sur arc
#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES MP
fmt     1 gcode$        # Gcode pst
fmt     1 memo_gcode
fmt     1 x$            # XYZ pst
fmt     1 y$
fmt     1 z$
fmt     1 xr$           # XYZ rapide pst
fmt     1 yr$
fmt     1 zr$
fmt     1 i$            # IJK centre des arcs pst 
fmt     1 j$
fmt     1 k$
fmt     1 arcrad$       # Valeur du rayon pst
fmt     1 linarc$       # couper les arcs
fmt     1 t$            # numéro d'outil pst
fmt     1 next_tool$    # numéro suivant pst
fmt     1 first_tool$   # numéro du premier outil pst
fmt     1 tloffno$      # Correcteur de Diamentre pst
fmt     1 tlngno$       # Correcteur de Longueur pst
fmt     1 tldia$        # diamétre outil pst
fmt     1 cc_computer$  # correction ordinateur
fmt     1 cc_pos$       # correction Armoire
fmt     1 fr$           # avance pst
fmt     1 fr_pos$       # AVANCE TRAVAIL au point pst
fmt     1 ss$           # vitesse de broche pst

fmt  "N" 4 n$ " "       # numérotetion des blocs a chaque ligne
fmt     4 next_n        # numéro du blocs a appel condition
fmt     4 memo_n
fmt  "P" 6 progno$      # Numéro de programe pst
fmt  "G" 4 cc$          # valeur de la correction dans NCI
fmt     1 coolant$      # Lubrification 0 1 2 3 arret axe buse les deux 
fmt     1 mi1$          # mi1 utilise pour degagement en Z avant rotation plateau
fmt     1 mi2$          # mi2 utilise pour ne pa rebloquer le plateau
fmt  "G" 5 mi9$         # origine d'usinage
fmt     1 op_id$        # Numero de l'operation du gestionaire PST
fmt     4 nez_on
#------------------- PERCAGES ------------------------------------------
fmt "P2="   7 refht$  "   /(DEBUT DU PREMIER TROU ) "     # profondeur percage pst
fmt  "P10="  7 initht$  "   /( DEGAGEMENT Z ) "           # Garde pour percage pst
fmt  "P3="  7  depth$  "   /( FIN DU DEUXIEME TROU )   "  # Plan de sécu percage pst
fmt    1 frplunge$                                        # Avance percage pst
fmt  "P4="  7 dwell$ "    /(TEMPO )"                      # Tempo pour percage pst
fmt  "P6="  7 peckclr$ "   /( PROFONDEUR DE PASSE )"      # garde d'approche rapide dans les débourrage pst
fmt  "P1="  7 peck1$ "   /( 1 ER DEBOURAGE )"             # Pas Z du premier débourrage pst
fmt  "P5="  7 peck2$ "   /( DEBOURAGE SUIVANT )"          # Pas Z des débourrages suivants
fmt  "P15=" 7 shftdrl$ "   /(DEBUT DU DEUXIEME TROU ) "   # profondeur percage pst
fmt  "P13=" 7 retr$   "   /( FIN DU PREMIER TROU )"       # Pas Z des débourrages suivants
fmt  "X" 3 xh$
fmt  "Y" 3 yh$
fmt  "Z" 3 zh$
fmt  "Z" 1 zdrl$
#------------------- SOUS PROG ------------------------------------------
fmt     1 sub_prg_no$       # Numéro de sous-programe interne en Z
fmt     1 main_prg_no$      # Numéro de sous prog interne en transformation 
fmt  "X" 1 sub_trnsx$       # decalage en X pour G52 en usinage transformer translation
fmt  "Y" 1 sub_trnsy$       # decalage en Y pour G52 en usinage transformer translation
fmt  "Z" 1 sub_trnsz$       # decalage en Z pour G52 en usinage transformer translation
sub_trnsx$   :  -99999
sub_trnsy$   :  -99999
sub_trnsz$   :  -99999
#------------------- 4 AXES ------------------------------------------
fmt    1 rotdia$            # diam de sbstitution
fmt    1 rotaxis$           # type de substitution
fmt  "v" 1 v$
fmt  "w" 1 w$
m7$        : 999
m8$        : 999


#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES NC
#
#------------------- POSITIONS ------------------------------------------
fmt  "X" 2 xabs         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs
fmt  "Z" 2 zabs

fmt  "X" 11 Xinc        # XYZ en incremental pour NC
fmt  "Y" 11 Yinc
fmt  "Z" 11 Zinc

fmt  "A" 2 axeA         # POSITION pour rotation plateau en ABS
fmt  "Ainc" 11 axeAi    # POSITION pour rotation plateau en INCREMENTAL

Xinc = xabs
Yinc = yabs
Zinc = zabs
axeAi = axeA            # A incremental

fmt "px" 2 old_x        # ancien XYZ du NC
fmt "py" 2 old_y
fmt "pz" 2 old_z

fmt  "I" 2 iabs         # IJK centre des arcs pour NC en G90 
fmt  "J" 2 jabs
fmt  "K" 2 kabs

fmt  "I" 2 iinc         # ijk centre des arcs pour NC en G91
fmt  "J" 2 jinc
fmt  "K" 2 kinc
fmt  "R" 3 rayon        # valeur de rayon de l'arc pour NC
fmt      1 cor_arc      # compensation sur les arc autorisée
#------------------- OUTILS ------------------------------------------
fmt      1 deg_debut
fmt      1 deg_outil
fmt      1 deg_4axe
fmt      1 deg_fin

fmt  "T" 5 outil            # numéro d'outil appele pour NC
fmt  "T" 5 outil_suivant    # numéro de l'outil suivant pour NC
fmt     5 nbroutil          # nombre d'outil du changeur de la def machine
fmt  "T" 5 memo_t
fmt  "D" 4 correcteur_D     # Correcteur de Diamentre pour NC
fmt  "H" 4 correcteur_H     # Correcteur de Longueur pour NC
fmt  "H" 4 old_correcteur_H

correcteur_D = tloffno$     # + nbroutil
correcteur_H = tlngno$

fmt  "DIAM " 2 diam_outil   # diamétre outil pour NC
fmt  "F" 4 avance           # avance pour NC
fmt  "S" 4 ssa              # Vitesse de broche affiché

ssa = abs(ss$)              # vitesse de broche en valeur absolue

fmt  "S" 4 old_ss           # memo de la vitesse de broche précédente
fmt     4 lubrif            # gestion de la lubrification pour NC
fmt     3 type_comp         # type de correction
fmt "SUREP R " 8 surep      # Surep au rayon 
fmt "SUREP Z " 8 surepl     # Surep en Z
fmt "SUREP 3D " 8 surep3d   # Surep en usinage 3D
surep3d = surep
fmt "R" 1 result            # resultat de calcul

fmt     5 prognosav         # Mémo du Numéro de programe 
fmt     1 debut             # flag pour debut de programme
#------------------- NUMEROTATION ------------------------------------------
fmt  "N" 4 num              # numero de bloc sur ligne appel outil si pas de numerotation des lignes
fmt    1 old_op_id          # Memo de l'operation
fmt    1 last_op_id         # Derniere operation
num : 0
num = num + 1
old_op_id : -99999

#------------------- ORIGINES D'USINAGE ------------------------------------------
fmt  "G" 4 origine          # origine d'usinage G54 a G59 pour NC
fmt  "G54.1P"  4 originebis # origine d'usinage G60 a G9999 pour NC
fmt  "G" 4 old_origine      # Stocage de la valeur precedente de origine d'usinage
#---------------------- SOUS PROG ------------------------------------
fmt "inc" 1 incremental     # mode incremental ou Absolue 
fmt     1 memo_incremental  # memeo du mode incremental ou Absolue
fmt     1 inc_degage        # degagement machine en INCREMENTAL ou en ABSOLUE

fmt  "O" 6 debsousprog      # Numéro du premier sous programe
fmt  "#100="  4 nprincipal  # memo du numero de ligne du prog principal
fmt  "X" 2 decX             # decalage d'origine en X pour G52
fmt  "Y" 2 decY             # decalage d'origine en Y pour G52
fmt  "Z" 2 decZ             # decalage d'origine en Z pour G52
fmt  "P" 5 subprognum       # numero du sous-programe pour l'appel
fmt  "O" 6 numsubprog       # Numéro entete de sous-programe
fmt     5 nomsubprog        # Numéro n'entete de sous-programe

fmt  "DEC" 2 decalage       # flag pour savoir si on a ecrit un G52
fmt      1 sous_prog_type   # type de merge des sous prog (0 apres prog principal 1 avant)
incremental : 0             # init en Absolue
decalage : 0
nez_on : 0

fmt  "transform" 2 transform


#------------------- PERCAGES ------------------------------------------
fmt  "Z" 2 profabs          # profondeur de percage en ABS
fmt  "Z" 2 profi            # profondeur de percage en INC
fmt  "R" 2 gardeabs         # Garde pour percage en ABS
fmt  "R" 2 gardei           # Garde pour percage en INC
fmt  "F" 3 pas              # valeur calculée du pas pour taraudage rigide
fmt     2 typcycle          # variable mise a 1 lors des percage pour afficher l'intitulé du cycle 
fmt  "Q" 2 incrementQ       #increment de debourrage ou brise copeaux
fmt  "D" 2 remonteD         # remonté en brise copeaux
fmt  "Q" 3 retrait          # valeur de retrait du grain de la barre d'allsage
fmt  "P" 2 tempo
tempo = dwell$


#-------------------- Axe A  ------------------------------------------

fmt  3 useaxe           # flag pour utiliser le 4eme axe
fmt  "S" 2 sens         # pour inverser le sens de l'axe
fmt     1 bloque        # pour gestion M10 M11
fmt     1 use_bloque
fmt     1 old_rotaxis   # memo de rotaxis$
fmt "A"  2 old_axeA     # memo de l ancien A
fmt "Sens" 2 sensA      # sens de rotation de A
fmt  "A" 2 epsi         # Delta de rotation de l'axe A
fmt  "Ntour" 2 nbrtour  # nombre de tour realise
fmt     3 tolquestion   # flag utilisé pour poser la question de tolérance de developpé q'une fois


fmt  "vx" 1 vx
fmt  "vy" 1 vy
fmt  "vz" 1 vz
fmt  "A" 1 axeA1
fmt  "A" 1 axeA2

fmt  "A" 1 delta_axeA1
fmt  "A" 1 axeA1_dep
fmt  "A" 1 old_axeA1
fmt     1 debutpmx       # flag debut prog pmx
srot_label : ""

axeA1_dep :  -999999



axeA     : 999           # Inint de A
old_axeA : 0.9999999     # Inint de old_axeA
nbrtour : 0              # Inint du nombre de tour realise
tolquestion : 0          # Inint de tolquestion
#vtol$      : 0.01


#----------------------Parametres de DEF MACHINE-------------------------------

fmt    1 type_composant  # type de composant
fmt    1 compt_axes_rot  # compteur d'axes rotatif
fmt    3 erreur          # numero d'erreur
fmt    3 testerreur4     # flag pour erreur 4
fmt    1 diviseur        # Axe de l'axe rotatif
fmt    1 old_syncaxis    # memo du numero de combinaison d'axes
fmt    1 nbr_combi       # Nombre de combinaison d'axes
fmt    1 palette         # flag pour machine avec palette
fmt    1 fmaxi           # avance maxi de la machine
fmt    1 fmini           # avance mini de la machine


write_ops    : 0         #Write NC operation information (True/False)
erreur : 0
nbr_combi : 0
compt_axes_rot : 0
palette : 0
#-----------------------------Liste des OUTILS----------------------------------------

fmt "T" 5 paramT1            # Né outil
fmt   5 paramT2              # Type d'outil
fmt   5 paramT3              # Matiere de l'outil 1=Rapide 2=carbure 3=carbure revetu 4=cermet 5=borzon
fmt   5 paramT4              # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt "DIAM=" 3 paramT5        # Diametre
fmt "R=" 3 paramT6           # Rayon de bout
fmt   3 paramT7              # Nombre de filet par mm
fmt "A=" 3 paramT8           # Angle de bout
fmt   5 paramT9              # Né de correcteur de rayon
fmt   5 paramT10             # Né de correcteur de longeur
fmt   3 paramT11             # Avance travail
fmt   3 paramT12             # Avance plongee
fmt   3 paramT13             # Avance retraction
fmt   5 paramT14             # Vitesse de broche
fmt   5 paramT15             # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt   5 paramT16    " DENTS" # Nombre de dents



#-----------------------------------------------------
#   ZONE de FORMULES  si : uniquement au dédut si = mise a jour systématique
#

tlchng_aft$ : 1     # Delay the tool change call until the first motion is read on all the NCI Gcode 1000, 1001, 1002 tool changes.
get_1004$   : 1     # Find gcode 1004 with getnextop?
rpd_typ_v7$ : 0     # Use Version 7 style contour flags?
getnextop$  : 1     # autorise la commande nextop nextccomp etc
strtool_v7$ : 2     # autorise la lecture des commentaires de la bibiotheque outil
skp_lead_flgs$  : 0 # Do NOT use v9 style contour flags
ncldr$      : 20    # nbr de zero de queue utilisés pour la fonction "fleader" 
ldrcode$    : 65
nobrk$      : no$   # ne pas décomposer en xy pui z les mouvements en rapid 
cc_1013$    : 1     # pour connaitre cc dans appel outil
opcode$     : 1
gcode$      : -1
progname$   : 1     # force le nom du nci en majuscule



#-----------------------------------------------------
#   DEFINITION DES STRING
#

#--------- DEFINITION DES STRING -----------------------
svide : ""               # STRING Vide utilisée pour faire des comparaisons
space : " "              # STRING pour forcer un espace
sdcom   : "("            # STRING de debut de commentaire
sfcom   : ")"            # STRING de fin de commentaire
sg43 : "G43"             # STRING de prise de correction en Z
snomgroupe_op : ""       # STRING du nom du groupe d'opération
snomgroupe_op_old : ""   # STRING de l'ancien nom du groupe d'opération
smachine : ""            # STRING du nom de la machine
spalette : "PALETTE"     # STRING du nom palette
scomentsprog : ""        # STRING du commentaire pour le titre du sous prog
snom_nc : ""             # STRING de stockage du non du NC complet avec chemin et extesion style c:\cfao\prog-cn\TOTO.NC
snom_numero : ""         # STRING de stockage du non du NC sous forme O0123.nc avec chemin et extesion style c:\cfao\prog-cn\ous forme O0123.NC
spoint : "."             # STRING du POINT pour l'extesion (.NC)
stringo : ""             # STRING du O pour le non (O0123) en nom du Numero PRG
seditor : "notepad.exe"  # STRING du non de l'editeur pour les prog en nom du Numero PRG (avec chemenin complet si pas dans Windows)
sfileops : ""            # STRING du nom du fichier OPS
sops : ".ops"            # STRING de l'extention des fichier OPS
sfmax : "FMAX"           # STRING de la vitesse rapide
serreurbase : ""

#--------- DEFINITION DES TABLEAUX DE STRING -----------------------
# erreur
serr0   : "err0"
serr1   : "ERREUR - LA FONCTION Ecriture de l'information CN d'opération DOIT ETRE VALIDEE DANS LA DEFINITION D'ARMOIRE"
serr2   : "ERREUR - CE POST-PRO NE SUPPORTE Q'UN SEUL AXE ROTATIF - VERIFIEZ LA DEF MACHINE ET LA COMBINAISON D'AXE"
serr3   : "ERREUR - CE POST-PRO NE SUPPORTE Q'UNE SEULE COMBINAISON D'AXE PAR PROGRAMME - VERIFIEZ LA COMBINAISON D'AXE DES OPERATIONS"
serr4   : "CORRECTION SUR ARC DETECTEE - Vérifiez les entrées/sorties de l'opération "
serreur : ""
fstrsel serr0 erreur serreur 5 -1

#   Mode Absolue ou incremental
sinc00  : ""       # Mode Absolue
sinc01  : ""       # Mode incremental
sinc02 : ""
sinc_abs : ""
fstrsel sinc00 incremental sinc_abs 3 -1

#   Affectation de coté de correction outil G41 G42
sc00    : "G40"
sc01    : "G41"
sc02    : "G42"
scord : ""
fstrsel  sc00 cc_pos$ scord 3 -1

#   Affectation de G0 é G3 dans sgcode en fonction du GCODE 
sg00    : "G0"       # Rapide
sg01    : "G1"       # travail
sg02    : "G2"       # arc horaire
sg03    : "G3"       # arc trigo
sq04    : "G4"       # tempo
sg05    : "G80"      # annulation Cycle Fixes
sgcode : ""

fstrsel  sg00 gcode$ sgcode 6 -1

#   Affectation des plans d'usinage pour 
spl00    : "G17"     # plan XY
spl01    : "G19"     # plan YZ
spl02    : "G18"     # plan XZ
spl03 : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1

#   Blocage déblocage 4ieme Axe
sblo0 : ""           # pour pas de blocage ni deblocage
sblo1   : "M10"      # blocage axe A
sblo2   : "M11"      # déblocage axe A
sblo3 : ""           # pour Frein axe A
sbloque : ""

fstrsel sblo0 bloque sbloque 4 -1

#      Rotation broche
sm00    : "M4"
sm01    : "M5"
sm02    : "M3"
sm03    : "M14"
sm04    : "M15"
sm05    : "M13"
sm06    : "M24"
sm07    : "M25"
sm08    : "M23"
sm09    : "M34"
sm10    : "M35"
sm11    : "M33"
spdlon : ""

spdlsel = fsg3(ss$)
#spdlsel = fsg3(ss)+(coolant*3)

fstrsel  sm00 spdlsel spdlon 12 -1


#   Types d'outils
stypT00 : "RIEN"
stypT01 : "FORET A CENTRER"
stypT02 : "FORET A NOYER"
stypT03 : "FORET"
stypT04 : "TARAUD A DROITE"
stypT05 : "TARAUD A GAUCHE"
stypT06 : "ALESOIR"
stypT07 : "BARRE D'ALESAGE"
stypT08 : "FRAISE A LAMER"
stypT09 : "FRAISE A EBAVURER"
stypT10 : "FRAISE 2 TAILLES"
stypT11 : "FRAISE BOULE"
stypT12 : "FRAISE A CHANFREINER"
stypT13 : "TOURTEAU"
stypT14 : "FRAISE 3 TAILLES"
stypT15 : "FRAISE A RAYON"
stypT16 : "FRAISE QUEUE D'ARONDE"
stypT17 : "FRAISE CONIQUE"
stypT18 : "FRAISE SPHERIQUE"
stypT19 : "FRAISE TORIQUE"

stypeT : ""
fstrsel stypT00 paramT2 stypeT 20 -1

#   Matiere des outils
smatT0  : "ARS"
smatT1  : "ARS"
smatT2  : "CARBURE"
smatT3  : "CARBURE PLAQUETTES"
smatT4  : "CERAMIQUE"
smatT5  : "BORZON"
smatT6  : "BORZON"
smatT7  : "BORZON"
smatT8  : "BORZON"
smatT9  : "BORZON"
smatT10 : "INCONNU"
smatT : ""
fstrsel smatT0 paramT3 smatT 11 -1

# Table de l'affichage du type de corection

stc0   : "CORRECTION AUCUNE"
stc1   : "CORRECTION ARMOIRE DROITE"
stc2   : "CORRECTION ARMOIRE GAUCHE"
stc3   : "CORRECTION ORDINATEUR DROITE"
stc4   : "CORRECTION ORDINATEUR GAUCHE"
stc5   : "CORRECTION USURE DROITE"
stc6   : "CORRECTION USURE GAUCHE"
stc7   : "CORRECTION USURE INVERSE DROITE"
stc8   : "CORRECTION USURE INVERSE GAUCHE"

stype_comp : ""

fstrsel  stc0 type_comp stype_comp 9 -1


#-----------------------------------------------------
#   Tables de parametres
#
fprmtbl 2    1              # lecture des parametres de surep pour surfacage
        12068  surepl       # surep en Z

fprmtbl 1    2              # lecture des parametres de surep pour contour et 3D        
        10010    surep      # surep R
        10068    surepl     # surep Z




fprmtbl 18000   4           # Lecture des Param de def armoire
        18171   write_ops   # Autoriser l'ecriture de l'information CN d'operation
    18458   texte           # Nombre de caracteres pour les commentaires
    18713   sous_prog_type  # type de merge des sous prog (0 apres prog principal 1 avant)
    18705   cor_arc         # compensation sur les arcs autorisée

#------------- Bloc de définition des Questions du post pro -----------------
#   Question 1
#



#   Question 2
#
sclient : ""
fq 2 sclient "CLIENT"


#   Question 3
#
srepere : ""
fq 3 srepere "DESIGNATION PIECE"

#   Question 4
#
sindice : ""
fq 4 sindice "REFERENCE PIECE"

#   Question 5
#
snumerodepiece : ""
fq 5 snumerodepiece "NUMERO DE PIECE SVP"


#   Question 6
# 
fq 6 progno$ "Numero de Prog SVP ?"

#   Question 7
# 


#   Question 8
# 
fq 8 vtol$    "TOLERANCE CORDALE POUR DEVELOPPE"

#   Question 10
# 
fq 10 progno$ "Numéro de programme //progno$// existant, ENTREZ UN NOUVEAU NUMERO"

#   Question 11
# 
fmt 2 remplace
remplace : 2

fq 11 remplace "Numéro de programme //progno$// existant, LE REMPLACER ?      0 pour NON - 1 pour OUI"

smesage : ""
fq 12 smesage "Commentaire opérateur pour arrêt machine programe?"

snomprog : ""
fq   13 snomprog "NOM DU PROGRAMMEUR ?"

srefpiec : ""
fq 14 srefpiec "REFERENCE PIECE ? ( 15 characteres maxi )"

fq 15 mi9$ "ATTENTION PAS D'ORIGINE PROGRAMME DE G54 a G59"


pdebug      # pour activer les infos de debug pst

        err_file$ = 4
        fastmode$ = 0
        bug2$ = -10


pinfos      # affichage d'infos

        #*tlchng_aft$, "--------------", e$
        #*workofs$, e$
        #*sub_trnstyp$, e$
        #*sub_trnmthd$, e$
        #*usecandrill$, e$
        #*usecanpeck$, e$
        #*usecanchip$, e$
        #*usecantap$, e$
        #*usecanbore1$, e$
        #*usecanbore2$, e$
        #*usecanmisc1$, e$
        #*usecanmisc2$, e$
        #*sous_prog_type, "----", e$

#---------------- BLOCS DE PRE TRAITEMENT POST PRO ---------------------------------
#
pprep$      # affectation des variables avant debut traitememt post pro
            spaces$ = 0
            tlchng_aft$ = 1
             #pdebug     # pour activer les infos de debug pst
            bldnxtool$ = 0


            #seqmax$ = seqmax$ - 200        #  se reserver les 200 dernier numero de ligne pour faire les sous prog
            #debsousprog = seqmax$          # memo du num de premier sous prog



    rd_mch_ent_no$ = 0             # pour lire les infos de base de la machine
    rd_cd$                         # lire le control definition

    if write_ops = 0, erreur = 1   # Write NC Operation information MUST be enabled in CD

      !erreur
      !serreur

    if erreur <> 0, [
        result = mprint(serreur, 2)
        exitpost$
            ]


#---------------- BLOCS DE DEF MACHINE ET DEF ARMOIRE ---------------------------------
#

pmachineinfo$    # lecture des parametre de def armoire et def machine

    #"-------------------pmachineinfo$", e$
    #~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$ 
    #if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
    #if prmcode$ = 19958, *prmcode$, "type de composant", "=", sparameter$, e$  # type de composant 5 = axe rotatif
    #if prmcode$ = 17399, *prmcode$, "AXE DE L'AXE ROTATIF", "=", sparameter$, e$   # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17402, *prmcode$, "sens de laxe", "=", sparameter$, e$       # sens de l'axe rotatif 0=trigo 1=horaire
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$       
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$ 
    #if prmcode$ = 17696, *prmcode$, "nom de la combinaison =", sparameter$, e$ 

    if prmcode$ = 17063, fmaxi = rpar(sparameter$, 1)             # avance maxi en G1
    if prmcode$ = 17062, fmini = rpar(sparameter$, 1)             # avance mini en G1



    if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000) #Lecture de la table de parametre Control Definition 

    if prmcode$ = 17012, smachine = sparameter$                   # Nom de la machine

    if prmcode$ = 17201,        [                                 # nom du composant
            if ucase(sparameter$) = spalette, palette = 1         # si c'est une palette, activer la gestion de palette

                        ]

    if prmcode$ = 19958,        [                                 # type de composant
            type_composant = rpar(sparameter$, 1)
            if type_composant = 5,  [                             # si c'est un axe rotatif
            useaxe = 1
            compt_axes_rot  = compt_axes_rot + 1                  # compter le nombre d'axes rotatif
                        ]
                        ]

    if prmcode$ = 17399,    [                                     #AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
            diviseur = rpar(sparameter$, 1)
            if diviseur > 3, diviseur = diviseur - 6              #ne garder que x y z
                    ]

    if prmcode$ = 17402,    [                                     # sens de l'axe rotatif 0=trigo 1=horaire
            sens = rpar(sparameter$, 1)
        if sens = 0, sens = 1                                     # variable sens pour le post pro
        else, sens = -1
                ]

      if prmcode$ = 17598,      [                                 # nombre d'outils du changeur de la def machine
        nbroutil = rpar(sparameter$, 1)
                        ]

      if prmcode$ = 17397,      [                                 # Nom de l'axe rotatif (ABC)
    srot_label = sparameter$
            ]

plireaxes   # Lecture des parametres de la combinaison d'axes uniquement
        #"plireaxes", syncaxis$, e$

    if syncaxis$ <> old_syncaxis, [
    compt_axes_rot = 0
    erreur = 0
        ]


    rd_mch_ent_no$ = syncaxis$      # pour avoir les infos de la conbinaison d'axe utilisée
    #rd_mch_ent_no$ = -2            # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    #rd_cd$                         # lecture de la def armoire
    rd_md$                          # lecture de la def machine


        result = nwadrs(srot_label, axeA)   # affectation du nom de l'axe rotatif en ABS
        result = nwadrs(srot_label, axeAi)  # affectation du nom de l'axe rotatif en INC

    ptestmachine
    old_syncaxis = syncaxis$

#---------------- BLOCS DE LECTURE DES PARAMETRES ---------------------------------
#

pparameter$  # lecture des parametres d'operation 
    #"------------------------------------------------pparameter$", e$
    # ~prmcode$, "=", sparameter$, e$                # pour afficher tous les parametres



    if opcode$ <> 19, result = fprm (1)                         # lecture des parametres de surep pour surfacage
    if opcode$ = 19, result = fprm (2)                          # lecture des parametres de surep pour contour et 3D 

    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)        # lecture des parametres d'outil
    if prmcode$ = 20018, snomgroupe_op = ucase (sparameter$)    # Lecture du nom de groupe d'usinage

    #if prmcode$ = 15166,  "--------------15166--------------", sparameter$, e$ 
    #if prmcode$ = 15181,  "--------------15181--------------", sparameter$, e$ 
    #if prmcode$ = 15370,  "--------------15370--------------", sparameter$, e$ 
    #if prmcode$ = 15239, sparameter$, e$   


pwrttparam$  # lecture des parametres d'outils 

        #*nbr_combi, "-------------pwrttparam--------", e$
        if syncaxis$ <> old_syncaxis, nbr_combi = nbr_combi + 1
        old_syncaxis = syncaxis$

         #~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

           if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)




#---------------- BLOCS DE TRAITEMENT DES SOUS PROG EN Z ---------------------------------

psub_call_s$       # appel sous prog en Z

    #"--------appel sous prog en Z---------", *sub_sec_no$, e$
        !sub_prg_no$                            # mise a jour du numero interne de sous prog en Z
        subprognum = debsousprog + sub_prg_no$  # affectation du numero de sous prog en Z
        nprincipal = n$  + seqinc$              # memo du numero de ligne pour le rappel dans le sous-programme

         # if sub_sec_no$ > 1 | sub_sec_no$ < 1,   [    # call suivant

        #*nprincipal, e$                        # affecation du parametre CN pour memo du numéro de ligne
        n$, "M98", subprognum, e$               # appel du sous prog

          #  ]        


        nprincipal = n$                         # memo du numero de ligne pour le prog principal



psub_st_s$    # ecriture de l'entete de sous prog en Z


        !sub_prg_no$                            # mise a jour du numero interne de sous prog en Z
        numsubprog = debsousprog + sub_prg_no$  # affectation du numero de sous prog en Z
        nomsubprog = numsubprog                 # affectation du nom de sous prog en Z
        memo_incremental = incremental          # memorisation du mode ABS INC Actuel 
        incremental = sub_inc$                  # Sous prog en incremental ou absolue


    if incremental = 1, p_casse_modalite        # casser la modalité xyz pour les sous prog en relatif 
    p_casse_modalite_avance                     # casser la modalité le l'avance pour les sous prog 

        if numsprog = 0, omitseq$ = 1           # pas du numero de ligne pour les sous prog 

        if texte <> 0,   [                      # entete avec commentaires


                if scomentsprog <> svide, *numsubprog, sdcom, spaces$ = 0, scomentsprog, sfcom, spaces$ = old_spaces, e$
                 else, *numsubprog, e$

                                ]


        else,       [                           # entete sans commentaires
                *numsubprog,  e$
                    ]

       # n$, *sinc_abs, e$                      # ecrire si sous prog en ABS ou INC
    gcode$ = 5                                  # pour forcer l'ecriture de code G du premier bloc du sous prog
        !gcode$

psub_end_s$    # fin sous prog en Z


        incremental = 0                         # rappel du mode INC ABS precedent
        #n$, *sinc_abs, e$

        #n, "M99", "P#100", e$                  # fermeture de sous prog
        n$, "M99", e$                           # fermeture de sous prog
   # space, e$                                  # sauter une ligne
       # omitseq$ = old_omitseq
        n$ = nprincipal                         # recuperation du numero de ligne pour prog principal

#-------------------------BLOCS DE TRAITEMENT DES SOUS PROG EN TRANSFORMER ---------------------------


pmirroir      # pour usinage transformer en mirroir

protation     # pour usinage transformer en rotation 

pechelle      # pour usinage transformer en echelle


ptranslation  # pour usinage transformer en translation

        #n$, "-------------------------------------", *sub_trnmthd$, e$


    if sub_trnmthd$ = 2, [              # translation en coordonnées

         n$, "(translate  coordinate)", e$


        prapid$



                        ]



    if sub_trnmthd$ = 1, [              # translation de l'origine du plan uniquement

        n$, "(translate tool plane origine only)", e$


        memo_incremental = incremental
        incremental = 0

            decX = sub_trnsx$
            decY = sub_trnsy$
            decZ = sub_trnsz$

            if decX <> 0 | decY <> 0 | decZ <> 0, [
            if decalage = 1, panulldecalageg52            # annuler les decalages d'origine
            decX = sub_trnsx$
            decY = sub_trnsy$
            decZ = sub_trnsz$
            n$, sinc_abs, "G52", *decX, *decY, *decZ, e$  # ecriture des valeur de decalage d'origine
            decalage = 1                                  # memo de mise en place de decalage pour l'annuler
        p_casse_modalite                                  # pour forcer le rappel des coordonées apres changement d'origine
        prapid$
                             ]

            incremental= memo_incremental
                n$, sinc_abs, e$
                    ]

    if sub_trnmthd$ = 0, [                                # translation du plan d'usinage uniquement

        n$, "(translate tool plane ----> must use new workofs$)", e$

        #poriusi
        n$, mi9$, e$
        p_casse_modalite                                  # pour forcer le rappel des coordonées apres changement d'origine
        prapid$

        ]

psub_call_mm$     # appel sous prog en transformation pour outils multiples


        #"appel sous prog en transformation pour outils multiples", e


        !main_prg_no$                                  # mise a jour du numero interne de sous prog en transformation pour outils multiples
        subprognum = debsousprog + main_prg_no$ +100   # affectation du numero de sous prog 

        if sub_trnstyp$ = 0, pmirroir                  # si on fait du mirroir
        if sub_trnstyp$ = 1, protation                 # si on fait de la rotation 
        if sub_trnstyp$ = 2, pechelle                  # si on fait de l'echelle
        if sub_trnstyp$ = 3, ptranslation              # si on fait de la translation aller avant dans bloc ecriture decalage orignie

        nprincipal = n$  + seqinc$                     # memo du numero de ligne pour le rappel dans le sous-programme

        #*nprincipal, e$                               # affecation du parametre CN pour memo du numéro de ligne
        n$, "M98", subprognum, e$                      # appel du sous prog

        nprincipal = n$                                # memo du numero de ligne pour le prog principal


      # n, "(PASSE ", sub_sec_no, "SUR ", sub_totl_no, ")", e


          #  "Subprogram number ", sub_op_id, e
          #  "Actual operation ID", sub_grp_id, e
          #  "Transform/non-transform indicator", sub_ref_id, e
          #  "Iteration counter", sub_sec_no, e
          #  "Total number of instances", sub_totl_no, e 






psub_call_m$   # appel sous prog en transformation pour outil unique

        # "appel sous prog en transformation pour outil unique", e$

        #main_prg_no$, sub_prg_no$, sub_ref_id$, sub_op_id$, sub_grp_id$, sub_trns_id$, sub_sec_no$, sub_totl_no$, sub_chn_no$, sub_inc$, e
        #*main_prg_no$, e


        !main_prg_no$                                  # mise a jour du numero interne de sous prog en transformation pour outils multiples
        subprognum = debsousprog + main_prg_no$ +100   # affectation du numero de sous prog 


        if sub_trnstyp$ = 0, pmirroir       # si on fait du mirroir
        if sub_trnstyp$ = 1, protation      # si on fait de la rotation 
        if sub_trnstyp$ = 2, pechelle       # si on fait de l'echelle
        if sub_trnstyp$ = 3, ptranslation   # si on fait de la translation aller avant dans bloc ecriture decalage orignie

        nprincipal = n$  + seqinc$          # memo du numero de ligne pour le rappel dans le sous-programme

        #*nprincipal, e$                    # affecation du parametre CN pour memo du numéro de ligne
        n$, "M98", subprognum, e$           # appel du sous prog

        nprincipal = n$                     # memo du numero de ligne pour le prog principal


      # n, "(PASSE ", sub_sec_no, "SUR ", sub_totl_no, ")", e


          #  "Subprogram number ", sub_op_id, e
          #  "Actual operation ID", sub_grp_id, e
          #  "Transform/non-transform indicator", sub_ref_id, e
          #  "Iteration counter", sub_sec_no, e
          #  "Total number of instances", sub_totl_no, e 


psub_end_m_r$    # bloc system non explique dans doc des PST (a voir)

        #"-------------------------------------------", "psub_end_m_r$", "******",*incremental, e$ e$


psub_st_m$    # entete sous prog en transformation 


        !main_prg_no$                                 # mise a jour du numero interne de sous prog en transformation pour outils multiples
        numsubprog = debsousprog + main_prg_no$ +100  # affectation du numero de sous prog 
        nomsubprog = numsubprog                       # affectation du nom de sous prog en Z
        memo_incremental = incremental                # memorisation du mode ABS INC Actuel 
        incremental = sub_inc$                        # Sous prog en incremental ou absolue


    if incremental = 1, p_casse_modalite              # casser la modalité pour les sous prog en relatif  
    p_casse_modalite_avance                           # casser la modalité le l'avance pour les sous prog 

        if numsprog = 0, omitseq$ = 1                 # pas du numero de ligne pour les sous prog 
        if texte <> 0,   [                            # entete avec commentaires


                if scomentsprog <> svide, *numsubprog, sdcom, spaces$ = 0, scomentsprog, sfcom, spaces$ = old_spaces, e$
                 else, *numsubprog, e$

                ]


        else,       [                                 # entete sans commentaires
                *numsubprog,  e$
                    ]

       # n$, *sinc_abs, e$                            # ecrire si sous prog en ABS ou INC
    gcode$ = 5                                        # pour forcer l'ecriture de code G du premier bloc du sous prog
        !gcode$

             #sub_op_id, sub_prg_no, e


psub_end_m$   # fin sous prog en transformation 


        incremental = 0                               # rappel du mode INC ABS precedent
        #n$, *sinc_abs, e$

        #n, "M99", "P#100", e$                        # fermeture de sous prog
        n$, "M99", e$                                 # fermeture de sous prog
    #space, e$                                        # sauter une ligne
        omitseq$ = old_omitseq
        n$ = nprincipal                               # recuperation du numero de ligne pour prog principal




#------------------- GESTION DES COMMENTAIRES ---------------------------------------
#   
pcomment$   # Gestion des commentaires dans le prog

        if entete = 0,  pcomment2   # commentaires des usinages
        else,       pcomment3       # commentaires d'entete de prog

pcomment_end$   # post traitement des commentaires

        if entete = 1, comm_cnt$ = old_comm_cnt         # pour pouvoir relire les commentaires apres appel de comment dans pheader



pcomment2       #Affichage des commentaire des usinages

    scomm$ = ucase (scomm$)                             # focer en majuscules
    scomentsprog = svide                                # mise a zero du commentaire de sous prog

    if texte <> 0, [

        if numcoment = 0, omitseq$ = 1                  # si pas de numero de bloc pour commentaires enlever les numeros de bloc
            if debut = 1, [
        # if gcode$ = 1051, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$   # Nom Machine
        if gcode$ = 1053, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$     # Nom du Groupe Machine
        if gcode$ = 1052, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$     # Commentaire de groupe Machine
        #if gcode$ = 1054, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$    # Descripteur de fichier
                    ]
        if gcode$ = 1005, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$     # Usinage commentaire - en commentaire
        if gcode$ = 1007, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces         # Entree Manuelle - en commentaire avec le mouvement sans e$
        if gcode$ = 1008, n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$     # Commentaire d'operation
        if gcode$ = 1008, scomentsprog = scomm$

        omitseq$ = old_omitseq                                                                # rappel des numero de bloc       

                ]

    if gcode$ = 1006, n$, scomm$, e$                                                          # Usinage commentaire - en code
    if gcode$ = 1026, scomm$                                                                  # Entree Manuelle - en code avec le mouvement sans e$

pcomment3   # Affichage des commentaires d'entete de prog

        if gcode$ = 1054, [
            scomm$ = ucase (scomm$)
            n$, sdcom, spaces$ = 0, scomm$, sfcom, spaces$ = old_spaces, e$                   # Descripteur de fichier

                ]
        old_comm_cnt = comm_cnt$



pnomgroupe  # Affichage du nom du groupe d'operation

    if snomgroupe_op <> svide & texte <> 0 & snomgroupe_op <> snomgroupe_op_old & info_groupe = 1, [

        if numcoment = 0, omitseq$ = 1                                                     # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        n$, sdcom, spaces$ = 0, "*", snomgroupe_op, "*", sfcom, spaces$ = old_spaces, e$   # nom du groupe d'operation
       # space, e$

        omitseq$ = old_omitseq                                                             # rappel des numero de bloc       
            snomgroupe_op_old = snomgroupe_op                                              # memo du nom du groupe d'operation
                        ]



#------------------- 4 Axes continue en fonctions 5 Axes ---------------------------------------
#
paxeA   # Affichage de l'axe A



        nbrtour = int (axeA / 360) * sens

    if incremental = 0, axeA, !axeAi
    if incremental = 1, !axeA, axeAi

        old_axeA = axeA




pcalculpmx  # Calacul de l'axe A x y z


    vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$

    if diviseur = 1, axeA1 = atan2(vy,vz) # on tourne autour de x  
    if diviseur = 2, axeA1 = atan2(vx,vz) # on tourne autour de Y 

    if axeA1 >  180, axeA2 = 360 - axeA1
    if axeA1 <= 180, axeA2 = axeA1 * -1

    delta_axeA1 = axeA1 - old_axeA1

    if delta_axeA1 >  180, delta_axeA1 = delta_axeA1 - 360
    if delta_axeA1 <  -180,delta_axeA1 = delta_axeA1 + 360

    axeA1_dep = axeA1_dep + delta_axeA1
    old_axeA1 = axeA1
        axeA = axeA1_dep * sens


    if diviseur = 1, [          # on tourne autour de x
    xabs = x$
    yabs = z$*sin(axeA2) + y$*cos(axeA2)
    zabs = z$*cos(axeA2) - y$*sin(axeA2)
            ]

    if diviseur = 2, [          # on tourne autour de Y             
    xabs = z$*sin(axeA2) + x$*cos(axeA2)
    yabs = y$
    zabs = z$*cos(axeA2) - x$*sin(axeA2)
            ]




pmx0$       # pre output pmx

            if fr$ = -2, gcode$ = 0
        else, gcode$ = 1
        pcalculpmx

pmx$        # Gestion 4 axes continue avec fonction 5 axes

        #" pmx1 mouvement 5axes"

    # premier mouvement 
        if debutpmx = 1, pmx_2


    # corp de l'iso
    if debutpmx = 0, [




            if gcode$ = 1,   [
            @xabs, @yabs, @old_x, @old_y, @axeA, @old_axeA
                if cc_pos$ <> 0, n$, correcteur_D, e$
        if xabs <> old_x | yabs <> old_y | axeA <> old_axeA, n$, sinc_abs, pcord, sgcode, pxyz, paxeA, pfr, e$
        else, n$, sinc_abs, sgcode, pxyz, paxeA, pfr, e$


                        ]

            if gcode$ = 0, n$, sinc_abs, sgcode, pxyz, paxeA, pfr, e$

            ]



        old_x = xabs
        old_y = yabs
        old_z = zabs

pmx_2
        #" pmx2", e$

    if debutpmx = 1, [

            bloque = 2
            if use_bloque = 0, bloque = 0
            n$, sbloque, e$
            gcode$ = 0

        n$, sinc_abs, *sgcode, *xabs, *yabs, paxeA, e$
        n$, sinc_abs, sgcode,  *zabs,  plubrifon, e$

        !x$, !y$, !z$, !xr$, !yr$, !zr$
        p_modal

    old_correcteur_H = correcteur_H     # memo du correcteur de longeur
    debutpmx = 0
            ]



pmx_end$




#------------------- 4 Axes continue en substitution d'axe ---------------------------------------
#

plinarc  # Convertir les G2 G3 en G1

        linarc$ = 1
        if tolquestion <> 1, q8
        tolquestion = 1


p_Apos  # calcul de l'axe A en substitution 

        @x$, @y$

        if diviseur = 1, axeA = (y$ * 360 / (pi$ * rotdia$)) * sens   # pour 4eme axe autour de X (substituer Y)
        if diviseur = 2, axeA = (x$ * 360 / (pi$ * rotdia$)) * sens   # pour 4eme axe autour de Y (substituer X)

    p_zdev          # calcul du Z en substitution 

p_zdev  # calcul du Z en substitution 

    @z$, @rotdia$
    zabs  = z$ +(rotdia$ /2)    # Z pour continue substitutuion en ABS


p_Apos_affiche  # affichage de l'angle au chg outil nul pour continue





           if useaxe <> 0, [

            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
                #"---------p_Apos_affiche-------", eé

           if epsi <> 0,    [
            pdegage4axes, e$
         bloque = 2
         if use_bloque = 0, bloque = 0
            n$, sbloque, e$
            if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, sbloque, e$
            else, n$, sgcode, sinc_abs, !axeA, *axeAi, sbloque, e$
                ]
            ]

        old_axeA = axeA



#------------------- 4 Axes positionné ---------------------------------------
#

prot0$  #   Tool plan view matrix du gcode 1014  


prot$



prot1   # calcul de l'axe A en positionné

        @old_axeA, @nbrtour

        if diviseur = 1, axeA = atan2(m8$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de X
        if diviseur = 2, axeA = atan2(m7$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de Y
    axeA = axeA * sens                      # prise en compte du sens de rotation

    epsi = axeA - old_axeA                      # variation angulaire
    sensA = 0
    if epsi > 0, sensA = 1                      # sens de la variation
    if epsi < 0, sensA =  -1
    epsi = abs(epsi)
    @epsi, @sensA                           # mise a jour

            if epsi > 180,  [                   # optimisation de l'angle
        axeA = axeA - (360 * sensA)
                epsi = axeA - old_axeA
                sensA = 0
        if epsi > 0, sensA = 1
        if epsi < 0, sensA = -1
                        ]
        nbrtour = int (axeA / 360)                  # Calcul du nombre de tour

         #"----prot1-----valeur corigee------", *diviseur, *old_axeA, *axeA,*epsi,*sensA,*nbrtour,  e


prot2   # affichage de l'angle au chg outil pour positionné


           if useaxe <> 0, [        # afficher les angle que si machine avec Axe A

            @old_axeA, @axeA        # mise a jour

            epsi = old_axeA - axeA  # regarder si on tourne
            epsi = abs(epsi)

           if epsi <> 0,    [       # si ca tourne
            bloque = 2          # deblocage de l'axe A
            if use_bloque = 0, bloque = 0
            n$, sbloque, e$
            if mi2$ = 0, bloque = 1         # preparer le blocage de l'axe A
            if use_bloque = 0, bloque = 0
            if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, e$
            else, n$, sgcode, sinc_abs, !axeA, *axeAi, e$
            n$, sbloque, e$     # bloquer l'axe A
                ]

            ]

        old_axeA = axeA         # memo de la position de l'axe A affiché




prot3   # affichage de l'angle au chg outil nul pour positionné



           if useaxe <> 0, [        # afficher les angle que si machine avec Axe A

            @old_axeA, @axeA        # mise a jour

            epsi = old_axeA - axeA  # regarder si on tourne
            epsi = abs(epsi)

           if epsi <> 0,    [       # si ca tourne

            xabs = x$           # reprendre les positions xyz avant le dégagement
            yabs = y$
            zabs = z$

            pdegage4axes        # Dégagement machine avant la rotation de l'axe A

            bloque = 2          # deblocage de l'axe A
            if use_bloque = 0, bloque = 0
            n$, sbloque, e$
            if mi2$ = 0, bloque = 1         # preparer le blocage de l'axe A
            if use_bloque = 0, bloque = 0
            if incremental = 0, n$, sgcode, sinc_abs,  *axeA, !axeAi, e$
            else, n$, sgcode, sinc_abs,  !axeA, *axeAi, e$

            n$, sbloque, e$     # bloquer l'axe A

            if incremental = 0, [           # Rappel des positions XYZ avant le dégagement
            n$, sgcode, sinc_abs, xabs, yabs, e$
            n$, sgcode, zabs, e$
                ]



                ]
            ]

        old_axeA = axeA         # memo de la position de l'axe A affiché






#   Gestion de la valeur de l'avance pour l'afficher
#            
pfr     # avance travail


        @cc_computer$, @cc_pos$                 # mise é jour des variables                 

        if cc_pos$ = 0  & cc_computer$ = 0,   type_comp = 0 #AUCUNE

        if cc_pos$ = 2  & cc_computer$ = 0,   type_comp = 1 #ARMOIRE DROITE
        if cc_pos$ = 1  & cc_computer$ = 0,   type_comp = 2 #ARMOIRE GAUCHE

        if cc_pos$ = 0  & cc_computer$ = 42,  type_comp = 3 #ORDINATEUR DROITE
        if cc_pos$ = 0  & cc_computer$ = 41,  type_comp = 4 #ORDINATEUR GAUCHE

    if cc_pos$ = 2  & cc_computer$ = 42,  type_comp = 5 #USURE DROITE
    if cc_pos$ = 1  & cc_computer$ = 41,  type_comp = 6 #USURE GAUCHE

    if cc_pos$ = 1  & cc_computer$ = 42,  type_comp = 7 #USURE INVERSE DROITE
    if cc_pos$ = 2  & cc_computer$ = 41,  type_comp = 8 #USURE INVERSE GAUCHE



    if gcode$ <> 0, [   # Avance travail
        @fr_pos$
        @fmini
        @fmaxi

        avance = fr_pos$    # affectation de l'avance

        if avance_arc <> 0, [   # acivation de l'avance optimiseé sur arc  (option PST)

        # arc horaire correction a gauche
        if gcode$ = 2 & (type_comp = 6 | type_comp = 4 | type_comp = 8), if (arcrad$ - tldia$/2) > 0, avance =(arcrad$*fr_pos$)/(arcrad$ - tldia$/2)
        # arc trigo correction a gauche
        if gcode$ = 3 & (type_comp = 6 | type_comp = 4 | type_comp = 8), avance =(arcrad$*fr_pos$)/(tldia$/2 + arcrad$)

        # arc horaire correction a droite
        if gcode$ = 2 & (type_comp = 5 | type_comp = 3 | type_comp = 7), if (arcrad$ - tldia$/2) > 0, avance =(arcrad$*fr_pos$)/(arcrad$ -tldia$/2)
        # arc trigo correction a droite 
        if gcode$ = 3 & (type_comp = 5 | type_comp = 3 | type_comp = 7), avance =(arcrad$*fr_pos$)/(tldia$/2 +arcrad$)

        avance = fr_pos$

        # test des avances en fonction des limites de la def machine
        if avance < fmini, avance = fmini
        if avance > fmaxi, avance = fmaxi

                ]

            avance
            result = newfs (4, avance)  # affectation en format modal
            ]

    if gcode$ = 0,  [   # Avance rapide

            ]

pavanceperce    # Avance en percage

    p_casse_modalite_avance             # pour forcer l'affichage de l'avance
    pfr                     # Affichage de l'avance


#   Gestion de la correction outil et du numéro de corecteur
#
pcorh       # Correction de longueur

        #if correcteur_H <> old_correcteur_H, sg43, *correcteur_H
        old_correcteur_H = correcteur_H



pcord_old


    if opcode$ < 16 | opcode$ > 18, [

    if cc$ = 140, cc$ = 40

         if cc$ <> 0, scord
                    ]

        else, [
        if cend$ = 1 & cc_pos$ <> 0, cc$ = 40

         if cc$ <> 0, scord

        cc$ = 0


        ]

#   Gestion de la correction outil et du numéro de corecteur
#
pcord



    if opcode$ < 16 | opcode$ > 18, [   # pour 3 axes

    if cc$ = 140, cc$ = 40

         if cc$ <> 0, scord
                    ]

        else, [                 # pour 4 axes pmx
        if cend$ = 1 & cc_pos$ <> 0, cc$ = 40

         if cc$ <> 0, scord

        cc$ = 0

        ]

    if cc$ <> 0, if gcode$ = 2 | gcode$ =3, if cor_arc = 0, erreur = 4, perreur

pcancelcc$  # Annulation de correction de rayon



#   Gestion lubrif -0 arret -1 axe outil -2 buse -3 les deux separé du M3 M4
#
plubrifon
           lubrif = coolant$

           if lubrif = 1, "M8"
           if lubrif = 2, "M8"
           if lubrif = 3, "M8"

plubrifoff
           if lubrif > 0, n$, "M9"



#   Initialisation de la machine
#
pintcn  #   Initialisation de la machine

        gcode$ = 0
        #n$, *sgcode, *sinc_abs, "G40", "G80", "G98", "G17", e$      # init CN
       # space, e$                           # Sauter une ligne


#   Gestion du dégagement de la machine au debut de prog
#
pdegage_debut       #   Gestion du dégagement de la machine au debut de prog

    if deg_debut <> 0, [

    memo_gcode = gcode$         # memo du gcode precedent
    gcode$ = 0              # Degagement en Rapide 
        @incremental
        memo_incremental = incremental      # memo du mode actuel G90 G91
        incremental = inc_degage        # passage en mode 90 ou 90 pour degagement


    if deg_debut >= 1, [            # si degager en Z       
        if sdegageZ <> svide, n$, *sgcode, e$, n$, smodedeg, sdegageZ, e$  # degager en Z
                ]

    if deg_debut = 2 | deg_debut = 4, [             # si degager en Z et X      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, e$  # degager en X    
            ]
    if deg_debut = 3 | deg_debut = 4, [             # si degager en Z et Y      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageY, e$  # degager en Y    
            ]
    if deg_debut = 5, [             # si degager en Z etXY      
    if sdegageX <> svide & sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, sdegageY, e$    # degager en X Y 
            ]


    gcode$ = memo_gcode         # rappel du gcode precedent
        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
       # @incremental                                                                                   # mise a jour
       # if sdegageZ <> svide | sdegageX <> svide | sdegageY <> svide, n$, sinc_abs, e$         
       # !incremental

            ]



#   Gestion du dégagement de la machine avant appel outil
#
pdegage     #   Gestion du dégagement de la machine avant appel outil

    if deg_outil <> 0, [

    memo_gcode = gcode$         # memo du gcode precedent
    gcode$ = 0              # Degagement en Rapide 
        @incremental
        memo_incremental = incremental      # memo du mode actuel G90 G91
        incremental = inc_degage        # passage en mode 90 ou 90 pour degagement

    if deg_outil >= 1, [            # si degager en Z       
        if sdegageZ <> svide, n$, *sgcode, e$, n$, smodedeg, sdegageZ, e$  # degager en Z
                ]

    if deg_outil = 2 | deg_outil = 4, [             # si degager en Z et X      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, e$  # degager en X    
            ]
    if deg_outil = 3 | deg_outil = 4, [             # si degager en Z et Y      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageY, e$  # degager en Y    
            ]
    if deg_outil = 5, [             # si degager en Z etXY      
    if sdegageX <> svide & sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, sdegageY, e$    # degager en X Y 
            ]

    gcode$ = memo_gcode         # rappel du gcode precedent
        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
        #@incremental                                                                                   # mise a jour
        #if sdegageZ <> svide | sdegageX <> svide | sdegageY <> svide, n$, sinc_abs, e$         
        #!incremental

            ]

#   Gestion du dégagement de la machine fin de prog
#
pdegage_fin #   Gestion du dégagement de la machine fin de prog

   if deg_fin <> 0, [
    memo_gcode = gcode$         # memo du gcode precedent
    gcode$ = 0              # Degagement en Rapide 
        @incremental                # mise a jour
        memo_incremental = incremental          # memo du mode actuel G90 G91
        incremental = inc_degage        # passage en mode 90 ou 90 pour degagement


    if deg_fin >= 1 & deg_fin < 6, [                # si degager en Z       
        if sdegageZ <> svide, n$, smodedeg, sdegageZ, e$  # degager en Z
                ]

    if deg_fin = 2 | deg_fin = 4, [             # si degager en Z et X      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, e$  # degager en X    
            ]
    if deg_fin = 3 | deg_fin = 4 | deg_fin = 6, [               # si degager en Z et Y      
    if sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageY, e$  # degager en Y    
            ]
    if deg_fin = 5, [               # si degager en Z etXY      
    if sdegageX <> svide & sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, sdegageY, e$    # degager en X Y 
            ]

    gcode$ = memo_gcode         # rappel du gcode precedent
        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
        @incremental                                                                                    # mise a jour
        if sdegageZ <> svide | sdegageX <> svide | sdegageY <> svide, n$, sinc_abs, e$
        !incremental
                ]



#   Gestion du dégagement de la machine avant rotation plateau
#
pdegage4axes        #   Gestion du dégagement de la machine avant rotation plateau

   if deg_4axe <> 0, [

    if mi1$ = 0, [

    memo_gcode = gcode$         # memo du gcode precedent
    gcode$ = 0              # Degagement en Rapide 
        @incremental
        memo_incremental = incremental          # memo du mode actuel G90 G91
        incremental = inc_degage            # passage en mode 90 ou 90 pour degagement


    p_casse_modalite            # casser la modalité pour rappel des XYZ    

    if deg_4axe >= 1, [             # si degager en Z       
        if sdegageZ <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageZ, e$  # degager en Z
                ]

    if deg_4axe = 2 | deg_4axe = 4, [               # si degager en Z et X      
    if sdegageX <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, e$  # degager en X    
            ]
    if deg_4axe = 3 | deg_4axe = 4, [               # si degager en Z et Y      
    if sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageY, e$  # degager en Y    
            ]
    if deg_4axe = 5, [              # si degager en Z etXY      
    if sdegageX <> svide & sdegageY <> svide, n$, sgcode, sinc_abs, smodedeg, sdegageX, sdegageY, e$    # degager en X Y 
            ]

    gcode$ = memo_gcode         # rappel du gcode precedent
        incremental = memo_incremental          # Rappel du mode actuel G90 G91
        @incremental                # mise a jour
        n$, sinc_abs, e$
            ]

                ]


#   Gestion des Origine d'usinages G54 a G59
#
poriusi


    if workofs$ >=0, [                  # ne pas afficher de G54 si le decalage < 0     

    origine = 54 + workofs$                 # origine de  54 a 59
    originebis = origine - 59               # origine > 59

        if origine <> old_origine, [                # si changement d'origine
        p_casse_modalite                # pour forcer le rappel des coordonées apres changement d'origine

        if origine <=59, *origine           # pour origine de 54 a 59
            else, *originebis               # pour origine > 59

        old_origine = origine               # memo de l'origine affichée

        ]
            ]

#   Gestion des G54 a 59 pour changement outil mul
#
poriusinul


    if workofs$ >=0, [                  # ne pas afficher de G54 si le decalage < 0     

    origine = 54 + workofs$                 # origine de  54 a 59
    originebis = origine - 59               # origine > 59
        if sub_trnmthd$ = 1, old_origine = origine
        if origine <> old_origine, [                # si changement d'origine
        p_casse_modalite                # pour forcer le rappel des coordonées apres changement d'origine

        if origine <=59, *origine           # pour origine de 54 a 59
            else, *originebis               # pour origine > 59

        old_origine = origine               # memo de l'origine affichée

        ]
            ]

#   Gestion des gammes de vitesse de broche
#
pgamme

    @ssa
    #if ssa < 1500, "M38"
    #else, "M39"


#----------------- BLOCS D'AFFICHAGES DES ENTETES ET APPEL OUTLIS -----------------


pentete     # QUESTION POUR L'ENTETE

           q2, q3, q4, q5

        sclient = ucase (sclient)
        srepere = ucase (srepere)
        sindice = ucase (sindice)
        snumerodepiece = ucase (snumerodepiece)

        if sclient <> svide, n$, sdcom, spaces$ = 0, "CLIENT - ", sclient, sfcom, spaces$ = old_spaces, e$
        if srepere <> svide, n$, sdcom, spaces$ = 0, "DESIGNATION - ", srepere, sfcom, spaces$ = old_spaces, e$
        if sindice <> svide, n$, sdcom, spaces$ = 0, "REFERENCE PIECE - ", sindice, sfcom, spaces$ = old_spaces, e$
        if snumerodepiece <> svide, n$, sdcom, spaces$ = 0, "NUMERO DE PIECE - ", snumerodepiece, sfcom, spaces$ = old_spaces, e$
        comment$        # pour sortie du descripteur de fichier
        entete = 0




pheader$     # ENTETE DE PROGRAMME

    rd_mch_ent_no$ = -1         # pour lire les info de toute la machine
    rd_md$                      # lire la definition machine    
    rd_mch_ent_no$ = 0          # pour lire les info de base de la machine
    rd_md$                      # lire la definition machine
    compt_axes_rot = 0          # pour remetre a zero le nombre d'axe rotatif avant la lecture de la conbinasin d'axe
    useaxe = 0

    if omitseq$ = 1, numcoment = 0      # si pas de numero de bloc ne pas numeroter les commentaires
    debut = 1                           # flag pour debut de prog
        old_omitseq = omitseq$          # memo du mode de numerotation de ligne
        old_spaces = spaces$            # memo du nombre d'espaces
    old_linarc = linarc$                # memo de la decomposition des arcs

        smcpath$ = ucase (smcpath$)     # convertir en MAJUSCULES les noms
        smcname$ = ucase (smcname$)
        smcext$ = ucase(smcext$)
        snamepst$ = ucase (snamepst$)
        snamenc$ = ucase (snamenc$)
        smachine = ucase (smachine)
        if progno$ = 0, progno$ = 8999




        if use_progno = 1, [            # si on sauve sous la forme 00123.NC
        pnom_nc                         # Génération des noms du fichier NC
        ptest_nom                       # Tester si prog O0123.NC existe
                ]

         prognosav = progno$            # memo du numéro de prog
         debsousprog = progno$         # memo du num de premier sous prog  


    #---------------------- Debut de prog -----------------------

        "%", e$

        if texte <> 0,      [                           # Si la machine accepte les commentaires

        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc

            progno$,e$ ,n$, sdcom, spaces$ = 0,  snamenc$, sfcom, spaces$ = old_spaces, e$                 # Nom du prog iso   

            if entete = 1, pentete                          # faire l'entete de prog



           # space, e$                               # Sauter une ligne
            if tooltable$ <> 0, n$, sdcom, spaces$ = 0, "LISTE DES OUTILS UTILISES", sfcom, spaces$ = old_spaces, e$    # pour liste des outils

        omitseq$ = old_omitseq                          # rappel des numero de bloc       
                ]

        else, progno$, e$                               # Si la machine n'accepte pas les commentaires, ne mettre que le numero 
            q13
        n$,sdcom,"EADS - COMPOSITES AQUITAINE",sfcom,,e$
        n$,sdcom,"CHARLY PRO 3 AXES 9108",sfcom,e$
        n$,sdcom,"ETABLI LE ",date$," A ",sfcom,e$
        n$,sdcom,"PROG PAR ",snomprog,sfcom,e$
        #n$,sdcom,"PIECE:", srefpiec,sfcom,e$



psof0$       # DEBUT DE PROGRAMME pour T=0

       psof$
pinfoutil       # infos sur l'outil

        if info_outil = 1,  [                           # si affichage des infos outil          
                strtool$ = ucase (strtool$)             # convertir en MAJUSCULES le nom outil

            if numcoment = 0, omitseq$ = 1              # si pas de numero de bloc pour commentaires enlever les numeros de bloc

            if strtool$ <> svide,   n$, sdcom, spaces$ = 0, paramT1, space, strtool$, space, stypeT, space,paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, spaces$ = old_spaces, e$
            else,           n$, sdcom, spaces$ = 0, paramT1, space, stypeT, space,paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, spaces$ = old_spaces, e$

            omitseq$ = old_omitseq                  # rappel des numero de bloc
                    ]

pappel_outil    # ecriture de l'appel outil pour psof et ptlchg


    pnomgroupe                                  # Nom du groupe d'operation
    comment$                                    # commentaires d'operation
             !tool_typ$

    if tool_typ$ = 5, ss$ = (abs(ss$))*-1       # si taraud é gauche inverser le sens de broche






        paffiche_outil
        if texte <> 0, pinfoutil
        if texte <> 0, paramcomp                        # afficher le type de compensation
        if texte <> 0, paramsurep                       # afficher les surepaisseur

            plane$ = 0                  # pour focer le rappel G17 G18 G19
        cc_pos$ = 0
        gcode$ = 0
        n$, "G10", e$
        n$, *sgcode, e$
        n$, *scord,e$
        n$, "G80", e$
        n$, *sinc_abs, e$
        n$, *splcode, e$
        #n$, poriusi, e$
        n$, mi9$, e$
        n$, *spdlon,*ssa, e$       # vitesse de broche  


        #n$, plubrifon, e$                                  # lubrif    
        #n$, "M1", e$
        #space, e$                              # Sauter une ligne
        debut = 0
        gcode$ = 5
        !gcode$



poutil  # appel outil sans outil suivant


    outil = t$


    if omitseq$ = 1, num, *outil, e$, n$, "M6", e$
    if omitseq$ = 0, n$,  *outil, e$, n$, "M6", e$

    #if omitseq$ = 1, num, *outil, *correcteur_D, "M6", e$
    #if omitseq$ = 0, n$,  *outil, *correcteur_D, "M6", e$

poutil_suivant  # appel outil avec outil suivant

            if outil_apres = 0, [       # flag pour la position d'appel de l'outil suivant
            outil = t$
            outil_suivant = next_tool$
            n$,  *outil_suivant, e$
                        ]

paffiche_outil  # affichage du numero d'outil

#     Début de programme pour outil
        if bldnxtool$ = 1,   [

                if op_id$ <> last_op_id & t$ <> next_tool$, poutil, poutil_suivant  # appel outil avec outil suivant juste apres
                if op_id$ <> last_op_id & t$ = next_tool$, poutil       # appel outil sans outil suivant
                if op_id$ = last_op_id & t$ <> first_tool$, poutil, poutil_suivant  # appel outil avec outil suivant juste apres
                if op_id$ = last_op_id & t$ = first_tool$, poutil       # appel outil sans outil suivant

                            ]


        if bldnxtool$ = 0,   poutil                     # appel outil sans outil suivant



paffiche_outil_suivant  # affichage de l'outil suivant ou non

    outil = t$
    outil_suivant = next_tool$

        if bldnxtool$ = 1 & outil_apres = 1,   [

                if op_id$ <> last_op_id & t$ <> next_tool$, outil_suivant   # appel outil suivant
                if op_id$ = last_op_id & t$ <> first_tool$, outil_suivant   # appel outil  suivant

                    ]

#     Début de programme pour outil
# 

fmt "toto" 2 toto


ptruc     # essai de prout 
            n$, "ca marche", e$



fmt "OPERATION =" 2 cont_op
vieux_op_id : 0

fmt "G" 5 old_mi9

psof$        # DEBUT DE PROGRAMME 
                cycle_heli_spiral = 0
            if mi9$ < 54 | mi9$ > 59, mi9$ = 55, q15
            old_mi9 = mi9$
            n$, sdebut_prog, e$
            spaces$ = 0
            memo_n = n$
            pinfos
            memo_t = t$
            plireaxes                   # Lecture des parametres de la combinaison d'axes uniquement
            if tooltable$ <> 0 & texte <> 0, [      # Si liste des outils et textes supportés
            if numcoment = 0, omitseq$ = 1  # Si pas de numero sur les commentaires
            n$, sdcom, spaces$ = 0, "FIN DE LISTE DES OUTILS", sfcom, spaces$ = old_spaces, e$
            #space, e$                   # Sauter une ligne
            omitseq$ = old_omitseq
                        ]

        pnumop                      # compteur d'operation
        gcode$ = 0
    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$

    old_origine = -9999             # pour forcer l'affichage du G54 au chg outil
    old_correcteur_H = -99999           # pour forcer l'appel du G43    
        incremental = 0                 # Travail en Absolue


      pintcn                      # Initialisation de la machine


        incremental = 2                 # pour re forcer l'affichage du mode Absolue
        !incremental
        incremental = 0

    pdegage_debut                           # Dégagement de la Machine au debut de prog

   # space, e$                   # sauter une ligne

    pappel_outil                        # APPEL OUTIL
    next_n = n$ + 2
    #"*", n$, "IF P054 < 2 GO ",next_n, " /(MODE PENDULAIRE)", e$
    #n$, "G51R180  (MODE PENDULAIRE  )", e$

    pplacement_cn                   # AFFICHAGE DES MOUVEMENTS MACHINE



#   Mise en route cn apres appel outil   
#
pplacement_cn   # AFFICHAGE DES MOUVEMENTS MACHINE

        @rotaxis$                   # mise a jour du type de substitution d'axe

        if nextop$ = 11,    [           # si  4 axes avec fonction 5 axes

        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres



        axeA = 0
        axeA1_dep = 0
        old_axeA1 = 0
        debutpmx = 1                # flag pour faire l'appel outil
        cc$ = cc_pos$ + 40
                        ]


    if nextop$ <> 11,           [   # utilisation en positionné ou substitution


        gcode$ = 0                              # Force le gcode a 0 pour faire un G0 apres


        xabs = x$
        yabs = y$
        zabs = z$


    if rotaxis$ = 0,    [           # 3 axes + diviser en positionne 

        prot1                                   # calcul rotation plateau
        old_axeA =  -99999                          # pour forcer l'affichage
        prot2                                   # affichage de l'angle au chg outil


        n$, *sinc_abs, e$
        #n$, poriusi, e$
        n$, mi9$, e$
        n$,  sgcode, *xabs, *yabs, paffiche_outil_suivant,ssa,spdlon, e$
        n$, *zabs,  plubrifon, e$
                        ]


   if rotaxis$ <> 0,    [           # utilisation en substitution

        plinarc
                p_Apos
                bloque = 2
                if use_bloque = 0, bloque = 0
        if rotaxis$ = 1,  xabs = 0                  # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2,  yabs = 0                  # diviseur tourne autour de X (Y sbstitue)


        n$, *sgcode, sinc_abs, sbloque, *axeA, e$
        n$, sgcode, sinc_abs, *xabs, *yabs, paffiche_outil_suivant, ssa, pgamme, spdlon, e$
    n$,  *zabs, plubrifon, e$

                        ]

    p_modal                                 # affectation en format modal
        !x$, !y$, !z$, !xabs, !yabs, !zabs, !Xinc, !Yinc, !Zinc, !axeA, !axeAi  # mise é jour des positions affichées

                            ]



   old_correcteur_H = correcteur_H  # memeo du correcteur de longeur
   old_ss = ss$                     # memo de la vitesse de broche
   old_op_id = op_id$               # memo du numero d'operation
   old_rotaxis = rotaxis$           # memo du type de substitution
   old_x = xabs                     # memo X Y Z
   old_y = yabs
   old_z = zabs


  c_mmlt$           # truc qui doit servire pour usinage transformé
  c_msng$

#---------------------------------------------------------------------------
fmt "valeur de string" 1 valstring

pstring    # valeur de la string
             if valstring = 1, n$, stringtxt1, e$
             if valstring = 2, n$, stringtxt2, e$
             if valstring = 3, n$, stringtxt3, e$
             if valstring = 4, n$, stringtxt4, e$
             if valstring = 5, n$, stringtxt5, e$
             if valstring = 6, n$, stringtxt6, e$
             if valstring = 7, n$, stringtxt7, e$
             if valstring = 8, n$, stringtxt8, e$
             if valstring = 9, n$, stringtxt9, e$
             if valstring = 10, n$, stringtxt10, e$



pcantext   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring
             if cant_val2$ > 0, valstring = cant_val2$, pstring
             if cant_val3$ > 0, valstring = cant_val3$, pstring
             if cant_val4$ > 0, valstring = cant_val4$, pstring
             if cant_val5$ > 0, valstring = cant_val5$, pstring
             if cant_val6$ > 0, valstring = cant_val6$, pstring
             if cant_val7$ > 0, valstring = cant_val7$, pstring
             if cant_val8$ > 0, valstring = cant_val8$, pstring
             if cant_val9$ > 0, valstring = cant_val9$, pstring
             if cant_val10$ > 0, valstring = cant_val10$, pstring
             ]

parretprog    # arret machine programmer avant op quand mi10 = 1
        n$,"M5 (ARRET BROCHE)",e$

        n$,sdegage_z,e$
        n$,sdegage_xy,e$
        if  cantext$ = 0,
        [
            q12
            n$,sdcom, smesage,sfcom,e$
        ]
        pcantext
        n$,"M0",e$
        n$, *spdlon, *ssa,e$


parretprog2    # arret machine programmer avant op quand mi10 = 1 et changement outil
        n$,"M5 (ARRET BROCHE)",e$
        n$,sdegage_z,e$
        n$,sdegage_xy,e$
        if  cantext$ = 0,
        [
            q12
             n$,sdcom, smesage,sfcom,e$
        ]
        pcantext
        n$,"M0",e$




ptlchg0$     # CHANGEMENT D'OUTIL NUL   
            cycle_heli_spiral = 0
            if mi9$ < 54 | mi9$ > 59, mi9$ = old_mi9
            old_mi9 = mi9$
            !old_mi9
            if mi10$ = 1 , parretprog
        pnumop                      # compteur d'operation      
    if subout$ = 0, omitseq$ = old_omitseq
        memo_incremental = incremental                  # memo du mode ABS INC actuel
        if subout$ = 0, incremental = 0                 # pour forcer le mode Absolue
        @rotaxis$, @old_rotaxis                         # mise a jour
        linarc$ = old_linarc                            # pour activer les G2 G3
    typcycle = 0                                        # variable mise a 1 lors des percage pour afficher l'intitulé du cycle          
    pnomgroupe                                          # Nom du groupe d'operation
        comment$                                        # commentaires d'operation
        if texte <> 0, paramcomp                        # afficher le type de compensation
        if texte <> 0, paramsurep                       # afficher les surepaisseur
    if tool_typ$ = 5, ss$ = (abs(ss$))*-1               # si tataud é gauche inverser le sens de broche
        if ss$ <> old_ss, n$, ssa, pgamme, *spdlon, e$  # si changement de vitesse de broche l'afficher





   if nextop$ = 11,             [       # si  4 axes avec fonction 5 axes
            if op_id$ <> old_op_id,     [
            old_axeA1 = 0
            axeA1_dep = 0.
            cc$ = cc_pos$ + 40
            #n$, poriusinul, e$          # affichage de l'origine d'usinage
            n$, mi9$, e$

                        ]
                            ]




   if nextop$ <> 11, [                      # utilisation en positionné ou substitution



        xabs = x$                   # prise en compte de XYZ
        yabs = y$
        zabs = z$

        if rotaxis$ = 0, [              # 3 axes + diviser en positionné 
        prot1                           # calcul rotation plateau
        prot3                           # affichage de l'angle
        #n$, poriusinul, e$             # affichage de l'origine d'usinage
        n$, mi9$, e$

        ]


        if rotaxis$ <> 0 & old_rotaxis = 0,  [      # si on passe de positionné a continue

        plinarc                             # Convertir les G2 G3 en G1
                p_Apos                              # calcul de l'axe A en substitution 
        if rotaxis$ = 1,  xabs = 0                  # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2,  yabs = 0                  # diviseur tourne autour de X (Y sbstitue)
        p_Apos_affiche                          # affichage de l'angle au chg outil nul pour continue
        n$, sgcode, sinc_abs,  xabs, yabs, !Xinc, !Yinc, e$
        n$, sgcode, sinc_abs,  zabs,  !Zinc, e$
        p_modal                                 # affectation en format modal
            !x$, !y$, !z$, !xabs, !yabs, !zabs, !Xinc, !Yinc, !Zinc, !axeA, !axeAi  # mise é jour des positions affichées
         old_correcteur_H = correcteur_H                    # memo du correcteur de longeur


                            ]

                ]



   incremental = memo_incremental   # rappel du mode incremental ou absolue précédent                
   old_ss = ss$                     # memo de la vitesse de broche
   old_op_id = op_id$               # memo du numero d'operation
   old_rotaxis = rotaxis$           # memo du type de substitution
   old_x = xabs                     # memo X Y Z
   old_y = yabs
   old_z = zabs

   c_mmlt$              # Appel sous prog multi outils
   c_msng$              # Appel sous prog mono outil

ptlchg0_end$

        #"--------------- fin ptlchg0_end$", e$


panulldecalageg52

        memo_incremental = incremental
        incremental = 0

        decX = 0
        decY = 0
        decZ =0

            n$, sinc_abs, "G52", *decX, *decY, *decZ, e$

        decalage = 0
        incremental = memo_incremental

ptlchg$      # CHANGEMENT D'OUTIL
            cycle_heli_spiral = 0
            if mi9$ < 54 | mi9$ > 59, mi9$ = old_mi9
            old_mi9 = mi9$
            if mi10$ = 1, parretprog2


        pnumop                      # compteur d'operation
    plubrifoff, e$                  # arret lubriff
    n$, "M5", e$                    # arret broche

    if decalage = 1, panulldecalageg52      # annuler les decalages d'origine
    pinfos
    if nbrtour <> 0,    [           # pour remise a zero du diviseur
        old_axeA = 0
        axeA = 0
        nbrtour = 0
                ]

    p_casse_modalite_avance             # pour rappel de l'avance sur le premier G1

    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$

    memo_incremental = incremental          # memo du mode incremental
        incremental = 2                 # pour re forcer l'affichage du mode Absolue
    !incremental
    incremental = 0                 # pour forcer le mode Absolue

    old_origine = -9999             # pour forcer l'affichage du G54 au chg outil
    old_correcteur_H = -99999           # pour forcer l'appel du G43    
    linarc$ = old_linarc                    # pour activer les G2 G3
    typcycle = 0                    # variable mise a 1 lors des percage pour afficher l'intitulé du cycle          
    pdegage                             # Dégagement de la Machine

   # space, e$                   # Sauter une ligne


        pappel_outil                        # APPEL OUTIL

            spaces$ = 0

           n$, "G10 ", e$
        pplacement_cn                   # AFFICHAGE DES MOUVEMENTS MACHINE
        incremental = memo_incremental          # pour revenir au mode precedent


peof0$

           peof$

pdecharge_outil     # Déchargement de l'outil en broche

    #if t$ <> memo_t, [
    #   outil = memo_t 
    #   n$, *outil, "M6", e$
    #       ]



    if t$ <> 0, [
        outil = 0
        n$, *outil, "M6", e$
            ]

peof$
        plubrifoff, e$                  # Arret lubriff
        # n$, "M5", e$                    # Arret broche
        if decalage = 1, panulldecalageg52      # Annuler les decalages d'origine
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        incremental = 2                 # pour re forcer l'affichage du mode Absolue
        !incremental
        incremental = 0                 # pour forcer le mode Absolue
        # pdecharge_outil                 # Déchargement de l'outil en broche        
        if useaxe <> 0 & old_axeA <> 0,  [      # Remise a 0 de l'axe A si pas a Zero
        axeA = 0                # A = 0
            prot2                   # affichage de l'angle 
                ]

    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$
    plane$ = 0

    #n$, "M1029", e$
    #"*", n$, "IF P53 = 1 GO ", *memo_n, e$
     n$, "G53", e$
     n$, "H0", e$
     n$, "G0 Z=P18", e$
     n$, "G0 X0. Y=P17", e$
     n$, "M5", e$
     n$, "G92", e$

   # n$, splcode, sinc_abs, e$           # Plan XY mode Absolue
    comment$                    # commentaires d'operation
    if palette = 1, n$, "M98", "P9901", e$  # 

    #pdegage_fin                 # Dégagement de la machine fin de prog
   # n$, "G53H0Z0", e$

    subout$ = 0                 # Ecriture dan le NC            
    #mergeext$                  # Merge les sous prog
    mergeaux$                   # merge les sous prog en Z
    mergesub$                   # merge les sous prog en transform

    #clearext$                  # Effacer les sous prog
    clearsub$
    clearaux$
    n$, sfin_prog, e$
    n$, "M2", e$                     # fin de fichier



#----------------CORPS DU CODE ISO G1 G2 G3 G0 -------------------------
pnezon  # mise en place du nez
        n$, "G10", e$
        n$, "M140", e$
        nez_on = 1

pnezoff  # retrait du nez
        n$, "G10", e$
        n$, "M141", e$
        nez_on = 0


plrapid     # Ligne en rapide       
        #if nez_on = 1, pnezoff
        xabs = x$
        yabs = y$
        zabs = z$
       #if nextccomp$ = 2 | nextccomp$ = 3, n$, pcord, correcteur_D, e$
          # if cc_pos$ <> 0 & nextop$ > 0, n$ ,pcord, correcteur_D, e$
           n$, `sgcode, sinc_abs, pcorh, pxyz, e$



pltravail    # Ligne en travail
        #if nez_on = 0, pnezon
        xabs = x$
        yabs = y$
        zabs = z$
       #if nextccomp$ = 2 | nextccomp$ = 3, n$, pcord,correcteur_D, e$
       #if cc_pos$ <> 0, n$, pcord, correcteur_D, e$

       if cc$ = 41 | cc$ = 42, n$, pcord, *correcteur_D, e$
       if cc$ = 40 | cc$ = 140, n$, pcord, e$
       n$,  `sgcode, sinc_abs, pxyz, pfr, e$


prapid$      # Ligne en rapide
    if gcode$ = 0, plrapid
        else, pltravail

pzrapid$     # Ligne Z en rapide
    if gcode$ = 0, plrapid
        else, pltravail

plin$        # Ligne travail
        if gcode$ = 0, plrapid
        else, pltravail

pz$      # z en avance TRAVAIL
        #"------PZ----", e$
    if gcode$ = 0, plrapid
        else, pltravail

p_modal     # affectation en format modal X Y Z A garde profondeur ABS ET INC
            # "p_modal"
            result = newfs (2, xabs)
            result = newfs (11, Xinc)
            result = newfs (2, yabs)
            result = newfs (11, Yinc)
            result = newfs (2, zabs)
            result = newfs (11, Zinc)
            result = newfs (2, axeA)
            result = newfs (11, axeAi)
            result = newfs (2, profabs)
            result = newfs (2, profi)
            result = newfs (2, gardeabs)
            result = newfs (2, gardei)


pcir$        # Circulaire
            #if nez_on = 0, pnezon
            p_modal     #affectation en format modal

        xabs = x$
        yabs = y$
        zabs = z$
            #"----------------", *arctype$,"---------------", e$


        if arctype$ >= 5, pcir_r, e$    # en R
        else, pcir_ij, e$           # en IJ 


p_casse_modalite_avance # casser la modalité de l'avance

            result = newfs (5, avance)

p_casse_modalite    # pour casser la modalité de Xabs et Xinc Yabs et Yinc Zabs et Zinc

                p_casse_modalite_X
            p_casse_modalite_Y
            p_casse_modalite_Z
            p_casse_modalite_A


p_casse_modalite_X  # pour casser la modalité de Xabs et Xinc

            result = newfs (3, xabs)
            result = newfs (12, Xinc)

p_casse_modalite_Y  # pour casser la modalité de Yabs et Yinc

            result = newfs (3, yabs)
            result = newfs (12, Yinc)


p_casse_modalite_Z  # pour casser la modalité de Zabs et Zinc

            result = newfs (3, zabs)
            result = newfs (12, Zinc)

p_casse_modalite_A  # pour casser la modalité de Zabs et Zinc

            result = newfs (3, axeA)
            result = newfs (12, axeAi)


p_casse_modalite_perce  # pour casser la modalité de profabs et profi gardeabs gardei

            result = newfs (3, profabs)
            result = newfs (3, profi)

            result = newfs (3, gardeabs)
            result = newfs (3, gardei)


pcir_r      # Circulaire G2 G3 G17 G18 G19 en R

        if cc$ = 41 | cc$ = 42, n$, pcord, *correcteur_D, e$
        if cc$ = 40 | cc$ = 140, n$, pcord, e$

        @plane$
        if arctype$ = 5, rayon = arcrad$            # pour Rayon
        if arctype$ = 6 & abs(sweep$) < 180, rayon = arcrad$    # pour Rayon signé
        if arctype$ = 6 & abs(sweep$) >=180, rayon = -arcrad$   # pour Rayon signé


        if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
        if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
        if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z


        n$, splcode, e$
        if plane$ = 0, n$, sinc_abs, *sgcode, pcord, pxyz, rayon, pfr   # plan XY
        if plane$ = 2, n$, sinc_abs, *sgcode, pcord, pxyz, rayon, pfr   # plan XZ
        if plane$ = 1, n$, sinc_abs, *sgcode, pcord, pxyz, rayon, pfr   # plan YZ

pcir_ij     # Circulaire G2 G3 G17 G18 G19 en IJ

        if cc$ = 41 | cc$ = 42, n$, pcord, correcteur_D, e$
        if cc$ = 40 | cc$ = 140, n$, pcord, e$
        n$, splcode, e$
        @plane$
        if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
        if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
        if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z

        if plane$ = 0, n$, *sgcode, pcord, pxyz, pijk, pfr
        if plane$ = 2, n$, *sgcode, pcord, pxyz, pijk, pfr
        if plane$ = 1, n$,  *sgcode, pcord, pxyz, pijk, pfr



pxyz        # ecriture des x, y, z en abs ou incremental pour corp ISO

    pxyz_new
    p_modal     # affectation en format modal

        !x$, !y$, !z$   # mise a jour xyz

        old_x = xabs    # memo des anciennes positions
        old_y = yabs
        old_z = zabs


pxyz_new    # ecriture des positions X Y Z et A pour substitution

    if rotaxis$ = 0,    [    # XYZ CLASIQUE 3 axes (+ positionné)





        if incremental = 0, xabs, yabs, zabs, !Xinc, !Yinc, !Zinc
        else,           !xabs, !yabs, !zabs, Xinc, Yinc, Zinc

                ]

    if rotaxis$ <> 0, [    # SUBSTITUTION 
            p_Apos                              # Calcul de l'axe A
        if rotaxis$ = 1,  xabs = 0                  # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2,  yabs = 0                  # diviseur tourne autour de X (Y sbstitue)

            if incremental = 0,     xabs, yabs, axeA, zabs, !Xinc, !Yinc, !axeAi, !Zinc
            else,           !xabs, !yabs, !axeA, !zabs, Xinc, Yinc, axeAi, Zinc

        old_axeA  = axeA                            # memo de l'axe A
        nbrtour = int (axeA / 360)                      # calcul du nombre de tours
            ]





pijk        # ecriture des IJK pour G90 G91 


        !i$, !j$, !k$


        if arctype$ = 1, [   # pour centre en absolue en G90  

    iabs = i$
    jabs = j$
    kabs = k$
    iinc = i$ - prv_x$
    jinc = j$ - prv_y$
    kinc = k$ - prv_z$
            ]

        else,       [     # pour centre en relatif en G90

    iabs = i$
    jabs = j$
    kabs = k$
    iinc = i$
    jinc = j$
    kinc = k$
            ]

        if incremental = 0 & plane$ = 0, *iabs, *jabs, !iinc, !jinc, !kinc
        if incremental = 0 & plane$ = 2, *iabs, *kabs, !iinc, !jinc, !kinc
        if incremental = 0 & plane$ = 1, *jabs, *kabs, !iinc, !jinc, !kinc

        if incremental = 1 & plane$ = 0, !iabs, !jabs, *iinc, *jinc, !kinc
        if incremental = 1 & plane$ = 2, !iabs, !kabs, *iinc, !jinc, *kinc
        if incremental = 1 & plane$ = 1, !jabs, !kabs, !iinc, *jinc, *kinc



#-------------------------------------------------------------------------

pdrill$      # Cycle de percage G81 G82

        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0 & dwell$ = 0,  n$, sdcom, spaces$ = 0, "PERCAGE 1) (G81 PERCAGE SIMPLE RETOUR RAPIDE", sfcom, spaces$ = old_spaces, e$
        if typcycle = 0 & dwell$ <> 0, n$, sdcom, spaces$ = 0,  "PERCAGE 2) (G82 PERCAGE TEMPO FIN DE TROU RETOUR RAPIDE", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq

            ]

    typcycle = 1

    gcode$ =0
    z$ =  initht$
    pzrapid$
    gcode$ = 81

    p_casse_modalite        # casser la modalité de xy
    p_casse_modalite_perce      # casser la modalité de la garde et la prof

        if dwell$ = 0,
        [
            "*",n$, *refht$, e$
             "*",n$, *depth$, e$
             "*",n$, *initht$, e$
             n$, sinc_abs, "G81",  pavanceperce, e$
             n$, ppercexy, e$
        ]
        else,
        [
             "*",n$, *refht$, e$
             "*",n$, *depth$, e$
             "*",n$, *dwell$, e$
             "*",n$, *initht$, e$
             n$, sinc_abs, "G82",  pavanceperce, e$
             n$, ppercexy, e$
        ]


ppeck$      # Cycle de débourrage G83


        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, sdcom, spaces$ = 0, "PERCAGE 3) (G83 PERCAGE DEBOURAGE RETOUR RAPIDE", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq
            ]

    typcycle = 1

    gcode$ =0
    z$ =  initht$
    pzrapid$
    gcode$ = 81


    p_casse_modalite        # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
             "*",n$, *peck1$ , e$
             "*",n$, *refht$, e$
             "*",n$, *depth$, e$
             "*",n$, *dwell$, e$
             "*",n$, *initht$, e$
             "*",n$, *peck2$ , e$
              "*",n$, *peckclr$ , e$
             n$, sinc_abs, "G83",  pavanceperce, e$
             n$, ppercexy, e$

pchpbrk$    # Cycle de brise copeaux G73

        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,  n$, sdcom, spaces$ = 0, "BRISE COPEAUX", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq
            ]

    typcycle = 1

    gcode$ =0
    z$ =  initht$
    pzrapid$
    gcode$ = 81

    p_casse_modalite        # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    incrementQ = peck1$
    incrementQ = retr$
    remonteD = peckclr$
    n$, sinc_abs, "G73", ppercexy, *incrementQ, remonteD, tempo, pavanceperce, e$



ptap$       # Cycle de taraudage G84

        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,  n$, sdcom, spaces$ = 0, "PAS DE TARAUDAGE POSSIBLE SUR CETTE MACHINE", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq
            ]

    typcycle = 1




pbore1$     # Cycle d'alésage G85

         if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        n$, sdcom, spaces$ = 0,  "Alesage 1) (G85 PERCAGE TEMPO FIN DE PERCAGE RETOUR TRAVAIL", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq

            ]

    typcycle = 1

    gcode$ =0
    z$ =  initht$
    pzrapid$
    gcode$ = 81

    p_casse_modalite        # casser la modalité de xy
    p_casse_modalite_perce      # casser la modalité de la garde et la prof


             "*",n$, *refht$, e$
             "*",n$, *depth$, e$
             "*",n$, *dwell$, e$
             "*",n$, *initht$, e$
             n$, sinc_abs, "G85",  pavanceperce, e$
             n$, ppercexy, e$



pbore2$     # Cycle d'alésage G86 


        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, sdcom, spaces$ = 0, "PERCAGE 4) (G89 PERCAGE DEUX NIVEAUX", sfcom, spaces$ = old_spaces, e$
        omitseq$ = old_omitseq
            ]

    typcycle = 1

    gcode$ =0
    z$ =  initht$
    pzrapid$
    gcode$ = 81


    p_casse_modalite        # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof

             "*",n$, *refht$, e$
             "*",n$, *depth$, e$
             "*",n$, *dwell$, e$
             "*",n$, *initht$, e$
             "*",n$, *retr$ , e$
             "*",n$, *shftdrl$ , e$


             n$, sinc_abs, "G89",  pavanceperce, e$
             n$, ppercexy, e$




pmisc1$     # Cycle 



                #dwell$, refht$, peck1$, peck2$, zdrl$, initht$, retr$, shftdrl$, peckclr$ , e$


pmisc2$     # Cycle  special helicoido-spiral

                         n$, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral
                        !x$, !y$, !z$, !xr$, !yr$, !zr$



pdrill_2$   # Percage suivant

           phole, e$
ppeck_2$    # Canned Peck Drill Cycle

           phole, e$
pchpbrk_2$  # Canned Chip Break Cycle

           phole, e$
ptap_2$     # Canned Tap Cycle

          n$, sinc_abs, ppercexy, e$

pbore1_2$   # Canned Bore #1 Cycle

        phole, e$

pbore2_2$   # Canned Bore #2 Cycle

        phole, e$

pmisc1_2$   # Canned Misc #1 Cycle


pmisc2_2$   # Cycle  special helicoido-spiral
                percage_helicoido_spiral_2
                !x$, !y$, !z$, !xr$, !yr$, !zr$





pnumop      # numerotation des operations post-processées

             if op_id$ <> old_op_id, numop = numop + 1



# ----------------------- DEBUT CYCLE SPECIAL HELICOIDO-SPIRAL ------------------------



#------------- DECLARATION DES VARIABLES via le cycle  ------------


fmt "Aval ou OPP=" 4 ava_opp                        # Détermine si la fraise travail en avalant ou opposition
fmt "Diametre final=" 2 dia_final                   # diametre du trou programmé 
fmt "Diametre ebauche=" 2 dia_ebauche               # diametre d'ebauche
fmt "Pas maximum en Z=" 2 pas_max_z                 # Pas maximum en Z
fmt "Pas maximum en XY=" 2 pas_max_xy               # Pas maximum en XY pour la spiral en fond de trou
fmt "Nb Tr de finition=" 4 nbe_tr_fin               # Nombre de tour pour passe de finition
fmt "F" 5 f_ent_cir                                 # avance en entree ciculaire au debut de l'helicoide
fmt "F" 5 f_int_hel                                 # avance de l'helicoide 
fmt "F" 5 f_spiral                                  # avance de la spiral
fmt "F" 5 f_int_fin                                 # avance sur la finition du trou
fmt "F" 5 f_sor_cir                                 # avance sur la sortie de la finition du trou
fmt "F" 5 f_base                                    # avance de base du cycle
fmt "Dis. entre perp=" 2 ent_perp                   # distance d'entree perpendiculaire au debut du cycle pour le G41
fmt "Gestion usure=" 4 cor_ray                      # ativation d'un G41 ou G42 suivant besoins
fmt "Nb Tr de finition de retour=" 4 nbe_tr_retour  # Nombre de tour pour la deuxieme passe de finition a l'opposer du sens de la premiere
fmt  "OPERATION "  5 numop                          # NUMERO D'OPERATION

fmt "Drl_prm1=" 3 drl_prm1$
fmt "Drl_prm2=" 3 drl_prm2$
fmt "Drl_prm3=" 3 drl_prm3$
fmt "Drl_prm4=" 3 drl_prm4$
fmt "Drl_prm5=" 3 drl_prm5$
fmt "Drl_prm6=" 3 drl_prm6$
fmt "Drl_prm7=" 3 drl_prm7$
fmt "Drl_prm8=" 3 drl_prm8$
fmt "Drl_prm9=" 3 drl_prm9$
fmt "Drl_prm10=" 3 drl_prm10$


#------------- DECLARATION DES VARIABLES pour calcul interne  ------------


fmt "X" 3 x_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Y" 3 y_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Z" 3 z_plan_securite                       # coordonee Z du plan de securite
fmt "Z" 3 z_retraction                          # coordonee Z du plan de rétraction 
fmt "Z" 3 z_dessus_brut                         # coordonee Z du dessus du brut , debut matiere 
fmt "Z" 3 z_profondeur                          # coordonee Z du fond du trou
fmt "X" 3 x_perp                                # coordonee X du point pour l'entre perpendiculaire
fmt "X" 3 x_ent_cir                             # coordonee X du point du centre du cercle pour l'entre circulaire
fmt "R" 3 ray_ent_cir                           # rayon du cercle de l'entree circulaire
fmt "Nb pas Z =" 4 nbe_pas_z                    # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Nb de pas actuel" 4 nbe_pas_actu           # nombre de pas actuel
fmt "Pas Z=" 3 pas_z                            # valeur reel du pas de l'helice
fmt "Nb pas XY =" 3 nbe_pas_xy                  # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Pas XY=" 3 pas_xy                          # valeur reel du pas de la spiral
fmt "Nb de cercle" 3 nbe_demi_cercle            # nombre de demi cercle que constitue la spiral
fmt "R" 3 ray_sor_cir                           # rayon pour la sortie de la spiral
fmt "X" 3 x_sor_cir                             # coordonee X du point du centre du cercle pour la sortie circulaire
fmt "helice total = " 3 hauteur_hel " mm"       # hauteur total de l'helicoide
fmt "Le cumul helice debut et fin = " 3 hauteur_hel_debfin " mm"                    # hauteur total de l'helicoide de debut et fin
fmt "R" 3 ray_ebauche                           # rayon d'ebauche 
fmt "Sens" 4 sens_usi                           # sens de l'usinage, -1 = avalant, 1 = opposition et depend de la reponce: Avalant=0 Oppositon = 1
fmt "I" 3 i_ent_cir                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 3 j_ent_cir                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 3 xp_chs                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "X" 3 old_xp_chs                            # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 3 yp_chs                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 zp_chs                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 3 ip_chs                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 3 jp_chs                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 3 i_eb_cir                              # coordonee I centre du cercle de l'helicoide en relatif point de depart
fmt "J" 3 j_eb_cir                              # coordonee J centre du cercle en relatif point de depart
fmt "Diam" 3 diam_cercle                        # diametre du cercle d'un demi tours de spiral
fmt "X max dans le trou" 3 xp_chs_max           # coordoonee maxi dans le centre du trou
fmt "Ray_cercle ebauche" 3 ray_cercle_ebauche   # Rayon de sortie sur la finition 
fmt "Ray_sortie" 3 ray_cercle_sortie            # Rayon de sortie sur la finition 
fmt "rap_ray_sortie=" 1 rapport_ray_sortie      # rapport muliplicateur du rayon de sortie
fmt "angle_ray_sortie" 1 angle_ray_sortie       # angle de balayage de la portion de cercle de la sortie
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral    # flag pour savoir si on a fait une spirale
fmt "Nb spiral debut " 4 nb_tr_debut " tr"      # Nombre de spiral en debut
fmt "Nb spiral fin " 4 nb_tr_fin    " tr"       # Nombre de spiral en fin
fmt "Pas spiral debut-fin " 3 pas_Z_deb_fin " mm"       # Pas de la spiral d'entree et de fin  
fmt "haut spi debut" 3 prof_z_deb_spi           # calcul de la hauteur de la spiral de debut en ebauche
fmt "haut spi fin" 3 prof_z_fin_spi             # calcul de la hauteur de la spiral de fin en ebauche

#------------------ DECLARATIONS DE MESSAGE SI VALEURS NON CONFORMES-----------


serreur_visu : ""
serreur1 : "Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2 : "Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3 : "Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4 : "Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5 : "Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamètre final - Opération n°"
serreur6 : "Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7 : "Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8 : "Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9 : "Erreur dans cycle CAQ, il faut entrer une valeur positive et entière pour le choix : Nbe de tours finition - Opération n°"
serreur10 : "Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11 : "Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12 : "Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13 : "Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14 : "Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15 : "Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16 : "Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17 : "Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18 : "Erreur dans cycle CAQ, il faut entrer une valeur positive et entière pour le choix : Nbe tours de retour - Opération n°"
serreur19 : "Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre ébauche - Opération n°"
serreur20 : "Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21 : "Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22 : "Erreur dans cycle CAQ, incohérence entre le plan de securité et la garde : Vérifiez vos plans Z - Opération n°"
serreur23 : "ATTENTION : Le rayon d'ébauche est supérieur au diamètre de l'outil, il restera théoriquement une carotte au milieu du trou mon lapin ! OK pour continuer, Annuler pour arrêt post-processeur - Opération n°"
serreur24 : "Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25 : "Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26 : "Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27 : "Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"

percage_helicoido_spiral_2  # ecriture générale du cycle spécial helicoédo-spiral trou suivant
                                gcode$ = 0
                                xabs = x$
                                yabs = y$
                                zabs = initht$
                                n$, *sgcode, *zabs, e$
                                n$, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                n$, *xabs, *yabs, e$
                                percage_helicoido_spiral


percage_helicoido_spiral   # ecriture générale du cycle spécial helicoédo-spiral

                            pcalcule_variable
                            #pvoir_variable
                            #ptest_variable
                            spaces$ = 1


                            if ent_perp <> -1,
                                [
                                phase_1                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                n$, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut - prof_z_deb_spi
                                phase_2                                         # debut ebauche helicoide

                                z_dessus_brut = z_dessus_brut - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                n$, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2                 # fin ebauche helicoide
                                ]




                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4         # premiere serie de passes de finition 
                                    ]
                                phase_5             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6         # entre ligne + cercle pour deuxiemme finition
                                    phase_7         # premiere serie de passes de deuxieme finition 
                                    phase_8         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2           # premiere serie de passes de finition 
                                phase_5_2           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2       # premiere serie de passes de deuxieme finition 
                                    phase_8_2       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]



pvoir_variable         # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction = ",z_retraction , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut =", z_dessus_brut, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$


pcalcule_variable       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            pas_max_xy = dwell$
                            z_dessus_brut = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin


                            hauteur_hel = z_dessus_brut - z_profondeur


                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            ptest_variable   # on test si toutes les variable sont OK 

                            cycle_heli_spiral = 1
                            xabs = x$           # reprendre les positions xyz avant le dégagement
                            yabs = y$
                            zabs = z$

                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp = xabs + ent_perp
                                i_ent_cir = ray_ent_cir * -1 # + x_perp  # si I en ABS
                                x_sor_cir = xabs + ((dia_final - tldia$ + ent_perp) / 2)
                                ]
                            else,   # on est en avalant
                                [
                                x_perp = xabs - ent_perp
                                i_ent_cir = ray_ent_cir # + x_perp  # si I en ABS
                                x_sor_cir = xabs - ((dia_final - tldia$ + ent_perp)/2)
                                ]

                            i_eb_cir = ray_ebauche

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable




ptest_variable        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                serreur_visu = serreur1 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                         if dia_final <=0,
                                [
                                serreur_visu = serreur2 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                         if hauteur_hel <= 0,
                        [
                                serreur_visu = serreur20 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                         if dia_ebauche <= 0,
                                [
                                serreur_visu = serreur3 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]
                        if dia_ebauche > dia_final,
                                [
                                serreur_visu = serreur4 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if dia_final < tldia$,
                                [
                                serreur_visu = serreur5 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if dia_ebauche < tldia$,
                                [
                                serreur_visu = serreur24 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [   
                            #   serreur_visu = serreur6 + no2str(numop) 
                            #   *serreur_visu, e$
                            #   result = mprint(serreur_visu)
                            #    exitpost$ # abandonner 
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                serreur_visu = serreur7 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                serreur_visu = serreur8 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if nbe_tr_fin < 0,
                                [
                                serreur_visu = serreur9 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if f_ent_cir < 0,
                                [
                                serreur_visu = serreur10 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if f_int_hel < 0,
                                [
                                serreur_visu = serreur11 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if f_spiral < 0,
                                [
                                serreur_visu = serreur12 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if f_int_fin < 0,
                                [
                                serreur_visu = serreur13 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if f_sor_cir < 0,
                                [
                                serreur_visu = serreur14 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                serreur_visu = serreur15 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                serreur_visu = serreur16 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                serreur_visu = serreur17 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if nbe_tr_retour < 0,
                                [
                                serreur_visu = serreur18 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if dia_ebauche < tldia$,
                                [
                                serreur_visu = serreur19 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if z_dessus_brut > z_retraction,
                                [
                                serreur_visu = serreur21 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                        if z_retraction > z_plan_securite,
                                [
                                serreur_visu = serreur21 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]
                        if drl_prm9$ < 0,
                                [
                                serreur_visu = serreur25 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]
                        if drl_prm10$ < 0,
                                [
                                serreur_visu = serreur26 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [

                                serreur_visu = serreur27 + no2str(numop)
                                *serreur_visu, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]


                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral = 0 ,
                                [
                                serreur_visu = serreur23 + no2str(numop)
                                result = mprint(serreur_visu,2)
                                if result = 1,  n$, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  *serreur_visu, exitpost$ # abandonner   
                                ]


pf_base             # ecriture que si sup a 0
                        if f_base > 0, avance = f_base, avance

pf_ent_cir          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance = f_ent_cir, avance

pf_int_hel          # ecriture que si sup a 0
                        if f_int_hel > 0, avance = f_int_hel, avance

pf_spiral           # ecriture que si sup a 0
                        if f_spiral > 0, avance = f_spiral, avance

pf_int_fin          # ecriture que si sup a 0
                        if f_int_fin > 0, avance = f_int_fin, avance

pf_sor_cir          # ecriture que si sup a 0
                        if f_sor_cir > 0, avance = f_sor_cir, avance






pcor_ray_on         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, n$,"G42",*correcteur_D,e$
                        else, n$,"G41",*correcteur_D,e$
                        ]
pcor_ray_on_inv         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, n$,"G41",*correcteur_D,e$
                        else, n$,"G42",*correcteur_D,e$
                        ]

pcor_ray_off            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, n$,"G40",e$


phase_1                 # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        n$, sdcom, "MOUVEMENT APPROCHE", sfcom, e$
                        n$, sgcode, *z_retraction, e$
                        gcode$ = 1
                        n$, sgcode, *z_dessus_brut, pf_base,  e$
                        pcor_ray_on
                        n$, sgcode, *x_perp, pf_ent_cir, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs = x_perp - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs = x_perp + (ray_ent_cir*2)
                                ]
                        yp_chs = yabs
                        j_ent_cir = 0 # si J en INC
                        #j_ent_cir = y$ # si J en ABS                   
                        n$, sgcode,xp_chs,yp_chs, i_ent_cir, j_ent_cir, e$

phase_1_2               #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            n$, sgcode, *z_retraction, e$
                            gcode$ = 1
                            n$, sgcode, *z_dessus_brut, pf_base,  e$
                            #pcor_ray_on
                            n$, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_dessus_brut
                            if sens_usi = 1,
                                [

                                xp_chs = xabs - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_ent_cir, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_ebauche - tldia$) /2)
                                ip_chs = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                n$, *sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_ent_cir , e$
                                ]
                            else,
                                [

                                xp_chs = xabs + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_ent_cir, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs + (( dia_ebauche - tldia$) /2)
                                ip_chs = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_ent_cir , e$
                                ]


phase_2                 #   ecriture de l'helice de sortie pour ebauche

                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_dessus_brut
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs = xp_chs + ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir
                                zp_chs = zp_chs - ( pas_z / 2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                xp_chs = xp_chs - ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs = z_profondeur
                                else, zp_chs = zp_chs - ( pas_z / 2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs = xp_chs - ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir * -1
                                zp_chs = zp_chs - ( pas_z / 2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                xp_chs = xp_chs + ( ray_ebauche * 2 )
                                ip_chs = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs = z_profondeur
                                else, zp_chs = zp_chs - ( pas_z / 2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_hel, e$
                                ]
                            ]



phase_3                 #   ecriture de la spirale d'ebauche au fond du trou 
                            n$, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs-xp_chs)*2) + (pas_xy)
                                xp_chs = xp_chs + diam_cercle
                                ip_chs = (diam_cercle/2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs-xabs)*2) + (pas_xy)
                                xp_chs = xp_chs - diam_cercle
                                ip_chs = (diam_cercle/2) * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs-xabs)*2) #+ (pas_xy/2)
                                xp_chs = xp_chs - diam_cercle
                                ip_chs = (diam_cercle/2) * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs-xp_chs)*2) + (pas_xy)
                                old_xp_chs = xp_chs
                                xp_chs = xp_chs + diam_cercle
                                if xp_chs > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs = xp_chs_max
                                    ]
                                ip_chs = (diam_cercle/2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs- xp_chs)*2) #+ (pas_xy/2)
                                xp_chs = xp_chs + diam_cercle
                                ip_chs = (diam_cercle/2)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs-xabs)*2) + (pas_xy)
                                old_xp_chs = xp_chs
                                xp_chs = xp_chs - diam_cercle
                                if xp_chs < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs = xp_chs_max
                                    ]
                                ip_chs = (diam_cercle/2) * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_spiral, e$
                                ]
                            ]

phase_4             #   ecriture des 1 er passes de finition au fond du trou
                            n$, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]

phase_4_2               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            n$, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]

phase_5             #   ecriture de la sortie en fin de finition
                            n$, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
                            else,
                                [
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]

phase_5_2               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            n$, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]
                            else,
                                [
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$
                                ]


phase_6                 #   ecriture de l'entree en debut de deuxieme finition
                            n$, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                n$, *sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs + ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]

phase_6_2               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            n$, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs = xabs - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 2
                                yp_chs = yabs
                                xp_chs = xabs - ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie))
                                n$, *sgcode, *xp_chs,*yp_chs, *zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv
                                n$, *sgcode, *xp_chs,*yp_chs, zp_chs, pf_sor_cir, e$
                                gcode$ = 3
                                yp_chs = yabs
                                xp_chs = xabs + ( (dia_final - tldia$) /2)
                                ip_chs = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                ]

phase_7                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            n$, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1

                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)

                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]

phase_7_2                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            n$, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs = yabs
                            jp_chs = 0
                            zp_chs = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)

                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                            else,
                                [
                                xp_chs = xabs + ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                xp_chs = xabs - ((dia_final - tldia$)/2)
                                ip_chs = ((dia_final - tldia$)/2) * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_int_fin, e$
                                ]
                        ]


phase_8             #   ecriture de la sortie en fin de deuxieme finition
                            n$, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]

phase_8_2               #   ecriture de la sortie en fin de deuxieme finition
                            n$, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs = 0
                            zp_chs = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs = xp_chs + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs = xp_chs - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs = yabs + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs = ray_cercle_sortie * -1
                                n$, *sgcode,xp_chs,yp_chs, zp_chs, *ip_chs, *jp_chs, pf_sor_cir , e$
                                gcode$ = 1
                                pcor_ray_off
                                n$, *sgcode, *xabs,*yabs, zp_chs, pf_sor_cir, e$

                                ]


# ------------------------ FIN CYCLE SPECIAL HELICOIDO-SPIRAL -------------------------



# ------------------------ debut  CYCLE SPECIAL percage decompose -------------------------

#-------- ecriture des format -------------

fmt "F" 5 avance_1
fmt "F" 5 avance_2
fmt "F" 5 avance_3
fmt "F" 5 avance_4
fmt "F" 5 avance_5
fmt "Z" 3 prof_1
fmt "Z" 3 prof_2
fmt "Z" 3 prof_3
fmt "Z" 3 prof_4
fmt "Z" 3 prof_5
fmt "Z" 3 prof_1_rel
fmt "Z" 3 prof_2_rel
fmt "Z" 3 prof_3_rel
fmt "Z" 3 prof_4_rel
fmt "Z" 3 prof_5_rel
fmt "G4 F" 5 tempo_1
fmt "G4 F" 5 tempo_2
fmt "G4 F" 5 tempo_3
fmt "G4 F" 5 tempo_4
fmt "G4 F" 5 tempo_5
fmt "ABS_REL" 4 abso_rel
fmt "sortie" 4 sortie_cycle_prof


serreur100 : "Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101 : "Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102 : "Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dès la première profondeur ! :-) - Opération n°"




pvoirvariable_2   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1 = ",prof_1, e$
                            "voir prof_2 = ",prof_2, e$
                            "voir prof_3 = ",prof_3, e$
                            "voir prof_4 = ",prof_4, e$
                            "voir prof_5 = ",prof_5, e$
                            "voir tempo_1 = ",*tempo_1, e$
                            "voir tempo_2 = ",*tempo_2, e$
                            "voir tempo_3 = ",*tempo_3, e$
                            "voir tempo_4 = ",*tempo_4, e$
                            "voir tempo_5 = ",*tempo_5, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction = ",z_retraction, e$


pcalcule_variable_2       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1 = drl_prm1$
                            prof_2 = drl_prm2$
                            prof_3 = drl_prm3$
                            prof_4 = drl_prm4$
                            prof_5 = drl_prm5$
                            tempo_1 = (frac(drl_prm6$)) * 10000
                            tempo_2 = (frac(drl_prm7$)) * 10000
                            tempo_3 = (frac(drl_prm8$)) * 10000
                            tempo_4 = (frac(drl_prm9$)) * 10000
                            tempo_5 = (frac(drl_prm10$)) * 10000
                            abso_rel = peck1$
                            zabs = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel =  prof_1 + tosz$
                            prof_2_rel = prof_2 + prof_1_rel
                            prof_3_rel = prof_3 + prof_2_rel
                            prof_4_rel = prof_4 + prof_3_rel
                            prof_5_rel = prof_5 + prof_4_rel

                            #pvoirvariable_2


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                serreur_visu = serreur100 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                serreur_visu = serreur101 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                               ]

                            if prof_1 = 9999,
                                [
                                serreur_visu = serreur102 + no2str(numop)
                                *serreur_visu, e$
                                result = mprint(serreur_visu)
                                exitpost$ # abandonner 
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5



percage_avance_controle_2

                                gcode$ = 0

                                xabs = x$
                                yabs = y$
                                zabs = initht$
                                n$, *sgcode, *zabs, e$
                                n$, sdcom, " POSITIONEMENT TROU SUIVANT", sfcom, e$
                                n$, *xabs, *yabs, e$
                                percage_avance_controle

percage_avance_controle    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral = 1

                            n$, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2
                            gcode$ = 0
                            n$, sgcode, zabs, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                n$, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr_pos$ = avance_1
                                n$, sgcode, prof_1, pfr,  e$
                                if tempo_1 > 0, n$, *tempo_1, e$

                                if prof_2 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_2
                                        n$, sgcode, prof_2, pfr,  e$
                                        if tempo_2 > 0, n$, *tempo_2, e$
                                        ]
                                if prof_3 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_3
                                        n$, sgcode, prof_3, pfr,  e$
                                        if tempo_3 > 0, n$, *tempo_3, e$
                                        ]
                                if prof_4 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_4
                                        n$, sgcode, prof_4, pfr,  e$
                                        if tempo_4 > 0, n$, *tempo_4, e$
                                        ]
                                if prof_5 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_5
                                        n$, sgcode, prof_5, pfr,  e$
                                        if tempo_5 > 0, n$, *tempo_5, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                n$, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr_pos$ = avance_1

                                n$, sgcode, prof_1_rel, pfr,  e$
                                if tempo_1 > 0, n$, *tempo_1, e$

                                if prof_2 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_2
                                        n$, sgcode, prof_2_rel, pfr,  e$
                                        if tempo_2 > 0, n$, *tempo_2, e$
                                        ]
                                if prof_3 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_3
                                        n$, sgcode, prof_3_rel, pfr,  e$
                                        if tempo_3 > 0, n$, *tempo_3, e$
                                        ]
                                if prof_4 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_4
                                        n$, sgcode, prof_4_rel, pfr,  e$
                                        if tempo_4 > 0, n$, *tempo_4, e$
                                        ]
                                if prof_5 = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        n$, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr_pos$ = avance_5
                                        n$, sgcode, prof_5_rel, pfr,  e$
                                        if tempo_5 > 0, n$, *tempo_5, e$
                                        ]

                                 ]




pdrlcst$     # cycle speciaux premier passage


                if drl_cycle$ = 9,
                [
                n$, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        percage_avance_controle
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
                ]





pdrlcst_2$     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                percage_avance_controle_2
                !x$, !y$, !z$, !xr$, !yr$, !zr$
                ]




ppercexy     # ecriture des x, y en abs ou incremental pour percage

        xabs = x$
        yabs = y$

           if rotaxis$ = 0,
            [   # XY CLASIQUE
            @depth$
            @refht$
            profabs = depth$
            profi = depth$ - refht$
            gardeabs = refht$
            gardei = refht$ - initht$
            !depth$
            !refht$

                    if incremental = 0,  xabs, yabs, # profabs, gardeabs, !Xinc, !Yinc, !profi, !gardei
                    else,           !xabs, !yabs, !profabs, !gardeabs, Xinc, Yinc, #profi, gardei

                        ]

           if rotaxis$ <> 0, [    # SUBSTITUTION Y par A (diviseur tourne autour de X)
            p_Apos
            @depth$
            @refht$
            profabs = depth$ + (rotdia$/2)
            profi = depth$ - refht$
            gardeabs = refht$ + (rotdia$/2)
            gardei = refht$-initht$
            !depth$
            !refht$

                if incremental = 0, xabs, yabs, axeA, profabs, gardeabs, !Xinc, !Yinc, !axeAi, !profi, !gardei
                else, !xabs, !yabs, !axeA, !profabs, !gardeabs, Xinc, Yinc, axeAi, profi, gardei

            old_axeA  = axeA
            nbrtour = int (axeA / 360)
                     ]

    p_modal     # afficher en format modal
        !x$, !y$    # mise a jour XY    

        old_x = xabs
        old_y = yabs






phole       # trous suivants


        n$, sinc_abs, ppercexy, e$


pcanceldc$  # Anuulation de cyle fixe

        z$ = initht$      # z au plan de secu
        profabs=  -99999    # raz des prof garde tempo
        gardeabs=  -99999
        tempo = 0
        !profabs
        !gardeabs
        !tempo
        if rotaxis$ = 0,zabs = z$
        else, zabs = z$ + (rotdia$/2)
        if cycle_heli_spiral = 1, gcode$ = 0, cycle_heli_spiral = 0 , n$, sdcom, " FIN CYCLE SPECIAL ", sfcom, e$    # choix du gcode pour ecrire G0
        else, gcode$ =5    # choix du gcode pour ecrire G80
        if incremental = 0, n$, sinc_abs, *sgcode, *zabs, !Zinc, e$
        if incremental = 1, n$, sinc_abs, *sgcode, !zabs, Zinc, e$
        !z$      # Raz de Z
        old_z = zabs


#------------------Liste des OUTILS---------------------------------------------------

ptypeBoutT # afficher on non le rayon de bout
           if paramT4 <> 0, space, paramT6

pangleT    # afficher on non l'angle de l'outil
           if paramT2 = 3 | paramT2 = 12 | paramT2 = 2 | paramT2 = 17 | paramT2 = 9 | paramT2 = 4 | paramT2 = 5, space, paramT8




pwrtt$      # Lite des outil     

            strtool$ = ucase(strtool$)

        if texte <> 0 & t$ > 0, [


            if numcoment = 0, omitseq$ = 1



            if strtool$ <> svide, n$, sdcom, spaces$ = 0, paramT1, space, strtool$, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, spaces$ = old_spaces, e$
            else, n$, sdcom, spaces$ = 0, paramT1, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, spaces$ = old_spaces, e$

            omitseq$ = old_omitseq

                ]

    last_op_id = op_id$



# -------------------------LECTURE DES PARAMETRES DE SUREP ET DE TYPE DE CORRECTION--------------------------------------------

paramcomp   # Type de correction d'outil au changement d'operation


    if info_corr = 1 & op_id$ <> old_op_id  & texte <> 0, [ # si afficher les infos de compesation et changement d'operation et texte supporté
        @cc_computer$, @cc_pos$                 # mise é jour des variables                 
        #cc_comp 41 42 0
        #cc_pos   1  2 0
        if cc_pos$ = 0  & cc_computer$ = 0,   type_comp = 0 #AUCUNE

        if cc_pos$ = 2  & cc_computer$ = 0,   type_comp = 1 #ARMOIRE DROITE
        if cc_pos$ = 1  & cc_computer$ = 0,   type_comp = 2 #ARMOIRE GAUCHE

        if cc_pos$ = 0  & cc_computer$ = 42,  type_comp = 3 #ORDINATEUR DROITE
        if cc_pos$ = 0  & cc_computer$ = 41,  type_comp = 4 #ORDINATEUR GAUCHE

    if cc_pos$ = 2  & cc_computer$ = 42,  type_comp = 5 #USURE DROITE
    if cc_pos$ = 1  & cc_computer$ = 41,  type_comp = 6 #USURE GAUCHE

    if cc_pos$ = 1  & cc_computer$ = 42,  type_comp = 7 #USURE INVERSE DROITE
    if cc_pos$ = 2  & cc_computer$ = 41,  type_comp = 8 #USURE INVERSE GAUCHE


        if opcode$ = 19, type_comp = 0              # mis sur aucune a la place d'ordinateur pour surfacage (bug)


    if numcoment = 0, omitseq$ = 1              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
    if opcode$ <> 3, n$, sdcom, spaces$ = 0, stype_comp, sfcom, spaces$ = old_spaces, e$    # pour ne pas afficher les infos si percage

    omitseq$ = old_omitseq                  # rappel des numero de bloc

                                    ]


paramsurep  # Affichage des surep au changement d'opération

        if info_surep = 1 & op_id$ <> old_op_id  & texte <> 0, [    # si afficher les infos de compesation et changement d'operation et texte supporté


    if numcoment = 0, omitseq$ = 1                  # si pas de numero de bloc pour commentaires enlever les numeros de bloc
    # surep pour surfacage
        if opcode$ = 19, n$, sdcom, spaces$ = 0, *surepl, sfcom, spaces$ = old_spaces, e$
    # surep 2d        
        if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19, n$, sdcom, spaces$ = 0, *surep, space, *surepl, sfcom, spaces$ = old_spaces, e$
    # surep 3d
        if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, n$, sdcom, spaces$ = 0, *surep3d, sfcom, spaces$ = old_spaces, e$

    omitseq$ = old_omitseq                      # rappel des numero de bloc
                                ]

ptestmachine    # verif de la def machine

        #*nbr_combi, "---------", e$
    if nbr_combi > 1, erreur = 3        # le pst ne supporte q'une combinaison d'axe par programme  
    if compt_axes_rot > 1, erreur = 2       # le pst ne supporte q'un axe rotaif
    if write_ops = 0, erreur = 1        # Write NC Operation information MUST be enabled in CD
    perreur

perreur

      !erreur
      !serreur


    if erreur <> 0, [

        if erreur = 4 & testerreur4 = 0, [
            serreurbase = serreur + no2str(numop)
            result = mprint(serreur2, 3)

            if result = 3, serreurbase , e$, exitpost$ # abandonner
            if result = 4, serreurbase         # recommencer                   
            if result = 5,  testerreur4 = 1     # ignorer

                ]

        if erreur <> 4, [
            result = mprint(serreur, 2)
            exitpost$
            ]
            ]




#-------------------------- RENOMMER LE FICHIER NC EN FONCTION DU NUMERO DE PROGRAMME -------------------------



pnom_nc     # Génération des noms du fichier NC

        snom_nc = spathnc$+snamenc$+spoint+sextnc$             # Fichier NC en cours de creation sous forme toto.nc
        snom_numero = no2str (progno$)
        snom_numero = spathnc$+stringo+snom_numero+spoint+sextnc$     # nouveau non de fichier NC sous forme O0015.nc


ptest_nom   # test du non du fichier NC si O0123.NC

        if fexist (snom_numero), q11

        if remplace = 0, pchange_nom
        if remplace = 1, result = remove (snom_numero)

pchange_nom     # changer le numéro de prog si fichier exite déja


        while fexist (snom_numero), [
            q10
            snom_numero = no2str (progno$)
            snom_numero = spathnc$+stringo+snom_numero+spoint+sextnc$
                        ]



ppost$       # traitement apres post pro pour effacer le fichier OPS et renommer le fichier NC

        sfileops= spathnci$ + snamenci$ + sops      # non du fichier ops
        result = remove (sfileops)          # effacer le fichier ops


        if use_progno = 1, result = remove (snom_numero)        #efface fichier en nom numero
        if use_progno = 1, result = rename (snom_nc, snom_numero)   #renomer fichier NC en nom numero
        if use_progno = 1, result = launch (seditor, snom_numero)   #lancer le blocnote




[CTRL_MILL|DEFAULT]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. "Origine Programme G54 à G59"//55
10. "Arrêt prog avant opération 1=oui"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Perçage G81 ou G82 (Lamage)"
2. "Avance"
3. "Tempo si > 0 = G82"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Brise copeaux G83"
2. "Avance"
3. "Tempo."
4. "Plan de sécurité"
5. "Garde"
9. "Increment de passe"
10. ""
11. ""
[chip break]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[tap]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Alesage G85 (Lamage)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "Perçage deux niveaux"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. "Fin du 1er trou"
11. "Debut du 2eme trou"
[misc1]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc2]
1. "Perçage CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Avalant=0 Oppo=1"
8. "Diamètre final"
9. "Diamètre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "Perçage décomposé"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 12]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 13]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 14]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 15]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 16]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 17]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 18]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 19]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 20]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill custom parameters]
1. "Paramètres de cycle spécial 1"
[peck drill custom parameters]
1. "Paramètres de cycle spécial 2"
[chip break drill custom parameters]
1. "Paramètres de cycle spécial 3"
[tap custom parameters]
1. "Paramètres de cycle spécial 4"
[bore1 custom parameters]
1. "Paramètres de cycle spécial 5"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle misc1"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoédo-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoédale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
1. "Perçage G81 ou G82"
2. "Débourrage G83"
3. ""
4. ""
5. "Alésage G85"
6. ""
7. ""
8. "Perçage CAQ"
9. ""
10. "Perçage décomposé"
11. ""
12. ""
13. ""
14. ""
15. ""
16. ""
17. ""
18. ""
19. ""
20. ""
[canned text]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[CTRL_MILL|3X_9108_2015_01]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. "Origine Programme G54 à G59"//55
10. "Arrêt prog avant opération 1=oui"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Perçage G81 ou G82 (Lamage)"
2. "Avance"
3. "Tempo si > 0 = G82"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Brise copeaux G83"
2. "Avance"
3. "Tempo."
4. "Plan de sécurité"
5. "Garde"
9. "Increment de passe"
10. ""
11. ""
[chip break]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[tap]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Alesage G85 (Lamage)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "Perçage deux niveaux"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. "Fin du 1er trou"
11. "Debut du 2eme trou"
[misc1]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc2]
1. "Perçage CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Avalant=0 Oppo=1"
8. "Diamètre final"
9. "Diamètre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "Perçage décomposé"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 12]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 13]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 14]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 15]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 16]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 17]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 18]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 19]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 20]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill custom parameters]
1. "Paramètres de cycle spécial 1"
[peck drill custom parameters]
1. "Paramètres de cycle spécial 2"
[chip break drill custom parameters]
1. "Paramètres de cycle spécial 3"
[tap custom parameters]
1. "Paramètres de cycle spécial 4"
[bore1 custom parameters]
1. "Paramètres de cycle spécial 5"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle misc1"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoédo-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoédale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
1. "Perçage G81 ou G82"
2. "Débourrage G83"
3. ""
4. ""
5. "Alésage G85"
6. ""
7. ""
8. "Perçage CAQ"
9. ""
10. "Perçage décomposé"
11. ""
12. ""
13. ""
14. ""
15. ""
16. ""
17. ""
18. ""
19. ""
20. ""
[canned text]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[CTRL_MILL|3X_9108_2015_03]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. "Origine Programme G54 à G59"//55
10. "Arrêt prog avant opération 1=oui"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Perçage G81 ou G82 (Lamage)"
2. "Avance"
3. "Tempo si > 0 = G82"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Brise copeaux G83"
2. "Avance"
3. "Tempo."
4. "Plan de sécurité"
5. "Garde"
9. "Increment de passe"
10. ""
11. ""
[chip break]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[tap]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Alesage G85 (Lamage)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "Perçage deux niveaux"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. "Fin du 1er trou"
11. "Debut du 2eme trou"
[misc1]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc2]
1. "Perçage CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Avalant=0 Oppo=1"
8. "Diamètre final"
9. "Diamètre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "Perçage décomposé"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 12]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 13]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 14]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 15]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 16]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 17]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 18]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 19]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 20]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill custom parameters]
1. "Paramètres de cycle spécial 1"
[peck drill custom parameters]
1. "Paramètres de cycle spécial 2"
[chip break drill custom parameters]
1. "Paramètres de cycle spécial 3"
[tap custom parameters]
1. "Paramètres de cycle spécial 4"
[bore1 custom parameters]
1. "Paramètres de cycle spécial 5"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle misc1"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoédo-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoédale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
1. "Perçage G81 ou G82"
2. "Débourrage G83"
3. ""
4. ""
5. "Alésage G85"
6. ""
7. ""
8. "Perçage CAQ"
9. ""
10. "Perçage décomposé"
11. ""
12. ""
13. ""
14. ""
15. ""
16. ""
17. ""
18. ""
19. ""
20. ""
[canned text]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[CTRL_MILL|3X_9108_2015_09]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. "Origine Programme G54 à G59"//55
10. "Arrêt prog avant opération 1=oui"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Perçage G81 ou G82 (Lamage)"
2. "Avance"
3. "Tempo si > 0 = G82"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Brise copeaux G83"
2. "Avance"
3. "Tempo."
4. "Plan de sécurité"
5. "Garde"
9. "Increment de passe"
10. ""
11. ""
[chip break]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[tap]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Alesage G85 (Lamage)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "Perçage deux niveaux"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. "Fin du 1er trou"
11. "Debut du 2eme trou"
[misc1]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc2]
1. "Perçage CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Avalant=0 Oppo=1"
8. "Diamètre final"
9. "Diamètre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "Perçage décomposé"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 12]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 13]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 14]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 15]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 16]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 17]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 18]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 19]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 20]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill custom parameters]
1. "Paramètres de cycle spécial 1"
[peck drill custom parameters]
1. "Paramètres de cycle spécial 2"
[chip break drill custom parameters]
1. "Paramètres de cycle spécial 3"
[tap custom parameters]
1. "Paramètres de cycle spécial 4"
[bore1 custom parameters]
1. "Paramètres de cycle spécial 5"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle misc1"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoédo-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoédale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
1. "Perçage G81 ou G82"
2. "Débourrage G83"
3. ""
4. ""
5. "Alésage G85"
6. ""
7. ""
8. "Perçage CAQ"
9. ""
10. "Perçage décomposé"
11. ""
12. ""
13. ""
14. ""
15. ""
16. ""
17. ""
18. ""
19. ""
20. ""
[canned text]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[CTRL_MILL|3X_9108_2016_12]
[misc integers]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. "Origine Programme G54 à G59"//55
10. "Arrêt prog avant opération 1=oui"
[misc reals]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill]
1. "Perçage G81 ou G82 (Lamage)"
2. "Avance"
3. "Tempo si > 0 = G82"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "Brise copeaux G83"
2. "Avance"
3. "Tempo."
4. "Plan de sécurité"
5. "Garde"
9. "Increment de passe"
10. ""
11. ""
[chip break]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[tap]
1. "PAS DISPONIBLE"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore1]
1. "Alesage G85 (Lamage)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "Perçage deux niveaux"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. ""
8. ""
9. ""
10. "Fin du 1er trou"
11. "Debut du 2eme trou"
[misc1]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[misc2]
1. "Perçage CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Avalant=0 Oppo=1"
8. "Diamètre final"
9. "Diamètre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "Perçage décomposé"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 12]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 13]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 14]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 15]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 16]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 17]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 18]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 19]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[drill cycle 20]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[simple drill custom parameters]
1. "Paramètres de cycle spécial 1"
[peck drill custom parameters]
1. "Paramètres de cycle spécial 2"
[chip break drill custom parameters]
1. "Paramètres de cycle spécial 3"
[tap custom parameters]
1. "Paramètres de cycle spécial 4"
[bore1 custom parameters]
1. "Paramètres de cycle spécial 5"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle misc1"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoédo-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoédale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
1. "Perçage G81 ou G82"
2. "Débourrage G83"
3. ""
4. ""
5. "Alésage G85"
6. ""
7. ""
8. "Perçage CAQ"
9. ""
10. "Perçage décomposé"
11. ""
12. ""
13. ""
14. ""
15. ""
16. ""
17. ""
18. ""
19. ""
20. ""
[canned text]
1. ""
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
[CTRL_TEXT_END]
