[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V19.00 P0 E1 W19.00 T1473932983 M19.00 I0 O0
#region   VARIABLES SIMULATION #OK

#region variables générales
sext : "CL"
sblk : "BLK"
fmt "X" 2 xaff
fmt "Y" 2 yaff
fmt "Z" 2 zaff
fmt "A" 2 aaff
fmt "C" 2 caff
fmt "R" 2 raff
fmt "N" 4 n2
fmt "N" 4 n$
fmt  "B" 3 axeB5xsimu
fmt  "C" 3 axeC5xsimu
fmt 8 m1simu
fmt 8 m2simu
fmt 8 m3simu
fmt 8 tox4simu
fmt 8 m4simu
fmt 8 m5simu
fmt 8 m6simu
fmt 8 toy4simu
fmt 8 m7simu
fmt 8 m8simu
fmt 8 m9simu
fmt 8 toz4simu
fmt 19 tox4$
fmt 19 toy4$
fmt 19 toz4$
fmt "Z" 2 drl_depth_z$
fmt "plinc" 2 plinc
fmt "planperc" 1 planperc
fmt 2 old_initht
fmt 2 old_refht
fmt 2 old_depth
#endregion

#region variables AG
fmt "v_delta_x" 1 v_delta_x_AG
fmt "v_delta_y" 1 v_delta_y_AG
fmt "v_delta_z" 1 v_delta_z_AG
fmt "v_delta_xyz" 1 v_delta_xyz_AG
fmt "v_sindir_x" 1 v_sindir_x_AG
fmt "v_sindir_y" 1 v_sindir_y_AG
fmt "v_sindir_z" 1 v_sindir_z_AG
fmt "v_delta_div" 1 v_delta_div_AG
fmt "v_abs_plus_x" 1 v_abs_plus_x_AG
fmt "v_abs_plus_y" 1 v_abs_plus_y_AG
fmt "v_abs_plus_z" 1 v_abs_plus_z_AG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_AG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_AG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_AG
fmt "old_v_abs_plus_z_sec" 1 old_v_abs_plus_z_sec_AG
fmt "old_v_abs_plus_x_sec" 1 old_v_abs_plus_x_sec_AG
fmt "old_v_abs_plus_y_sec" 1 old_v_abs_plus_y_sec_AG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_fin_AG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_fin_AG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_fin_AG
fmt "old_opcode" 1 old_opcode_AG
fmt "X" 2 xprintcorg_AG
fmt "Y" 2 yprintcorg_AG
fmt "Z" 2 zprintcorg_AG
fmt 19 old_corg_x_AG
fmt 19 old_corg_y_AG
fmt 19 old_corg_z_AG
fmt 19 dif_old_corg_x_AG
fmt 19 dif_old_corg_y_AG
fmt 19 dif_old_corg_z_AG
fmt 1 premperc_AG
fmt  "R" 24 rayon_AG
fmt 2 flag_cloche_AG
fmt 2 flag_chargement_cloche_AG
fmt 2 arret_prog_AG
fmt 2 old_tool_AG
fmt "C_UN" 2 scchangeur_AG
fmt "C_UN" 2 sccloche_AG
fmt 1 flag_outil_AG
fmt "dif_c_AG" 1 dif_c_AG
fmt "dif_a_AG" 1 dif_a_AG
fmt "old_axeC_simu_AG" 1 old_axeC_simu_AG
fmt "old_axeA_simu_AG" 1 old_axeA_simu_AG
fmt "delta_AG" 1 delta_AG
fmt "old_xprint_simu_AG" 1 old_xprint_simu_AG
fmt "old_yprint_simu_AG" 1 old_yprint_simu_AG
fmt "old_zprint_simu_AG" 1 old_zprint_simu_AG
fmt "conttour_AG" 1 conttour_AG
fmt "X" 3 x_inter_AG
fmt "Y" 3 y_inter_AG
fmt "Z" 3 z_inter_AG
fmt "delta_c_AG" 1 delta_c_AG
fmt "delta_b_AG" 1 delta_b_AG
fmt "C" 3 c_inter_AG
fmt "A" 3 b_inter_AG
fmt "v_delta_x_simu_AG" 1 v_delta_x_simu_AG
fmt "v_delta_y_simu_AG" 1 v_delta_y_simu_AG
fmt "v_delta_z_simu_AG" 1 v_delta_z_simu_AG
fmt "v_delta_xyz_simu_AG" 1 v_delta_xyz_simu_AG
fmt "v_sindir_x_simu_AG" 1 v_sindir_x_simu_AG
fmt "v_sindir_y_simu_AG" 1 v_sindir_y_simu_AG
fmt "v_sindir_z_simu_AG" 1 v_sindir_z_simu_AG
fmt "v_delta_div_simu_AG" 1 v_delta_div_simu_AG
fmt "v_abs_plus_x_simu_AG" 1 v_abs_plus_x_simu_AG
fmt "v_abs_plus_y_simu_AG" 1 v_abs_plus_y_simu_AG
fmt "v_abs_plus_z_simu_AG" 1 v_abs_plus_z_simu_AG

flag_cloche_AG : 0
flag_chargement_cloche_AG : 0
flag_changement_outil_AG : 0
premperc_AG : 0
old_opcode_AG : 0
flag_outil_AG : 0
conttour_AG : 0
delta_AG : 15

#endregion

#region variables BG
fmt "v_delta_x" 1 v_delta_x_BG
fmt "v_delta_y" 1 v_delta_y_BG
fmt "v_delta_z" 1 v_delta_z_BG
fmt "v_delta_xyz" 1 v_delta_xyz_BG
fmt "v_sindir_x" 1 v_sindir_x_BG
fmt "v_sindir_y" 1 v_sindir_y_BG
fmt "v_sindir_z" 1 v_sindir_z_BG
fmt "v_delta_div" 1 v_delta_div_BG
fmt "v_abs_plus_x" 1 v_abs_plus_x_BG
fmt "v_abs_plus_y" 1 v_abs_plus_y_BG
fmt "v_abs_plus_z" 1 v_abs_plus_z_BG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_BG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_BG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_BG
fmt "old_v_abs_plus_z_sec" 1 old_v_abs_plus_z_sec_BG
fmt "old_v_abs_plus_x_sec" 1 old_v_abs_plus_x_sec_BG
fmt "old_v_abs_plus_y_sec" 1 old_v_abs_plus_y_sec_BG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_fin_BG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_fin_BG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_fin_BG
fmt "old_opcode" 1 old_opcode_BG
fmt "X" 2 xprintcorg_BG
fmt "Y" 2 yprintcorg_BG
fmt "Z" 2 zprintcorg_BG
fmt 19 old_corg_x_BG
fmt 19 old_corg_y_BG
fmt 19 old_corg_z_BG
fmt 19 dif_old_corg_x_BG
fmt 19 dif_old_corg_y_BG
fmt 19 dif_old_corg_z_BG
fmt 1 premperc_BG
fmt  "R" 24 rayon_BG
fmt 2 flag_cloche_BG
fmt 2 flag_chargement_cloche_BG
fmt 2 arret_prog_BG
fmt 2 old_tool_BG
fmt "CO_UN" 2 scchangeur_BG
fmt "CO_UN" 2 sccloche_BG
fmt "CO_DEUX" 2 scchangeur_2_BG
fmt "CO_DEUX" 2 sccloche_2_BG
fmt 2 change_tool_cloche_BG
fmt 2 mr8_changeur_BG
fmt 2 dechargement_cloche_BG
fmt 1 flag_outil_BG
fmt "dif_c_BG" 1 dif_c_BG
fmt "dif_a_BG" 1 dif_a_BG
fmt "old_axeC_simu_BG" 1 old_axeC_simu_BG
fmt "old_axeA_simu_BG" 1 old_axeA_simu_BG
fmt "delta_BG" 1 delta_BG
fmt "old_xprint_simu_BG" 1 old_xprint_simu_BG
fmt "old_yprint_simu_BG" 1 old_yprint_simu_BG
fmt "old_zprint_simu_BG" 1 old_zprint_simu_BG
fmt "conttour_BG" 1 conttour_BG
fmt "X" 3 x_inter_BG
fmt "Y" 3 y_inter_BG
fmt "Z" 3 z_inter_BG
fmt "delta_c_BG" 1 delta_c_BG
fmt "delta_b_BG" 1 delta_b_BG
fmt "C" 3 c_inter_BG
fmt "A" 3 b_inter_BG
fmt "v_delta_x_simu_BG" 1 v_delta_x_simu_BG
fmt "v_delta_y_simu_BG" 1 v_delta_y_simu_BG
fmt "v_delta_z_simu_BG" 1 v_delta_z_simu_BG
fmt "v_delta_xyz_simu_BG" 1 v_delta_xyz_simu_BG
fmt "v_sindir_x_simu_BG" 1 v_sindir_x_simu_BG
fmt "v_sindir_y_simu_BG" 1 v_sindir_y_simu_BG
fmt "v_sindir_z_simu_BG" 1 v_sindir_z_simu_BG
fmt "v_delta_div_simu_BG" 1 v_delta_div_simu_BG
fmt "v_abs_plus_x_simu_BG" 1 v_abs_plus_x_simu_BG
fmt "v_abs_plus_y_simu_BG" 1 v_abs_plus_y_simu_BG
fmt "v_abs_plus_z_simu_BG" 1 v_abs_plus_z_simu_BG

dechargement_cloche_BG : 0
change_tool_cloche_BG : 0
flag_cloche_BG : 0
flag_chargement_cloche_BG : 0
flag_changement_outil_BG : 0
premperc_BG : 0
old_opcode_BG : 0
flag_outil_BG : 0
conttour_BG : 0
delta_BG : 15
#endregion

#region variables CG
fmt "v_delta_x" 1 v_delta_x_CG
fmt "v_delta_y" 1 v_delta_y_CG
fmt "v_delta_z" 1 v_delta_z_CG
fmt "v_delta_xyz" 1 v_delta_xyz_CG
fmt "v_sindir_x" 1 v_sindir_x_CG
fmt "v_sindir_y" 1 v_sindir_y_CG
fmt "v_sindir_z" 1 v_sindir_z_CG
fmt "v_delta_div" 1 v_delta_div_CG
fmt "v_abs_plus_x" 1 v_abs_plus_x_CG
fmt "v_abs_plus_y" 1 v_abs_plus_y_CG
fmt "v_abs_plus_z" 1 v_abs_plus_z_CG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_CG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_CG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_CG
fmt "old_v_abs_plus_z_sec" 1 old_v_abs_plus_z_sec_CG
fmt "old_v_abs_plus_x_sec" 1 old_v_abs_plus_x_sec_CG
fmt "old_v_abs_plus_y_sec" 1 old_v_abs_plus_y_sec_CG
fmt "v_abs_plus_x_sec" 1 v_abs_plus_x_sec_fin_CG
fmt "v_abs_plus_y_sec" 1 v_abs_plus_y_sec_fin_CG
fmt "v_abs_plus_z_sec" 1 v_abs_plus_z_sec_fin_CG
fmt "old_opcode" 1 old_opcode_CG
fmt "X" 2 xprintcorg_CG
fmt "Y" 2 yprintcorg_CG
fmt "Z" 2 zprintcorg_CG
fmt 19 old_corg_x_CG
fmt 19 old_corg_y_CG
fmt 19 old_corg_z_CG
fmt 19 dif_old_corg_x_CG
fmt 19 dif_old_corg_y_CG
fmt 19 dif_old_corg_z_CG
fmt 1 premperc_CG
fmt  "R" 24 rayon_CG
fmt 2 flag_cloche_CG
fmt 2 flag_chargement_cloche_CG
fmt 2 old_tool_CG
fmt "T_C" 2 scchangeur_CG
fmt  "C" 12 axe_C_garage_CG
fmt  "B" 12 axe_A_garage_CG
fmt  "num garage" 12 garage_CG
fmt 1 flag_outil_CG
fmt "dif_c_CG" 1 dif_c_CG
fmt "dif_a_CG" 1 dif_a_CG
fmt "old_axeC_simu_CG" 1 old_axeC_simu_CG
fmt "old_axeA_simu_CG" 1 old_axeA_simu_CG
fmt "delta_CG" 1 delta_CG
fmt "old_xprint_simu_CG" 1 old_xprint_simu_CG
fmt "old_yprint_simu_CG" 1 old_yprint_simu_CG
fmt "old_zprint_simu_CG" 1 old_zprint_simu_CG
fmt "conttour_CG" 1 conttour_CG
fmt "X" 3 x_inter_CG
fmt "Y" 3 y_inter_CG
fmt "Z" 3 z_inter_CG
fmt "delta_c_CG" 1 delta_c_CG
fmt "delta_b_CG" 1 delta_b_CG
fmt "C" 3 c_inter_CG
fmt "B" 3 b_inter_CG
fmt "v_delta_x_simu_CG" 1 v_delta_x_simu_CG
fmt "v_delta_y_simu_CG" 1 v_delta_y_simu_CG
fmt "v_delta_z_simu_CG" 1 v_delta_z_simu_CG
fmt "v_delta_xyz_simu_CG" 1 v_delta_xyz_simu_CG
fmt "v_sindir_x_simu_CG" 1 v_sindir_x_simu_CG
fmt "v_sindir_y_simu_CG" 1 v_sindir_y_simu_CG
fmt "v_sindir_z_simu_CG" 1 v_sindir_z_simu_CG
fmt "v_delta_div_simu_CG" 1 v_delta_div_simu_CG
fmt "v_abs_plus_x_simu_CG" 1 v_abs_plus_x_simu_CG
fmt "v_abs_plus_y_simu_CG" 1 v_abs_plus_y_simu_CG
fmt "v_abs_plus_z_simu_CG" 1 v_abs_plus_z_simu_CG

garage_CG : 0
flag_cloche_CG : 0
flag_chargement_cloche_CG : 0
flag_changement_outil_CG : 0
premperc_CG : 0
old_opcode_CG : 0
flag_outil_CG : 0
conttour_CG : 0
delta_CG : 15

#endregion

#region strings générales

sazero : "A+0.000"
sbzero : "B+0.000"
sczero : "C+0.000"
sa_quatre_vingt_dix : "A+90.000"
sa_moins_quatre_vingt_dix : "A-90.000"
sb_quatre_vingt_dix : "B+90.000"
sb_moins_quatre_vingt_dix : "B-90.000"
sb_soixante : "B+60.000"
sb_moins_soixante : "B-60.000"
string_B_CG : ""
sc_moins_quatre_vingt_dix : "C-90.000"
sc_moins_cent_quatre_vingt : "C-180.000"
sc_cent_quatre_vingt : "C180.000"
sxzero : "X+0.000"
sxtete : "X+0.000"
sytete : "Y+310.000"
sztete : "Z-540.000"
satete : "A-100.000"
sctete : "C+58.000"
sfsimurapid : "F10000"
stype_arc : ""
sdegageZ    : "Z0."
snumligne : ""

sr : "MW_RELMOVE RAPID" # mouvement rapide par rapport a la piece
sl : "MW_RELMOVE FEED" # mouvement ligne travail par rapport a la piece
sc : "MW_RELARCMOVE FEED"  # mouvement par rapport a la piece
sm : "MW_MACHMOVE RAPID"    # MOUVEMENT par rapport au repere de la machine
sf : "MW_OP_END"      # fin d'une operation 
srtcpon : "MW_RTCP ON MACHINE_ANGLES"
srtcpoff : "MW_RTCP OFF"

space_aff : "" # "<EOC>"     # <EOC> pour un affichage avec tabulation, "" sans 

paf_cal_aff

               if prog_AG = 1,  [
                                xaff = xprint_AG
                                yaff = yprint_AG
                                zaff = zprint_AG
                                aaff = axeA_AG
                                caff = axeC_AG
                                ]
               if prog_BG = 1,  [
                                xaff = xprint_BG
                                yaff = yprint_BG
                                zaff = zprint_BG
                                aaff = axeA_BG
                                caff = axeC_BG
                                ]
               if prog_CG = 1,  [
                                xaff = xprint_CG
                                yaff = yprint_CG
                                zaff = zprint_CG
                                aaff = axeA_CG
                                caff = axeC_CG
                                ]
paf_xyzac    # ici on gere l'affichage en bout de ligne X Y Z A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*aaff,space_aff,*caff

paf_xy    # ici on gere l'affichage en bout de ligne X Y 
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff

paf_xyz    # ici on gere l'affichage en bout de ligne X Y Z 
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,sgcode,*xaff,*yaff,*zaff

paf_xyac    # ici on gere l'affichage en bout de ligne X Y A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*aaff,space_aff,*caff

paf_zac    # ici on gere l'affichage en bout de ligne Z A C
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*zaff,space_aff,*aaff,space_aff,*caff

paf_xyzr    # ici on gere l'affichage en bout de ligne X Y Z R
                paf_cal_aff
                pnumligne,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*raff

paf_ac    # ici on gere l'affichage en bout de ligne A C
                paf_cal_aff
                pnumligne,35, no_spc$,*n2,*sgcode,space_aff,*aaff,space_aff,*caff

paf
                paf_cal_aff
                pnumligne,35,no_spc$,*n2
pafcom
                paf_cal_aff
                35,no_spc$
#endregion

#region strings AG
sxmag_AG : "X1829.620"
symag_AG : "Y0.000"
szmag_AG : "Z+1160.000"
sxmach_AG : "X0.000"
symach_AG : "Y0.000"
szmach_AG : "Z+1891.828"
sxmach_garage_AG : "X+2000.000"
symach_garage_AG : "Y+3920.000"
symach_garage2_AG : "Y+4120.000"
szmach_garage_AG : "Z+1741.000"
sxcloche_AG : "X+1504.000"
sycloche_AG : ""
szcloche_AG : "Z+1891.828"
szcloche_2_AG : "Z+482.000"
sxchangeur_AG : "X_UN-500.000"
sxchangeur_2_AG : "X_UN+0.000"
szchangeur_AG : "Z_UN-125.000"
szchangeur_2_AG : "Z_UN+0.000"

ssortie_cloche1_AG : "CLOCHE_UNE+0"
ssortie_cloche2_AG : "CLOCHE_DEUX+0"
ssortie_cloche3_AG : "CLOCHE_TROIS+0"
ssortie_cloche4_AG : "CLOCHE_QUATRE+0"
ssortie_cloche5_AG : "CLOCHE_CINQ+0"
ssortie_cloche6_AG : "CLOCHE_SIX+0"

sentre_cloche_AG  : "CLOCHE_UNE+200 CLOCHE_DEUX+200 CLOCHE_TROIS+200 CLOCHE_QUATRE+200 CLOCHE_CINQ+200 CLOCHE_SIX+200"

#endregion

#region strings BG
sxmag_BG : ""
sxmag_Z1_BG : "X+995.454"
sxmag_Z2_BG : "X+7925.531"

symag_BG : "Y-183.371"
symag_2_BG : "Y-454.171"
symag_3_BG : "Y-534.171"

szmag_BG : "Z+1532.768"
szmag_2_BG : "Z+1522.768"
szmag_3_BG : "Z+1433.979"

sxmach_BG : ""
symach_BG : ""
szmach_BG : ""

sxmach_Z1_BG : "X+0.000"
symach_Z1_BG : "Y+0.000"
szmach_Z1_BG : "Z+1522.768"

sxmach_Z2_BG : "X+5000.000"
symach_Z2_BG : "Y+0.000"
szmach_Z2_BG : "Z+1522.768"

sxmach_garage_BG : "X-1350.000"
symach_garage_BG : "Y-800.000"
symach_garage2_BG : "Y+4120.000"
szmach_garage_BG : "Z+1500.000"

sxcloche_BG : ""
sxcloche_1_BG : "X+995.454"
sxcloche_2_BG : "X+7925.531"
sycloche_BG : "Y-445.371"
szcloche_BG : "Z578.240"
scloche_BG : "C-180.000"
sacloche_BG : "A+90.000"

sychangeur_BG : ""
sychangeur_Z1_BG : "YO_UN+1400.000"
sychangeur_Z2_BG : "YO_DEUX+1400.000"

sychangeur_2_BG : ""
sychangeur_2_Z1_BG : "YO_UN+0.000"
sychangeur_2_Z2_BG : "YO_DEUX+0.000"

sychangeur_3_BG : ""
sychangeur_3_Z1_BG : "YO_UN+1002.000"
sychangeur_3_Z2_BG : "YO_DEUX+1002.000"

souverture_porte_BG : ""
souverture_porte_Z1_BG : "X_UN-2700.000 X_DEUX-1500.000"
souverture_porte_Z2_BG : "X_TROIS+2700.000 X_QUATRE+1500.000"

sfermeture_porte_BG : ""
sfermeture_porte_Z1_BG : "X_UN+0.000 X_DEUX+0.000"
sfermeture_porte_Z2_BG : "X_TROIS+0.000 X_QUATRE+0.000"

ssortie_cloche1_BG : "CLOCHE_UNE+0"
ssortie_cloche2_BG : "CLOCHE_DEUX+0"
ssortie_cloche3_BG : "CLOCHE_TROIS+0"
ssortie_cloche4_BG : "CLOCHE_QUATRE+0"
ssortie_cloche5_BG : "CLOCHE_CINQ+0"
ssortie_cloche6_BG : "CLOCHE_SIX+0"
ssortie_cloche7_BG : "CLOCHE_SEPT+0"
ssortie_cloche8_BG : "CLOCHE_HUIT+0"

sentre_cloche_BG  : "CLOCHE_UNE+200 CLOCHE_DEUX+200 CLOCHE_TROIS+200 CLOCHE_QUATRE+200 CLOCHE_CINQ+200 CLOCHE_SIX+200 CLOCHE_SEPT+200 CLOCHE_HUIT+200"

#endregion

#region strings CG
sxmag_CG : ""
symag_CG : ""
szmag_CG : ""
szmag_2_CG : ""
sxchangeur_CG : ""
sychangeur_CG : ""
sychangeur_2_CG : ""

sxmag_Z1_CG : "X+2726.699"
symag_Z1_CG : "Y+1325.908"
szmag_Z1_CG : "Z+599.795"
szmag_Z1_2_CG : "Z+649.805"

sxmag_Z2_CG : "X+1846.096"
symag_Z2_CG : "Y+1326.588"
szmag_Z2_CG : "Z+600.495"
szmag_Z2_2_CG : "Z+650.495"

sxchangeur_Z1_CG : "T_X+434.000"
sychangeur_Z1_CG : "T_Y-500.000"
sychangeur_2_Z1_CG : "T_Y+0.000"

sxchangeur_Z2_CG : "T_X-434.000"
sychangeur_Z2_CG : "T_Y-500.000"
sychangeur_2_Z2_CG : "T_Y+0.000"

souverture_porte_CG : ""
souverture_porte_Z1_CG : "P_UNE+900.000"
souverture_porte_Z2_CG : "P_DEUX+900.000"

sfermeture_porte_CG : ""
sfermeture_porte_Z1_CG : "P_UNE+0.000"
sfermeture_porte_Z2_CG : "P_DEUX+0.000"

sxmach_CG : ""
symach_CG : ""
szmach_CG : ""

sxmach_Z1_CG : "X+4420.000"
symach_Z1_CG : "Y+0.000"
szmach_Z1_CG : "Z+1242.795"

sxmach_Z2_CG : "X+0.000"
symach_Z2_CG : "Y+0.000"
szmach_Z2_CG : "Z+1242.795"

sxmach_garage_CG : ""
symach_garage_CG : ""
szmach_garage_CG : ""

sxmach_garage_Z1_CG : "X+4550.000"
symach_garage_Z1_CG : "Y+1255.818"
szmach_garage_Z1_CG : "Z+1242.795"

sxmach_garage_Z2_CG : "X+250.000"
symach_garage_Z2_CG : "Y+1255.818"
szmach_garage_Z2_CG : "Z+1242.795"

sxcloche_CG : "X1500.000"
sycloche_CG : "Y0.000"
szcloche_CG : "Z1500.000"
souverture_cloche_CG : "Cl_B_UNE-180.000 Cl_B_DEUX+180.000"
sfermeture_cloche_CG : "Cl_B_UNE+0.000 Cl_B_DEUX+0.000"

sentre_cloche_CG  : ""
#endregion

#endregion

#region Mouvements habillage machsim

#region chargement cloche

pchargement_cloche_AG
	sccloche_AG = mi4_AG * 60
    sm, szcloche_AG, pafcom, "CHARGEMENT CLOCHE (REMONTE EN Z)", e$
    sm, sxcloche_AG, sa_quatre_vingt_dix, sc_moins_quatre_vingt_dix, pafcom, "CHARGEMENT CLOCHE (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, sccloche_AG, pafcom, "CHARGEMENT CLOCHE (ROTATION DU CHANGEUR)", e$
    sm, szcloche_2_AG, pafcom, "CHARGEMENT CLOCHE (DESCENTE EN Z)", e$
    sm, sxchangeur_AG
	if mi4_AG = 1 , ssortie_cloche1_AG
	if mi4_AG = 2 , ssortie_cloche2_AG
	if mi4_AG = 3 , ssortie_cloche3_AG
	if mi4_AG = 4 , ssortie_cloche4_AG
	if mi4_AG = 5 , ssortie_cloche5_AG
	if mi4_AG = 6 , ssortie_cloche6_AG
	pafcom, "CHARGEMENT CLOCHE (SORTIE DU CHANGEUR ET PRISE DE CLOCHE)", e$
	sm, szchangeur_AG, pafcom, "CHARGEMENT CLOCHE (DESCENTE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, pafcom, "CHARGEMENT CLOCHE (ENTREE DU CHANGEUR)", e$
    sm, szcloche_AG, szchangeur_2_AG, pafcom,"CHARGEMENT CLOCHE (REMONTE EN Z ET REMONTEE DU CHANGEUR)", e$
	sm, sazero, sczero, pafcom,"CHARGEMENT CLOCHE (MISE A ZERO DES AXES ROTATIFS)", e$
	
    flag_cloche_AG = 1
	flag_chargement_cloche_AG = 1
pchargement_cloche_BG

    if (old_tool_AG = tlngno$) & (old_mi4_BG = mi4_BG),
    else, [
    if ((change_tool_cloche_BG = 0) & (old_mi4_BG <> 0) & (old_mi4_BG <> 9)), pdechargement_cloche_BG, dechargement_cloche_BG = 1

    if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))),	[										
															sxcloche_BG = sxcloche_2_BG
															]
					if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)),	[										
															sxcloche_BG = sxcloche_1_BG
															]
    sccloche_BG = mi4_BG * 90
	sccloche_2_BG = mi4_BG * 90	
    sm
	if dechargement_cloche_BG = 0, szmag_2_BG 
	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))), sccloche_2_BG
	if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)), sccloche_BG
	pafcom, "CHARGEMENT CLOCHE (REMONTE EN Z ET ROTATION DU CHANGEUR)", e$
    sm, sxcloche_BG, sycloche_BG, pafcom, "CHARGEMENT CLOCHE (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, sacloche_BG, scloche_BG, pafcom, "CHARGEMENT CLOCHE (POSITIONNEMENT AXES ROTATIFS)", e$
	sm, souverture_porte_BG, pafcom,"CHARGEMENT CLOCHE (OUVERTURE PORTES DU CHANGEUR)", e$
	sm, szcloche_BG, pafcom, "CHARGEMENT CLOCHE (DESCENTE EN Z)", e$
	sm, sychangeur_3_BG, pafcom, "CHARGEMENT CLOCHE (SORTIE DU CHANGEUR)", e$
	sm, sychangeur_2_BG, [
                         if (mi4_BG = 1 | mi4_BG = 11), ssortie_cloche1_BG
                         if (mi4_BG = 2 | mi4_BG = 12), ssortie_cloche2_BG
                         if (mi4_BG = 3 | mi4_BG = 13), ssortie_cloche3_BG
                         if (mi4_BG = 4 | mi4_BG = 14), ssortie_cloche4_BG
                         if (mi4_BG = 5 | mi4_BG = 21), ssortie_cloche5_BG
                         if (mi4_BG = 6 | mi4_BG = 22), ssortie_cloche6_BG
                         if (mi4_BG = 7 | mi4_BG = 23), ssortie_cloche7_BG
                         if (mi4_BG = 8 | mi4_BG = 24), ssortie_cloche8_BG
                         ]
	pafcom, "CHARGEMENT CLOCHE (ENTREE DU CHANGEUR ET CHARGEMENT CLOCHE)", e$
    sm, szmag_2_BG, pafcom,"CHARGEMENT CLOCHE (REMONTE EN Z)", e$
	sm, sfermeture_porte_BG, pafcom,"CHARGEMENT CLOCHE (FERMETURE PORTES DU CHANGEUR)", e$
	sm, sazero, sczero, pafcom,"CHARGEMENT CLOCHE (MISE A ZERO DES AXES ROTATIFS)", e$		
	flag_cloche_BG = 1
	flag_chargement_cloche_BG = 1
    old_mi4_BG = mi4_BG	
		]
	
pchargement_cloche_CG

    sm, szmach_CG, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szmach_CG, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szcloche_CG, sbzero, sczero, pafcom, "CHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szmach_CG, sbzero, sczero
    flag_cloche_CG = 1
	flag_chargement_cloche_CG = 1
#endregion

#region déchargement cloche
pdechargement_cloche_AG

    sm, szcloche_AG, szchangeur_AG, sccloche_AG, pafcom, "DECHARGEMENT CLOCHE (REMONTE EN Z ET DESCENTE DU CHANGEUR)", e$
    sm, sxcloche_AG, sa_quatre_vingt_dix, sc_moins_quatre_vingt_dix, pafcom, "DECHARGEMENT CLOCHE (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	#sm, sccloche_AG, pafcom, "CHARGEMENT CLOCHE (ROTATION DU CHANGEUR)", e$
    sm, szcloche_2_AG, pafcom, "DECHARGEMENT CLOCHE (DESCENTE EN Z)", e$
    sm, sxchangeur_AG, pafcom, "DECHARGEMENT CLOCHE (SORTIE DU CHANGEUR)", e$
	sm, szchangeur_2_AG, pafcom, "DECHARGEMENT CLOCHE (REMONTEE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, sentre_cloche_AG, pafcom, "DECHARGEMENT CLOCHE (ENTREE DU CHANGEUR ET DECHARGEMENT CLOCHE)", e$
    sm, szcloche_AG, pafcom,"DECHARGEMENT CLOCHE (REMONTE EN Z)", e$
	sm, sazero, sczero, pafcom,"DECHARGEMENT CLOCHE (MISE A ZERO DES AXES ROTATIFS)", e$
	
    flag_cloche_AG = 1
	
pdechargement_et_charge_cloche_AG	
    
	sm, szcloche_AG, szchangeur_AG, sccloche_AG, pafcom, "DECHARGEMENT CLOCHE (REMONTE EN Z ET DESCENTE DU CHANGEUR)", e$
    sm, sxcloche_AG, sa_quatre_vingt_dix, sc_moins_quatre_vingt_dix, pafcom, "DECHARGEMENT CLOCHE (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
    sm, szcloche_2_AG, pafcom, "DECHARGEMENT CLOCHE (DESCENTE EN Z)", e$
    sm, sxchangeur_AG, pafcom, "DECHARGEMENT CLOCHE (SORTIE DU CHANGEUR)", e$
	sm, szchangeur_2_AG, pafcom, "DECHARGEMENT CLOCHE (REMONTEE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, sentre_cloche_AG, pafcom, "DECHARGEMENT CLOCHE (ENTREE DU CHANGEUR ET DECHARGEMENT CLOCHE)", e$
	sccloche_AG = mi4_AG * 60
	sm, sccloche_AG, pafcom, "CHARGEMENT CLOCHE (ROTATION DU CHANGEUR)", e$
    sm, sxchangeur_AG
	if mi4_AG = 1 , ssortie_cloche1_AG
	if mi4_AG = 2 , ssortie_cloche2_AG
	if mi4_AG = 3 , ssortie_cloche3_AG
	if mi4_AG = 4 , ssortie_cloche4_AG
	if mi4_AG = 5 , ssortie_cloche5_AG
	if mi4_AG = 6 , ssortie_cloche6_AG
	pafcom, "CHARGEMENT CLOCHE (SORTIE DU CHANGEUR ET PRISE DE CLOCHE)", e$
	sm, szchangeur_AG, pafcom, "CHARGEMENT CLOCHE (DESCENTE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, pafcom, "CHARGEMENT CLOCHE (ENTREE DU CHANGEUR)", e$
    sm, szcloche_AG, szchangeur_2_AG, pafcom,"CHARGEMENT CLOCHE (REMONTE EN Z ET REMONTEE DU CHANGEUR)", e$
	sm, sazero, sczero, pafcom,"CHARGEMENT CLOCHE (MISE A ZERO DES AXES ROTATIFS)", e$	
	
	flag_cloche_AG = 1
	flag_chargement_cloche_AG = 1

pdechargement_cloche_BG

	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))),	[										
															sxcloche_BG = sxcloche_2_BG
															]
					if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)),	[										
															sxcloche_BG = sxcloche_1_BG
															]
    sm, szmag_2_BG 
	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))), sccloche_2_BG
	if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)), sccloche_BG
	pafcom, "DECHARGEMENT CLOCHE (REMONTE EN Z)", e$
    sm, sxcloche_BG, sycloche_BG, pafcom, "DECHARGEMENT CLOCHE (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, sacloche_BG, scloche_BG, pafcom, "DECHARGEMENT CLOCHE (POSITIONNEMENT AXES ROTATIFS)", e$
	sm, souverture_porte_BG, pafcom,"DECHARGEMENT CLOCHE (OUVERTURE PORTES DU CHANGEUR)", e$
	sm, szcloche_BG, pafcom, "DECHARGEMENT CLOCHE (DESCENTE EN Z)", e$
	sm, sychangeur_3_BG, pafcom, "DECHARGEMENT CLOCHE (SORTIE DU CHANGEUR)", e$
	sm, sychangeur_2_BG, sentre_cloche_BG, pafcom, "DECHARGEMENT CLOCHE (ENTREE DU CHANGEUR ET DECHARGEMENT CLOCHE)", e$
	if ((mi4_BG > 0) & (mi4_BG <> 9)) | (change_tool_cloche_BG = 1),
	else,	[
			sm, szmag_2_BG, pafcom,"DECHARGEMENT CLOCHE (REMONTE EN Z)", e$
			sm, sfermeture_porte_BG, pafcom,"DECHARGEMENT CLOCHE (FERMETURE PORTES DU CHANGEUR)", e$
			sm, sazero, sczero, pafcom,"DECHARGEMENT CLOCHE (MISE A ZERO DES AXES ROTATIFS)", e$
			]
	
    flag_cloche_BG = 1

pdechargement_cloche_CG

    sm, szmach_CG, sbzero, sczero, pafcom,"DECHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szmach_CG, sbzero, sczero, pafcom, "DECHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szcloche_CG, sbzero, sczero, pafcom, "DECHARGEMENT CLOCHE", e$
    sm, sxcloche_CG, sycloche_CG, szmach_CG, sbzero, sczero, sentre_cloche_CG, paf, "M170",e$
    flag_cloche_CG = 1
#endregion

#region chargement premier outil
pdebut_chagement_outil_AG
	if t$ = 51 | t$ = 52 | t$ = 61 | t$ = 62,
	[
	sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	if t$ = 51 | t$ = 52,	sm, "X-2245.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	if t$ = 61 | t$ = 62,	sm, "X-2005.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	sm, "C30.", pafcom, "CHANGEMENT D'OUTIL (ROTATION TETE PRISE RA)", e$
	sm, "Z151.5", pafcom, "CHANGEMENT D'OUTIL (PRISE RA)", e$
	sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, "C0.", pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	]
	else,	[
			scchangeur_AG = t$ * 22.5
    		sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
    		sm, sxmag_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X AU DESSUS DU CHANGEUR)", e$
    		sm, szmag_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
			sm, sxchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
			sm, szchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE DU CHANGEUR)", e$
			sm, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
			sm, szchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (REMONTE DU CHANGEUR)", e$
			sm, sxchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    		sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
			]
	old_outil_simu = t$

pdebut_chagement_outil_BG

	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))),	[										
															sxmag_BG = sxmag_Z2_BG
															souverture_porte_BG = souverture_porte_Z2_BG
															sfermeture_porte_BG = sfermeture_porte_Z2_BG
															sychangeur_BG = sychangeur_Z2_BG
															sychangeur_2_BG = sychangeur_2_Z2_BG
															sychangeur_3_BG = sychangeur_3_Z2_BG
															]
					if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)),	[										
															sxmag_BG = sxmag_Z1_BG
															souverture_porte_BG = souverture_porte_Z1_BG
															sfermeture_porte_BG = sfermeture_porte_Z1_BG
															sychangeur_BG = sychangeur_Z1_BG
															sychangeur_2_BG = sychangeur_2_Z1_BG
															sychangeur_3_BG = sychangeur_3_Z1_BG
															]
    sm, szmag_BG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z ET ROTATION DU CHANGEUR)", e$
	scchangeur_BG = t$ * 22.5
	scchangeur_2_BG = t$ * 22.5
	sm, sa_quatre_vingt_dix, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT DES AXES ROTATIFS)", e$
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN Z)", e$
    sm, sxmag_BG, symag_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X ET Y)", e$
	sm, sazero, pafcom, "CHANGEMENT D'OUTIL (REMISE A 0 DE L'AXE A)", e$
	sm, souverture_porte_BG, pafcom,"CHANGEMENT D'OUTIL (OUVERTURE PORTES DU CHANGEUR)", e$
	sm, sychangeur_BG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, symag_2_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, szmag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, symag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DEPOSE D'OUTIL)", e$
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, symag_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT POUR ROTATION DU CHANGEUR)", e$
	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))), sm, scchangeur_2_BG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)), sm, scchangeur_BG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, symag_3_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, szmag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z ET PRISE D'OUTIL)", e$
	sm, symag_2_BG, pafcom, "CHANGEMENT D'OUTIL (DEPLACEMENT EN Y)", e$
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, symag_BG, pafcom, "CHANGEMENT D'OUTIL (DEPLACEMENT EN Y)", e$
	sm, sychangeur_2_BG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
	if (mi4_BG > 0) & (mi4_BG <> 9),
	else, sm, sfermeture_porte_BG, pafcom,"CHANGEMENT D'OUTIL (FERMETURE PORTES DU CHANGEUR)", e$

pdebut_chagement_outil_CG
	
	if ((mi5_CG = 1) | (mi5_CG = 9)),	[
					sxmag_CG = sxmag_Z1_CG
					symag_CG = symag_Z1_CG
					szmag_CG = szmag_Z1_CG
					szmag_2_CG = szmag_Z1_2_CG
					sxchangeur_CG = sxchangeur_Z1_CG
					sychangeur_CG = sychangeur_Z1_CG
					sychangeur_2_CG = sychangeur_2_Z1_CG
					souverture_porte_CG = souverture_porte_Z1_CG
					sfermeture_porte_CG = sfermeture_porte_Z1_CG
					]
					
			else,	[
					sxmag_CG = sxmag_Z2_CG
					symag_CG = symag_Z2_CG
					szmag_CG = szmag_Z2_CG
					szmag_2_CG = szmag_Z2_2_CG
					sxchangeur_CG = sxchangeur_Z2_CG
					sychangeur_CG = sychangeur_Z1_CG
					sychangeur_2_CG = sychangeur_2_Z1_CG
					souverture_porte_CG = souverture_porte_Z2_CG
					sfermeture_porte_CG = sfermeture_porte_Z2_CG					
					]					
	scchangeur_CG = t$ * 22.5
    sm, szmach_CG, sbzero, sxchangeur_CG, souverture_porte_CG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z ET OUVERTURE PORTE DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sc_moins_quatre_vingt_dix, souverture_cloche_CG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR ET OUVERTURE CLOCHE)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, sychangeur_CG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmag_2_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DEPOSE OUTIL ET REMONTE EN Z)", e$
	sm, sxmag_CG, symag_CG, szmag_2_CG, sbzero, sc_moins_quatre_vingt_dix, scchangeur_CG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z ET PRISE D'OUTIL)", e$	
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, sychangeur_2_CG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sc_moins_quatre_vingt_dix, sfermeture_porte_CG, pafcom, "CHANGEMENT D'OUTIL (DEGAGEMENT EN Z ET FERMETURE PORTE DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sczero, pafcom, "CHANGEMENT D'OUTIL (MISE A ZERO DE L'AXE C)", e$
	
#endregion

#region changement d'outil

fmt 2 old_outil_simu
old_outil_simu : 0

pchagement_outil_AG
	
	if t$ <> 51 & t$ <> 52 & t$ <> 61 & t$ <> 62 & old_outil_simu <> 51 & old_outil_simu <> 52 & old_outil_simu <> 61 & old_outil_simu <> 62,
    [
	sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$											
    sm, sxmag_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X AU DESSUS DU CHANGEUR)", e$
	sm, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
    sm, szmag_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sf, e$
    old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$
    spaces$ = 0
	ppreptete
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	sm, sxmag_AG, szmag_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, sxchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, szchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE DU CHANGEUR)", e$
	scchangeur_AG = t$ * 22.5
	sm, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, szchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (REMONTE DU CHANGEUR)", e$
	sm, sxmag_AG, szmag_AG, sazero, sczero, szchangeur_2_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (REMONTE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$	
	]	
	
	if (old_outil_simu = 51 | old_outil_simu = 52 | old_outil_simu = 61 | old_outil_simu = 62) & t$ <> 51 & t$ <> 52 & t$ <> 61 & t$ <> 62,
    [
	sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	if old_outil_simu = 51 | old_outil_simu = 52,	sm, "X-2245.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	if old_outil_simu = 61 | old_outil_simu = 62,	sm, "X-2005.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
    sm, "C30.", pafcom, "CHANGEMENT D'OUTIL (ROTATION TETE DEPOSE RA)", e$
	sm, "Z151.5", pafcom, "CHANGEMENT D'OUTIL (DEPOSE RA)", e$
	sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	sm, sxmag_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X AU DESSUS DU CHANGEUR)", e$
	sf, e$
    old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$
    spaces$ = 0
	ppreptete
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	sm, sxmag_AG, szmach_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X AU DESSUS DU CHANGEUR)", e$
	sm, szchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE DU CHANGEUR)", e$
	sm, sxchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	scchangeur_AG = t$ * 22.5
	sm, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, szmag_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, szchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (REMONTE DU CHANGEUR)", e$
	sm, sxmag_AG, szmag_AG, sazero, sczero, szchangeur_2_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (REMONTE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$	
	]
	
	if (t$ = 51 | t$ = 52 | t$ = 61 | t$ = 62) & (old_outil_simu = 51 | old_outil_simu = 52 | old_outil_simu = 61 | old_outil_simu = 62),
    [
	sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	if old_outil_simu = 51 | old_outil_simu = 52,	sm, "X-2245.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	if old_outil_simu = 61 | old_outil_simu = 62,	sm, "X-2005.", pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
    sm, "C30.", pafcom, "CHANGEMENT D'OUTIL (ROTATION TETE DEPOSE RA)", e$
	sm, "Z151.5", pafcom, "CHANGEMENT D'OUTIL (DEPOSE RA)", e$
	sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	sf, e$
    old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$
    spaces$ = 0
	ppreptete
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	if t$ = 51 | t$ = 52,	sm, "X-2245.", szmach_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	if t$ = 61 | t$ = 62,	sm, "X-2005.", szmach_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	sm, "C30.", pafcom, "CHANGEMENT D'OUTIL (ROTATION TETE PRISE RA)", e$
	sm, "Z151.5", pafcom, "CHANGEMENT D'OUTIL (PRISE RA)", e$
    sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, "C0.", pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	]	
	
	if (t$ = 51 | t$ = 52 | t$ = 61 | t$ = 62) & old_outil_simu <> 51 & old_outil_simu <> 52 & old_outil_simu <> 61 & old_outil_simu <> 62,
    [
	sm, szmach_AG, sazero, sczero, pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$											
    sm, sxmag_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X AU DESSUS DU CHANGEUR)", e$
	sm, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	 sm, szmag_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sf, e$
    old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$
    spaces$ = 0
	ppreptete
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	sm, sxmag_AG, szmag_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, sxchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, szchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE DU CHANGEUR)", e$
	sm, sxchangeur_2_AG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	if t$ = 51 | t$ = 52,	sm, "X-2245.", szmach_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	if t$ = 61 | t$ = 62,	sm, "X-2005.", szmach_AG, sazero, sczero, sentre_cloche_AG, scchangeur_AG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT MAGASIN RA)", e$
	sm, "C30.", pafcom, "CHANGEMENT D'OUTIL (ROTATION TETE PRISE RA)", e$
	sm, "Z151.5", pafcom, "CHANGEMENT D'OUTIL (PRISE RA)", e$
    sm, szmach_AG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, "C0.", pafcom,"CHANGEMENT D'OUTIL (MISE A ZERO DES AXES ROTATIFS)", e$
	]	
			old_outil_simu = t$

pchagement_outil_BG

    sm, szmag_BG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z ET ROTATION DU CHANGEUR)", e$
	scchangeur_BG = t$ * 22.5
	scchangeur_2_BG = t$ * 22.5
	sm, sa_quatre_vingt_dix, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT DES AXES ROTATIFS)", e$
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN Z)", e$
    sm, sxmag_BG, symag_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT EN X ET Y)", e$
	sm, sazero, pafcom, "CHANGEMENT D'OUTIL (REMISE A 0 DE L'AXE A)", e$
	sm, souverture_porte_BG, pafcom,"CHANGEMENT D'OUTIL (OUVERTURE PORTES DU CHANGEUR)", e$
	sm, sychangeur_BG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, symag_2_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, szmag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, symag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DEPOSE D'OUTIL)", e$
	
	sf, e$
    old_corg_x_BG = tox4$, old_corg_y_BG = toy4$, old_corg_z_BG = toz4$
    spaces$ = 0
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, symag_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT POUR ROTATION DU CHANGEUR)", e$
	if ((mi5_BG = 1) | ((mi5_BG = 9) & (mr8_changeur_BG >= 5000))), sm, scchangeur_2_BG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	if ((mi5_BG = 9) & (mr8_changeur_BG < 5000)), sm, scchangeur_BG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, symag_3_BG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR)", e$
	sm, szmag_3_BG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z ET PRISE D'OUTIL)", e$
	sm, symag_2_BG, pafcom, "CHANGEMENT D'OUTIL (DEPLACEMENT EN Y)", e$
	sm, szmag_2_BG, pafcom, "CHANGEMENT D'OUTIL (REMONTE EN Z)", e$
	sm, symag_BG, pafcom, "CHANGEMENT D'OUTIL (DEPLACEMENT EN Y)", e$
	sm, sychangeur_2_BG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
	if (mi4_BG > 0) & (mi4_BG <> 9),
	else,	sm, sfermeture_porte_BG, pafcom,"CHANGEMENT D'OUTIL (FERMETURE PORTES DU CHANGEUR)", e$	
	
pchagement_outil_CG

    sm, szmach_CG, sbzero, sxchangeur_CG, souverture_porte_CG, pafcom,"CHANGEMENT D'OUTIL (REMONTE EN Z ET OUVERTURE PORTE DU CHANGEUR)", e$
    sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sc_moins_quatre_vingt_dix, souverture_cloche_CG, pafcom, "CHANGEMENT D'OUTIL (POSITIONNEMENT AU DESSUS DU CHANGEUR ET OUVERTURE CLOCHE)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
    sf, e$
    old_corg_x_CG = tox4$, old_corg_y_CG = toy4$, old_corg_z_CG = toz4$
    spaces$ = 0
    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
    spaces$ = 1
	"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, sxchangeur_CG, scchangeur_CG, souverture_cloche_CG, souverture_porte_CG, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, sychangeur_CG, pafcom, "CHANGEMENT D'OUTIL (SORTIE DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmag_2_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DEPOSE OUTIL ET REMONTE EN Z)", e$
	scchangeur_CG = t$ * 22.5
	sm, sxmag_CG, symag_CG, szmag_2_CG, sbzero, sc_moins_quatre_vingt_dix, scchangeur_CG, pafcom, "CHANGEMENT D'OUTIL (ROTATION DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, pafcom, "CHANGEMENT D'OUTIL (DESCENTE EN Z ET PRISE D'OUTIL)", e$	
	sm, sxmag_CG, symag_CG, szmag_CG, sbzero, sc_moins_quatre_vingt_dix, sychangeur_2_CG, pafcom, "CHANGEMENT D'OUTIL (ENTREE DU CHANGEUR)", e$
    sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sc_moins_quatre_vingt_dix, sfermeture_porte_CG, pafcom, "CHANGEMENT D'OUTIL (DEGAGEMENT EN Z ET FERMETURE PORTE DU CHANGEUR)", e$
	sm, sxmag_CG, symag_CG, szmach_CG, sbzero, sczero, pafcom, "CHANGEMENT D'OUTIL (MISE A ZERO DE L'AXE C)", e$
	
#endregion

#region garage

pgarage_AG

pgarage_BG

pgarage_CG

		if ((mi5_CG = 1) | (mi5_CG = 9)),	[
						sxmach_garage_CG = sxmach_garage_Z1_CG
						symach_garage_CG = symach_garage_Z1_CG
						szmach_garage_CG = szmach_garage_Z1_CG
						sm, szmach_garage_CG, paf,"GARAGE (DEGAGEMENT EN Z)", e$
						if axe_A_garage_CG > 0 & axe_C_garage_CG > 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 1, old_axeC_simu_CG = 180
						if axe_A_garage_CG > 0 & axe_C_garage_CG < 0, sm, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 2, old_axeC_simu_CG = -180
						if axe_A_garage_CG < 0,	sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 3, old_axeC_simu_CG = 0
						if axe_A_garage_CG = 0 & axe_C_garage_CG > 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 4, old_axeC_simu_CG = 180
						if axe_A_garage_CG = 0 & axe_C_garage_CG < 0, sm, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 5, old_axeC_simu_CG = -180
						if axe_A_garage_CG = 0 & axe_C_garage_CG = 0, sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$	, garage_CG = 6, old_axeC_simu_CG = 0
						if axe_A_garage_CG > 0 & axe_C_garage_CG = 0, sm, sb_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 7, old_axeC_simu_CG = 180	
						sm, sxmach_garage_CG, symach_garage_CG, paf, "GARAGE (POSITIONNEMENT AXES LINEAIRES)", e$
						sm, sbzero, paf, "GARAGE (MISE A ZERO DE L'AXE B APRES OUVERTURE PORTE)", e$
						old_axeA_simu_CG = 0
						old_xprint_simu_CG = 4550
						old_yprint_simu_CG = 1255.818
						old_zprint_simu_CG = mr2print_CG
						]
						
				else,	[
						sxmach_garage_CG = sxmach_garage_Z2_CG
						symach_garage_CG = symach_garage_Z2_CG
						szmach_garage_CG = szmach_garage_Z2_CG
						sm, szmach_garage_CG, paf,"GARAGE (DEGAGEMENT EN Z)", e$
						if axe_A_garage_CG > 0,	sm, sb_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 8, old_axeC_simu_CG = 0
						if axe_A_garage_CG < 0 & axe_C_garage_CG > 0, sm, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 9, old_axeC_simu_CG = 180
						if axe_A_garage_CG < 0 & axe_C_garage_CG < 0, sm, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 10, old_axeC_simu_CG = -180
						if axe_A_garage_CG = 0, sm, sb_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 11, old_axeC_simu_CG = 0
						if axe_A_garage_CG < 0 & axe_C_garage_CG = 0, sm, sb_moins_quatre_vingt_dix, sczero, paf, "GARAGE (POSITIONNEMENT AXES ROTATIFS)", e$, garage_CG = 12, old_axeC_simu_CG = 0
						sm, sxmach_garage_CG, symach_garage_CG, paf, "GARAGE (POSITIONNEMENT AXES LINEAIRES)", e$
						sm, sbzero, paf, "GARAGE (MISE A ZERO DE L'AXE B APRES OUVERTURE PORTE)", e$
						old_axeA_simu_CG = 0
						old_xprint_simu_CG = 250
						old_yprint_simu_CG = 1255.818
						old_zprint_simu_CG = mr2print_CG
						]

#endregion

#region prtcp_simu

prtcp_simu_AG
	
							dif_c_AG = abs(axeC_AG - old_axeC_simu_AG)
							dif_a_AG = abs(axeA_AG - old_axeA_simu_AG)
							if dif_c_AG >= delta_AG | dif_a_AG >= delta_AG,
							[						
							v_delta_x_simu_AG = xprint_AG - old_xprint_simu_AG 
							v_delta_y_simu_AG = yprint_AG - old_yprint_simu_AG 
							v_delta_z_simu_AG = zprint_AG - old_zprint_simu_AG 
							if v_delta_x_simu_AG <> 0 | v_delta_y_simu_AG <> 0 | v_delta_z_simu_AG <> 0,	[	
							
							if drill5axes_AG <> 1,	[
													if mr2print_AG <> -1 & changop_AG = 1, old_zprint_simu_AG = mr2print_AG, v_delta_z_simu_AG = 0
													]
							v_delta_xyz_simu_AG = sqrt(v_delta_x_simu_AG^2 + v_delta_y_simu_AG^2 + v_delta_z_simu_AG^2)
							v_sindir_x_simu_AG = v_delta_x_simu_AG/v_delta_xyz_simu_AG
							v_sindir_y_simu_AG = v_delta_y_simu_AG/v_delta_xyz_simu_AG
							v_sindir_z_simu_AG = v_delta_z_simu_AG/v_delta_xyz_simu_AG
							v_delta_div_simu_AG = v_delta_xyz_simu_AG / 10
							v_abs_plus_x_simu_AG = v_delta_div_simu_AG * v_sindir_x_simu_AG
							v_abs_plus_y_simu_AG = v_delta_div_simu_AG * v_sindir_y_simu_AG
							v_abs_plus_z_simu_AG = v_delta_div_simu_AG * v_sindir_z_simu_AG
							while conttour_AG < 9,
							 					[
												conttour_AG = 1 + conttour_AG
												x_inter_AG = old_xprint_simu_AG + (v_abs_plus_x_simu_AG * conttour_AG)
												y_inter_AG = old_yprint_simu_AG + (v_abs_plus_y_simu_AG * conttour_AG)
												z_inter_AG = old_zprint_simu_AG + (v_abs_plus_z_simu_AG * conttour_AG)
												delta_c_AG = (old_axeC_simu_AG - axeC_AG) / 10
												delta_b_AG = (old_axeA_simu_AG - axeA_AG) / 10
												c_inter_AG = (old_axeC_simu_AG - delta_c_AG * conttour_AG)
												b_inter_AG = (old_axeA_simu_AG - delta_b_AG * conttour_AG)
												sr,*x_inter_AG, *y_inter_AG, *z_inter_AG, *b_inter_AG, *c_inter_AG, pfr_AG,paf, "(MOUVEMENT RTCP)",e$
												]
							]
							if v_delta_x_simu_AG = 0 & v_delta_y_simu_AG = 0 & v_delta_z_simu_AG = 0,	[
							if drill5axes_AG <> 1,	[
													if mr2print_AG <> -1 & changop_AG = 1, old_zprint_simu_AG = mr2print_AG, v_delta_z_simu_AG = 0
													]
							while conttour_AG < 9,
							 					[
												conttour_AG = 1 + conttour_AG
												x_inter_AG = old_xprint_simu_AG
												y_inter_AG = old_yprint_simu_AG
												z_inter_AG = old_zprint_simu_AG
												delta_c_AG = (old_axeC_simu_AG - axeC_AG) / 10
												delta_b_AG = (old_axeA_simu_AG - axeA_AG) / 10
												c_inter_AG = (old_axeC_simu_AG - delta_c_AG * conttour_AG)
												b_inter_AG = (old_axeA_simu_AG - delta_b_AG * conttour_AG)
												sr,*x_inter_AG, *y_inter_AG, *z_inter_AG, *b_inter_AG, *c_inter_AG, pfr_AG,paf, "(MOUVEMENT RTCP)",e$
												]
							]	
							]

	old_axeC_simu_AG = axeC_AG
	old_axeA_simu_AG = axeA_AG
	old_xprint_simu_AG = xprint_AG
	old_yprint_simu_AG = yprint_AG
	old_zprint_simu_AG = zprint_AG
	conttour_AG = 0
	
prtcp_simu_BG
	
							dif_c_BG = abs(axeC_BG - old_axeC_simu_BG)
							dif_a_BG = abs(axeA_BG - old_axeA_simu_BG)
							if dif_c_BG >= delta_BG | dif_a_BG >= delta_BG,
							[						
							v_delta_x_simu_BG = xprint_BG - old_xprint_simu_BG 
							v_delta_y_simu_BG = yprint_BG - old_yprint_simu_BG 
							v_delta_z_simu_BG = zprint_BG - old_zprint_simu_BG 
							if v_delta_x_simu_BG <> 0 | v_delta_y_simu_BG <> 0 | v_delta_z_simu_BG <> 0,	[	
							
							if drill5axes_BG <> 1,	[
													if mr2print_BG <> -1 & changop_BG = 1, old_zprint_simu_BG = mr2print_BG, v_delta_z_simu_BG = 0
													]
							v_delta_xyz_simu_BG = sqrt(v_delta_x_simu_BG^2 + v_delta_y_simu_BG^2 + v_delta_z_simu_BG^2)
							v_sindir_x_simu_BG = v_delta_x_simu_BG/v_delta_xyz_simu_BG
							v_sindir_y_simu_BG = v_delta_y_simu_BG/v_delta_xyz_simu_BG
							v_sindir_z_simu_BG = v_delta_z_simu_BG/v_delta_xyz_simu_BG
							v_delta_div_simu_BG = v_delta_xyz_simu_BG / 10
							v_abs_plus_x_simu_BG = v_delta_div_simu_BG * v_sindir_x_simu_BG
							v_abs_plus_y_simu_BG = v_delta_div_simu_BG * v_sindir_y_simu_BG
							v_abs_plus_z_simu_BG = v_delta_div_simu_BG * v_sindir_z_simu_BG
							while conttour_BG < 9,
							 					[
												conttour_BG = 1 + conttour_BG
												x_inter_BG = old_xprint_simu_BG + (v_abs_plus_x_simu_BG * conttour_BG)
												y_inter_BG = old_yprint_simu_BG + (v_abs_plus_y_simu_BG * conttour_BG)
												z_inter_BG = old_zprint_simu_BG + (v_abs_plus_z_simu_BG * conttour_BG)
												delta_c_BG = (old_axeC_simu_BG - axeC_BG) / 10
												delta_b_BG = (old_axeA_simu_BG - axeA_BG) / 10
												c_inter_BG = (old_axeC_simu_BG - delta_c_BG * conttour_BG)
												b_inter_BG = (old_axeA_simu_BG - delta_b_BG * conttour_BG)
												sr,*x_inter_BG, *y_inter_BG, *z_inter_BG, *b_inter_BG, *c_inter_BG, pfr_BG,paf, "(MOUVEMENT RTCP)",e$
												]
							]
							if v_delta_x_simu_BG = 0 & v_delta_y_simu_BG = 0 & v_delta_z_simu_BG = 0,	[
							if drill5axes_BG <> 1,	[
													if mr2print_BG <> -1 & changop_BG = 1, old_zprint_simu_BG = mr2print_BG, v_delta_z_simu_BG = 0
													]
							while conttour_BG < 9,
							 					[
												conttour_BG = 1 + conttour_BG
												x_inter_BG = old_xprint_simu_BG
												y_inter_BG = old_yprint_simu_BG
												z_inter_BG = old_zprint_simu_BG
												delta_c_BG = (old_axeC_simu_BG - axeC_BG) / 10
												delta_b_BG = (old_axeA_simu_BG - axeA_BG) / 10
												c_inter_BG = (old_axeC_simu_BG - delta_c_BG * conttour_BG)
												b_inter_BG = (old_axeA_simu_BG - delta_b_BG * conttour_BG)
												sr,*x_inter_BG, *y_inter_BG, *z_inter_BG, *b_inter_BG, *c_inter_BG, pfr_BG,paf, "(MOUVEMENT RTCP)",e$
												]
							]	
							]

	old_axeC_simu_BG = axeC_BG
	old_axeA_simu_BG = axeA_BG
	old_xprint_simu_BG = xprint_BG
	old_yprint_simu_BG = yprint_BG
	old_zprint_simu_BG = zprint_BG
	conttour_BG = 0
	
prtcp_simu_CG

							dif_c_CG = abs(axeC_CG - old_axeC_simu_CG)
							dif_a_CG = abs(axeA_CG - old_axeA_simu_CG)
							if dif_c_CG >= delta_CG | dif_a_CG >= delta_CG,
							[						
							v_delta_x_simu_CG = xprint_CG - old_xprint_simu_CG 
							v_delta_y_simu_CG = yprint_CG - old_yprint_simu_CG 
							v_delta_z_simu_CG = zprint_CG - old_zprint_simu_CG 
							if v_delta_x_simu_CG <> 0 | v_delta_y_simu_CG <> 0 | v_delta_z_simu_CG <> 0,	[	
							
							if drill5axes_CG <> 1,	[
													if mr2print_CG <> -1 & changop_CG = 1, old_zprint_simu_CG = mr2print_CG, v_delta_z_simu_CG = 0
													]
							v_delta_xyz_simu_CG = sqrt(v_delta_x_simu_CG^2 + v_delta_y_simu_CG^2 + v_delta_z_simu_CG^2)
							v_sindir_x_simu_CG = v_delta_x_simu_CG/v_delta_xyz_simu_CG
							v_sindir_y_simu_CG = v_delta_y_simu_CG/v_delta_xyz_simu_CG
							v_sindir_z_simu_CG = v_delta_z_simu_CG/v_delta_xyz_simu_CG
							v_delta_div_simu_CG = v_delta_xyz_simu_CG / 10
							v_abs_plus_x_simu_CG = v_delta_div_simu_CG * v_sindir_x_simu_CG
							v_abs_plus_y_simu_CG = v_delta_div_simu_CG * v_sindir_y_simu_CG
							v_abs_plus_z_simu_CG = v_delta_div_simu_CG * v_sindir_z_simu_CG
							while conttour_CG < 9,
							 					[
												conttour_CG = 1 + conttour_CG
												x_inter_CG = old_xprint_simu_CG + (v_abs_plus_x_simu_CG * conttour_CG)
												y_inter_CG = old_yprint_simu_CG + (v_abs_plus_y_simu_CG * conttour_CG)
												z_inter_CG = old_zprint_simu_CG + (v_abs_plus_z_simu_CG * conttour_CG)
												delta_c_CG = (old_axeC_simu_CG - axeC_CG) / 10
												delta_b_CG = (old_axeA_simu_CG - axeA_CG) / 10
												c_inter_CG = (old_axeC_simu_CG - delta_c_CG * conttour_CG)
												b_inter_CG = (old_axeA_simu_CG - delta_b_CG * conttour_CG)
												sr,*x_inter_CG, *y_inter_CG, *z_inter_CG, *b_inter_CG, *c_inter_CG, pfr_CG,paf, "(MOUVEMENT RTCP)",e$
												]
							]
							if v_delta_x_simu_CG = 0 & v_delta_y_simu_CG = 0 & v_delta_z_simu_CG = 0,	[
							if drill5axes_CG <> 1,	[
													if mr2print_CG <> -1 & changop_CG = 1, old_zprint_simu_CG = mr2print_CG, v_delta_z_simu_CG = 0
													]
							while conttour_CG < 9,
							 					[
												conttour_CG = 1 + conttour_CG
												x_inter_CG = old_xprint_simu_CG
												y_inter_CG = old_yprint_simu_CG
												z_inter_CG = old_zprint_simu_CG
												delta_c_CG = (old_axeC_simu_CG - axeC_CG) / 10
												delta_b_CG = (old_axeA_simu_CG - axeA_CG) / 10
												c_inter_CG = (old_axeC_simu_CG - delta_c_CG * conttour_CG)
												b_inter_CG = (old_axeA_simu_CG - delta_b_CG * conttour_CG)
												sr,*x_inter_CG, *y_inter_CG, *z_inter_CG, *b_inter_CG, *c_inter_CG, pfr_CG,paf, "(MOUVEMENT RTCP)",e$
												]
							]	
							]

	old_axeC_simu_CG = axeC_CG
	old_axeA_simu_CG = axeA_CG
	old_xprint_simu_CG = xprint_CG
	old_yprint_simu_CG = yprint_CG
	old_zprint_simu_CG = zprint_CG
	conttour_CG = 0

#endregion

#endregion

#region   DEBUT PST #OK
# ----------------------------------------
# -   Post pro fraisage 5 axes           -
# -   Version origine pour 8.0                        -
# ----------------------------------------
# -     MASTERCAM VX6  F.I.CAM         -
# ----------------------------------------


# - commancé le : 16/05/01  Par : Eric Dauvilliers-
# - Pour la société : COMPOSITES AQUITAINE-M6
# - Armoire CN      : siemens 840d           - 
# - Nom MACHINE     : CRENEAU            - 
# - Fichier associé :       -
# ----------------------------------------
# - Variable mi1    : ajout de tour sur C au debut du prog 
# - Variable mi2    : sens d'attaque A+ ou A- 
# - Variable mi3    : retournement de tete a plan secu mi2 ou sur place 0 ou 1          
# - Variable mi1    :
# - Variable mr7    : angle maxi pour G9                    
# - Variable mr8    : dec x                   
# - Variable mr9    : dec Y                   
# - Variable mr10   : dec Z                    
# - Variable mr1    : valeur de recul suivent axes outil pour degagement
# - Variable mi2    : Coordone Z de retournement
# - VARIABLE MI10   : flag pour arret programme avant OP

# ----------------------------------------
# -   DESCRIPTION DES MODIFICATIONS      -
#
# le 09/07/2001 - modif position percage 5 axes, ajout date heure nom prog,voir prot3 G151 S0 ou c0 a0 
# le 17/07/2001 - modif G1 G93- M7 M150 M9 gestion entre phase, G80 en fin de cycle
# le 23/07/2001 - modif Z pour ER , N32000 max, et autre
# le 05/08/2001 - point x y z abs 3d entre transition de plan (dur dur),+ divers 
# le 06/08/2001 - G0 du 1 er et dernier mouv en 5 axes continues puis G93, + divers
# le 03/09/2001 - Ajt n prog + divers fautes ortho + espace, alti de retour OK, xy 3D ABS OK entre cycle 5 ax, A et C au + tot OK
# le 06/10/2001 - modif entete G77 etc..,remonte alt retournement meme en 3d
# le 12/10/2001 - modif bug bute retournement
# le 13/10/2001 - option E5300xx en place
# le 20/10/2001 - arret prog mi10 et modif xyz sur meme ligne en percage
# le 9/11/2001  - G151 S0 sur arret prog, remonte z secu que entre op differante, correction bug de pp17 pp18 pp19
# le 12/07/2005 - correction de différent prob suite passage eric sur site
# le 21/07/2005 - correction de BUG-PP-BA, de BUG-PP-BB, et BUG-PP-BC.
# Le 30/09/2005 - correction de BUG-PP-URGA ET URGB
# Le 27/07/2009 - correction de bug de liaisons entre operation 
# Le 28/07/2009 - Integration d'une téte a renvoie d'angle double 
# Dev PP renvoi LE 31 juil 2009 reste a finir percage 5 axes avec renvoi, trouver ou est en pdril_2 xrprint_BG, yrprint_BG et zrprint_BG 
# Dev normal, gere les altitude plan de securite en percage normal 
# le 28/10/2009 Finition des dev pour renvoie d'angle
# le 8 juin 2010 finition du percage 5 axes avec gestion des hauteur
# ajout d'un cycle de contour en dent de scie
# ajout de commentaires en cantext
# le 26 avril 2011 15h10 =>finition pour plan secu ou retraction renvoi d'angle 
# le 26 avril 2011 15h45 => ajout pour rediction de bruit outil vertical de la variale cone_mini
# le 26 avril 2011 16h35 => correction orthographe
# le 26 avril 2011 17h25 => finition plan de secu avec renvoi angle en 5 x et 3d
# le 26 avril 2011 18h35 => inversion du G9
# le 27 avril 2011 11h11 => sup du retour plan secu en arret prog M01 
# le 27 avril 2011 15h05 => warning sur rattrpage d'angle
# le  5 juin  2012 15h00 => dev pour rotation automatic pour choix plan en vrac ( le x toujours horizontal n'est plus necessaire si calculduplan = 1 )
# le  6 juin  2012 11h00 => debut de transformation pour passage de num en siemens
# le  3 sep   2012 14h30 => Debut essai avec le creno
# le  du 3 au 7 sep => M7M8M9 , outil par nom, control outil, gestion aspi, usure outil, macro debut fin, cycle helicoide, etc..
# le 28 - 11 - 2012 = > revision 2 cycle caq triple spiral + debut goute d'eau
# le 29 - 11 - 2012 => modification pp suite essai du fabfla
# ----------------------------------------
#
#============================================================================
# POST-PROCESSEUR 5 NUM 1060 TETE TWIST   A porté par C + tete renvois d'angle 
# machine creneau industiel client concept industriel
# DEV ERIC DAUVILLIERS Sté FICAM 02.37.26.28.10
#                              |
# axe C               90       |  axe A                  x
# vu de dessus                 |  vu de coté             |
#                180       0   |                 -90     |    90
#                              |                         
#                     270      |                         0
#============================================================================
# VARIABLES ANGULAIRE MINI  ET MAXI DES AXES DE ROTATIONs 
#endregion

#region   REGLAGES DU PST #OK
#region STRINGS
sderoul_AG : ""
sderoul_BG : ""
sderoul_CG : ""
senroul_AG : ""
senroul_BG : ""
senroul_CG : ""
sderoul_aff_AG : "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
sderoul_aff_BG : "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
sderoul_aff_CG : "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post-processeur suite butte axe C plus, dernières valeurs : "
senroul_aff_AG : "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
senroul_aff_BG : "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
senroul_aff_CG : "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ - Sortie du post processeur suite buttée axe C moins, dernières valeurs : "
slettreA : "A"
slettreB : "B"
slettreC : "C"
space : " "
sopration : "Operation N°"

cone_mini = 0.001  # valeur angulaire a partir duquel on fais du A0 C0, evite le bruit 
sderoul : "ATTENTION OPERATION DE RETOURNEMENT EN 5 AXES "
calculduplan = 0   #laisser le pp recalculer xyz suivant rotation non sur axe x 
sra : ""
fmt "" 4 nbcaracter
srenvoi : ""
srenvoi_droite : "RA1"
srenvoi_gauche : "RA2"

# Changer les valeurs entre "" pour chois entre 0 et 6 sur parametre valeur optionnel cycle 832
scycle832_a : "CYCLE832(0.2,11112101)"
scycle832_b : "CYCLE832(0.2,11112101)"
scycle832_c : "CYCLE832(0.2,11112101)"
scycle832_d : "CYCLE832(0.2,11112101)"
scycle832_e : "CYCLE832(0.2,11112101)"
scycle832_f : "CYCLE832(0.2,11112101)"
scycle832_anul : "CYCLE832 ()"

susure_outil_1 : ""
susure_outil_2 : ""
susure_outil_3 : ""
susure_outil_4 : ""
susure_outil_5 : ""
susure_outil_6 : ""
susure_outil_7 : ""
susure_outil_8 : ""
susure_outil_9 : ""
susure_outil_10 : ""
susure_outil_11 : ""
susure_outil_12 : ""
susure_outil_13 : ""
susure_outil_14 : ""
susure_outil_15 : ""
susure_outil_16 : ""
susure_outil_17 : ""
susure_outil_18 : ""
susure_outil_19 : ""
susure_outil_20 : ""
susure_outil_21 : ""
susure_outil_22 : ""
susure_outil_23 : ""
susure_outil_24 : ""
susure_outil_25 : ""
susure_outil_26 : ""
susure_outil_27 : ""
susure_outil_28 : ""
susure_outil_29 : ""
susure_outil_30 : ""
sdim_outillage : ""
#endregion
#region FS
#--------------------------------- FORMATS ----------------------------------
fs  1  1.9
fs  2  1.3n
fs  3  1 0n
fs  4  1 0
fs  5  1.0n
fs  6  5 0
fs  7  1.4n
fs  8  1.3
fs  9  1 3t
fs 10  1.2
fs 11  1.6
fs 12  1.4
fs 13 +1.4ln
fs 14  3.2ltn
fs 15  1.2ltn
#fs 16  1
fs 17  1.1  #quotient mi1
fs 18  1.1  #reste decimale quotient mi1
fs 19  1.3ltn
fs 20  4 0
fs 24  +1.3ln
#endregion
#region FMT
#--------------------------- AFFECTATIONS FORMATS ---------------------------
fmt  "X" 1 xr$
fmt  "Y" 1 yr$
fmt  "Z" 1 zr$
fmt  "ZR" 2 oldzr
fmt    2 mr3$
fmt "" 3 tete_rev_ang_droite
fmt "" 3 tete_rev_ang_gauche
fmt "val dec tete=" 8 dec_axe_tete
fmt  "X" 2 xdep
fmt  "Y" 2 ydep
fmt  "Z" 2 zdep
fmt  "X" 1 x$
fmt  "Y" 1 y$
fmt  "Z" 1 z$
fmt "X" 1 drl_init_x$
fmt "Y" 1 drl_init_y$
fmt "Z" 1 drl_init_z$
fmt "Z" 1 drl_sel_ref$
fmt "VX" 1 vec_reel_x
fmt "VY" 1 vec_reel_y
fmt "VZ" 1 vec_reel_z
fmt "NX" 2 nextx$
fmt "NU" 2 nextu$
fmt "ret" 2 retplangarde
fmt "A" 2 move_ang$
fmt  "X" 1 xcal
fmt  "Y" 1 ycal
fmt  "Z" 1 zcal
fmt  "Z" 1 zrcal
fmt "cone_mini" 1 cone_mini
fmt  "C" 1 axeccalra
fmt  "difc" 8 difanglec
fmt  "difa" 8 difanglea
fmt      1 new_m7
fmt      1 new_m8
fmt "M1=" 1 m1$
fmt "M2=" 1 m2$
fmt "M3=" 1 m3$
fmt "M4=" 1 m4$
fmt "M5=" 1 m5$
fmt "M6=" 1 m6$
fmt "M7=" 1 m7$
fmt "M8=" 1 m8$
fmt "M9=" 1 m9$
fmt      7 mini_a_reel
fmt      7 sortie
fmt  ""  3 changop_AG
fmt  ""  3 changop_BG
fmt  ""  3 changop_CG
fmt  ""  3 changop_AM
fmt  ""  3 changop_BM
fmt  ""  3 changop_CM
fmt  ""  3 mod5xcont
fmt  "Tourne=" 1 tourne
fmt "cal du plan =" 1 calculduplan
fmt "5 axes horizontal" 2 vertical_z
fmt  "C" 12 axeC1
fmt  "A" 12 axeA1
fmt  "C" 12 minC
fmt  "C" 12 maxC
fmt  "NB" 8 nbt
fmt  "DC" 12 dep_axe_c     #angle de depart axe c 
fmt  "A" 12 prvaxea
fmt  "DAC" 12 dif_axe_c
fmt  "DAC" 12 dif_axe_c2
fmt  "ABSD" 8 absdif
fmt  "ABSD" 8 absdif2
fmt  "DEB" 4 debut
fmt  "X" 1 xdeg1
fmt  "Y" 1 ydeg1
fmt  "Z" 1 zdeg1
fmt  "X" 1 xdeg2
fmt  "Y" 1 ydeg2
fmt  "X" 1 xdeg3
fmt  "Y" 1 ydeg3
fmt  "Z" 1 zdeg3
fmt  "X" 2 xdegrap
fmt  "Y" 2 ydegrap
fmt  "Z" 2 zdegrap
fmt  "X" 1 xdegrap1
fmt  "Y" 1 ydegrap1
fmt  "Z" 1 zdegrap1
fmt  "X" 1 xdegrap2
fmt  "Y" 1 ydegrap2
fmt  "Z" 1 zdegrap2
fmt  "X" 1 xdegrap3
fmt  "Y" 1 ydegrap3
fmt  "Z" 1 zdegrap3
fmt  "X" 1 xdegvec
fmt  "Y" 1 ydegvec
fmt  "Z" 1 zdegvec
fmt "sav_x_pmx" 1 sav_x_pmx
fmt "sav_y_pmx" 1 sav_y_pmx
fmt "sav_z_pmx" 1 sav_z_pmx
fmt "sav_u_pmx" 1 sav_u_pmx
fmt "sav_v_pmx" 1 sav_v_pmx
fmt "sav_w_pmx" 1 sav_w_pmx
fmt  "OLV" 8 old_longvec
fmt  "Z" 8 lastz
fmt "R" 1 result        # resultat de calcul
# Format des variable ecritent dans le post pro
fmt "Z" 2 zsecuprint
fmt "" 1 m1print
fmt "" 1 m2print
fmt "" 1 m3print
fmt "" 1 m4print
fmt "" 1 m5print
fmt "" 1 m6print
fmt "" 1 m7print
fmt "" 1 m8print
fmt "" 1 m9print
fmt  "X" 1 u$
fmt  "Y" 1 v$
fmt  "Z" 1 w$
fmt  "X" 1 ucal
fmt  "Y" 1 vcal
fmt  "Z" 1 wcal
fmt  "U" 1 old_u
fmt  "V" 1 old_v
fmt  "W" 1 old_w
fmt  2 Du
fmt  2 Dv
fmt  2 Dw
fmt "D" 2 deltaUVW
fmt  2 Dx
fmt  2 Dy
fmt  2 Dz
fmt "D" 2 deltaXYZ
fmt "LV" 2 longvec
fmt  "Vx" 1 Vx
fmt  "Vy" 1 Vy
fmt  "Vz" 1 Vz
fmt  "X" 1 xcor
fmt  "Y" 1 ycor
fmt  "Z" 1 zcor
fmt  "I" 2 i$
fmt  "J" 2 j$
fmt  "K" 2 k$
fmt  "F" 4 fr$ #OK
fmt  "S" 3 old_ss
fmt  "L" 2 lubrif
fmt  "L" 2 lubrif_m7
fmt  "L" 2 lubrif_m8
fmt  "L" 2 lubrif_m207
fmt  "L" 2 lubrif_m200
fmt  "L" 2 old_lubrif_m7
fmt  "L" 2 old_lubrif_m8
fmt  "L" 2 old_lubrif_m207
fmt  "L" 2 old_lubrif_m200
fmt  "L" 2 coolant$
fmt     3 opcode$
fmt  "G" 4 gcode$
fmt  "%" 6 progno$
fmt     3 spdlon
fmt  "T" 3 t$
fmt  "T" 3 next_tool$
fmt  "D" 3 tloffno$
fmt  "D" 4 tlngno$
fmt  "G" 3 cc$
fmt     2 tldia$
fmt     2 tlrad$
fmt  "OP" 3 op_id$
fmt  "LOP" 3 lastopid
fmt  "M" 3 lstation$
fmt  "M" 3 oldstation
fmt  "T" 1 typepercage
fmt  "" 8 depth$
fmt  "" 8 refht$
fmt  "" 8 initht$
fmt  "" 2 dwell$
fmt  "" 2 peckclr$
fmt  "" 2 peck1$
fmt  "" 2 peck2$
fmt  ""  2 shftdrl$
fmt  ""  2 retr$
fmt  "F" 3 frplunge$ #OK
fmt "" 8 avance_plonge
fmt "" 8 tosz$
fmt     3 mi1$
fmt     3 mi4$
fmt     3 mi8$
fmt "old_mi8" 3 oldmi8
fmt     3 old_mi1
fmt  "G" 3 mi2$
fmt  "P" 2 passe
fmt  "Z" 2 mr1$
fmt  "Z" 2 mr2$
fmt  ""   3 trans_mi1$
fmt  ""   3 trans_mi2$
fmt  "OP" 3 operation
fmt  "LUB" 8 lub
fmt  "PPR" 8 ppr
fmt  "X" 1 x1
fmt  "Y" 1 y1
fmt  "X" 1 x2
fmt  "Y" 1 y2
fmt  "Z" 1 z2
fmt  "X" 1 x3
fmt  "Y" 1 y3
fmt  "Z" 1 z3
fmt  "X" 1 x4
fmt  "Y" 1 y4
fmt  "Z" 1 z4
fmt  "X" 8 xaproche
fmt  "Y" 8 yaproche
fmt  "aCAl" 12 axeacal
fmt  "CCAl" 12 axeccal
fmt  "Pl" 2 plinc5a
fmt  "XV" 2 vieuxx
fmt  "YV" 2 vieuxy
fmt  "ZV" 2 vieuxz
fmt  "dx" 2 deltax
fmt  "dy" 2 deltay
fmt  "dz" 2 deltaz
fmt  "E" 3 e53
fmt     3 e40
fmt     8 vale53
fmt  "P" 2 pasmi7
fmt  "P" 2 pasn
fmt  "ANG" 2 move_ang3$
fmt "" 4 oscilliation
fmt "" 4 paquet_mi4
fmt "" 4 paquet_mi5
fmt "" 4 paquet_mi8
fmt "compteur_descrip" 2 compteur_descrip
compteur_descrip : 0
fmt 2 debut_pp
debut_pp : 0
fmt 2 delta_rot_C
delta_rot_C = 175
#endregion
#region FQ
fq 1 t$ "MACHINE STC9101 PROGRAMME COMPLET, ATTENTION PRISE D'OUTIL INTERDIT (Sauf si 51-52-61 OU 62) ?"
fq 4 t$ "MACHINE STC9101 PROGRAMME PARTITIONNÉ, ATTENTION PRISE D'OUTIL INTERDIT (Sauf si 51-52-61 OU 62) ?"
fmt  8 vectdeg
fq   2 vectdeg "Limite angle atteint! Longeur du vecteur de recul"

snomprog : ""
fq   3 snomprog "ASSUREZ VOUS QUE LA LETTRE U (RAMDISK) EST MONTEE SINON LES PROGRAMMES NE SERONT PAS GENERES, ENTREZ LE NOM DU PROGRAMMEUR ?"

fmt "hops" 4 HOPS

srefpiec : ""
fq 7 srefpiec "REFERENCE PIECE ? ( 15 characteres maxi )"

smesage : ""
fq 10 smesage "MACHINE STC9101, STC9103 et STC9110 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_AG : ""
#fq 10 smesage_AG "MACHINE STC9101 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_BG : ""
#fq 11 smesage_BG "MACHINE STC9103 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

#smesage_CG : ""
#fq 12 smesage_CG "MACHINE STC9110 PROGRAMME COMPLET ET PARTITIONNÉ, Commentaire opérateur pour arrêt programmé ?"

fq 13 trplus_AG "MACHINE STC9101 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 14 trplus_BG "MACHINE STC9103 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 15 trplus_CG "MACHINE STC9110 PROGRAMME COMPLET, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 16 trplus_AM "MACHINE STC9101 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 17 trplus_BM "MACHINE STC9103 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 18 trplus_CM "MACHINE STC9110 PROGRAMME PARTITIONNÉ, Ajout d'un tour au demarrage sur C ? +1 = +1 tour- -1 = -1 tour"

fq 19 axeC_AG "MACHINE STC9101 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 20 axeC_BG "MACHINE STC9103 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 21 axeC_CG "MACHINE STC9110 PROGRAMME COMPLET, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 22 axeC_AM "MACHINE STC9101 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 23 axeC_BM "MACHINE STC9103 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

fq 24 axeC_CM "MACHINE STC9110 PROGRAMME PARTITIONNÉ, L'angle C sort des limites machine! verifiez +1 pour -1 ou -1 pour +1"

#endregion
#region Le reste (LUB, GCODE, usecandrill, etc,...)
#-----------------------------Variable pour OUTILS----------------------------------------
fmt   2 paramT1         # Né outil
fmt   2 paramT2         # Type d'outil
fmt   2 paramT3         # longeur sorti outil 
fmt   2 paramT4         # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt   3 paramT5         # Diametre
fmt   3 paramT6         # Rayon de bout
fmt   3 paramT7         # Nombre de filet par mm
fmt   3 paramT8         # Angle de bout
fmt   5 paramT9         # Né de correcteur de rayon
fmt   5 paramT10        # Né de correcteur de longeur
fmt   3 paramT11        # Avance travail
fmt   3 paramT12        # Avance plongee
fmt   3 paramT13        # Avance retraction
fmt   5 paramT14        # Vitesse de broche
fmt   5 paramT15        # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt   5 paramT16    " DENTS" # Nombre de dents
#---------------------------------------------------------------------------
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
#---------------------------------------------------------------------------
#omitround$ : 1
#sub_level$ = 1
mrg_subfile$
auxprg$ = 2
extprg$ = 2
lccprg$ = 2
subprg$    : yes$
mergesub$  : 0
getnextop$ : 1
mill      : 1
spaces$    : 1
no$        = 0
#progno$    : 100
seqmax$    = 32000
omitseq$   : no$
frrapid   : 300
frmax     : 300
ssmax     : 34000
breakarcs$ : 0       #Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
arctype$   : 1       # Arc center 1=abs, 2=inc, 3=st-cen, 4=unsigned inc.
do_full_arc$ : 0     #Allow full circle output? 0=no, 1=yes
helix_arc$   : 2     #Support helix arc output, 0=no, 1=all planes, 2=XY plane only
ncldr$     : 20      # No. of leader characters
ldrcode$   : 65      # Leader character dec. equiv.
bldnxtool$ : yes$    # Build next tool table
tooltable$ : yes$
opcode$    : 1
nobrk$     : yes$    # Omit breakup of rapid linear motion? yes/no(xy,z or z,xy)
x$         : 9999
y$         : 9999
z$         : 9999
i$         : 0
j$         : 0
k$         : 0
gcode$     :   -1
strtool_v7$ : 1
rotaxtyp$   : 3
nbr_cht    : 0
gfr        : 1
#sextnc$      : ""
operation   : 0
sx_label : ""
sy_label : ""
sz_label : ""
si_label : ""
sj_label : ""
sk_label : ""
sxr_label : ""
syr_label : ""
szr_label : ""
smr2_label : ""
soutil : ""
svide : ""
oldmi8 : 0
smi4_str : ""
smi5_str : ""
smi8_str : ""
#---------------------------------------------------------------------
usecandrill$ : yes$
usecanpeck$  : yes$
usecanchip$  : yes$
usecantap$   : no$
usecanbore1$ : yes$
usecanbore2$ : no$
usecanmisc1$ : yes$
usecanmisc2$ : no$
#----------------------------------------------------------------------
fastmode$  : 1
bug1$   : 5            # 1 = Output post to screen - 2 = output leader to screen
bug2$   : 40           # Add postline label to each line at column 'bug2'
bug3$   : 50           # Add whatline to each line
bug4$   : 60           # Add nci no
whatno$ : yes$         # Ignore whatline branches to plin1 etc.?
linktolvar$    : 1     # Associer les variables de tolérance X aux variables V9-
linkplnvar$    : 1     # Associer les variables spécifiques plan X aux variables V9-?
linklvar$      : 1     # Associer les variables spécifiques X Tournage aux variables V9-
cant_tlchng$   : 1     # Ignorer entrée de texte programmé au changement avec tlchng_aft?
newglobal$     : 0     # Activer la vérification d'erreur pour les variables globales?
#----------------------------------------------------------------------------

sm93    : "G93"
sm94 : "G94"
sgfr : ""

fstrsel  sm93 gfr sgfr 2 -1

sg00    : "G0"
sg01    : "G1"
sg02    : "G2"
sg03    : "G3"
sg04    : "G1"
sgcode : ""

fstrsel  sg00 gcode$ sgcode 5 -1

spl00    : "G17"
spl01    : "G19"
spl02    : "G18"
spl03 : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1

sm00    : "M4"
sm01    : "M5"
sm02    : "M3"
spdlon ??
#CNC<<ECHEC>>spdlon
#CNC<<MSG -ERREUR(703)>> Label found in another type list

spdlsel = fsg3(ss$)
#spdlsel = fsg3(ss)+(coolant*3)

fstrsel  sm00 spdlsel spdlon 3 -1
#endregion
#endregion

#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE #OK
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE AG
fmt  "%" 20 mr1_AG
fmt      7 mini_a_AG
fmt      7 maxi_a_AG
fmt      7 mini_c_AG
fmt      7 maxi_c_AG
fmt "Z" 2 zsecu_AG
fmt  "X" 2 x3dprint_AG
fmt  "Y" 2 y3dprint_AG
fmt  "Z" 2 z3dprint_AG
fmt  "C" 7 axeCpos1_AG
fmt  "A" 7 axeApos1_AG
fmt  "EA" 7 axeApos_AG
fmt  "EC" 7 axeCpos_AG
fmt  "EU" 2 tox4print_AG
fmt  "EV" 2 toy4print_AG
fmt  "EW" 2 toz4print_AG
fmt  "I" 2 iprint_AG
fmt  "J" 2 jprint_AG
fmt  "K" 2 kprint_AG
fmt  "I" 2 xc_AG
fmt  "J" 2 yc_AG
fmt "X" 2 xrprint_AG
fmt "Y" 2 yrprint_AG
fmt "Z" 2 zrprint_AG
fmt "X" 2 xrprintrap_AG
fmt "Y" 2 yrprintrap_AG
fmt "Z" 2 zrprintrap_AG
fmt "Y" 2 depthprint_AG
fmt "Y" 2 refhtprint_AG
fmt "Y" 2 inithtprint_AG
fmt "Z" 2 mr2print_AG
fmt "S" 3 ssprint_AG
fmt "G04 F" 2 tempo_AG " ; temporisation "
fmt  "T" 3 tprint_AG
fmt  "" 3 tprint2_AG
fmt "E80004=" 2 vale84_AG
fmt  "N" 3 nplus_AG
fmt  "Z" 2 z1_AG
fmt  "Z" 2 prvmr2_AG
fmt "X" 8 xprint_AG
fmt "Y" 8 yprint_AG
fmt "Z" 8 zprint_AG
fmt "X" 8 xgarde_AG
fmt "Y" 8 ygarde_AG
fmt "Z" 8 zgarde_AG
fmt  "F" 4 avance_AG
fmt  "F" 10 fr5axe_AG
fmt  "F" 10 frbase_AG
fmt  "K" 2 pas_AG
fmt  "X" 2 xdeg_AG
fmt  "Y" 2 ydeg_AG
fmt  "Z" 2 zdeg_AG
fmt  "Z" 1 zdeg2_AG
fmt  "C" 12 prvaxec_AG
fmt  "X" 1 old_x_AG
fmt  "Y" 1 old_y_AG
fmt  "Z" 1 old_z_AG
fmt  "X" 2 old_x_print_AG
fmt  "Y" 2 old_y_print_AG
fmt  "Z" 2 old_z_print_AG
fmt  "C" 12 axeC_AG
fmt  "A" 12 axeA_AG
fmt  "Z" 2 old_zinitht_AG
fmt "Z" 2 dest_ret_5x_AG
fmt "Z" 2 old_dest_ret_5x_AG
fmt  "ER" 8 initht5x_AG
fmt  "Z" 8 zinitht_AG
fmt  "" 2 sdis_AG
fmt  "X" 2 xabs_AG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_AG
fmt  "Z" 2 zabs_AG
fmt "Z" 2 z_retraction_AG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_AG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_AG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_AG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_AG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_AG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_AG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_AG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_AG
fmt "Z" 3 prof_2_AG
fmt "Z" 3 prof_3_AG
fmt "Z" 3 prof_4_AG
fmt "Z" 3 prof_5_AG
fmt "Z" 3 prof_1_rel_AG
fmt "Z" 3 prof_2_rel_AG
fmt "Z" 3 prof_3_rel_AG
fmt "Z" 3 prof_4_rel_AG
fmt "Z" 3 prof_5_rel_AG
fmt "G4 F" 15 tempo_1_AG
fmt "G4 F" 15 tempo_2_AG
fmt "G4 F" 15 tempo_3_AG
fmt "G4 F" 15 tempo_4_AG
fmt "G4 F" 15 tempo_5_AG
fmt  "Z" 8 zaproche_AG
fmt "" 3 tete_rev_ang_11
fmt "" 3 tete_rev_ang_12
fmt "" 3 tete_rev_ang_21
fmt "" 3 tete_rev_ang_22
fmt  "LT" 8 station_tool
fmt  "abs_inc" 4 abs_inc
fmt  "X" 2 xinc_abs
fmt  "Y" 2 yinc_abs
fmt  "Z" 2 zinc_abs
fmt     9 mr8_AG
fmt     9 mr9_AG
fmt     9 mr10_AG
fmt     9 mr4_AG
fmt  "op" 1 prvop_id_AG
fmt     3 spdlon_AG
fmt 2 ecrigeneral_AG
fmt  "OP" 3 operation_AG
fmt  "E" 3 e53_AG
fmt  "DEB" 4 debut_AG
fmt  "OPERATION "  5 numop_AG
fmt 2 erreur_AG
fmt  "Z" 8 depth_AG
fmt  "EH" 8 refht_AG
fmt  "ER" 8 initht_AG
fmt  "EF" 2 dwell_AG
fmt  "EP" 2 peckclr_AG
fmt  "P" 2 peck1_AG
fmt  "Q" 2 peck2_AG
fmt     3 mi4_AG
fmt     3 old_mi4_AG
fmt  "M" 3 oldstation_AG
fmt     3 mi5_AG
fmt  "M" 3 oldmi5_AG
fmt     3 mi8_AG
fmt  "M" 3 oldmi8_AG
fmt "DEC_X_AG " 2 DEC_X_AG
fmt "DEC_Y_AG " 2 DEC_Y_AG
fmt "DEC_Z_AG " 2 DEC_Z_AG
fmt "prog_AG" 2 prog_AG
fmt "DEC X = "  2 mr8AF_AG
fmt "DEC Y = "  2 mr9AF_AG
fmt "DEC Z = "  2 mr10AF_AG
fmt "Mi2 pour A base =" 4 mi2_A_base_AG
fmt "Mi1 pour C base =" 4 mi1_C_base_AG
fmt  "TR" 4 trplus_AG
fmt  "I" 7 invers_AG
fmt  "D" 1 deja_AG
fmt  "VX" 1 old_vx_AG
fmt  "VY" 1 old_vy_AG
fmt  "VZ" 1 old_vz_AG
fmt  "Vx" 1 Vx_AG
fmt  "Vy" 1 Vy_AG
fmt  "Vz" 1 Vz_AG
fmt     2 typcycle_AG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_AG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_AG
fmt "old_sub_trnstyp_AG" 4 old_sub_trnstyp_AG
fmt "old_sub_totl_no_AG" 4 old_sub_totl_no_AG
fmt  "NB" 8 nbt_AG
fmt  "CT" 4 cont_axe_c_AG     #compte tour axe c
fmt  "X" 2 old_tox4_AG
fmt  "Y" 2 old_toy4_AG
fmt  "Z" 2 old_toz4_AG
fmt  "EC" 7 old_axeCpos_AG
fmt  "EA" 7 old_axeApos_AG
fmt      7 oldreel_axeCpos_AG
fmt      7 reel_axeCpos_AG
fmt      7 difaxecpos_AG
fmt      7 comptour_AG
fmt      7 naxecpos_AG
fmt "renv angle on off=" 4 tete_rev_AG
fmt  "cosangle" 11 cosangle_AG
fmt "LP12=" 1 long_p12_AG
fmt "LP23=" 1 long_p23_AG
fmt "LP13=" 1 long_p13_AG
fmt "Angle5x=" 1 ang5x_AG
fmt  "X" 1 old_x_5x_AG
fmt  "Y" 1 old_y_5x_AG
fmt  "Z" 1 old_z_5x_AG

nbt_AG = 2            # nombre de tour possible pour retournement
old_sub_trnstyp_AG : -1
old_sub_totl_no_AG : -1
prog_AG : -1
operation_AG : 0
drill5axes_AG  : 0
old_mi4_AG : 0

tete_rev_ang_11 = 51 # numero de la tete a renvoie d'angle numero 1 broche numero 1
tete_rev_ang_12 = 52 # numero de la tete a renvoie d'angle numero 1 broche numero 2
tete_rev_ang_21 = 61 # numero de la tete a renvoie d'angle numero 2 broche numero 1
tete_rev_ang_22 = 62 # numero de la tete a renvoie d'angle numero 2 broche numero 2
mini_a_AG =   -110.001
maxi_a_AG = 110.001
mini_c_AG = -365.001
maxi_c_AG = 365.001
zsecu_AG = 1500   # valeur altitude de securité en Z
dec_tete_AG = 113.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_AG : 100
gfr_AG : 1
smi4_str_AG : ""
smi5_str_AG : ""
smi8_str_AG : ""
SDEC_X_AG : ""
SDEC_Y_AG : ""
SDEC_Z_AG : ""
sprog_complet_AG : ""
sprog_NOK_AG : "STC9101 : NON"
sprog_OK_AG : "STC9101 : OUI"

sm93_AG    : "G93"
sm94_AG : "G94"
sgfr_AG : ""

fstrsel  sm93_AG gfr_AG sgfr_AG 2 -1

spl00_AG    : "G17"
spl01_AG    : "G19"
spl02_AG    : "G18"
spl03_AG : ""
splcode_AG : ""

fstrsel  spl00_AG plane$ splcode_AG 4 -1

sm00_AG    : "M4"
sm01_AG    : "M5"
sm02_AG    : "M3"
spdlon_AG ??
spdlsel_AG = fsg3(ss$)

fstrsel  sm00_AG spdlsel_AG spdlon_AG 3 -1

stringtxt1_AG : "$ BRIDER LA PIECE AVEC VIS"
stringtxt2_AG : "$ OTER LES VIS"
stringtxt3_AG : "$ BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_AG : "$ OTER LES SERRE-JOINTS"
stringtxt5_AG : "$ OTER LES CHUTES"
stringtxt6_AG : "TEXTE6"
stringtxt7_AG : "TEXTE7"
stringtxt8_AG : "TEXTE8"
stringtxt9_AG : "TEXTE9"
stringtxt10_AG : "TEXTE10"

fmt 4 deja_gcode_AG
pgcode_AG #modalité pgcode_AG

            if (gcode$ = 0) & (deja_gcode_AG <> 0), "G0",  deja_gcode_AG = 0
            if (gcode$ = 1) & (deja_gcode_AG <> 1), "G1",  deja_gcode_AG = 1
            if (gcode$ = 2) & (deja_gcode_AG <> 2), "G2",  deja_gcode_AG = 2
            if (gcode$ = 3) & (deja_gcode_AG <> 3), "G3",  deja_gcode_AG = 3
            if (gcode$ = 4) & (deja_gcode_AG <> 4), "G1",  deja_gcode_AG = 4

pgcode_force_AG #modalité pgcode_AG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE BG

fmt      7 mini_a_BG
fmt      7 maxi_a_BG
fmt      7 mini_c_BG
fmt      7 maxi_c_BG
fmt "Z" 2 zsecu_BG
fmt  "X" 2 x3dprint_BG
fmt  "Y" 2 y3dprint_BG
fmt  "Z" 2 z3dprint_BG
fmt  "C" 7 axeCpos1_BG
fmt  "A" 7 axeApos1_BG
fmt  "X=" 7 axeApos_BG
fmt  "Z=" 7 axeCpos_BG
fmt "X" 2 tox4print_BG
fmt "Y" 2 toy4print_BG
fmt "Z" 2 toz4print_BG
fmt  "I" 2 iprint_BG
fmt  "J" 2 jprint_BG
fmt  "K" 2 kprint_BG
fmt "X" 2 xrprint_BG
fmt "Y" 2 yrprint_BG
fmt "Z" 2 zrprint_BG
fmt "X" 2 xrprintrap_BG
fmt "Y" 2 yrprintrap_BG
fmt "Z" 2 zrprintrap_BG
fmt "Y" 2 depthprint_BG
fmt "Y" 2 refhtprint_BG
fmt "Y" 2 inithtprint_BG
fmt "Z" 2 mr2print_BG
fmt "S" 3 ssprint_BG
fmt "G04 F" 2 tempo_BG " ; temporisation "
fmt  "T" 3 tprint_BG
fmt  "" 3 tprint2_BG
fmt "E80004=" 2 vale84_BG
fmt  "N" 3 nplus_BG
fmt  "Z" 2 z1_BG
fmt  "Z" 2 prvmr2_BG
fmt "X" 8 xprint_BG
fmt "Y" 8 yprint_BG
fmt "Z" 8 zprint_BG
fmt "X" 8 xgarde_BG
fmt "Y" 8 ygarde_BG
fmt "Z" 8 zgarde_BG
fmt  "F" 4 avance_BG
fmt  "F" 10 fr5axe_BG
fmt  "F" 10 frbase_BG
fmt  "K" 2 pas_BG
fmt  "X" 2 xdeg_BG
fmt  "Y" 2 ydeg_BG
fmt  "Z" 2 zdeg_BG
fmt  "Z" 1 zdeg2_BG
fmt  "C" 12 prvaxec_BG
fmt  "X" 1 old_x_BG
fmt  "Y" 1 old_y_BG
fmt  "Z" 1 old_z_BG
fmt  "X" 2 old_x_print_BG
fmt  "Y" 2 old_y_print_BG
fmt  "Z" 2 old_z_print_BG
fmt  "C" 12 axeC_BG
fmt  "A" 12 axeA_BG
fmt  "Z" 2 old_zinitht_BG
fmt "Z" 2 dest_ret_5x_BG
fmt "Z" 2 old_dest_ret_5x_BG
fmt  "" 8 initht5x_BG
fmt  "Z" 8 zinitht_BG
fmt  "" 2 sdis_BG
fmt  "X" 2 xabs_BG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_BG
fmt  "Z" 2 zabs_BG
fmt "Z" 2 z_retraction_BG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_BG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_BG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_BG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_BG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_BG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_BG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_BG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_BG
fmt "Z" 3 prof_2_BG
fmt "Z" 3 prof_3_BG
fmt "Z" 3 prof_4_BG
fmt "Z" 3 prof_5_BG
fmt "Z" 3 prof_1_rel_BG
fmt "Z" 3 prof_2_rel_BG
fmt "Z" 3 prof_3_rel_BG
fmt "Z" 3 prof_4_rel_BG
fmt "Z" 3 prof_5_rel_BG
fmt "G4 F" 15 tempo_1_BG
fmt "G4 F" 15 tempo_2_BG
fmt "G4 F" 15 tempo_3_BG
fmt "G4 F" 15 tempo_4_BG
fmt "G4 F" 15 tempo_5_BG
fmt  "Z" 8 zaproche_BG
fmt  "X,ORI_X1" 13 mr8_BG
fmt  "Y,ORI_Y1" 13 mr9_BG
fmt  "Z,ORI_Z1" 13 mr10_BG
fmt  "USURE_L(" 2 mr4_BG ")"
fmt  "op" 1 prvop_id_BG
fmt     3 spdlon_BG
fmt 2 ecrigeneral_BG
fmt  "OP" 3 operation_BG
fmt  "E" 3 e53_BG
fmt  "DEB" 4 debut_BG
fmt  "OPERATION "  5 numop_BG
fmt 2 erreur_BG
fmt     3 mi4_BG
fmt     3 old_mi4_BG
fmt  "M" 3 oldstation_BG
fmt     3 mi5_BG
fmt  "M" 3 oldmi5_BG
fmt     3 mi8_BG
fmt  "M" 3 oldmi8_BG
fmt "DEC_X_BG " 2 DEC_X_BG
fmt "DEC_Y_BG " 2 DEC_Y_BG
fmt "DEC_Z_BG " 2 DEC_Z_BG
fmt "prog_BG" 2 prog_BG
fmt "DEC X = "  2 mr8AF_BG
fmt "DEC Y = "  2 mr9AF_BG
fmt "DEC Z = "  2 mr10AF_BG
fmt "Mi2 pour A base =" 4 mi2_A_base_BG
fmt "Mi1 pour C base =" 4 mi1_C_base_BG
fmt  "TR" 4 trplus_BG
fmt  "I" 7 invers_BG
fmt  "D" 1 deja_BG
fmt  "VX" 1 old_vx_BG
fmt  "VY" 1 old_vy_BG
fmt  "VZ" 1 old_vz_BG
fmt  "Vx" 1 Vx_BG
fmt  "Vy" 1 Vy_BG
fmt  "Vz" 1 Vz_BG
fmt     2 typcycle_BG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_BG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_BG
fmt "old_sub_trnstyp_BG" 4 old_sub_trnstyp_BG
fmt "old_sub_totl_no_BG" 4 old_sub_totl_no_BG
fmt  "NB" 8 nbt_BG
fmt  "CT" 4 cont_axe_c_BG     #compte tour axe c
fmt  "X" 2 old_tox4_BG
fmt  "Y" 2 old_toy4_BG
fmt  "Z" 2 old_toz4_BG
fmt  "EC" 7 old_axeCpos_BG
fmt  "EA" 7 old_axeApos_BG
fmt      7 oldreel_axeCpos_BG
fmt      7 reel_axeCpos_BG
fmt      7 difaxecpos_BG
fmt      7 comptour_BG
fmt      7 naxecpos_BG
fmt "renv angle on off=" 4 tete_rev_BG
fmt  "cosangle" 11 cosangle_BG
fmt "LP12=" 1 long_p12_BG
fmt "LP23=" 1 long_p23_BG
fmt "LP13=" 1 long_p13_BG
fmt "Angle5x=" 1 ang5x_BG
fmt  "X" 1 old_x_5x_BG
fmt  "Y" 1 old_y_5x_BG
fmt  "Z" 1 old_z_5x_BG

nbt_BG = 2            # nombre de tour possible pour retournement
old_sub_trnstyp_BG : -1
old_sub_totl_no_BG : -1
prog_BG : -1
operation_BG : 0
drill5axes_BG  : 0
old_mi4_BG : 0

mini_a_BG =   -110.001
maxi_a_BG = 110.001
mini_c_BG = -365.001
maxi_c_BG = 365.001
zsecu_BG = 800   # valeur altitude de securité en Z
dec_tete_BG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_BG : 100
gfr_BG : 1
smi4_str_BG : ""
smi5_str_BG : ""
smi8_str_BG : ""
SDEC_X_BG : ""
SDEC_Y_BG : ""
SDEC_Z_BG : ""
sprog_complet_BG : ""
sprog_NOK_BG : "STC9103 : NON"
sprog_OK_BG : "STC9103 : OUI"

sm93_BG    : "G93"
sm94_BG : "G94"
sgfr_BG : ""

fstrsel  sm93_BG gfr_BG sgfr_BG 2 -1

spl00_BG    : "G17"
spl01_BG    : "G19"
spl02_BG    : "G18"
spl03_BG : ""
splcode_BG : ""

fstrsel  spl00_BG plane$ splcode_BG 4 -1

sm00_BG    : "M4"
sm01_BG    : "M5"
sm02_BG    : "M3"
spdlon_BG ??
spdlsel_BG = fsg3(ss$)

fstrsel  sm00_BG spdlsel_BG spdlon_BG 3 -1

stringtxt1_BG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_BG : "OTER LES VIS"
stringtxt3_BG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_BG : "OTER LES SERRE-JOINTS"
stringtxt5_BG : "OTER LES CHUTES"
stringtxt6_BG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_BG : "TEXTE7"
stringtxt8_BG : "TEXTE8"
stringtxt9_BG : "TEXTE9"
stringtxt10_BG : "TEXTE10"
spalpeur_BG : "PALPEUR_3D"

fmt 4 deja_gcode_BG
pgcode_BG #modalité pgcode_BG

            if (gcode$ = 0) & (deja_gcode_BG <> 0), "G0",  deja_gcode_BG = 0
            if (gcode$ = 1) & (deja_gcode_BG <> 1), "G1",  deja_gcode_BG = 1
            if (gcode$ = 2) & (deja_gcode_BG <> 2), "G2",  deja_gcode_BG = 2
            if (gcode$ = 3) & (deja_gcode_BG <> 3), "G3",  deja_gcode_BG = 3
            if (gcode$ = 4) & (deja_gcode_BG <> 4), "G1",  deja_gcode_BG = 4

pgcode_force_BG #modalité pgcode_BG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE CG

fmt      7 mini_a_CG
fmt      7 maxi_a_CG
fmt      7 mini_c_CG
fmt      7 maxi_c_CG
fmt      7 mini_c_sans_cloche_CG
fmt      7 maxi_c_sans_cloche_CG
fmt      7 mini_c_avec_cloche_CG
fmt      7 maxi_c_avec_cloche_CG
fmt "Z" 2 zsecu_CG
fmt  "X" 2 x3dprint_CG
fmt  "Y" 2 y3dprint_CG
fmt  "Z" 2 z3dprint_CG
fmt  "C" 7 axeCpos1_CG
fmt  "B" 7 axeApos1_CG
fmt  "X=" 7 axeApos_CG
fmt  "Z=" 7 axeCpos_CG
fmt "X" 2 tox4print_CG
fmt "Y" 2 toy4print_CG
fmt "Z" 2 toz4print_CG
fmt  "I" 2 iprint_CG
fmt  "J" 2 jprint_CG
fmt  "K" 2 kprint_CG
fmt "X" 2 xrprint_CG
fmt "Y" 2 yrprint_CG
fmt "Z" 2 zrprint_CG
fmt "X" 2 xrprintrap_CG
fmt "Y" 2 yrprintrap_CG
fmt "Z" 2 zrprintrap_CG
fmt "Y" 2 depthprint_CG
fmt "Y" 2 refhtprint_CG
fmt "Y" 2 inithtprint_CG
fmt "Z" 2 mr2print_CG
fmt "S" 3 ssprint_CG
fmt "G04 F" 2 tempo_CG " ; temporisation "
fmt  "T" 3 tprint_CG
fmt  "" 3 tprint2_CG
fmt "E80004=" 2 vale84_CG
fmt  "N" 3 nplus_CG
fmt  "Z" 2 z1_CG
fmt  "Z" 2 prvmr2_CG
fmt "X" 8 xprint_CG
fmt "Y" 8 yprint_CG
fmt "Z" 8 zprint_CG
fmt "X" 8 xgarde_CG
fmt "Y" 8 ygarde_CG
fmt "Z" 8 zgarde_CG
fmt  "F" 4 avance_CG
fmt  "F" 10 fr5axe_CG
fmt  "F" 10 frbase_CG
fmt  "K" 2 pas_CG
fmt  "X" 2 xdeg_CG
fmt  "Y" 2 ydeg_CG
fmt  "Z" 2 zdeg_CG
fmt  "Z" 1 zdeg2_CG
fmt  "C" 12 prvaxec_CG
fmt  "X" 1 old_x_CG
fmt  "Y" 1 old_y_CG
fmt  "Z" 1 old_z_CG
fmt  "X" 2 old_x_print_CG
fmt  "Y" 2 old_y_print_CG
fmt  "Z" 2 old_z_print_CG
fmt  "C" 12 axeC_CG
fmt  "B" 12 axeA_CG
fmt  "Z" 2 old_zinitht_CG
fmt "Z" 2 dest_ret_5x_CG
fmt "Z" 2 old_dest_ret_5x_CG
fmt  "" 8 initht5x_CG
fmt  "Z" 8 zinitht_CG
fmt  "" 2 sdis_CG
fmt  "X" 2 xabs_CG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_CG
fmt  "Z" 2 zabs_CG
fmt "Z" 2 z_retraction_CG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_CG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_CG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_CG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_CG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_CG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_CG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_CG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_CG
fmt "Z" 3 prof_2_CG
fmt "Z" 3 prof_3_CG
fmt "Z" 3 prof_4_CG
fmt "Z" 3 prof_5_CG
fmt "Z" 3 prof_1_rel_CG
fmt "Z" 3 prof_2_rel_CG
fmt "Z" 3 prof_3_rel_CG
fmt "Z" 3 prof_4_rel_CG
fmt "Z" 3 prof_5_rel_CG
fmt "G4 F" 15 tempo_1_CG
fmt "G4 F" 15 tempo_2_CG
fmt "G4 F" 15 tempo_3_CG
fmt "G4 F" 15 tempo_4_CG
fmt "G4 F" 15 tempo_5_CG
fmt  "Z" 8 zaproche_CG
fmt  "X,ORI_X1" 13 mr8_CG
fmt  "Y,ORI_Y1" 13 mr9_CG
fmt  "Z,ORI_Z1" 13 mr10_CG
fmt  "USURE_L(" 2 mr4_CG ")"
fmt  "op" 1 prvop_id_CG
fmt     3 spdlon_CG
fmt 2 ecrigeneral_CG
fmt  "OP" 3 operation_CG
fmt  "E" 3 e53_CG
fmt  "DEB" 4 debut_CG
fmt  "OPERATION "  5 numop_CG
fmt 2 erreur_CG
fmt     3 mi4_CG
fmt     3 old_mi4_CG
fmt  "M" 3 oldstation_CG
fmt     3 mi5_CG
fmt  "M" 3 oldmi5_CG
fmt     3 mi8_CG
fmt  "M" 3 oldmi8_CG
fmt "DEC_X_CG " 2 DEC_X_CG
fmt "DEC_Y_CG " 2 DEC_Y_CG
fmt "DEC_Z_CG " 2 DEC_Z_CG
fmt "prog_CG" 2 prog_CG
fmt "DEC X = "  2 mr8AF_CG
fmt "DEC Y = "  2 mr9AF_CG
fmt "DEC Z = "  2 mr10AF_CG
fmt "Mi2 pour A base =" 4 mi2_A_base_CG
fmt "Mi1 pour C base =" 4 mi1_C_base_CG
fmt  "TR" 4 trplus_CG
fmt  "I" 7 invers_CG
fmt  "D" 1 deja_CG
fmt  "VX" 1 old_vx_CG
fmt  "VY" 1 old_vy_CG
fmt  "VZ" 1 old_vz_CG
fmt  "Vx" 1 Vx_CG
fmt  "Vy" 1 Vy_CG
fmt  "Vz" 1 Vz_CG
fmt     2 typcycle_CG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_CG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_CG
fmt "old_sub_trnstyp_CG" 4 old_sub_trnstyp_CG
fmt "old_sub_totl_no_CG" 4 old_sub_totl_no_CG
fmt  "NB" 8 nbt_CG
fmt 4 blocaxe_CG
fmt  "CT" 4 cont_axe_c_CG     #compte tour axe c
fmt "LONG_MAX=" 15 LONG_MAX_CG
fmt "LONG_MIN=" 15 LONG_MIN_CG
fmt  "X" 2 old_tox4_CG
fmt  "Y" 2 old_toy4_CG
fmt  "Z" 2 old_toz4_CG
fmt  "EC" 7 old_axeCpos_CG
fmt  "EA" 7 old_axeApos_CG
fmt      7 oldreel_axeCpos_CG
fmt      7 reel_axeCpos_CG
fmt      7 difaxecpos_CG
fmt      7 comptour_CG
fmt      7 naxecpos_CG
fmt "renv angle on off=" 4 tete_rev_CG
fmt 2 change_outil_CG
fmt  "cosangle" 11 cosangle_CG
fmt "LP12=" 1 long_p12_CG
fmt "LP23=" 1 long_p23_CG
fmt "LP13=" 1 long_p13_CG
fmt "Angle5x=" 1 ang5x_CG
fmt  "X" 1 old_x_5x_CG
fmt  "Y" 1 old_y_5x_CG
fmt  "Z" 1 old_z_5x_CG

change_outil_CG : 0
nbt_CG = 1            # nombre de tour possible pour retournement
old_sub_trnstyp_CG : -1
old_sub_totl_no_CG : -1
prog_CG : -1
operation_CG : 0
drill5axes_CG  : 0
old_mi4_CG : 0

mini_a_CG =   -120.001
maxi_a_CG = 120.001
mini_c_sans_cloche_CG = -185.001
maxi_c_sans_cloche_CG = 185.001
mini_c_avec_cloche_CG = -185.001
maxi_c_avec_cloche_CG = 185.001
zsecu_CG = 800   # valeur altitude de securité en Z
dec_tete_CG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_CG : 100
gfr_CG : 1
smi4_str_CG : ""
smi5_str_CG : ""
smi8_str_CG : ""
SDEC_X_CG : ""
SDEC_Y_CG : ""
SDEC_Z_CG : ""
sprog_complet_CG : ""
sprog_NOK_CG : "STC9110 : NON"
sprog_OK_CG : "STC9110 : OUI"

sm93_CG    : "G93"
sm94_CG : "G94"
sgfr_CG : ""

fstrsel  sm93_CG gfr_CG sgfr_CG 2 -1

spl00_CG    : "G17"
spl01_CG    : "G19"
spl02_CG    : "G18"
spl03_CG : ""
splcode_CG : ""

fstrsel  spl00_CG plane$ splcode_CG 4 -1

sm00_CG    : "M4"
sm01_CG    : "M5"
sm02_CG    : "M3"
spdlon_CG ??
spdlsel_CG = fsg3(ss$)

fstrsel  sm00_CG spdlsel_CG spdlon_CG 3 -1

stringtxt1_CG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_CG : "OTER LES VIS"
stringtxt3_CG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_CG : "OTER LES SERRE-JOINTS"
stringtxt5_CG : "OTER LES CHUTES"
stringtxt6_CG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_CG : "TEXTE7"
stringtxt8_CG : "TEXTE8"
stringtxt9_CG : "TEXTE9"
stringtxt10_CG : "TEXTE10"
spalpeur_CG : "PALPEUR_3D"

fmt 4 deja_gcode_CG
pgcode_CG #modalité pgcode_CG

            if (gcode$ = 0) & (deja_gcode_CG <> 0), "G0",  deja_gcode_CG = 0
            if (gcode$ = 1) & (deja_gcode_CG <> 1), "G1",  deja_gcode_CG = 1
            if (gcode$ = 2) & (deja_gcode_CG <> 2), "G2",  deja_gcode_CG = 2
            if (gcode$ = 3) & (deja_gcode_CG <> 3), "G3",  deja_gcode_CG = 3
            if (gcode$ = 4) & (deja_gcode_CG <> 4), "G1",  deja_gcode_CG = 4

pgcode_force_CG #modalité pgcode_CG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE DG

fmt      7 mini_a_DG
fmt      7 maxi_a_DG
fmt      7 mini_c_DG
fmt      7 maxi_c_DG
fmt      7 mini_c_sans_cloche_DG
fmt      7 maxi_c_sans_cloche_DG
fmt      7 mini_c_avec_cloche_DG
fmt      7 maxi_c_avec_cloche_DG
fmt "Z" 2 zsecu_DG
fmt  "X" 2 x3dprint_DG
fmt  "Y" 2 y3dprint_DG
fmt  "Z" 2 z3dprint_DG
fmt  "C" 7 axeCpos1_DG
fmt  "B" 7 axeApos1_DG
fmt  "X=" 7 axeApos_DG
fmt  "Z=" 7 axeCpos_DG
fmt "X" 2 tox4print_DG
fmt "Y" 2 toy4print_DG
fmt "Z" 2 toz4print_DG
fmt  "I" 2 iprint_DG
fmt  "J" 2 jprint_DG
fmt  "K" 2 kprint_DG
fmt "X" 2 xrprint_DG
fmt "Y" 2 yrprint_DG
fmt "Z" 2 zrprint_DG
fmt "X" 2 xrprintrap_DG
fmt "Y" 2 yrprintrap_DG
fmt "Z" 2 zrprintrap_DG
fmt "Y" 2 depthprint_DG
fmt "Y" 2 refhtprint_DG
fmt "Y" 2 inithtprint_DG
fmt "Z" 2 mr2print_DG
fmt "S" 3 ssprint_DG
fmt "G04 F" 2 tempo_DG " ; temporisation "
fmt  "T" 3 tprint_DG
fmt  "" 3 tprint2_DG
fmt "E80004=" 2 vale84_DG
fmt  "N" 3 nplus_DG
fmt  "Z" 2 z1_DG
fmt  "Z" 2 prvmr2_DG
fmt "X" 8 xprint_DG
fmt "Y" 8 yprint_DG
fmt "Z" 8 zprint_DG
fmt "X" 8 xgarde_DG
fmt "Y" 8 ygarde_DG
fmt "Z" 8 zgarde_DG
fmt  "F" 4 avance_DG
fmt  "F" 10 fr5axe_DG
fmt  "F" 10 frbase_DG
fmt  "K" 2 pas_DG
fmt  "X" 2 xdeg_DG
fmt  "Y" 2 ydeg_DG
fmt  "Z" 2 zdeg_DG
fmt  "Z" 1 zdeg2_DG
fmt  "C" 12 prvaxec_DG
fmt  "X" 1 old_x_DG
fmt  "Y" 1 old_y_DG
fmt  "Z" 1 old_z_DG
fmt  "X" 2 old_x_print_DG
fmt  "Y" 2 old_y_print_DG
fmt  "Z" 2 old_z_print_DG
fmt  "C" 12 axeC_DG
fmt  "B" 12 axeA_DG
fmt  "Z" 2 old_zinitht_DG
fmt "Z" 2 dest_ret_5x_DG
fmt "Z" 2 old_dest_ret_5x_DG
fmt  "" 8 initht5x_DG
fmt  "Z" 8 zinitht_DG
fmt  "" 2 sdis_DG
fmt  "X" 2 xabs_DG         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_DG
fmt  "Z" 2 zabs_DG
fmt "Z" 2 z_retraction_DG                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_DG                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_DG                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_DG                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_DG                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_DG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_DG                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_DG                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_DG
fmt "Z" 3 prof_2_DG
fmt "Z" 3 prof_3_DG
fmt "Z" 3 prof_4_DG
fmt "Z" 3 prof_5_DG
fmt "Z" 3 prof_1_rel_DG
fmt "Z" 3 prof_2_rel_DG
fmt "Z" 3 prof_3_rel_DG
fmt "Z" 3 prof_4_rel_DG
fmt "Z" 3 prof_5_rel_DG
fmt "G4 F" 15 tempo_1_DG
fmt "G4 F" 15 tempo_2_DG
fmt "G4 F" 15 tempo_3_DG
fmt "G4 F" 15 tempo_4_DG
fmt "G4 F" 15 tempo_5_DG
fmt  "Z" 8 zaproche_DG
fmt  "X,ORI_X1" 13 mr8_DG
fmt  "Y,ORI_Y1" 13 mr9_DG
fmt  "Z,ORI_Z1" 13 mr10_DG
fmt  "USURE_L(" 2 mr4_DG ")"
fmt  "op" 1 prvop_id_DG
fmt     3 spdlon_DG
fmt 2 ecrigeneral_DG
fmt  "OP" 3 operation_DG
fmt  "E" 3 e53_DG
fmt  "DEB" 4 debut_DG
fmt  "OPERATION "  5 numop_DG
fmt 2 erreur_DG
fmt     3 mi4_DG
fmt     3 old_mi4_DG
fmt  "M" 3 oldstation_DG
fmt     3 mi5_DG
fmt  "M" 3 oldmi5_DG
fmt     3 mi8_DG
fmt  "M" 3 oldmi8_DG
fmt "DEC_X_DG " 2 DEC_X_DG
fmt "DEC_Y_DG " 2 DEC_Y_DG
fmt "DEC_Z_DG " 2 DEC_Z_DG
fmt "prog_DG" 2 prog_DG
fmt "DEC X = "  2 mr8AF_DG
fmt "DEC Y = "  2 mr9AF_DG
fmt "DEC Z = "  2 mr10AF_DG
fmt "Mi2 pour A base =" 4 mi2_A_base_DG
fmt "Mi1 pour C base =" 4 mi1_C_base_DG
fmt  "TR" 4 trplus_DG
fmt  "I" 7 invers_DG
fmt  "D" 1 deja_DG
fmt  "VX" 1 old_vx_DG
fmt  "VY" 1 old_vy_DG
fmt  "VZ" 1 old_vz_DG
fmt  "Vx" 1 Vx_DG
fmt  "Vy" 1 Vy_DG
fmt  "Vz" 1 Vz_DG
fmt     2 typcycle_DG
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_DG    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_DG
fmt "old_sub_trnstyp_DG" 4 old_sub_trnstyp_DG
fmt "old_sub_totl_no_DG" 4 old_sub_totl_no_DG
fmt  "NB" 8 nbt_DG
fmt 4 blocaxe_DG
fmt  "CT" 4 cont_axe_c_DG     #compte tour axe c
fmt "LONG_MAX=" 15 LONG_MAX_DG
fmt "LONG_MIN=" 15 LONG_MIN_DG
fmt  "X" 2 old_tox4_DG
fmt  "Y" 2 old_toy4_DG
fmt  "Z" 2 old_toz4_DG
fmt  "EC" 7 old_axeCpos_DG
fmt  "EA" 7 old_axeApos_DG
fmt      7 oldreel_axeCpos_DG
fmt      7 reel_axeCpos_DG
fmt      7 difaxecpos_DG
fmt      7 comptour_DG
fmt      7 naxecpos_DG
fmt "renv angle on off=" 4 tete_rev_DG
fmt  "cosangle" 11 cosangle_DG
fmt "LP12=" 1 long_p12_DG
fmt "LP23=" 1 long_p23_DG
fmt "LP13=" 1 long_p13_DG
fmt "Angle5x=" 1 ang5x_DG
fmt  "X" 1 old_x_5x_DG
fmt  "Y" 1 old_y_5x_DG
fmt  "Z" 1 old_z_5x_DG

nbt_DG = 1            # nombre de tour possible pour retournement
old_sub_trnstyp_DG : -1
old_sub_totl_no_DG : -1
prog_DG : -1
operation_DG : 0
drill5axes_DG  : 0
old_mi4_DG : 0

mini_a_DG =   -120.001
maxi_a_DG = 120.001
mini_c_sans_cloche_DG = -185.001
maxi_c_sans_cloche_DG = 185.001
mini_c_avec_cloche_DG = -185.001
maxi_c_avec_cloche_DG = 185.001
zsecu_DG = 800   # valeur altitude de securité en Z
dec_tete_DG = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_DG : 100
gfr_DG : 1
smi4_str_DG : ""
smi5_str_DG : ""
smi8_str_DG : ""
SDEC_X_DG : ""
SDEC_Y_DG : ""
SDEC_Z_DG : ""
sprog_complet_DG : ""
sprog_NOK_DG : "STC9110 : NON"
sprog_OK_DG : "STC9110 : OUI"

sm93_DG    : "G93"
sm94_DG : "G94"
sgfr_DG : ""

fstrsel  sm93_DG gfr_DG sgfr_DG 2 -1

spl00_DG    : "G17"
spl01_DG    : "G19"
spl02_DG    : "G18"
spl03_DG : ""
splcode_DG : ""

fstrsel  spl00_DG plane$ splcode_DG 4 -1

sm00_DG    : "M4"
sm01_DG    : "M5"
sm02_DG    : "M3"
spdlon_DG ??
spdlsel_DG = fsg3(ss$)

fstrsel  sm00_DG spdlsel_DG spdlon_DG 3 -1

stringtxt1_DG : "BRIDER LA PIECE AVEC VIS"
stringtxt2_DG : "OTER LES VIS"
stringtxt3_DG : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_DG : "OTER LES SERRE-JOINTS"
stringtxt5_DG : "OTER LES CHUTES"
stringtxt6_DG : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_DG : "TEXTE7"
stringtxt8_DG : "TEXTE8"
stringtxt9_DG : "TEXTE9"
stringtxt10_DG : "TEXTE10"
spalpeur_DG : "PALPEUR_3D"

fmt 4 deja_gcode_DG
pgcode_DG #modalité pgcode_DG

            if (gcode$ = 0) & (deja_gcode_DG <> 0), "G0",  deja_gcode_DG = 0
            if (gcode$ = 1) & (deja_gcode_DG <> 1), "G1",  deja_gcode_DG = 1
            if (gcode$ = 2) & (deja_gcode_DG <> 2), "G2",  deja_gcode_DG = 2
            if (gcode$ = 3) & (deja_gcode_DG <> 3), "G3",  deja_gcode_DG = 3
            if (gcode$ = 4) & (deja_gcode_DG <> 4), "G1",  deja_gcode_DG = 4

pgcode_force_DG #modalité pgcode_DG

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE AM

fmt      7 mini_a_AM
fmt      7 maxi_a_AM
fmt      7 mini_c_AM
fmt      7 maxi_c_AM
fmt "Z" 2 zsecu_AM
fmt  "X" 2 x3dprint_AM
fmt  "Y" 2 y3dprint_AM
fmt  "Z" 2 z3dprint_AM
fmt  "C" 7 axeCpos1_AM
fmt  "A" 7 axeApos1_AM
fmt  "EA" 7 axeApos_AM
fmt  "EC" 7 axeCpos_AM
fmt  "EU" 2 tox4print_AM
fmt  "EV" 2 toy4print_AM
fmt  "EW" 2 toz4print_AM
fmt  "I" 2 iprint_AM
fmt  "J" 2 jprint_AM
fmt  "K" 2 kprint_AM
fmt  "I" 2 xc_AM
fmt  "J" 2 yc_AM
fmt "X" 2 xrprint_AM
fmt "Y" 2 yrprint_AM
fmt "Z" 2 zrprint_AM
fmt "X" 2 xrprintrap_AM
fmt "Y" 2 yrprintrap_AM
fmt "Z" 2 zrprintrap_AM
fmt "Y" 2 depthprint_AM
fmt "Y" 2 refhtprint_AM
fmt "Y" 2 inithtprint_AM
fmt "Z" 2 mr2print_AM
fmt "@ROTATION_BROCHE@" 3 ssprint_AM
fmt "G04 F" 2 tempo_AM " ; temporisation "
fmt  "@NOM_OUTIL@" 3 tprint_AM
fmt  "" 3 tprint2_AM
fmt "E80004=" 2 vale84_AM
fmt  "N" 3 nplus_AM
fmt  "Z" 2 z1_AM
fmt  "Z" 2 prvmr2_AM
fmt "X" 8 xprint_AM
fmt "Y" 8 yprint_AM
fmt "Z" 8 zprint_AM
fmt "X" 8 xgarde_AM
fmt "Y" 8 ygarde_AM
fmt "Z" 8 zgarde_AM
fmt  "@AVANCE@" 4 avance_AM
fmt  "@AVANCE@" 10 fr5axe_AM
fmt  "@AVANCE@" 10 frbase_AM
fmt   10 fr5axe_flag_AM
fmt   10 frbase_flag_AM
fmt  "K" 2 pas_AM
fmt  "X" 2 xdeg_AM
fmt  "Y" 2 ydeg_AM
fmt  "Z" 2 zdeg_AM
fmt  "Z" 1 zdeg2_AM
fmt  "C" 12 prvaxec_AM
fmt  "X" 1 old_x_AM
fmt  "Y" 1 old_y_AM
fmt  "Z" 1 old_z_AM
fmt  "X" 2 old_x_print_AM
fmt  "Y" 2 old_y_print_AM
fmt  "Z" 2 old_z_print_AM
fmt  "C" 12 axeC_AM
fmt  "A" 12 axeA_AM
fmt  "Z" 2 old_zinitht_AM
fmt "Z" 2 dest_ret_5x_AM
fmt "Z" 2 old_dest_ret_5x_AM
fmt  "ER" 8 initht5x_AM
fmt  "Z" 8 zinitht_AM
fmt  "" 2 sdis_AM
fmt  "X" 2 xabs_AM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_AM
fmt  "Z" 2 zabs_AM
fmt "Z" 2 z_retraction_AM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_AM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_AM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_AM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_AM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_AM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_AM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_AM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_AM
fmt "Z" 3 prof_2_AM
fmt "Z" 3 prof_3_AM
fmt "Z" 3 prof_4_AM
fmt "Z" 3 prof_5_AM
fmt "Z" 3 prof_1_rel_AM
fmt "Z" 3 prof_2_rel_AM
fmt "Z" 3 prof_3_rel_AM
fmt "Z" 3 prof_4_rel_AM
fmt "Z" 3 prof_5_rel_AM
fmt "G4 F" 15 tempo_1_AM
fmt "G4 F" 15 tempo_2_AM
fmt "G4 F" 15 tempo_3_AM
fmt "G4 F" 15 tempo_4_AM
fmt "G4 F" 15 tempo_5_AM
fmt  "Z" 8 zaproche_AM
fmt     9 mr8_AM
fmt     9 mr9_AM
fmt     9 mr10_AM
fmt     9 mr4_AM
fmt  "op" 1 prvop_id_AM
fmt     3 spdlon_AM
fmt 2 ecrigeneral_AM
fmt "Old progno" 4 old_progno_AM
fmt  "OP" 3 operation_AM
#fmt  "@CORRECTEUR_DYN_LG_OUTIL@" 3 e53_AM
fmt  "E" 3 e53_AM
fmt  "DEB" 4 debut_AM
fmt  "OPERATION "  5 numop_AM
fmt 6 numprg_concat_AM
fmt 6 cont_mi10_AM
fmt 2 old_mi10_AM
fmt 5 numop_garage_AM
fmt 2 erreur_AM
fmt 6 numprg_garage_AM
fmt 6 old_numprg_garage_AM
#fmt  "@CORRECTEUR_LONGUEUR@" 4 tlngno_AM
fmt  "D" 4 tlngno_AM
fmt  "Z" 8 depth_AM
fmt  "EH" 8 refht_AM
fmt  "ER" 8 initht_AM
fmt  "EF" 2 dwell_AM
fmt  "EP" 2 peckclr_AM
fmt  "P" 2 peck1_AM
fmt  "Q" 2 peck2_AM
fmt     3 mi4_AM
fmt  "M" 3 oldstation_AM
fmt     3 mi5_AM
fmt  "M" 3 oldmi5_AM
fmt     3 mi8_AM
fmt  "M" 3 oldmi8_AM
fmt "DEC_X_AM " 2 DEC_X_AM
fmt "DEC_Y_AM " 2 DEC_Y_AM
fmt "DEC_Z_AM " 2 DEC_Z_AM
fmt "prog_AM" 2 prog_AM
fmt "Mi2 pour A base =" 4 mi2_A_base_AM
fmt "Mi1 pour C base =" 4 mi1_C_base_AM
fmt  "TR" 4 trplus_AM
fmt  "I" 7 invers_AM
fmt  "D" 1 deja_AM
fmt  "VX" 1 old_vx_AM
fmt  "VY" 1 old_vy_AM
fmt  "VZ" 1 old_vz_AM
fmt  "Vx" 1 Vx_AM
fmt  "Vy" 1 Vy_AM
fmt  "Vz" 1 Vz_AM
fmt  "@AVANCE@" 4 fr_AM
fmt  "@AVANCE@" 3 frplunge_AM
fmt "@AVANCE@" 5 f_ent_cir_AM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE@" 5 f_int_hel_AM                                   # avance de l'helicoide 
fmt "@AVANCE@" 5 f_spiral_AM                                    # avance de la spiral
fmt "@AVANCE@" 5 f_int_fin_AM                                   # avance sur la finition du trou
fmt "@AVANCE@" 5 f_sor_cir_AM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE@" 5 f_base_AM                                      # avance de base du cycle
fmt "@AVANCE@" 4 avance_1_AM
fmt "@AVANCE@" 4 avance_2_AM
fmt "@AVANCE@" 4 avance_3_AM
fmt "@AVANCE@" 4 avance_4_AM
fmt "@AVANCE@" 4 avance_5_AM
fmt     2 typcycle_AM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_AM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_AM
fmt "old_sub_trnstyp_AM" 4 old_sub_trnstyp_AM
fmt "old_sub_totl_no_AM" 4 old_sub_totl_no_AM
fmt  "CT" 4 cont_axe_c_AM     #compte tour axe c
fmt  "X" 2 old_tox4_AM
fmt  "Y" 2 old_toy4_AM
fmt  "Z" 2 old_toz4_AM
fmt  "EC" 7 old_axeCpos_AM
fmt  "EA" 7 old_axeApos_AM
fmt      7 oldreel_axeCpos_AM
fmt      7 reel_axeCpos_AM
fmt      7 difaxecpos_AM
fmt      7 comptour_AM
fmt      7 naxecpos_AM
fmt "renv angle on off=" 4 tete_rev_AM
fmt  "cosangle" 11 cosangle_AM
fmt "LP12=" 1 long_p12_AM
fmt "LP23=" 1 long_p23_AM
fmt "LP13=" 1 long_p13_AM
fmt "Angle5x=" 1 ang5x_AM
fmt  "X" 1 old_x_5x_AM
fmt  "Y" 1 old_y_5x_AM
fmt  "Z" 1 old_z_5x_AM

old_sub_trnstyp_AM : -1
old_sub_totl_no_AM : -1
prog_AM : -1
cont_mi10_AM : 0
operation_AM : 0
drill5axes_AM  : 0

mini_a_AM =   -110.001
maxi_a_AM = 110.001
mini_c_AM = -365.001
maxi_c_AM = 365.001
zsecu_AM = 1500   # valeur altitude de securité en Z
dec_tete_AM = 113.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_AM : 100
gfr_AM : 1
sprog_concat_AM : ""

sm93_AM    : "G93"
sm94_AM : "G94"
sgfr_AM : ""

fstrsel  sm93_AM gfr_AM sgfr_AM 2 -1

spl00_AM    : "G17"
spl01_AM    : "G19"
spl02_AM    : "G18"
spl03_AM : ""
splcode_AM : ""

fstrsel  spl00_AM plane$ splcode_AM 4 -1

sm00_AM    : "M4"
sm01_AM    : "M5"
sm02_AM    : "M3"
spdlon_AM ??
spdlsel_AM = fsg3(ss$)

fstrsel  sm00_AM spdlsel_AM spdlon_AM 3 -1

stringtxt1_AM : "$ BRIDER LA PIECE AVEC VIS"
stringtxt2_AM : "$ OTER LES VIS"
stringtxt3_AM : "$ BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_AM : "$ OTER LES SERRE-JOINTS"
stringtxt5_AM : "$ OTER LES CHUTES"
stringtxt6_AM : "TEXTE6"
stringtxt7_AM : "TEXTE7"
stringtxt8_AM : "TEXTE8"
stringtxt9_AM : "TEXTE9"
stringtxt10_AM : "TEXTE10"

fmt 4 deja_gcode_AM
pgcode_AM #modalité pgcode_AM

            if (gcode$ = 0) & (deja_gcode_AM <> 0), "G0",  deja_gcode_AM = 0
            if (gcode$ = 1) & (deja_gcode_AM <> 1), "G1",  deja_gcode_AM = 1
            if (gcode$ = 2) & (deja_gcode_AM <> 2), "G2",  deja_gcode_AM = 2
            if (gcode$ = 3) & (deja_gcode_AM <> 3), "G3",  deja_gcode_AM = 3
            if (gcode$ = 4) & (deja_gcode_AM <> 4), "G1",  deja_gcode_AM = 4

pgcode_force_AM #modalité pgcode_AM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE BM

fmt      7 mini_a_BM
fmt      7 maxi_a_BM
fmt      7 mini_c_BM
fmt      7 maxi_c_BM
fmt "Z" 2 zsecu_BM
fmt  "X" 2 x3dprint_BM
fmt  "Y" 2 y3dprint_BM
fmt  "Z" 2 z3dprint_BM
fmt  "C" 7 axeCpos1_BM
fmt  "A" 7 axeApos1_BM
fmt  "X=" 7 axeApos_BM
fmt  "Z=" 7 axeCpos_BM
fmt "X" 2 tox4print_BM
fmt "Y" 2 toy4print_BM
fmt "Z" 2 toz4print_BM
fmt  "I" 2 iprint_BM
fmt  "J" 2 jprint_BM
fmt  "K" 2 kprint_BM
fmt "X" 2 xrprint_BM
fmt "Y" 2 yrprint_BM
fmt "Z" 2 zrprint_BM
fmt "X" 2 xrprintrap_BM
fmt "Y" 2 yrprintrap_BM
fmt "Z" 2 zrprintrap_BM
fmt "Y" 2 depthprint_BM
fmt "Y" 2 refhtprint_BM
fmt "Y" 2 inithtprint_BM
fmt "Z" 2 mr2print_BM
fmt "@ROTATION_BROCHE@" 3 ssprint_BM
fmt "G04 F" 2 tempo_BM " ; temporisation "
fmt  "T" 3 tprint_BM
fmt  "" 3 tprint2_BM
fmt "E80004=" 2 vale84_BM
fmt  "N" 3 nplus_BM
fmt  "Z" 2 z1_BM
fmt  "Z" 2 prvmr2_BM
fmt "X" 8 xprint_BM
fmt "Y" 8 yprint_BM
fmt "Z" 8 zprint_BM
fmt "X" 8 xgarde_BM
fmt "Y" 8 ygarde_BM
fmt "Z" 8 zgarde_BM
fmt  "@AVANCE@" 4 avance_BM
fmt  "@AVANCE@" 10 fr5axe_BM
fmt  "@AVANCE@" 10 frbase_BM
fmt   10 fr5axe_flag_BM
fmt   10 frbase_flag_BM
fmt  "K" 2 pas_BM
fmt  "X" 2 xdeg_BM
fmt  "Y" 2 ydeg_BM
fmt  "Z" 2 zdeg_BM
fmt  "Z" 1 zdeg2_BM
fmt  "C" 12 prvaxec_BM
fmt  "X" 1 old_x_BM
fmt  "Y" 1 old_y_BM
fmt  "Z" 1 old_z_BM
fmt  "X" 2 old_x_print_BM
fmt  "Y" 2 old_y_print_BM
fmt  "Z" 2 old_z_print_BM
fmt  "C" 12 axeC_BM
fmt  "A" 12 axeA_BM
fmt  "Z" 2 old_zinitht_BM
fmt "Z" 2 dest_ret_5x_BM
fmt "Z" 2 old_dest_ret_5x_BM
fmt  "" 8 initht5x_BM
fmt  "Z" 8 zinitht_BM
fmt  "" 2 sdis_BM
fmt  "X" 2 xabs_BM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_BM
fmt  "Z" 2 zabs_BM
fmt "Z" 2 z_retraction_BM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_BM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_BM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_BM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_BM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_BM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_BM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_BM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_BM
fmt "Z" 3 prof_2_BM
fmt "Z" 3 prof_3_BM
fmt "Z" 3 prof_4_BM
fmt "Z" 3 prof_5_BM
fmt "Z" 3 prof_1_rel_BM
fmt "Z" 3 prof_2_rel_BM
fmt "Z" 3 prof_3_rel_BM
fmt "Z" 3 prof_4_rel_BM
fmt "Z" 3 prof_5_rel_BM
fmt "G4 F" 15 tempo_1_BM
fmt "G4 F" 15 tempo_2_BM
fmt "G4 F" 15 tempo_3_BM
fmt "G4 F" 15 tempo_4_BM
fmt "G4 F" 15 tempo_5_BM
fmt  "Z" 8 zaproche_BM
fmt  "X,ORI_X1" 13 mr8_BM
fmt  "Y,ORI_Y1" 13 mr9_BM
fmt  "Z,ORI_Z1" 13 mr10_BM
fmt  "USURE_L(" 2 mr4_BM ")"
fmt  "op" 1 prvop_id_BM
fmt     3 spdlon_BM
fmt 2 ecrigeneral_BM
fmt "Old progno" 4 old_progno_BM
fmt  "OP" 3 operation_BM
fmt  "E" 3 e53_BM
fmt  "DEB" 4 debut_BM
fmt  "OPERATION "  5 numop_BM
fmt 6 numprg_concat_BM
fmt 6 cont_mi10_BM
fmt 2 old_mi10_BM
fmt 5 numop_garage_BM
fmt 2 erreur_BM
fmt 6 numprg_garage_BM
fmt 6 old_numprg_garage_BM
fmt     3 mi4_BM
fmt  "M" 3 oldstation_BM
fmt     3 mi5_BM
fmt  "M" 3 oldmi5_BM
fmt     3 mi8_BM
fmt  "M" 3 oldmi8_BM
fmt "DEC_X_BM " 2 DEC_X_BM
fmt "DEC_Y_BM " 2 DEC_Y_BM
fmt "DEC_Z_BM " 2 DEC_Z_BM
fmt "prog_BM" 2 prog_BM
fmt "Mi2 pour A base =" 4 mi2_A_base_BM
fmt "Mi1 pour C base =" 4 mi1_C_base_BM
fmt  "TR" 4 trplus_BM
fmt  "I" 7 invers_BM
fmt  "D" 1 deja_BM
fmt  "VX" 1 old_vx_BM
fmt  "VY" 1 old_vy_BM
fmt  "VZ" 1 old_vz_BM
fmt  "Vx" 1 Vx_BM
fmt  "Vy" 1 Vy_BM
fmt  "Vz" 1 Vz_BM
fmt  "@AVANCE@" 4 fr_BM
fmt  "@AVANCE@" 3 frplunge_BM
fmt "@AVANCE@" 5 f_ent_cir_BM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE@" 5 f_int_hel_BM                                   # avance de l'helicoide 
fmt "@AVANCE@" 5 f_spiral_BM                                    # avance de la spiral
fmt "@AVANCE@" 5 f_int_fin_BM                                   # avance sur la finition du trou
fmt "@AVANCE@" 5 f_sor_cir_BM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE@" 5 f_base_BM                                      # avance de base du cycle
fmt "@AVANCE@" 4 avance_1_BM
fmt "@AVANCE@" 4 avance_2_BM
fmt "@AVANCE@" 4 avance_3_BM
fmt "@AVANCE@" 4 avance_4_BM
fmt "@AVANCE@" 4 avance_5_BM
fmt     2 typcycle_BM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_BM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_BM
fmt "old_sub_trnstyp_BM" 4 old_sub_trnstyp_BM
fmt "old_sub_totl_no_BM" 4 old_sub_totl_no_BM
fmt  "CT" 4 cont_axe_c_BM     #compte tour axe c
fmt  "X" 2 old_tox4_BM
fmt  "Y" 2 old_toy4_BM
fmt  "Z" 2 old_toz4_BM
fmt  "EC" 7 old_axeCpos_BM
fmt  "EA" 7 old_axeApos_BM
fmt      7 oldreel_axeCpos_BM
fmt      7 reel_axeCpos_BM
fmt      7 difaxecpos_BM
fmt      7 comptour_BM
fmt      7 naxecpos_BM
fmt "renv angle on off=" 4 tete_rev_BM
fmt  "cosangle" 11 cosangle_BM
fmt "LP12=" 1 long_p12_BM
fmt "LP23=" 1 long_p23_BM
fmt "LP13=" 1 long_p13_BM
fmt "Angle5x=" 1 ang5x_BM
fmt  "X" 1 old_x_5x_BM
fmt  "Y" 1 old_y_5x_BM
fmt  "Z" 1 old_z_5x_BM

old_sub_trnstyp_BM : -1
old_sub_totl_no_BM : -1
prog_BM : -1
cont_mi10_BM : 0
operation_BM : 0
drill5axes_BM  : 0

mini_a_BM =   -110.001
maxi_a_BM = 110.001
mini_c_BM = -365.001
maxi_c_BM = 365.001
zsecu_BM = 800   # valeur altitude de securité en Z
dec_tete_BM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_BM : 100
gfr_BM : 1
sprog_concat_BM : ""

sm93_BM    : "G93"
sm94_BM : "G94"
sgfr_BM : ""

fstrsel  sm93_BM gfr_BM sgfr_BM 2 -1

spl00_BM    : "G17"
spl01_BM    : "G19"
spl02_BM    : "G18"
spl03_BM : ""
splcode_BM : ""

fstrsel  spl00_BM plane$ splcode_BM 4 -1

sm00_BM    : "M4"
sm01_BM    : "M5"
sm02_BM    : "M3"
spdlon_BM ??
spdlsel_BM = fsg3(ss$)

fstrsel  sm00_BM spdlsel_BM spdlon_BM 3 -1

stringtxt1_BM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_BM : "OTER LES VIS"
stringtxt3_BM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_BM : "OTER LES SERRE-JOINTS"
stringtxt5_BM : "OTER LES CHUTES"
stringtxt6_BM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_BM : "TEXTE7"
stringtxt8_BM : "TEXTE8"
stringtxt9_BM : "TEXTE9"
stringtxt10_BM : "TEXTE10"
spalpeur_BM : "PALPEUR_3D"

fmt 4 deja_gcode_BM
pgcode_BM #modalité pgcode_BM

            if (gcode$ = 0) & (deja_gcode_BM <> 0), "G0",  deja_gcode_BM = 0
            if (gcode$ = 1) & (deja_gcode_BM <> 1), "G1",  deja_gcode_BM = 1
            if (gcode$ = 2) & (deja_gcode_BM <> 2), "G2",  deja_gcode_BM = 2
            if (gcode$ = 3) & (deja_gcode_BM <> 3), "G3",  deja_gcode_BM = 3
            if (gcode$ = 4) & (deja_gcode_BM <> 4), "G1",  deja_gcode_BM = 4

pgcode_force_BM #modalité pgcode_BM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE CM

fmt      7 mini_a_CM
fmt      7 maxi_a_CM
fmt      7 mini_c_CM
fmt      7 maxi_c_CM
fmt      7 mini_c_sans_cloche_CM
fmt      7 maxi_c_sans_cloche_CM
fmt      7 mini_c_avec_cloche_CM
fmt      7 maxi_c_avec_cloche_CM
fmt "Z" 2 zsecu_CM
fmt  "X" 2 x3dprint_CM
fmt  "Y" 2 y3dprint_CM
fmt  "Z" 2 z3dprint_CM
fmt  "C" 7 axeCpos1_CM
fmt  "B" 7 axeApos1_CM
fmt  "X=" 7 axeApos_CM
fmt  "Z=" 7 axeCpos_CM
fmt "X" 2 tox4print_CM
fmt "Y" 2 toy4print_CM
fmt "Z" 2 toz4print_CM
fmt  "I" 2 iprint_CM
fmt  "J" 2 jprint_CM
fmt  "K" 2 kprint_CM
fmt "X" 2 xrprint_CM
fmt "Y" 2 yrprint_CM
fmt "Z" 2 zrprint_CM
fmt "X" 2 xrprintrap_CM
fmt "Y" 2 yrprintrap_CM
fmt "Z" 2 zrprintrap_CM
fmt "Y" 2 depthprint_CM
fmt "Y" 2 refhtprint_CM
fmt "Y" 2 inithtprint_CM
fmt "Z" 2 mr2print_CM
fmt "@ROTATION_BROCHE@" 3 ssprint_CM
fmt "G04 F" 2 tempo_CM " ; temporisation "
fmt  "@NOM_OUTIL@" 3 tprint_CM
fmt  "" 3 tprint2_CM
fmt "E80004=" 2 vale84_CM
fmt  "N" 3 nplus_CM
fmt  "Z" 2 z1_CM
fmt  "Z" 2 prvmr2_CM
fmt "X" 8 xprint_CM
fmt "Y" 8 yprint_CM
fmt "Z" 8 zprint_CM
fmt "X" 8 xgarde_CM
fmt "Y" 8 ygarde_CM
fmt "Z" 8 zgarde_CM
fmt  "@AVANCE@" 4 avance_CM
fmt  "@AVANCE@" 10 fr5axe_CM
fmt  "@AVANCE@" 10 frbase_CM
fmt   10 fr5axe_flag_CM
fmt   10 frbase_flag_CM
fmt  "K" 2 pas_CM
fmt  "X" 2 xdeg_CM
fmt  "Y" 2 ydeg_CM
fmt  "Z" 2 zdeg_CM
fmt  "Z" 1 zdeg2_CM
fmt  "C" 12 prvaxec_CM
fmt  "X" 1 old_x_CM
fmt  "Y" 1 old_y_CM
fmt  "Z" 1 old_z_CM
fmt  "X" 2 old_x_print_CM
fmt  "Y" 2 old_y_print_CM
fmt  "Z" 2 old_z_print_CM
fmt  "C" 12 axeC_CM
fmt  "B" 12 axeA_CM
fmt  "Z" 2 old_zinitht_CM
fmt "Z" 2 dest_ret_5x_CM
fmt "Z" 2 old_dest_ret_5x_CM
fmt  "" 8 initht5x_CM
fmt  "Z" 8 zinitht_CM
fmt  "" 2 sdis_CM
fmt  "X" 2 xabs_CM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_CM
fmt  "Z" 2 zabs_CM
fmt "Z" 2 z_retraction_CM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_CM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_CM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_CM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_CM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_CM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_CM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_CM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_CM
fmt "Z" 3 prof_2_CM
fmt "Z" 3 prof_3_CM
fmt "Z" 3 prof_4_CM
fmt "Z" 3 prof_5_CM
fmt "Z" 3 prof_1_rel_CM
fmt "Z" 3 prof_2_rel_CM
fmt "Z" 3 prof_3_rel_CM
fmt "Z" 3 prof_4_rel_CM
fmt "Z" 3 prof_5_rel_CM
fmt "G4 F" 15 tempo_1_CM
fmt "G4 F" 15 tempo_2_CM
fmt "G4 F" 15 tempo_3_CM
fmt "G4 F" 15 tempo_4_CM
fmt "G4 F" 15 tempo_5_CM
fmt  "Z" 8 zaproche_CM
fmt  "X,ORI_X1" 13 mr8_CM
fmt  "Y,ORI_Y1" 13 mr9_CM
fmt  "Z,ORI_Z1" 13 mr10_CM
fmt  "USURE_L(" 2 mr4_CM ")"
fmt  "op" 1 prvop_id_CM
fmt     3 spdlon_CM
fmt 2 ecrigeneral_CM
fmt "Old progno" 4 old_progno_CM
fmt  "OP" 3 operation_CM
fmt  "E" 3 e53_CM
fmt  "DEB" 4 debut_CM
fmt  "OPERATION "  5 numop_CM
fmt 6 numprg_concat_CM
fmt 6 cont_mi10_CM
fmt 2 old_mi10_CM
fmt 5 numop_garage_CM
fmt 2 erreur_CM
fmt 6 numprg_garage_CM
fmt 6 old_numprg_garage_CM
fmt     3 mi4_CM
fmt  "M" 3 oldstation_CM
fmt     3 mi5_CM
fmt  "M" 3 oldmi5_CM
fmt     3 mi8_CM
fmt  "M" 3 oldmi8_CM
fmt "DEC_X_CM " 2 DEC_X_CM
fmt "DEC_Y_CM " 2 DEC_Y_CM
fmt "DEC_Z_CM " 2 DEC_Z_CM
fmt "prog_CM" 2 prog_CM
fmt "Mi2 pour A base =" 4 mi2_A_base_CM
fmt "Mi1 pour C base =" 4 mi1_C_base_CM
fmt  "TR" 4 trplus_CM
fmt  "I" 7 invers_CM
fmt  "D" 1 deja_CM
fmt  "VX" 1 old_vx_CM
fmt  "VY" 1 old_vy_CM
fmt  "VZ" 1 old_vz_CM
fmt  "Vx" 1 Vx_CM
fmt  "Vy" 1 Vy_CM
fmt  "Vz" 1 Vz_CM
fmt  "@AVANCE@" 4 fr_CM
fmt  "@AVANCE@" 3 frplunge_CM
fmt "@AVANCE@" 5 f_ent_cir_CM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE@" 5 f_int_hel_CM                                   # avance de l'helicoide 
fmt "@AVANCE@" 5 f_spiral_CM                                    # avance de la spiral
fmt "@AVANCE@" 5 f_int_fin_CM                                   # avance sur la finition du trou
fmt "@AVANCE@" 5 f_sor_cir_CM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE@" 5 f_base_CM                                      # avance de base du cycle
fmt "@AVANCE@" 4 avance_1_CM
fmt "@AVANCE@" 4 avance_2_CM
fmt "@AVANCE@" 4 avance_3_CM
fmt "@AVANCE@" 4 avance_4_CM
fmt "@AVANCE@" 4 avance_5_CM
fmt     2 typcycle_CM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_CM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_CM
fmt "old_sub_trnstyp_CM" 4 old_sub_trnstyp_CM
fmt "old_sub_totl_no_CM" 4 old_sub_totl_no_CM
fmt 4 blocaxe_CM
fmt  "CT" 4 cont_axe_c_CM     #compte tour axe c
fmt "LONG_MAX=" 15 LONG_MAX_CM
fmt "LONG_MIN=" 15 LONG_MIN_CM
fmt  "X" 2 old_tox4_CM
fmt  "Y" 2 old_toy4_CM
fmt  "Z" 2 old_toz4_CM
fmt  "EC" 7 old_axeCpos_CM
fmt  "EA" 7 old_axeApos_CM
fmt      7 oldreel_axeCpos_CM
fmt      7 reel_axeCpos_CM
fmt      7 difaxecpos_CM
fmt      7 comptour_CM
fmt      7 naxecpos_CM
fmt "renv angle on off=" 4 tete_rev_CM
fmt  "cosangle" 11 cosangle_CM
fmt "LP12=" 1 long_p12_CM
fmt "LP23=" 1 long_p23_CM
fmt "LP13=" 1 long_p13_CM
fmt "Angle5x=" 1 ang5x_CM
fmt  "X" 1 old_x_5x_CM
fmt  "Y" 1 old_y_5x_CM
fmt  "Z" 1 old_z_5x_CM

old_sub_trnstyp_CM : -1
old_sub_totl_no_CM : -1
prog_CM : -1
cont_mi10_CM : 0
operation_CM : 0
drill5axes_CM  : 0

mini_a_CM =   -120.001
maxi_a_CM = 120.001
mini_c_sans_cloche_CM = -185.001
maxi_c_sans_cloche_CM = 185.001
mini_c_avec_cloche_CM = -270.001
maxi_c_avec_cloche_CM = 270.001
zsecu_CM = 800   # valeur altitude de securité en Z
dec_tete_CM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_CM : 100
gfr_CM : 1
sprog_concat_CM : ""

sm93_CM    : "G93"
sm94_CM : "G94"
sgfr_CM : ""

fstrsel  sm93_CM gfr_CM sgfr_CM 2 -1

spl00_CM    : "G17"
spl01_CM    : "G19"
spl02_CM    : "G18"
spl03_CM : ""
splcode_CM : ""

fstrsel  spl00_CM plane$ splcode_CM 4 -1

sm00_CM    : "M4"
sm01_CM    : "M5"
sm02_CM    : "M3"
spdlon_CM ??
spdlsel_CM = fsg3(ss$)

fstrsel  sm00_CM spdlsel_CM spdlon_CM 3 -1

stringtxt1_CM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_CM : "OTER LES VIS"
stringtxt3_CM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_CM : "OTER LES SERRE-JOINTS"
stringtxt5_CM : "OTER LES CHUTES"
stringtxt6_CM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_CM : "TEXTE7"
stringtxt8_CM : "TEXTE8"
stringtxt9_CM : "TEXTE9"
stringtxt10_CM : "TEXTE10"
spalpeur_CM : "PALPEUR_3D"

fmt 4 deja_gcode_CM
pgcode_CM #modalité pgcode_CM

            if (gcode$ = 0) & (deja_gcode_CM <> 0), "G0",  deja_gcode_CM = 0
            if (gcode$ = 1) & (deja_gcode_CM <> 1), "G1",  deja_gcode_CM = 1
            if (gcode$ = 2) & (deja_gcode_CM <> 2), "G2",  deja_gcode_CM = 2
            if (gcode$ = 3) & (deja_gcode_CM <> 3), "G3",  deja_gcode_CM = 3
            if (gcode$ = 4) & (deja_gcode_CM <> 4), "G1",  deja_gcode_CM = 4

pgcode_force_CM #modalité pgcode_CM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region   VARIABLES D'AFFICHAGE POUR MULTI PP MACHINE DM

fmt      7 mini_a_DM
fmt      7 maxi_a_DM
fmt      7 mini_c_DM
fmt      7 maxi_c_DM
fmt      7 mini_c_sans_cloche_DM
fmt      7 maxi_c_sans_cloche_DM
fmt      7 mini_c_avec_cloche_DM
fmt      7 maxi_c_avec_cloche_DM
fmt "Z" 2 zsecu_DM
fmt  "X" 2 x3dprint_DM
fmt  "Y" 2 y3dprint_DM
fmt  "Z" 2 z3dprint_DM
fmt  "C" 7 axeCpos1_DM
fmt  "B" 7 axeApos1_DM
fmt  "X=" 7 axeApos_DM
fmt  "Z=" 7 axeCpos_DM
fmt "X" 2 tox4print_DM
fmt "Y" 2 toy4print_DM
fmt "Z" 2 toz4print_DM
fmt  "I" 2 iprint_DM
fmt  "J" 2 jprint_DM
fmt  "K" 2 kprint_DM
fmt "X" 2 xrprint_DM
fmt "Y" 2 yrprint_DM
fmt "Z" 2 zrprint_DM
fmt "X" 2 xrprintrap_DM
fmt "Y" 2 yrprintrap_DM
fmt "Z" 2 zrprintrap_DM
fmt "Y" 2 depthprint_DM
fmt "Y" 2 refhtprint_DM
fmt "Y" 2 inithtprint_DM
fmt "Z" 2 mr2print_DM
fmt "@ROTATION_BROCHE@" 3 ssprint_DM
fmt "G04 F" 2 tempo_DM " ; temporisation "
fmt  "@NOM_OUTIL@" 3 tprint_DM
fmt  "" 3 tprint2_DM
fmt "E80004=" 2 vale84_DM
fmt  "N" 3 nplus_DM
fmt  "Z" 2 z1_DM
fmt  "Z" 2 prvmr2_DM
fmt "X" 8 xprint_DM
fmt "Y" 8 yprint_DM
fmt "Z" 8 zprint_DM
fmt "X" 8 xgarde_DM
fmt "Y" 8 ygarde_DM
fmt "Z" 8 zgarde_DM
fmt  "@AVANCE@" 4 avance_DM
fmt  "@AVANCE@" 10 fr5axe_DM
fmt  "@AVANCE@" 10 frbase_DM
fmt   10 fr5axe_flag_DM
fmt   10 frbase_flag_DM
fmt  "K" 2 pas_DM
fmt  "X" 2 xdeg_DM
fmt  "Y" 2 ydeg_DM
fmt  "Z" 2 zdeg_DM
fmt  "Z" 1 zdeg2_DM
fmt  "C" 12 prvaxec_DM
fmt  "X" 1 old_x_DM
fmt  "Y" 1 old_y_DM
fmt  "Z" 1 old_z_DM
fmt  "X" 2 old_x_print_DM
fmt  "Y" 2 old_y_print_DM
fmt  "Z" 2 old_z_print_DM
fmt  "C" 12 axeC_DM
fmt  "B" 12 axeA_DM
fmt  "Z" 2 old_zinitht_DM
fmt "Z" 2 dest_ret_5x_DM
fmt "Z" 2 old_dest_ret_5x_DM
fmt  "" 8 initht5x_DM
fmt  "Z" 8 zinitht_DM
fmt  "" 2 sdis_DM
fmt  "X" 2 xabs_DM         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs_DM
fmt  "Z" 2 zabs_DM
fmt "Z" 2 z_retraction_DM                          # coordonee Z du plan de rétraction 
fmt "Z" 2 z_dessus_brut_DM                         # coordonee Z du dessus du brut , debut matiere 
fmt "X" 2 x_perp_DM                                # coordonee X du point pour l'entre perpendiculaire
fmt "I" 2 i_ent_cir_DM                             # coordonee I centre du cercle en relatif point de depart
fmt "J" 2 j_ent_cir_DM                             # coordonee J centre du cercle en relatif point de depart
fmt "X" 2 xp_chs_DM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "Y" 2 yp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 2 zp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "I" 2 ip_chs_DM                                # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "J" 2 jp_chs_DM                                # ecriture d'un Y dans le cycle Helicoédo-Spiral
fmt "Z" 3 prof_1_DM
fmt "Z" 3 prof_2_DM
fmt "Z" 3 prof_3_DM
fmt "Z" 3 prof_4_DM
fmt "Z" 3 prof_5_DM
fmt "Z" 3 prof_1_rel_DM
fmt "Z" 3 prof_2_rel_DM
fmt "Z" 3 prof_3_rel_DM
fmt "Z" 3 prof_4_rel_DM
fmt "Z" 3 prof_5_rel_DM
fmt "G4 F" 15 tempo_1_DM
fmt "G4 F" 15 tempo_2_DM
fmt "G4 F" 15 tempo_3_DM
fmt "G4 F" 15 tempo_4_DM
fmt "G4 F" 15 tempo_5_DM
fmt  "Z" 8 zaproche_DM
fmt  "X,ORI_X1" 13 mr8_DM
fmt  "Y,ORI_Y1" 13 mr9_DM
fmt  "Z,ORI_Z1" 13 mr10_DM
fmt  "USURE_L(" 2 mr4_DM ")"
fmt  "op" 1 prvop_id_DM
fmt     3 spdlon_DM
fmt 2 ecrigeneral_DM
fmt "Old progno" 4 old_progno_DM
fmt  "OP" 3 operation_DM
fmt  "E" 3 e53_DM
fmt  "DEB" 4 debut_DM
fmt  "OPERATION "  5 numop_DM
fmt 6 numprg_concat_DM
fmt 6 cont_mi10_DM
fmt 2 old_mi10_DM
fmt 5 numop_garage_DM
fmt 2 erreur_DM
fmt 6 numprg_garage_DM
fmt 6 old_numprg_garage_DM
fmt     3 mi4_DM
fmt  "M" 3 oldstation_DM
fmt     3 mi5_DM
fmt  "M" 3 oldmi5_DM
fmt     3 mi8_DM
fmt  "M" 3 oldmi8_DM
fmt "DEC_X_DM " 2 DEC_X_DM
fmt "DEC_Y_DM " 2 DEC_Y_DM
fmt "DEC_Z_DM " 2 DEC_Z_DM
fmt "prog_DM" 2 prog_DM
fmt "Mi2 pour A base =" 4 mi2_A_base_DM
fmt "Mi1 pour C base =" 4 mi1_C_base_DM
fmt  "TR" 4 trplus_DM
fmt  "I" 7 invers_DM
fmt  "D" 1 deja_DM
fmt  "VX" 1 old_vx_DM
fmt  "VY" 1 old_vy_DM
fmt  "VZ" 1 old_vz_DM
fmt  "Vx" 1 Vx_DM
fmt  "Vy" 1 Vy_DM
fmt  "Vz" 1 Vz_DM
fmt  "@AVANCE@" 4 fr_DM
fmt  "@AVANCE@" 3 frplunge_DM
fmt "@AVANCE@" 5 f_ent_cir_DM                                   # avance en entree ciculaire au debut de l'helicoide
fmt "@AVANCE@" 5 f_int_hel_DM                                   # avance de l'helicoide 
fmt "@AVANCE@" 5 f_spiral_DM                                    # avance de la spiral
fmt "@AVANCE@" 5 f_int_fin_DM                                   # avance sur la finition du trou
fmt "@AVANCE@" 5 f_sor_cir_DM                                   # avance sur la sortie de la finition du trou
fmt "@AVANCE@" 5 f_base_DM                                      # avance de base du cycle
fmt "@AVANCE@" 4 avance_1_DM
fmt "@AVANCE@" 4 avance_2_DM
fmt "@AVANCE@" 4 avance_3_DM
fmt "@AVANCE@" 4 avance_4_DM
fmt "@AVANCE@" 4 avance_5_DM
fmt     2 typcycle_DM
fmt "cycle_heli_spiral=" 4 cycle_heli_spiral_DM    # flag pour savoir si on a fait une spirale
fmt  "DR" 3 drill5axes_DM
fmt "old_sub_trnstyp_DM" 4 old_sub_trnstyp_DM
fmt "old_sub_totl_no_DM" 4 old_sub_totl_no_DM
fmt 4 blocaxe_DM
fmt  "CT" 4 cont_axe_c_DM     #compte tour axe c
fmt "LONG_MAX=" 15 LONG_MAX_DM
fmt "LONG_MIN=" 15 LONG_MIN_DM
fmt  "X" 2 old_tox4_DM
fmt  "Y" 2 old_toy4_DM
fmt  "Z" 2 old_toz4_DM
fmt  "EC" 7 old_axeCpos_DM
fmt  "EA" 7 old_axeApos_DM
fmt      7 oldreel_axeCpos_DM
fmt      7 reel_axeCpos_DM
fmt      7 difaxecpos_DM
fmt      7 comptour_DM
fmt      7 naxecpos_DM
fmt "renv angle on off=" 4 tete_rev_DM
fmt  "cosangle" 11 cosangle_DM
fmt "LP12=" 1 long_p12_DM
fmt "LP23=" 1 long_p23_DM
fmt "LP13=" 1 long_p13_DM
fmt "Angle5x=" 1 ang5x_DM
fmt  "X" 1 old_x_5x_DM
fmt  "Y" 1 old_y_5x_DM
fmt  "Z" 1 old_z_5x_DM

old_sub_trnstyp_DM : -1
old_sub_totl_no_DM : -1
prog_DM : -1
cont_mi10_DM : 0
operation_DM : 0
drill5axes_DM  : 0

mini_a_DM =   -120.001
maxi_a_DM = 120.001
mini_c_sans_cloche_DM = -185.001
maxi_c_sans_cloche_DM = 185.001
mini_c_avec_cloche_DM = -270.001
maxi_c_avec_cloche_DM = 270.001
zsecu_DM = 800   # valeur altitude de securité en Z
dec_tete_DM = 50.5 # decalage entre axe z et nez de broche auxiliaire gauche et droite sur tete a renvois d'angle
dest_ret_5x_DM : 100
gfr_DM : 1
sprog_concat_DM : ""

sm93_DM    : "G93"
sm94_DM : "G94"
sgfr_DM : ""

fstrsel  sm93_DM gfr_DM sgfr_DM 2 -1

spl00_DM    : "G17"
spl01_DM    : "G19"
spl02_DM    : "G18"
spl03_DM : ""
splcode_DM : ""

fstrsel  spl00_DM plane$ splcode_DM 4 -1

sm00_DM    : "M4"
sm01_DM    : "M5"
sm02_DM    : "M3"
spdlon_DM ??
spdlsel_DM = fsg3(ss$)

fstrsel  sm00_DM spdlsel_DM spdlon_DM 3 -1

stringtxt1_DM : "BRIDER LA PIECE AVEC VIS"
stringtxt2_DM : "OTER LES VIS"
stringtxt3_DM : "BRIDER LA PIECE AVEC SERRE-JOINTS"
stringtxt4_DM : "OTER LES SERRE-JOINTS"
stringtxt5_DM : "OTER LES CHUTES"
stringtxt6_DM : "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
stringtxt7_DM : "TEXTE7"
stringtxt8_DM : "TEXTE8"
stringtxt9_DM : "TEXTE9"
stringtxt10_DM : "TEXTE10"
spalpeur_DM : "PALPEUR_3D"

fmt 4 deja_gcode_DM
pgcode_DM #modalité pgcode_DM

            if (gcode$ = 0) & (deja_gcode_DM <> 0), "G0",  deja_gcode_DM = 0
            if (gcode$ = 1) & (deja_gcode_DM <> 1), "G1",  deja_gcode_DM = 1
            if (gcode$ = 2) & (deja_gcode_DM <> 2), "G2",  deja_gcode_DM = 2
            if (gcode$ = 3) & (deja_gcode_DM <> 3), "G3",  deja_gcode_DM = 3
            if (gcode$ = 4) & (deja_gcode_DM <> 4), "G1",  deja_gcode_DM = 4

pgcode_force_DM #modalité pgcode_DM

            if (gcode$ = 0) , "G0"
            if (gcode$ = 1) , "G1"
            if (gcode$ = 2) , "G2"
            if (gcode$ = 3) , "G3"
            if (gcode$ = 4) , "G1"
#endregion
#region FLAGS POUR PROG CONCATENES
SARRET_LUB : "@ARRET_LUB@" #OK
SROTATION_BROCHE_ARRET : "@ROTATION_BROCHE_ARRET@" #PAS OK
SARRET_ASPI : "@ARRET_ASPI@" #OK
SCORRECTEUR_LONGUEUR : "@CORRECTEUR_LONGUEUR@" #PAS OK
SCHARGEMENT_OUTIL : "@CHARGEMENT_OUTIL@" #PAS OK
SCORRECTEUR_DYN_LG_OUTIL : "@CORRECTEUR_DYN_LG_OUTIL@" #PAS OK
SROTATION_BROCHE_HORAIRE : "@ROTATION_BROCHE_HORAIRE@" #PAS OK
SROTATION_BROCHE_TRIGO : "@ROTATION_BROCHE_TRIGO@" #PAS OK
SNOM_OUTIL : "@NOM_OUTIL@" #OK
SCLOCHE : "@CLOCHE@" #OK
SMARCHE_ASPI : "@MARCHE_ASPI@" #OK
SDEC_ORIGINE_TYPE_G : "@DEC_ORIGINE_TYPE_G@" #PAS OK
SVALIDATION_SECU_Z : "@VALIDATION_SECU_Z@" #PAS OK
SSHUNT_SECU_Z : "@SHUNT_SECU_Z@" #PAS OK
SAVANCE_TRAVAIL_INVERSE : "@AVANCE_TRAVAIL_INVERSE@" #PAS OK
SAVANCE_TRAVAIL_STANDARD : "@AVANCE_TRAVAIL_STANDARD@" #PAS OK
SDEBUT_LUB : "@DEBUT_LUB@" #OK
SAVANCE_TRAVAIL : "@AVANCE@" #a rajouter
SROTATION_BROCHE : "@ROTATION_BROCHE@" #a rajouter
#endregion
#endregion

#region   REPERTOIRES #OK       
#region CREATION DU REPERTOIRE
#---------------- BLOCS DE PRE TRAITEMENT POST PRO POUR CREATION DU REPERTOIRE programme et des sous repertoire machine ---------------------------------
# INITIALISATION DES STRING
spathgeneral : ""
spathgeneral_ramdisk : ""
spathgeneral_pur : ""
spathmchineA : ""
spathmchineB : ""
spathmchineC : ""
spathmchineA_ramdisk : ""
spathmchineB_ramdisk : ""
spathmchineC_ramdisk : ""
snumprog : ""
smachineA : "\STC9101\"   # nom de la machine A determinant le repertoire
smachineB : "\STC9103\"   # nom de la machine B determinant le repertoire   
smachineC : "\STC9110\"   # nom de la machine C determinant le repertoire
smachine_AG : "STC9101"
smachine_BG : "STC9103"
smachine_CG : "STC9110"
sextmachineA : "xpi"      # extention pour les programme machine A
sextmachineC : "mpf"      # extention pour les programme machine B
sextmachineB : "mpf"      # extention pour les programme machine C
smkdir : "Y:\CFAO\X8\Machines\creedir.exe"  # ou et nom de l'executable permetant la creation de repertoire
srmdir : "Y:\CFAO\X8\Machines\effacedir.exe"
sdpdir : "Y:\CFAO\X8\Machines\deplacedir.exe"
sramdisk : "U:\POST\"
sentre_cote = no2asc(34)  # permet d'afficher les " en debut et fin de string de rertoires
sunderscore = "_"
# INITIALISATION DES variables
fmt "Old progno" 4 old_progno

pgestion_rep       # Destruction-creation des repertoire ou placer les programmes


pdestruc_rep       # Destruction-creation des repertoire ou placer les programmes


#endregion
#region CHANGEMENT DE REPERTOIRE
pchange_AG   # attribution direction pour machine A
		snumligne = "AG"
		if prog_AG = 1,
                [

                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir
                spathsub$ = spathmchineA_ramdisk   # attribution du repertoire 
                snamesub$ = snamenc$        # attribution du nom du fichier a ecrire
                sextsub$ = sextmachineA     # attribution de l'extention du fichier a ecrire
                ###subout$###=1                 # on active l'ecriture dans le fichier Sub
                #newsub$                        # on ouvre le fichier
                #if old_progno <> progno$,
                if ecrigeneral_AG = 0,
                        [
                        if (erreur_AG = 0) & (erreur_AM = 0),   [
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "      dans ",spathmchineA,  e$
                                                                ###subout$### = 1
                                                                ecrigeneral_AG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
pchange_BG   # attribution direction pour machine B             
		snumligne = "BG"
		if prog_BG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir 
                spathsub$ = spathmchineB_ramdisk    # attribution du repertoire 
                snamesub$ = snamenc$
                sextsub$ = sextmachineB
                ###subout$###=1
                #newsub$
                #if old_progno <> progno$,
                if ecrigeneral_BG = 0,
                        [
                        if (erreur_BG = 0) & (erreur_BM = 0),   [
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "      dans ",spathmchineB,  e$
                                                                ###subout$### = 1
                                                                ecrigeneral_BG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
pchange_CG   # attribution direction pour machine C
		snumligne = "CG"
		if prog_CG = 1,
                [
                subout$=0
                snumprog = no2str(progno$)  # nom du programme a sortir
                spathsub$ = spathmchineC_ramdisk
                snamesub$ = snamenc$
                sextsub$ = sextmachineC
                ###subout$###=1
                #newsub$
                #if old_progno <> progno$,
                if ecrigeneral_CG = 0,
                        [
                        if (erreur_CG = 0) & (erreur_CM = 0),   [
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme complet", snamesub$, no_spc$,".",no_spc$,sextsub$, "      dans ",spathmchineC,  e$
                                                                ###subout$### = 1
                                                                ecrigeneral_CG = 1
                                                                ]
                        ]
                ]
        else, subout$ = 3
pchange_AM   # attribution direction pour machine A
		snumligne = "AM"
		if prog_AM = 1,
                [
                subout$=0
                pnumprog_AM
                spathsub$ = spathmchineA_ramdisk   # attribution du repertoire 
                snamesub$ = snumprog + sunderscore + snamenc$       # attribution du nom du fichier a ecrire
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineA     # attribution de l'extention du fichier a ecrire
                ###subout$###=1                 # on active l'ecriture dans le fichier Sub
                #newsub$                        # on ouvre le fichier 
                if old_progno_AM <> numprg_concat_AM,
                        [
                        if (erreur_AG = 0) & (erreur_AM = 0),   [
                                                                clearsub$
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "   dans ",spathmchineA,  e$
                                                                ###subout$### = 1
                                                                old_progno_AM = numprg_concat_AM
                                                                ]
                        ]
                ]
        else, subout$ = 3
pchange_BM   # attribution direction pour machine B         
		snumligne = "BM"
		if prog_BM = 1,
                [
                subout$=0
                pnumprog_BM
                spathsub$ = spathmchineB_ramdisk    # attribution du repertoire
                snamesub$ = snumprog + sunderscore + snamenc$
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineB
                ###subout$###=1
                #newsub$
                if old_progno_BM <> numprg_concat_BM,
                        [
                        if (erreur_BG = 0) & (erreur_BM = 0),   [
                                                                clearsub$
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "   dans ",spathmchineB,  e$
                                                                ###subout$### = 1
                                                                old_progno_BM = numprg_concat_BM
                                                                ]
                        ]
                ]
        else, subout$ = 3
pchange_CM   # attribution direction pour machine C
		snumligne = "CM"
		if prog_CM = 1,
                [
                subout$=0
                pnumprog_CM
                spathsub$ = spathmchineC_ramdisk
                snamesub$ = snumprog + sunderscore + snamenc$
                snumprog = snumprog + sunderscore + snamenc$
                sextsub$ = sextmachineC
                ###subout$###=1
                #newsub$
                if old_progno_CM <> numprg_concat_CM,
                        [
                        if (erreur_CG = 0) & (erreur_CM = 0),   [
                                                                clearsub$
                                                                ###subout$### = 2  # on ecrit dans le fichier aux que l'on integrera a la fin dans le fichier de synthese
                                                                #"- programme découpé", snumprog, no_spc$,".",no_spc$,sextsub$, "   dans ",spathmchineC,  e$
                                                                ###subout$### = 1
                                                                old_progno_CM = numprg_concat_CM
                                                                ]
                        ]
                ]
        else, subout$ = 3
#endregion
#region pgestion_prog
pgestion_prog

            prog_AG = 1

            prog_BG = 0

            prog_CG = 0

            prog_AM = 0

            prog_BM = 0

            prog_CM = 0

#endregion
#region pnumprog

pnumprog_AM

                numprg_concat_AM = numprg_garage_AM + cont_mi10_AM
                snumprog = no2str(numprg_concat_AM)
                snumprog = "%" + snumprog
pnumprog_BM

                numprg_concat_BM = numprg_garage_BM + cont_mi10_BM
                snumprog = no2str(numprg_concat_BM)
                snumprog = "%" + snumprog
pnumprog_CM

                numprg_concat_CM = numprg_garage_CM + cont_mi10_CM
                snumprog = no2str(numprg_concat_CM)
                snumprog = "%" + snumprog
#endregion
#region pcont_garage
pcont_garage_AM
                if op_id$ <> prvop_id_AM,
                [
                numprg_garage_AM = progno$ * 10
                if numprg_garage_AM <> old_numprg_garage_AM, cont_mi10_AM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_AM = cont_mi10_AM + 1
                if numprg_garage_AM = old_numprg_garage_AM, [
                                                        if mi10$ = 0 & old_mi10_AM = 1, psortie_garage_AM
														if mi10$ = 0 & old_mi10_AM = -1, psortie_garage_AM
                                                        ]
                if cont_mi10_AM >= 9, psortie_garage2_AM
                old_mi10_AM = mi10$
                ]
pcont_garage_BM
                if op_id$ <> prvop_id_BM,
                [
                numprg_garage_BM = progno$ * 10
                if numprg_garage_BM <> old_numprg_garage_BM, cont_mi10_BM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_BM = cont_mi10_BM + 1
                if numprg_garage_BM = old_numprg_garage_BM, [
                                                        if mi10$ = 0 & old_mi10_BM = 1, psortie_garage_BM
														if mi10$ = 0 & old_mi10_BM = -1, psortie_garage_BM
                                                        ]
                if cont_mi10_BM >= 9, psortie_garage2_BM
                old_mi10_BM = mi10$
                ]
pcont_garage_CM
                if op_id$ <> prvop_id_CM,
                [
                numprg_garage_CM = progno$ * 10
                if numprg_garage_CM <> old_numprg_garage_CM, cont_mi10_CM = 0
                if (mi10$ = 1) | (mi10$ = -1), cont_mi10_CM = cont_mi10_CM + 1
                if numprg_garage_CM = old_numprg_garage_CM, [
                                                        if mi10$ = 0 & old_mi10_CM = 1, psortie_garage_CM
														if mi10$ = 0 & old_mi10_CM = -1, psortie_garage_CM
                                                        ]
                if cont_mi10_CM >= 9, psortie_garage2_CM
                old_mi10_CM = mi10$
                ]
#endregion
#region pdecomposition_mi1

fmt "mi1_trans_AG " 17 mi1_trans_AG
fmt "mi1_mirro_AG " 17 mi1_mirro_AG
fmt "mi1_rotat_AG " 17 mi1_rotat_AG
fmt "mi1_trans_AM " 17 mi1_trans_AM
fmt "mi1_mirro_AM " 17 mi1_mirro_AM
fmt "mi1_rotat_AM " 17 mi1_rotat_AM

fmt "mi1_trans_BG " 17 mi1_trans_BG
fmt "mi1_mirro_BG " 17 mi1_mirro_BG
fmt "mi1_rotat_BG " 17 mi1_rotat_BG
fmt "mi1_trans_BM " 17 mi1_trans_BM
fmt "mi1_mirro_BM " 17 mi1_mirro_BM
fmt "mi1_rotat_BM " 17 mi1_rotat_BM

fmt "mi1_trans_CG " 17 mi1_trans_CG
fmt "mi1_mirro_CG " 17 mi1_mirro_CG
fmt "mi1_rotat_CG " 17 mi1_rotat_CG
fmt "mi1_trans_CM " 17 mi1_trans_CM
fmt "mi1_mirro_CM " 17 mi1_mirro_CM
fmt "mi1_rotat_CM " 17 mi1_rotat_CM

fmt "mi1_trans_CG " 17 mi1_trans_DG
fmt "mi1_mirro_CG " 17 mi1_mirro_DG
fmt "mi1_rotat_CG " 17 mi1_rotat_DG
fmt "mi1_trans_DM " 17 mi1_trans_DM
fmt "mi1_mirro_DM " 17 mi1_mirro_DM
fmt "mi1_rotat_DM " 17 mi1_rotat_DM

fmt "mi1_quot_1 " 17 mi1_quot_1
fmt "mi1_quot_2 " 17 mi1_quot_2
fmt "mi1_quot_3 " 17 mi1_quot_3
fmt "mi1_quot_4 " 17 mi1_quot_4
fmt "mi1_quot_5 " 17 mi1_quot_5
fmt "mi1_quot_6 " 17 mi1_quot_6
fmt "mi1_quot_7 " 17 mi1_quot_7
fmt "mi1_quot_8 " 17 mi1_quot_8
fmt "mi1_quot_9 " 17 mi1_quot_9
fmt "mi1_quot_10 " 17 mi1_quot_10
fmt "mi1_quot_11 " 17 mi1_quot_11
fmt "mi1_quot_12 " 17 mi1_quot_12

fmt "mi1_rest_quot_1 " 18 mi1_rest_quot_1
fmt "mi1_rest_quot_2 " 18 mi1_rest_quot_2
fmt "mi1_rest_quot_3 " 18 mi1_rest_quot_3
fmt "mi1_rest_quot_4 " 18 mi1_rest_quot_4
fmt "mi1_rest_quot_5 " 18 mi1_rest_quot_5
fmt "mi1_rest_quot_6 " 18 mi1_rest_quot_6
fmt "mi1_rest_quot_7 " 18 mi1_rest_quot_7
fmt "mi1_rest_quot_8 " 18 mi1_rest_quot_8
fmt "mi1_rest_quot_9 " 18 mi1_rest_quot_9
fmt "mi1_rest_quot_10 " 18 mi1_rest_quot_10
fmt "mi1_rest_quot_11 " 18 mi1_rest_quot_11
fmt "mi1_rest_quot_12 " 18 mi1_rest_quot_12

pdecomposition_mi1
                        if mi1$ < 0, psortie_mi1
                        mi1_quot_1 = mi1$ / 3
                        mi1_rest_quot_1 = frac(mi1_quot_1) * 10
                        mi1_quot_1 = int(mi1_quot_1)
						mi1_quot_2 = mi1_quot_1 / 3
                        mi1_rest_quot_2 = frac(mi1_quot_2) * 10
                        mi1_quot_2 = int(mi1_quot_2)
						mi1_quot_3 = mi1_quot_2 / 3
                        mi1_rest_quot_3 = frac(mi1_quot_3) * 10
                        mi1_quot_3 = int(mi1_quot_3)
						mi1_quot_4 = mi1_quot_3 / 3
                        mi1_rest_quot_4 = frac(mi1_quot_4) * 10
                        mi1_quot_4 = int(mi1_quot_4)
						mi1_quot_5 = mi1_quot_4 / 3
                        mi1_rest_quot_5 = frac(mi1_quot_5) * 10
                        mi1_quot_5 = int(mi1_quot_5)
						mi1_quot_6 = mi1_quot_5 / 3
                        mi1_rest_quot_6 = frac(mi1_quot_6) * 10
                        mi1_quot_6 = int(mi1_quot_6)
						mi1_quot_7 = mi1_quot_6 / 3
                        mi1_rest_quot_7 = frac(mi1_quot_7) * 10
                        mi1_quot_7 = int(mi1_quot_7)
						mi1_quot_8 = mi1_quot_7 / 3
                        mi1_rest_quot_8 = frac(mi1_quot_8) * 10
                        mi1_quot_8 = int(mi1_quot_8)
						mi1_quot_9 = mi1_quot_8 / 3
                        mi1_rest_quot_9 = frac(mi1_quot_9) * 10
                        mi1_quot_9 = int(mi1_quot_9)
						mi1_quot_10 = mi1_quot_9 / 3
                        mi1_rest_quot_10 = frac(mi1_quot_10) * 10
                        mi1_quot_10 = int(mi1_quot_10)
						mi1_quot_11 = mi1_quot_10 / 3
                        mi1_rest_quot_11 = frac(mi1_quot_11) * 10
                        mi1_quot_11 = int(mi1_quot_11)
						mi1_quot_12 = mi1_quot_11 / 3
                        mi1_rest_quot_12 = frac(mi1_quot_12) * 10
                        mi1_quot_12 = int(mi1_quot_12)
						
                        mi1_rest_quot_1 = int(mi1_rest_quot_1)
                        mi1_rest_quot_2 = int(mi1_rest_quot_2)
                        mi1_rest_quot_3 = int(mi1_rest_quot_3)
                        mi1_rest_quot_4 = int(mi1_rest_quot_4)
                        mi1_rest_quot_5 = int(mi1_rest_quot_5)
                        mi1_rest_quot_6 = int(mi1_rest_quot_6)
                        mi1_rest_quot_7 = int(mi1_rest_quot_7)
                        mi1_rest_quot_8 = int(mi1_rest_quot_8)
                        mi1_rest_quot_9 = int(mi1_rest_quot_9)
						mi1_rest_quot_10 = int(mi1_rest_quot_10)
						mi1_rest_quot_11 = int(mi1_rest_quot_11)
						mi1_rest_quot_12 = int(mi1_rest_quot_12)

                        mi1_trans_AG = mi1_rest_quot_1 / 3
                        mi1_trans_AG = int(mi1_trans_AG)
                        mi1_trans_AM = mi1_trans_AG

                        mi1_mirro_AG = mi1_rest_quot_2 / 3
                        mi1_mirro_AG = int(mi1_mirro_AG)
                        mi1_mirro_AM = mi1_mirro_AG

                        mi1_rotat_AG = mi1_rest_quot_3 / 3
                        mi1_rotat_AG = int(mi1_rotat_AG)
                        mi1_rotat_AM = mi1_rotat_AG

                        mi1_trans_BG = mi1_rest_quot_4 / 3
                        mi1_trans_BG = int(mi1_trans_BG)
                        mi1_trans_BM = mi1_trans_BG

                        mi1_mirro_BG = mi1_rest_quot_5 / 3
                        mi1_mirro_BG = int(mi1_mirro_BG)
                        mi1_mirro_BM = mi1_mirro_BG

                        mi1_rotat_BG = mi1_rest_quot_6 / 3
                        mi1_rotat_BG = int(mi1_rotat_BG)
                        mi1_rotat_BM = mi1_rotat_BG

                        mi1_trans_CG = mi1_rest_quot_7 / 3
                        mi1_trans_CG = int(mi1_trans_CG)
                        mi1_trans_CM = mi1_trans_CG

                        mi1_mirro_CG = mi1_rest_quot_8 / 3
                        mi1_mirro_CG = int(mi1_mirro_CG)
                        mi1_mirro_CM = mi1_mirro_CG

                        mi1_rotat_CG = mi1_rest_quot_9 / 3
                        mi1_rotat_CG = int(mi1_rotat_CG)
                        mi1_rotat_CM = mi1_rotat_CG

						mi1_trans_DG = mi1_rest_quot_10 / 3
                        mi1_trans_DG = int(mi1_trans_DG)
                        mi1_trans_DM = mi1_trans_DG

                        mi1_mirro_DG = mi1_rest_quot_11 / 3
                        mi1_mirro_DG = int(mi1_mirro_DG)
                        mi1_mirro_DM = mi1_mirro_DG

                        mi1_rotat_DG = mi1_rest_quot_12 / 3
                        mi1_rotat_DG = int(mi1_rotat_DG)
                        mi1_rotat_DM = mi1_rotat_DG

                        #"voir", e$
                        #*mi1_quot_1, *mi1_rest_quot_1, *mi1_trans_AG, e$
                        #*mi1_quot_2, *mi1_rest_quot_2, *mi1_mirro_AG, e$
                        #*mi1_quot_3, *mi1_rest_quot_3, *mi1_rotat_AG, e$
                        #*mi1_quot_4, *mi1_rest_quot_4, *mi1_trans_BG, e$
                        #*mi1_quot_5, *mi1_rest_quot_5, *mi1_mirro_BG, e$
                        #*mi1_quot_6, *mi1_rest_quot_6, *mi1_rotat_BG, e$
                        #*mi1_quot_7, *mi1_rest_quot_7, *mi1_trans_CG, e$
                        #*mi1_quot_8, *mi1_rest_quot_8, *mi1_mirro_CG, e$
                        #*mi1_quot_9, *mi1_rest_quot_9, *mi1_rotat_CG, e$
                        #" ", e$
                        #*mi1_trans_AM, e$
                        #*mi1_mirro_AM, e$
                        #*mi1_rotat_AM, e$
                        #*mi1_trans_BM, e$
                        #*mi1_mirro_BM, e$
                        #*mi1_rotat_BM, e$
                        #*mi1_trans_CM, e$
                        #*mi1_mirro_CM, e$
                        #*mi1_rotat_CM, e$
#endregion
#region pdecomposition_mi2

fmt "mi2_trans_AG " 17 mi2_trans_AG
fmt "mi2_mirro_AG " 17 mi2_mirro_AG
fmt "mi2_rotat_AG " 17 mi2_rotat_AG
fmt "mi2_trans_AM " 17 mi2_trans_AM
fmt "mi2_mirro_AM " 17 mi2_mirro_AM
fmt "mi2_rotat_AM " 17 mi2_rotat_AM

fmt "mi2_trans_BG " 17 mi2_trans_BG
fmt "mi2_mirro_BG " 17 mi2_mirro_BG
fmt "mi2_rotat_BG " 17 mi2_rotat_BG
fmt "mi2_trans_BM " 17 mi2_trans_BM
fmt "mi2_mirro_BM " 17 mi2_mirro_BM
fmt "mi2_rotat_BM " 17 mi2_rotat_BM

fmt "mi2_trans_CG " 17 mi2_trans_CG
fmt "mi2_mirro_CG " 17 mi2_mirro_CG
fmt "mi2_rotat_CG " 17 mi2_rotat_CG
fmt "mi2_trans_CM " 17 mi2_trans_CM
fmt "mi2_mirro_CM " 17 mi2_mirro_CM
fmt "mi2_rotat_CM " 17 mi2_rotat_CM

fmt "mi2_trans_CG " 17 mi2_trans_DG
fmt "mi2_mirro_CG " 17 mi2_mirro_DG
fmt "mi2_rotat_CG " 17 mi2_rotat_DG
fmt "mi2_trans_CM " 17 mi2_trans_DM
fmt "mi2_mirro_CM " 17 mi2_mirro_DM
fmt "mi2_rotat_CM " 17 mi2_rotat_DM

fmt "mi2_quot_1 " 17 mi2_quot_1
fmt "mi2_quot_2 " 17 mi2_quot_2
fmt "mi2_quot_3 " 17 mi2_quot_3
fmt "mi2_quot_4 " 17 mi2_quot_4
fmt "mi2_quot_5 " 17 mi2_quot_5
fmt "mi2_quot_6 " 17 mi2_quot_6
fmt "mi2_quot_7 " 17 mi2_quot_7
fmt "mi2_quot_8 " 17 mi2_quot_8
fmt "mi2_quot_9 " 17 mi2_quot_9
fmt "mi2_quot_10 " 17 mi2_quot_10
fmt "mi2_quot_11 " 17 mi2_quot_11
fmt "mi2_quot_12 " 17 mi2_quot_12

fmt "mi2_rest_quot_1 " 18 mi2_rest_quot_1
fmt "mi2_rest_quot_2 " 18 mi2_rest_quot_2
fmt "mi2_rest_quot_3 " 18 mi2_rest_quot_3
fmt "mi2_rest_quot_4 " 18 mi2_rest_quot_4
fmt "mi2_rest_quot_5 " 18 mi2_rest_quot_5
fmt "mi2_rest_quot_6 " 18 mi2_rest_quot_6
fmt "mi2_rest_quot_7 " 18 mi2_rest_quot_7
fmt "mi2_rest_quot_8 " 18 mi2_rest_quot_8
fmt "mi2_rest_quot_9 " 18 mi2_rest_quot_9
fmt "mi2_rest_quot_10 " 18 mi2_rest_quot_10
fmt "mi2_rest_quot_11 " 18 mi2_rest_quot_11
fmt "mi2_rest_quot_12 " 18 mi2_rest_quot_12
pdecomposition_mi2
                        if mi2$ < 0, psortie_mi2
                        mi2_quot_1 = mi2$ / 3
                        mi2_rest_quot_1 = frac(mi2_quot_1) * 10
                        mi2_quot_1 = int(mi2_quot_1)
                        mi2_quot_2 = mi2_quot_1 / 3
                        mi2_rest_quot_2 = frac(mi2_quot_2) * 10
                        mi2_quot_2 = int(mi2_quot_2)
                        mi2_quot_3 = mi2_quot_2 / 3
                        mi2_rest_quot_3 = frac(mi2_quot_3) * 10
                        mi2_quot_3 = int(mi2_quot_3)
                        mi2_quot_4 = mi2_quot_3 / 3
                        mi2_rest_quot_4 = frac(mi2_quot_4) * 10
                        mi2_quot_4 = int(mi2_quot_4)
                        mi2_quot_5 = mi2_quot_4 / 3
                        mi2_rest_quot_5 = frac(mi2_quot_5) * 10
                        mi2_quot_5 = int(mi2_quot_5)
                        mi2_quot_6 = mi2_quot_5 / 3
                        mi2_rest_quot_6 = frac(mi2_quot_6) * 10
                        mi2_quot_6 = int(mi2_quot_6)
                        mi2_quot_7 = mi2_quot_6 / 3
                        mi2_rest_quot_7 = frac(mi2_quot_7) * 10
                        mi2_quot_7 = int(mi2_quot_7)
                        mi2_quot_8 = mi2_quot_7 / 3
                        mi2_rest_quot_8 = frac(mi2_quot_8) * 10
                        mi2_quot_8 = int(mi2_quot_8)
                        mi2_quot_9 = mi2_quot_8 / 3
                        mi2_rest_quot_9 = frac(mi2_quot_9) * 10
                        mi2_quot_9 = int(mi2_quot_9)
						mi2_quot_10 = mi2_quot_9 / 3
                        mi2_rest_quot_10 = frac(mi2_quot_10) * 10
                        mi2_quot_10 = int(mi2_quot_10)
						mi2_quot_11 = mi2_quot_10 / 3
                        mi2_rest_quot_11 = frac(mi2_quot_11) * 10
                        mi2_quot_11 = int(mi2_quot_11)
						mi2_quot_12 = mi2_quot_11 / 3
                        mi2_rest_quot_12 = frac(mi2_quot_12) * 10
                        mi2_quot_12 = int(mi2_quot_12)
						
                        mi2_rest_quot_1 = int(mi2_rest_quot_1)
                        mi2_rest_quot_2 = int(mi2_rest_quot_2)
                        mi2_rest_quot_3 = int(mi2_rest_quot_3)
                        mi2_rest_quot_4 = int(mi2_rest_quot_4)
                        mi2_rest_quot_5 = int(mi2_rest_quot_5)
                        mi2_rest_quot_6 = int(mi2_rest_quot_6)
                        mi2_rest_quot_7 = int(mi2_rest_quot_7)
                        mi2_rest_quot_8 = int(mi2_rest_quot_8)
                        mi2_rest_quot_9 = int(mi2_rest_quot_9)
						mi2_rest_quot_10 = int(mi2_rest_quot_10)
						mi2_rest_quot_11 = int(mi2_rest_quot_11)
						mi2_rest_quot_12 = int(mi2_rest_quot_12)

                        mi2_trans_AG = mi2_rest_quot_1 / 3
                        mi2_trans_AG = int(mi2_trans_AG)
                        mi2_trans_AM = mi2_trans_AG

                        mi2_mirro_AG = mi2_rest_quot_2 / 3
                        mi2_mirro_AG = int(mi2_mirro_AG)
                        mi2_mirro_AM = mi2_mirro_AG

                        mi2_rotat_AG = mi2_rest_quot_3 / 3
                        mi2_rotat_AG = int(mi2_rotat_AG)
                        mi2_rotat_AM = mi2_rotat_AG

                        mi2_trans_BG = mi2_rest_quot_4 / 3
                        mi2_trans_BG = int(mi2_trans_BG)
                        mi2_trans_BM = mi2_trans_BG

                        mi2_mirro_BG = mi2_rest_quot_5 / 3
                        mi2_mirro_BG = int(mi2_mirro_BG)
                        mi2_mirro_BM = mi2_mirro_BG

                        mi2_rotat_BG = mi2_rest_quot_6 / 3
                        mi2_rotat_BG = int(mi2_rotat_BG)
                        mi2_rotat_BM = mi2_rotat_BG

                        mi2_trans_CG = mi2_rest_quot_7 / 3
                        mi2_trans_CG = int(mi2_trans_CG)
                        mi2_trans_CM = mi2_trans_CG

                        mi2_mirro_CG = mi2_rest_quot_8 / 3
                        mi2_mirro_CG = int(mi2_mirro_CG)
                        mi2_mirro_CM = mi2_mirro_CG

                        mi2_rotat_CG = mi2_rest_quot_9 / 3
                        mi2_rotat_CG = int(mi2_rotat_CG)
                        mi2_rotat_CM = mi2_rotat_CG
						
						mi2_trans_DG = mi2_rest_quot_10 / 3
                        mi2_trans_DG = int(mi2_trans_DG)
                        mi2_trans_DM = mi2_trans_DG

                        mi2_mirro_DG = mi2_rest_quot_11 / 3
                        mi2_mirro_DG = int(mi2_mirro_DG)
                        mi2_mirro_DM = mi2_mirro_DG

                        mi2_rotat_DG = mi2_rest_quot_12 / 3
                        mi2_rotat_DG = int(mi2_rotat_DG)
                        mi2_rotat_DM = mi2_rotat_DG
						
                        #"voir", e$
                        #*mi2_quot_1, *mi2_rest_quot_1, *mi2_trans_AG, e$
                        #*mi2_quot_2, *mi2_rest_quot_2, *mi2_mirro_AG, e$
                        #*mi2_quot_3, *mi2_rest_quot_3, *mi2_rotat_AG, e$
                        #*mi2_quot_4, *mi2_rest_quot_4, *mi2_trans_BG, e$
                        #*mi2_quot_5, *mi2_rest_quot_5, *mi2_mirro_BG, e$
                        #*mi2_quot_6, *mi2_rest_quot_6, *mi2_rotat_BG, e$
                        #*mi2_quot_7, *mi2_rest_quot_7, *mi2_trans_CG, e$
                        #*mi2_quot_8, *mi2_rest_quot_8, *mi2_mirro_CG, e$
                        #*mi2_quot_9, *mi2_rest_quot_9, *mi2_rotat_CG, e$
                        #" ", e$
                        #*mi2_trans_AM, e$
                        #*mi2_mirro_AM, e$
                        #*mi2_rotat_AM, e$
                        #*mi2_trans_BM, e$
                        #*mi2_mirro_BM, e$
                        #*mi2_rotat_BM, e$
                        #*mi2_trans_CM, e$
                        #*mi2_mirro_CM, e$
                        #*mi2_rotat_CM, e$
#endregion
#region pdecomposition_mi4
pdecomposition_mi4    # sortie des parties d'une chaine numerique
			if (mi4$ < 1000) & (mi4$ <> 0),	[	
                    						if mi4$ < 1000,  [
                                    						smi4_str=no2str(mi4$)
                                    						paquet_mi4 = 3
                                    						smi4_str_AG = brksps(paquet_mi4,smi4_str)
															paquet_mi4 = 2
                            								smi4_str_BG = brksps(paquet_mi4,smi4_str)
                                    						smi4_str_CG = smi4_str
                                    						smi4_str_DG = "0"
                                    						mi4_AG = plcval(smi4_str_AG,1)
                                    						mi4_BG = plcval(smi4_str_BG,1)
                                    						mi4_CG = plcval(smi4_str_CG,1)
															mi4_DG = plcval(smi4_str_DG,1)
                                    						mi4_AM = plcval(smi4_str_AG,1)
                                    						mi4_BM = plcval(smi4_str_BG,1)
                                    						mi4_CM = plcval(smi4_str_CG,1)
															mi4_DM = plcval(smi4_str_DG,1)
                                    						]
											if mi4$ < 100,  [
                                    						smi4_str=no2str(mi4$)
                                    						paquet_mi4 = 2
                                    						smi4_str_AG = brksps(paquet_mi4,smi4_str)
                                    						smi4_str_BG = smi4_str
                                    						smi4_str_CG = "0"
															smi4_str_DG = "0"
                                    						mi4_AG = plcval(smi4_str_AG,1)
                                    						mi4_BG = plcval(smi4_str_BG,1)
                                    						mi4_CG = plcval(smi4_str_CG,1)
															mi4_DG = plcval(smi4_str_DG,1)
                                    						mi4_AM = plcval(smi4_str_AG,1)
                                    						mi4_BM = plcval(smi4_str_BG,1)
                                    						mi4_CM = plcval(smi4_str_CG,1)
															mi4_DM = plcval(smi4_str_DG,1)
                                    						]
											if mi4$ < 10,   [
                                    						smi4_str=no2str(mi4$)
                                    						paquet_mi4 = 1
                                    						smi4_str_AG = smi4_str
                                    						smi4_str_BG = "0"
                                    						smi4_str_CG = "0"
															smi4_str_DG = "0"
                                    						mi4_AG = plcval(smi4_str_AG,1)
                                    						mi4_BG = plcval(smi4_str_BG,1)
                                    						mi4_CG = plcval(smi4_str_CG,1)
															mi4_DG = plcval(smi4_str_DG,1)
                                    						mi4_AM = plcval(smi4_str_AG,1)
                                    						mi4_BM = plcval(smi4_str_BG,1)
                                    						mi4_CM = plcval(smi4_str_CG,1)
															mi4_DM = plcval(smi4_str_DG,1)
                                    						]
									
											]		

                    else,   [
                            smi4_str=no2str(mi4$)
                            paquet_mi4 = 4
                            smi4_str_AG = brksps(paquet_mi4,smi4_str)
                            paquet_mi4 = 3
                            smi4_str_BG = brksps(paquet_mi4,smi4_str)
							paquet_mi4 = 2
							smi4_str_CG = brksps(paquet_mi4,smi4_str)
                            smi4_str_DG = smi4_str
                            mi4_AG = plcval(smi4_str_AG,1)
                            mi4_BG = plcval(smi4_str_BG,1)
                            mi4_CG = plcval(smi4_str_CG,1)
							mi4_DG = plcval(smi4_str_DG,1)
                            mi4_AM = plcval(smi4_str_AG,1)
                            mi4_BM = plcval(smi4_str_BG,1)
                            mi4_CM = plcval(smi4_str_CG,1)
							mi4_DM = plcval(smi4_str_DG,1)
                            ]
							
					if mi4$ = 0,	[
                            		mi4_AG = 0
                            		mi4_BG = 0
                            		mi4_CG = 0
									mi4_DG = 0
                            		mi4_AM = 0
                            		mi4_BM = 0
                            		mi4_CM = 0
									mi4_DM = 0
                            		]
                    #"voir smi4_str_AG ",  *smi4_str_AG, " voir smi4_str_BG ",  *smi4_str_BG, " voir smi4_str_CG ", *smi4_str_CG, e$
                    #"mi4_AG ",  *mi4_AG, " mi4_BG ",  *mi4_BG, " mi4_CG ", *mi4_CG, e$
                    if mi5_BG = 1,  [
                                    if mi4_BG = 1, mi4_BG = 11
                                    if mi4_BG = 2, mi4_BG = 12
                                    if mi4_BG = 3, mi4_BG = 13
                                    if mi4_BG = 4, mi4_BG = 14
                                    if mi4_BG = 5, mi4_BG = 21
                                    if mi4_BG = 6, mi4_BG = 22
                                    if mi4_BG = 7, mi4_BG = 23
                                    if mi4_BG = 8, mi4_BG = 24
                                    ]
                    if mi5_CG = 1,  [
                                    if mi4_CG = 1, mi4_CG = 11
                                    if mi4_CG = 2, mi4_CG = 12
                                    if mi4_CG = 3, mi4_CG = 13
                                    if mi4_CG = 4, mi4_CG = 14
                                    if mi4_CG = 5, mi4_CG = 21
                                    if mi4_CG = 6, mi4_CG = 22
                                    if mi4_CG = 7, mi4_CG = 23
                                    if mi4_CG = 8, mi4_CG = 24
                                    ]		
                    if mi5_DG = 1,  [
                                    if mi4_DG = 1, mi4_DG = 11
                                    if mi4_DG = 2, mi4_DG = 12
                                    if mi4_DG = 3, mi4_DG = 13
                                    if mi4_DG = 4, mi4_DG = 14
                                    if mi4_DG = 5, mi4_DG = 21
                                    if mi4_DG = 6, mi4_DG = 22
                                    if mi4_DG = 7, mi4_DG = 23
                                    if mi4_DG = 8, mi4_DG = 24
                                    ]									
                    if mi5_BM = 1,  [
                                    if mi4_BM = 1, mi4_BM = 11
                                    if mi4_BM = 2, mi4_BM = 12
                                    if mi4_BM = 3, mi4_BM = 13
                                    if mi4_BM = 4, mi4_BM = 14
                                    if mi4_BM = 5, mi4_BM = 21
                                    if mi4_BM = 6, mi4_BM = 22
                                    if mi4_BM = 7, mi4_BM = 23
                                    if mi4_BM = 8, mi4_BM = 24
                                    ]
                    if mi5_CM = 1,  [
                                    if mi4_CM = 1, mi4_CM = 11
                                    if mi4_CM = 2, mi4_CM = 12
                                    if mi4_CM = 3, mi4_CM = 13
                                    if mi4_CM = 4, mi4_CM = 14
                                    if mi4_CM = 5, mi4_CM = 21
                                    if mi4_CM = 6, mi4_CM = 22
                                    if mi4_CM = 7, mi4_CM = 23
                                    if mi4_CM = 8, mi4_CM = 24
                                    ]
                    if mi5_DM = 1,  [
                                    if mi4_DM = 1, mi4_DM = 11
                                    if mi4_DM = 2, mi4_DM = 12
                                    if mi4_DM = 3, mi4_DM = 13
                                    if mi4_DM = 4, mi4_DM = 14
                                    if mi4_DM = 5, mi4_DM = 21
                                    if mi4_DM = 6, mi4_DM = 22
                                    if mi4_DM = 7, mi4_DM = 23
                                    if mi4_DM = 8, mi4_DM = 24
                                    ]									
#endregion
#region pdecomposition_mi5
pdecomposition_mi5    # sortie des parties d'une chaine numerique
                    smi5_str=no2str(mi5$)
                    paquet_mi5 = 4
                    smi5_str_AG = brksps(paquet_mi5,smi5_str)
                    paquet_mi5 = 3
                    smi5_str_BG = brksps(paquet_mi5,smi5_str)
					paquet_mi5 = 2
                    smi5_str_CG = brksps(paquet_mi5,smi5_str)
                    smi5_str_DG = smi5_str
                    mi5_AG = plcval(smi5_str_AG,1)
                    mi5_BG = plcval(smi5_str_BG,1)
                    mi5_CG = plcval(smi5_str_CG,1)
					mi5_DG = plcval(smi5_str_DG,1)
                    mi5_AM = plcval(smi5_str_AG,1)
                    mi5_BM = plcval(smi5_str_BG,1)
                    mi5_CM = plcval(smi5_str_CG,1)
					mi5_DM = plcval(smi5_str_DG,1)
                    #"voir smi5_str_AG ",  *smi5_str_AG, " voir smi5_str_BG ",  *smi5_str_BG, " voir smi5_str_CG ", *smi5_str_CG, e$
                    #"mi5_AG ",  *mi5_AG, " mi5_BG ",  *mi5_BG, " mi5_CG ", *mi5_CG, e$
#endregion
#region pdecomposition_mi8
pdecomposition_mi8    # sortie des parties d'une chaine numerique
                    smi8_str=no2str(mi8$)
                    paquet_mi8 = 4
                    smi8_str_AG = brksps(paquet_mi8,smi8_str)
                    paquet_mi8 = 3
                    smi8_str_BG = brksps(paquet_mi8,smi8_str)
                    paquet_mi8 = 2
                    smi8_str_CG = brksps(paquet_mi8,smi8_str)
					smi8_str_DG = smi8_str
                    mi8_AG = plcval(smi8_str_AG,1)
                    mi8_BG = plcval(smi8_str_BG,1)
                    mi8_CG = plcval(smi8_str_CG,1)
					mi8_DG = plcval(smi8_str_DG,1)
                    mi8_AM = plcval(smi8_str_AG,1)
                    mi8_BM = plcval(smi8_str_BG,1)
                    mi8_CM = plcval(smi8_str_CG,1)
					mi8_DM = plcval(smi8_str_DG,1)
                    #"voir smi8_str_AG ",  *smi8_str_AG, " voir smi8_str_BG ",  *smi8_str_BG, " voir smi8_str_CG ", *smi8_str_CG, e$
                    #"mi8_AG ",  *mi8_AG, " mi8_BG ",  *mi8_BG, " mi8_CG ", *mi8_CG, e$
#endregion
#region pnumligne

fmt  "N" 4 n_AG
fmt  "N" 4 n_BG
fmt  "N" 4 n_CG
fmt  "N" 4 n_AM
fmt  "N" 4 n_BM
fmt  "N" 4 n_CM
n_AG : 0
n_BG : 0
n_CG : 0
n_AM : 0
n_BM : 0
n_CM : 0

pnumligne
		if snumligne = "AG",	[
								!seqmax$
								if n_AG = seqmax$, n_AG = 0
								n_AG = n_AG + 5, n2 = n_AG, *n_AG
								]
		if snumligne = "BG", n_BG = n_BG + 5, n2 = n_BG, *n_BG
		if snumligne = "CG", n_CG = n_CG + 5, n2 = n_CG, *n_CG
		if snumligne = "AM",	[
								!seqmax$
								if n_AM = seqmax$, n_AM = 0
								n_AM = n_AM + 5, n2 = n_AM, *n_AM
								]
		if snumligne = "BM", n_BM = n_BM + 5, n2 = n_BM, *n_BM
		if snumligne = "CM", n_CM = n_CM + 5, n2 = n_CM, *n_CM
#endregion
#endregion

#region   ERREURS #OK
#region   Strings erreur
serreur_visu_descripteur : " ATTENTION ARRET POST-PRO : Soit la case (sortir descripteur de fichier MCX) est décochée, soit le fichier programme ne contient pas de descripteur d'usinage !!!"
serreur_visu_transformation : " ATTENTION ARRET POST-PRO : La case (sous programmme, absolu) dans l'opération de transformation est décochée !!!"
serreur_mi1 : " ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle C ne doit pas etre inférieure à 0 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur_mi2 : " ATTENTION ARRET POST-PRO : La valeur de l'option pour l'orientation de l'angle A ou B ne doit pas etre inférieure à 0 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreurtest_outil : " ATTENTION ARRET POST-PRO : La case (Code outil du fournisseur) doit être remplie - Opération n°"
serreur_visu_general : ""
#region erreurs AG
serreur_delta_rot_C_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_num_prog_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Numéro de programme incorrect dans les valeurs optionnelles !!! Il doit être compris entre 1 et 8999 "
serreur_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_AG  : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_AG  : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_AG  : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_AG  : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_AG   : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_AG   : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_AG : "- MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_AG : " - MACHINE STC9101 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_AG : ""
#endregion
#region erreurs BG
serreur_delta_rot_C_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 3700 Tr/Min"
serreurcycle_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_BG  : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_BG  : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_BG  : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_BG  : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_BG   : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_BG   : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_BG : "- MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_BG : " - MACHINE STC9103 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_BG : ""
#endregion
#region erreurs CG
serreur_delta_rot_C_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_CG  : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_CG  : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_CG  : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_CG  : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_CG   : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_CG   : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_CG : " - MACHINE STC9110 PROGRAMME COMPLET -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_visu_CG : ""
#endregion
#region erreurs AM
serreur_delta_rot_C_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_AM  : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_AM  : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_AM  : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_AM  : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_AM   : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_AM   : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_AM : "- MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_AM : " - MACHINE STC9101 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_AM : ""
#endregion
#region erreurs BM
serreur_delta_rot_C_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 3700 Tr/Min"
serreurcycle_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_BM  : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_BM  : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_BM  : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_BM  : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_BM   : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_BM   : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_BM : "- MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_BM : " - MACHINE STC9103 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_BM : ""
#endregion
#region erreurs CM
serreur_delta_rot_C_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Delta de rotation de l'axe C supérieur à 175° entre deux points d'usinage, Operation N°"
serreur_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Cycle de perçage non supporté avec renvoi d'angle "
serreurss_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  LA VITESSE DE ROTATION AVEC UN RENVOI D'ANGLE DOIT ETRE INFERIEURE A 5000 Tr/Min"
serreurcycle_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Type de cycle de perçage non supporté sur cette machine "
serreurcloche_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de cloche avec un renvoi d'angle "
serreurlub_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Pas de mise en place de la lubrification avec un renvoi d'angle "
serreuroutil_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition des paramètres outil pour mesure non conforme dans le champ Code fournisseur-> Exemple de format : 1-002.12-011.00-021.02"
serreurnomoutil_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Définition du nom outil non conforme => Exemple de format : 12345 commentaire_outil, Operation N°"
serreurblum1_CM  : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il est impossible d'effectuer un palpage bague en 5 axes"
serreurblum2_CM  : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur n'est utilisable qu'avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum3_CM  : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Le palpeur est obligatoire avec un cycle de palpage (voir percage cycle palpage bague) "
serreurblum4_CM  : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Un cycle de palpage bague ne peut etre appliqué qu'a un seul point et pas à un groupe de points (voir percage cycle palpage bague) "
serreuraxeA_CM   : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : L'axe A sort de ses limites de +- 110°, Operation N°"
serreurimp_CM   : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Opération impropre à régénérer, Opération N°"
serreuroscil_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il y  un choix à faire entre oscillation Mastercam ou post-pro, pas les deux!, Operation N°"
serreurpolarA_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Altitude de retournement désactivée après changement d'outil, entrez une valeur, Operation N°"
serreurarretprog_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de désactiver l'altitude de retournement lors d'un arrêt programmé, Operation N°"
serreumr_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Interdiction de mettre 0 ou 1 à l'altitude de retournement, Operation N°"
serreur100_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il ne faut pas entrer de valeur négative sur les avances - Opération n°"
serreur101_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, il faut entrer 0 ou 1 sur le paramètre Absolu(0) - Relatif(1) - Opération n°"
serreur102_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans le cycle de perçage décomposé à avance contrôlée, bon... là, il faut être très con pour mettre 9999 dés la premiére profondeur ! :-) - Opération n°"
serreur200_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, il faut choisir entre arrosage centre outil M7 ou soufflage centre outil M207, on ne peut pas faire les deux - Opération n°"
serreur201_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage centre outil M7 ou soufflage centre outil M207 avec le Soufflage par impulsion, on ne peut pas faire les deux - Opération n°"
serreur203_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur, on ne peut utiliser arrosage exterieur M8 ou arrosage centre outil M7 avec aspiration (mettre 9 dans Num cloche MI4) - Opération n°"
serreur300_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle A doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur301_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : La valeur sur l'options pour l'orientation de l'angle C doit etre 0 ou 1 ou -1 ou -2 dans Valeurs optionnelles et/ou paramètres spéciaux - Opération n°"
serreur1_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Avalant=0 - Opposition=1 - Opération n°"
serreur2_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre final - Opération n°"
serreur3_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Diamètre ébauche - Opération n°"
serreur4_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur inférieure au diamètre final pour le choix : Diamètre ébauche - Opération n°"
serreur5_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamètre final - Opération n°"
serreur6_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur plus petite pour le choix : Pas maxi hélice en Z - Opération n°"
serreur7_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi hélice en Z - Opération n°"
serreur8_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur strictement positive pour le choix : Pas maxi XY spirale - Opération n°"
serreur9_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe de tours finition - Opération n°"
serreur10_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f entrée circulaire - Opération n°"
serreur11_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. hélicoïdale - Opération n°"
serreur12_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f spirale - Opération n°"
serreur13_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f interpo. finale - Opération n°"
serreur14_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive d'avance pour le choix : f sortie circulaire - Opération n°"
serreur15_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, la valeur : Dis. Entrée Perp. est incompatible avec les valeurs du diamètre de l'ébauche et de l'outil - Opération n°"
serreur16_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive car correction usure demandée pour le choix : Dist. Entrée perp. - Opération n°"
serreur17_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur 0 ou 1 pour le choix : Cor. Ray. usure=1 - Opération n°"
serreur18_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive et entiére pour le choix : Nbe tours de retour - Opération n°"
serreur19_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamétre outil pour le choix : Diamétre ébauche - Opération n°"
serreur20_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le dessus du brut et profondeur du trou : Vérifiez vos plans Z - Opération n°"
serreur21_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre la garde et le dessus du brut : Vérifiez vos plans Z - Opération n°"
serreur22_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, incohérence entre le plan de securite et la garde : Vérifiez vos plans Z - Opération n°"
serreur23_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION : Le rayon d'ébauche est supérieur au diamétre de l'outil, il restera théoriquement une carotte! OK pour continuer, Annuler pour arrét post-processeur - Opération n°"
serreur24_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur supérieure au diamètre outil pour le choix : Diamétre ébauche - Opération n°"
serreur25_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Pas en Z debut/fin - Opération n°"
serreur26_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, il faut entrer une valeur positive pour le choix : Nb tours debut/fin - Opération n°"
serreur27_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Erreur dans cycle CAQ, les valeurs rentrées pour le Pas en Z debut/fin et le Nb tours debut/fin créent une spirale trop importante - Opération n°"
serreur_garage_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Obligation d'incrémenter le numéro de programme car l'opération précédente contient un garage et celle ci n'en a pas - Opération n°"
serreur_garage2_CM : " - MACHINE STC9110 PROGRAMME PARTITIONNÉ -  Trop de garages (9 ou plus) dans le même programme, retirer un garage ou changer de numéro de programme - Opération n°"
serreur_visu_CM : ""
#endregion
#endregion
#region   pbloc sortie

psortietest_outil

            serreur_visu_general = serreurtest_outil + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_general, e$
            if subout$ <> 3, result = mprint(serreur_visu_general)
            ###subout$### = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1
            #peof$, exitpost$ # abandonner
######################################################			
psortie_axeC_5X_AG

			if erreur_AG <> 1,	[
            serreur_visu_AG = serreur_delta_rot_C_AG + no2str(numop_AG)
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3,  result = mprint(serreur_visu_AG)
            erreur_AG = 1
            #exitpost$ # abandonner  
							]																																		
	
psortie_axeC_5X_BG

			if erreur_BG <> 1,	[
            serreur_visu_BG = serreur_delta_rot_C_BG + no2str(numop_BG)
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3,  result = mprint(serreur_visu_BG)
            erreur_BG = 1
            #exitpost$ # abandonner  
							]	
							
psortie_axeC_5X_CG

			if erreur_CG <> 1,	[
            serreur_visu_CG = serreur_delta_rot_C_CG + no2str(numop_CG)
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3,  result = mprint(serreur_visu_CG)
            erreur_CG = 1
            #exitpost$ # abandonner  
							]		
	
psortie_axeC_5X_AM

			if erreur_AM <> 1,	[
            serreur_visu_AM = serreur_delta_rot_C_AM + no2str(numop_AM)
            "MW_OP_COMMENT", *serreur_visu_AM, e$
            if subout$ <> 3,  result = mprint(serreur_visu_AM)
            erreur_AM = 1
            #exitpost$ # abandonner  
							]		
	
psortie_axeC_5X_BM

			if erreur_BM <> 1,	[
            serreur_visu_BM = serreur_delta_rot_C_BM + no2str(numop_BM)
            "MW_OP_COMMENT", *serreur_visu_BM, e$
            if subout$ <> 3,  result = mprint(serreur_visu_BM)
            erreur_BM = 1
            #exitpost$ # abandonner  
							]		
	
psortie_axeC_5X_CM

			if erreur_CM <> 1,	[
            serreur_visu_CM = serreur_delta_rot_C_CM + no2str(numop_CM)
            "MW_OP_COMMENT", *serreur_visu_CM, e$
            if subout$ <> 3,  result = mprint(serreur_visu_CM)
            erreur_CM = 1
            #exitpost$ # abandonner  
							]		

###################################################### 			
psortie_ratrap_planinc_enroul_CG

			senroul_CG = senroul_aff_CG + slettreC + no2str(axeCpos1_CG) + space + slettreB + no2str(axeApos1_CG) + space + sopration + no2str(numop_CG)
			###subout$### = 4
			"MW_OP_COMMENT", *senroul_CG, e$
			if subout$ <> 3, result = mprint(senroul_CG)
			###subout$### = 3
			erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner

psortie_ratrap_planinc_deroul_CG

			sderoul_CG = sderoul_aff_CG + slettreC + no2str(axeCpos1_CG) + space + slettreB + no2str(axeApos1_CG) + space + sopration + no2str(numop_CG)
			###subout$### = 4
			"MW_OP_COMMENT", *sderoul_CG, e$
			if subout$ <> 3, result = mprint(sderoul_CG)
			###subout$### = 3
			erreur_CG = 1, erreur_CM = 1 #, exitpost$ # abandonner
###################################################### 			
psortie_num_prog_AG
            serreur_visu_AG = serreur_num_prog_AG
            ###subout$### = 4
            #"MW_OP_COMMENT",*serreur_visu_AG, e$
            #result = mprint(serreur_visu_AG)
            ###subout$### = 3
            #erreur_AG = 1
            #exitpost$ # abandonner 
######################################################          
psortie_transformation
            serreur_visu_general = serreur_visu_transformation
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_general, e$
            if subout$ <> 3, result = mprint(serreur_visu_general)
            ###subout$### = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1
            #peof$, exitpost$ # abandonner
######################################################
psortie_mi1
            serreur_visu_general = serreur_mi1 + no2str(numop_AG + 1)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_general, e$
            if subout$ <> 3, result = mprint(serreur_visu_general)
            ###subout$### = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1
            #peof$, exitpost$ # abandonner
######################################################
psortie_mi2
            serreur_visu_general = serreur_mi2 + no2str(numop_AG + 1)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_general, e$
            if subout$ <> 3, result = mprint(serreur_visu_general)
            ###subout$### = 3
            erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1
            #peof$, exitpost$ # abandonner          
######################################################
psortie_descripteur

            serreur_visu_general = serreur_visu_descripteur
            ###subout$### = 4
            #*serreur_visu_general, e$
            #result = mprint(serreur_visu_general)
            ###subout$### = 3
            #erreur_AG = 1, erreur_AM = 1, erreur_BG = 1, erreur_BM = 1, erreur_CG = 1, erreur_CM = 1
            #peof$, exitpost$ # abandonner 
######################################################
psortie_garage2_AM
            numop_garage_AM = numop_AM + 1
            serreur_visu_AM = serreur_garage2_AM + no2str(numop_garage_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$ # abandonner 

psortie_garage2_BM
            numop_garage_BM = numop_BM + 1
            serreur_visu_BM = serreur_garage2_BM + no2str(numop_garage_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner 

psortie_garage2_CM
            numop_garage_CM = numop_CM + 1
            serreur_visu_CM = serreur_garage2_CM + no2str(numop_garage_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner             
######################################################

psortie_garage_AM
            numop_garage_AM = numop_AM + 1
            serreur_visu_AM = serreur_garage_AM + no2str(numop_garage_AM)
            ###subout$### = 4
            #"MW_OP_COMMENT",*serreur_visu_AM, e$
            #if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$ # abandonner 

psortie_garage_BM
            numop_garage_BM = numop_BM + 1
            serreur_visu_BM = serreur_garage_BM + no2str(numop_garage_BM)
            ###subout$### = 4
            #"MW_OP_COMMENT",*serreur_visu_BM, e$
            #if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner 

psortie_garage_CM
            numop_garage_CM = numop_CM + 1
            serreur_visu_CM = serreur_garage_CM + no2str(numop_garage_CM)
            ###subout$### = 4
            #"MW_OP_COMMENT",*serreur_visu_CM, e$
            #if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
######################################################

psortie15_AG
            serreur_visu_AG = serreumr_AG + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$ # abandonner     
psortie15_BG
            serreur_visu_BG = serreumr_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$ # abandonner 
psortie15_CG
            serreur_visu_CG = serreumr_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$ # abandonner 
psortie15_AM
            serreur_visu_AM = serreumr_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$ # abandonner     
psortie15_BM
            serreur_visu_BM = serreumr_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
psortie15_CM
            serreur_visu_CM = serreumr_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner             
######################################################                          

psortie14_AG

            serreur_visu_AG = serreurarretprog_AG + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$ # abandonner
psortie14_BG

            serreur_visu_BG = serreurarretprog_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$ # abandonner
psortie14_CG

            serreur_visu_CG = serreurarretprog_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$ # abandonner         
psortie14_AM

            serreur_visu_AM = serreurarretprog_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$ # abandonner
psortie14_BM

            serreur_visu_BM = serreurarretprog_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner
psortie14_CM

            serreur_visu_CM = serreurarretprog_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
######################################################                  

psortie13_AG
            serreur_visu_AG = serreurpolarA_AG  + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$  
psortie13_BG   # avertissement si osciliation double 
            serreur_visu_BG = serreurpolarA_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$ # abandonner 
psortie13_CG   # avertissement si osciliation double 
            serreur_visu_CG = serreurpolarA_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$ # abandonner             
psortie13_AM
            serreur_visu_AM = serreurpolarA_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$  
psortie13_BM   # avertissement si osciliation double 
            serreur_visu_BM = serreurpolarA_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner 
psortie13_CM   # avertissement si osciliation double 
            serreur_visu_CM = serreurpolarA_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner     
######################################################                      

psortie12_AG
            serreur_visu_AG = serreuroscil_AG + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$
psortie12_BG
            serreur_visu_BG = serreuroscil_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$
psortie12_CG
            serreur_visu_CG = serreuroscil_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$      
psortie12_AM
            serreur_visu_AM = serreuroscil_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$
psortie12_BM
            serreur_visu_BM = serreuroscil_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$
psortie12_CM
            serreur_visu_CM = serreuroscil_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$  
######################################################                      

psortie11_AG
            serreur_visu_AG = serreurimp_AG + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$
psortie11_BG   # avertissement si angle A impossible
            serreur_visu_BG = serreurimp_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$ # abandonner
psortie11_CG   # avertissement si angle A impossible
            serreur_visu_CG = serreurimp_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$ # abandonner         
psortie11_AM
            serreur_visu_AM = serreurimp_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$
psortie11_BM   # avertissement si angle A impossible
            serreur_visu_BM = serreurimp_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner
psortie11_CM   # avertissement si angle A impossible
            serreur_visu_CM = serreurimp_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner 
######################################################                  

psortie10_AG
            serreur_visu_AG = serreuraxeA_AG + no2str(numop_AG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_AG, e$
            if subout$ <> 3, result = mprint(serreur_visu_AG)
            ###subout$### = 3
            erreur_AG = 1
            #exitpost$ # abandonner

psortie10_BG
            serreur_visu_BG = serreuraxeA_BG + no2str(numop_BG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            ###subout$### = 3
            erreur_BG = 1
            #exitpost$ # abandonner

psortie10_CG
            serreur_visu_CG = serreuraxeA_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1
            #exitpost$ # abandonner

psortie10_AM
            serreur_visu_AM = serreuraxeA_AM + no2str(numop_AM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_AM, e$
            if subout$ <> 3, result = mprint(serreur_visu_AM)
            ###subout$### = 3
            erreur_AM = 1
            #exitpost$ # abandonner

psortie10_BM
            serreur_visu_BM = serreuraxeA_BM + no2str(numop_BM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            ###subout$### = 3
            erreur_BM = 1
            #exitpost$ # abandonner

psortie10_CM
            serreur_visu_CM = serreuraxeA_CM + no2str(numop_CM)
            ###subout$### = 4
            "MW_OP_COMMENT",*serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            ###subout$### = 3
            erreur_CM = 1
            #exitpost$ # abandonner
######################################################                      

psortie9_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum4_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum4_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie9_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum4_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum4_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie9_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum4_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum4_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie9_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum4_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum4_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie8_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum3_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum3_BG , e$#, exitpost$ # abandonner  
            ###subout$### = 3
            erreur_BG = 1
psortie8_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum3_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum3_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie8_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum3_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum3_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie8_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage 
            if subout$ <> 3, result = mprint(serreurblum3_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum3_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie7_BG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage
            if subout$ <> 3, result = mprint(serreurblum2_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum2_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie7_CG  # avertisement et arret du post pro quand incompatibilite outil cycle palpage
            if subout$ <> 3, result = mprint(serreurblum2_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum2_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie7_BM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage
            if subout$ <> 3, result = mprint(serreurblum2_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum2_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie7_CM  # avertisement et arret du post pro quand incompatibilite outil cycle palpage
            if subout$ <> 3, result = mprint(serreurblum2_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum2_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie6_BG  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes
            if subout$ <> 3, result = mprint(serreurblum1_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum1_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie6_CG  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes
            if subout$ <> 3, result = mprint(serreurblum1_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurblum1_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie6_BM  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes
            if subout$ <> 3, result = mprint(serreurblum1_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum1_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie6_CM  # avertisement et arret du post pro quand incompatibilite cycle palpage en 5 axes
            if subout$ <> 3, result = mprint(serreurblum1_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurblum1_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie5_BG  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreuroutil_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreuroutil_BG , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner    
            ###subout$### = 3
            erreur_BG = 1
psortie5_CG  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreuroutil_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreuroutil_CG , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner    
            ###subout$### = 3
            erreur_CG = 1
psortie5_BM  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreuroutil_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreuroutil_BM , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner     
            ###subout$### = 3
            erreur_BM = 1
psortie5_CM  # avertisement et arret du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreuroutil_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreuroutil_CM , e$, "Il y a", *long_string,"caractères au lieu de 22 attendus !",e$#,  exitpost$ # abandonner 
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie4_BG  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreurlub_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurlub_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie4_CG  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreurlub_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurlub_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie4_BM  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreurlub_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurlub_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie4_CM  # avertissement et arrét du post pro quand incompatibilite cloche avec lubrification
            if subout$ <> 3, result = mprint(serreurlub_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurlub_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################                  

psortie3_BG  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcloche_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurcloche_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie3_CG  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcloche_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurcloche_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie3_BM  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcloche_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurcloche_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie3_CM  # avertisement et arret du post pro quand incompatibilite cloche avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcloche_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurcloche_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################          

psortie2_BG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcycle_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurcycle_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie2_CG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcycle_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreurcycle_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie2_BM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcycle_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurcycle_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie2_CM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreurcycle_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreurcycle_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################          

psortie_AG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_AG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreur_AG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_AG = 1
psortie_BG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_BG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreur_BG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1
psortie_CG  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_CG, 3)
            ###subout$### = 4
            "MW_OP_COMMENT", serreur_CG , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
psortie_AM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_AM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreur_AM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_AM = 1
psortie_BM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_BM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreur_BM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
psortie_CM  # avertisement et arret du post pro quand incompatibilite machine avec renvoi d'angle
            if subout$ <> 3, result = mprint(serreur_CM, 3)
            ###subout$### = 4
            "MW_OP_COMMENT",serreur_CM , e$#, exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
######################################################
#endregion
#endregion  

#region Gestion de cloche 9110

fmt "gestion cloche " 1 gestion_cloche_CG	
fmt "change cloche "  1 change_cloche_CG
fmt  "B" 12 axeA_cloche_CG
fmt  "B" 7 axeApos1_cloche_CG
fmt "flagmr2_CG" 1 flagmr2_CG
fmt "old_opcode_cloche_CG" 1 old_opcode_cloche_CG

fmt "gestion cloche " 1 gestion_cloche_CM	
fmt "change cloche "  1 change_cloche_CM
fmt  "B" 12 axeA_cloche_CM
fmt  "B" 7 axeApos1_cloche_CM
fmt "flagmr2_CM" 1 flagmr2_CM
fmt "old_opcode_cloche_CM" 1 old_opcode_cloche_CM

serreumrcloche_CG : "- MACHINE STC9110 PROGRAMME COMPLET -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"
serreumrcloche_CM : "- MACHINE STC9110 PROGRAMME PARTITIONNÉ -  ATTENTION ARRET POST-PRO : Il faut absolument activer l'altitude de retournement pour orienter l'axe B en vu d'un changement d'état de cloche, Operation N°"


pgestionduB_cloche_CG
			
			#"voir", *old_opcode_cloche_CG, e$
			if gestion_cloche_CG = 0,	[
										if (old_opcode_cloche_CG = 13) | (old_opcode_cloche_CG = 14) | (old_opcode_cloche_CG = 17) | (old_opcode_cloche_CG = 18),[
																if (change_cloche_CG = 1) & (axeA_CG > 60), axeA_cloche_CG = 60
																if (change_cloche_CG = 1) & (axeA_CG < -60), axeA_cloche_CG = -60
																]
														else,	[
																if (change_cloche_CG = 1) & (axeApos1_cloche_CG > 60), axeA_cloche_CG = 60
																if (change_cloche_CG = 1) & (axeApos1_cloche_CG < -60), axeA_cloche_CG = -60
																]
										gestion_cloche_CG = 1
										]
										#"voir", *axeA_cloche_CG, e$
pgestionduB_cloche_CM
			
			#"voir", *old_opcode_cloche_CM, e$
			if gestion_cloche_CM = 0,	[
										if (old_opcode_cloche_CM = 13) | (old_opcode_cloche_CM = 14) | (old_opcode_cloche_CM = 17) | (old_opcode_cloche_CM = 18),[
																if (change_cloche_CM = 1) & (axeA_CM > 60), axeA_cloche_CM = 60
																if (change_cloche_CM = 1) & (axeA_CM < -60), axeA_cloche_CM = -60
																]
														else,	[
																if (change_cloche_CM = 1) & (axeApos1_cloche_CM > 60), axeA_cloche_CM = 60
																if (change_cloche_CM = 1) & (axeApos1_cloche_CM < -60), axeA_cloche_CM = -60
																]
										gestion_cloche_CM = 1
										]
										#"voir", *axeA_cloche_CM, e$
										
psortie_cloche_CG

            serreur_visu_CG = serreumrcloche_CG + no2str(numop_CG)
            ###subout$### = 4
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            ###subout$### = 3
            erreur_CG = 1		

psortie_cloche_CM

            serreur_visu_CM = serreumrcloche_CM + no2str(numop_CM)
            subout$ = 4
            *serreur_visu_CM, e$
            result = mprint(serreur_visu_CM)
            subout$ = 3
            erreur_CM = 1
			
pprep_cloche_CG
			flagmr2_CG = 0
			axeApos1_cloche_CG = axeApos1_CG
			axeA_cloche_CG = 0
			if oldstation_CG <> mi4_CG, change_cloche_CG = 1
			else, change_cloche_CG = 0
			gestion_cloche_CG = 0
			if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
			else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG

pprep_cloche_CM
			flagmr2_CM = 0
			axeApos1_cloche_CM = axeApos1_CM
			axeA_cloche_CM = 0
			if oldstation_CM <> mi4_CM, change_cloche_CM = 1
			else, change_cloche_CM = 0
			gestion_cloche_CM = 0
			if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
			else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM
			
#endregion

#region   PPRINT #OK
pprint_debut  # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle 1 er point de passage pour percage            
#region PPRINT AG
pprint_AG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle

        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22,
            [   # on est dans le cas renvoie d'angle  
            ssprint_AG = ss$ * 0.5

            if ssprint_AG > 2500,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_AG, 3)
                "MW_OP_COMMENT", serreurss_AG , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_AG = 1
                ]
            tete_rev_AG = 1
            dec_axe_tete = dec_tete_AG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sorti d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
            if t$ = tete_rev_ang_11 , tprint_AG = 50
            if t$ = tete_rev_ang_12 , tprint_AG = 50
            if t$ = tete_rev_ang_21 , tprint_AG = 60
            if t$ = tete_rev_ang_22 , tprint_AG = 60

             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_AG = u$ - x$
                Vy_AG = v$ - y$
                Vz_AG = w$ - z$
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)

                xdegvec  = (Vx_AG / longvec) * dec_axe_tete
                ydegvec  = (Vy_AG / longvec) * dec_axe_tete
                zdegvec  = (Vz_AG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AG cal", axeCcalra

                xdeg_AG = xdegvec  + x$
                ydeg_AG = ydegvec  + y$
                zdeg_AG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AG = z$
                xdeg1 = xdeg_AG * cos(axeccalra) - ydeg_AG * sin(axeccalra)
                ydeg1 = xdeg_AG * sin(axeccalra) + ydeg_AG * cos(axeccalra)
                zdeg1 = zdeg_AG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AG - xdeg3)
                y4 = y3 + (ydeg_AG - ydeg3)
                z4 = z3 + (zdeg_AG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AG = x$#xdeg_AG
                yprint_AG = y$#ydeg_AG
                zprint_AG = z$#zdeg_AG

                xcal = xdeg_AG
                ycal = ydeg_AG
                zcal = zdeg_AG

                xrprint_AG = xr$#xdegvec + xr$
                yrprint_AG = yr$#ydegvec + yr$
                zrprint_AG = zr$#zdegvec + zr$
				
				if mr2$ = -1, mr2print_AG = mr2$
                else, mr2print_AG = mr2$ - toz4$
                zsecuprint = zsecu_AG - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continus avec renvoi d'angle  

            if mod5xcont = 2,
                [# on est dans le cas percage 5 axes  avec renvoi d'angle
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_AG = u$ - x$
                Vy_AG = v$ - y$
                Vz_AG = w$ - z$
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)

                xdegvec = (Vx_AG / longvec) * dec_axe_tete
                ydegvec = (Vy_AG / longvec) * dec_axe_tete
                zdegvec = (Vz_AG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AG cal", axeCcalra


                xdeg_AG = xdegvec + x$
                ydeg_AG = ydegvec + y$
                zdeg_AG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AG = z$
                xdeg1 = xdeg_AG * cos(axeccalra) - ydeg_AG * sin(axeccalra)
                ydeg1 = xdeg_AG * sin(axeccalra) + ydeg_AG * cos(axeccalra)
                zdeg1 = zdeg_AG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AG - xdeg3)
                y4 = y3 + (ydeg_AG - ydeg3)
                z4 = z3 + (zdeg_AG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AG = x$#xdeg_AG
                yprint_AG = y$#ydeg_AG
                zprint_AG = z$#zdeg_AG

                xcal = xdeg_AG
                ycal = ydeg_AG
                zcal = zdeg_AG

                xrprint_AG = drl_init_x$#xdegvec + drl_init_x$
                yrprint_AG = drl_init_y$#ydegvec + drl_init_y$
                zrprint_AG = drl_init_z$#zdegvec + drl_init_z$
                xrprintrap_AG = sav_x_pmx#xdegvec + sav_x_pmx
                yrprintrap_AG = sav_y_pmx#ydegvec + sav_y_pmx
                zrprintrap_AG = sav_z_pmx#zdegvec + sav_z_pmx

                xgarde_AG = u$#xdegvec + u$
                ygarde_AG = v$#ydegvec + v$
                zgarde_AG = w$#zdegvec + w$

				if mr2$ = -1, mr2print_AG = mr2$
                else, mr2print_AG = mr2$ - toz4$
                zsecuprint = zsecu_AG - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_AG = x$ #* -1
                        yprint_AG = y$
                        zprint_AG = z$# + dec_axe_tete

                        iprint_AG = i$ #* -1
                        jprint_AG = j$
						xc_AG = xc$ #* -1
						yc_AG = yc$
                        kprint_AG = k$ #+ dec_axe_tete

                        xrprint_AG = xr$ #* -1
                        yrprint_AG = yr$
                        zrprint_AG = zr$ #+ dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ # 


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_AG = (y$*sin(tourne) + x$*cos(tourne))# * -1
                        yprint_AG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_AG = z$ #+ dec_axe_tete

                        iprint_AG = (j$*sin(tourne) + i$*cos(tourne))# * -1
                        jprint_AG = (j$*cos(tourne) - i$*sin(tourne))
						xc_AG = (yc$*sin(tourne) + xc$*cos(tourne))# * -1
						yc_AG = (yc$*cos(tourne) - xc$*sin(tourne))
                        kprint_AG = k$ #+ dec_axe_tete

                        xrprint_AG = (yr$*sin(tourne) + xr$*cos(tourne))# * -1
                        yrprint_AG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_AG = zr$ #+ dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$# * -1
                ycal = y$
                zcal = z$ #+ dec_axe_tete
                zrcal = zr$ #+ dec_axe_tete
                ucal = u$# * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_AG = tox4$
                toy4print_AG = toy4$
                toz4print_AG = toz4$

                depthprint_AG = depth$ #+ dec_axe_tete
                refhtprint_AG = refht$ #+ dec_axe_tete
                inithtprint_AG = initht$ #+ dec_axe_tete

                if mr2$ = -1, mr2print_AG = mr2$
                else, mr2print_AG = mr2$ - toz4$
                zsecuprint = zsecu_AG - toz4$

                sx_label = "X"
                sy_label = "Y"
                sz_label = "Z"
                si_label = "I"
                sj_label = "J"
                sk_label = "K"
                sxr_label = "X"
                syr_label = "Y"
                szr_label = "Z"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_AG = ss$
          tprint_AG =  t$
          tete_rev_AG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_AG = x$
          yprint_AG = y$
          zprint_AG = z$

          xrprint_AG = xr$
          yrprint_AG = yr$
          zrprint_AG = zr$

          iprint_AG = i$
          jprint_AG = j$
		  xc_AG = xc$
		  yc_AG = yc$
          kprint_AG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_AG = y$*sin(tourne) + x$*cos(tourne)
          yprint_AG = y$*cos(tourne) - x$*sin(tourne)
          zprint_AG = z$

          xrprint_AG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_AG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_AG = zr$

          iprint_AG = j$*sin(tourne) + i$*cos(tourne)
          jprint_AG = j$*cos(tourne) - i$*sin(tourne)
		  xc_AG = yc$*sin(tourne) + xc$*cos(tourne)
		  yc_AG = yc$*cos(tourne) - xc$*sin(tourne)
          kprint_AG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          tox4print_AG = tox4$
          toy4print_AG = toy4$
          toz4print_AG = toz4$

          if mr2$ = -1, mr2print_AG = mr2$
          else, mr2print_AG = mr2$ - toz4$
          zsecuprint = zsecu_AG - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"


          result = nwadrs(sx_label, xprint_AG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AG)  # affectation du nom de l'axe Z en rapid

        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$

#endregion
#region PPRINT BG
pprint_BG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_BG = ss$ * 1

            if ssprint_BG > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_BG, 3)
                "MW_OP_COMMENT", serreurss_BG , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_BG = 1
                ]
            tete_rev_BG = 1
            dec_axe_tete = dec_tete_BG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_BG = u$ - x$
                Vy_BG = v$ - y$
                Vz_BG = w$ - z$
                @Vx_BG,@Vy_BG,@Vz_BG
                longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)

                xdegvec  = (Vx_BG / longvec) * dec_axe_tete
                ydegvec  = (Vy_BG / longvec) * dec_axe_tete
                zdegvec  = (Vz_BG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BG cal", axeCcalra

                xdeg_BG = xdegvec  + x$
                ydeg_BG = ydegvec  + y$
                zdeg_BG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BG = z$
                xdeg1 = xdeg_BG * cos(axeccalra) - ydeg_BG * sin(axeccalra)
                ydeg1 = xdeg_BG * sin(axeccalra) + ydeg_BG * cos(axeccalra)
                zdeg1 = zdeg_BG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BG - xdeg3)
                y4 = y3 + (ydeg_BG - ydeg3)
                z4 = z3 + (zdeg_BG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BG = xdeg_BG
                yprint_BG = ydeg_BG
                zprint_BG = zdeg_BG

                xcal = xdeg_BG
                ycal = ydeg_BG
                zcal = zdeg_BG

                xrprint_BG = xdegvec + xr$
                yrprint_BG = ydegvec + yr$
                zrprint_BG = zdegvec + zr$

                if mr2$ = -1, mr2print_BG = mr2$
                else, mr2print_BG = mr2$ - toz4$
                zsecuprint = zsecu_BG - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_BG = u$ - x$
                Vy_BG = v$ - y$
                Vz_BG = w$ - z$
                @Vx_BG,@Vy_BG,@Vz_BG
                longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)

                xdegvec = (Vx_BG / longvec) * dec_axe_tete
                ydegvec = (Vy_BG / longvec) * dec_axe_tete
                zdegvec = (Vz_BG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BG cal", axeCcalra


                xdeg_BG = xdegvec + x$
                ydeg_BG = ydegvec + y$
                zdeg_BG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BG = z$
                xdeg1 = xdeg_BG * cos(axeccalra) - ydeg_BG * sin(axeccalra)
                ydeg1 = xdeg_BG * sin(axeccalra) + ydeg_BG * cos(axeccalra)
                zdeg1 = zdeg_BG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BG - xdeg3)
                y4 = y3 + (ydeg_BG - ydeg3)
                z4 = z3 + (zdeg_BG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BG = xdeg_BG
                yprint_BG = ydeg_BG
                zprint_BG = zdeg_BG

                xcal = xdeg_BG
                ycal = ydeg_BG
                zcal = zdeg_BG

                xrprint_BG = xdegvec + drl_init_x$
                yrprint_BG = ydegvec + drl_init_y$
                zrprint_BG = zdegvec + drl_init_z$
                xrprintrap_BG = xdegvec + sav_x_pmx
                yrprintrap_BG = ydegvec + sav_y_pmx
                zrprintrap_BG = zdegvec + sav_z_pmx

                xgarde_BG = xdegvec + u$
                ygarde_BG = ydegvec + v$
                zgarde_BG = zdegvec + w$


                if mr2$ = -1, mr2print_BG = mr2$
                else, mr2print_BG = mr2$ - toz4$
                zsecuprint = zsecu_BG - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_BG = x$ * -1
                        yprint_BG = y$
                        zprint_BG = z$ + dec_axe_tete

                        iprint_BG = i$ * -1
                        jprint_BG = j$
                        kprint_BG = k$ + dec_axe_tete

                        xrprint_BG = xr$ * -1
                        yrprint_BG = yr$
                        zrprint_BG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_BG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_BG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_BG = z$ + dec_axe_tete

                        iprint_BG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_BG = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_BG = k$ + dec_axe_tete

                        xrprint_BG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_BG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_BG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_BG = tox4$
                toy4print_BG = toy4$
                toz4print_BG = toz4$

                depthprint_BG = depth$ + dec_axe_tete
                refhtprint_BG = refht$ + dec_axe_tete
                inithtprint_BG = initht$ + dec_axe_tete

                if mr2$ = -1, mr2print_BG = mr2$
                else, mr2print_BG = mr2$ - toz4$
                zsecuprint = zsecu_BG - toz4$

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_BG)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_BG)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_BG)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_BG)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_BG)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_BG)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_BG)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_BG)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_BG)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_BG)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_BG = ss$
          tprint_BG =  t$
          tete_rev_BG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_BG = x$
          yprint_BG = y$
          zprint_BG = z$

          xrprint_BG = xr$
          yrprint_BG = yr$
          zrprint_BG = zr$

          iprint_BG = i$
          jprint_BG = j$
          kprint_BG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_BG = y$*sin(tourne) + x$*cos(tourne)
          yprint_BG = y$*cos(tourne) - x$*sin(tourne)
          zprint_BG = z$

          xrprint_BG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_BG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_BG = zr$

          iprint_BG = j$*sin(tourne) + i$*cos(tourne)
          jprint_BG = j$*cos(tourne) - i$*sin(tourne)
          kprint_BG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_BG = tox4$
          toy4print_BG = toy4$
          toz4print_BG = toz4$


          if mr2$ = -1, mr2print_BG = mr2$
          else, mr2print_BG = mr2$ - toz4$
          zsecuprint = zsecu_BG - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_BG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BG)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT CG
pprint_CG   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_CG = ss$ * 1

            if ssprint_CG > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_CG, 3)
                "MW_OP_COMMENT", serreurss_CG , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_CG = 1
                ]
            tete_rev_CG = 1
            dec_axe_tete = dec_tete_CG + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_CG = u$ - x$
                Vy_CG = v$ - y$
                Vz_CG = w$ - z$
                @Vx_CG,@Vy_CG,@Vz_CG
                longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)

                xdegvec  = (Vx_CG / longvec) * dec_axe_tete
                ydegvec  = (Vy_CG / longvec) * dec_axe_tete
                zdegvec  = (Vz_CG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CG cal", axeCcalra

                xdeg_CG = xdegvec  + x$
                ydeg_CG = ydegvec  + y$
                zdeg_CG = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CG = z$
                xdeg1 = xdeg_CG * cos(axeccalra) - ydeg_CG * sin(axeccalra)
                ydeg1 = xdeg_CG * sin(axeccalra) + ydeg_CG * cos(axeccalra)
                zdeg1 = zdeg_CG

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CG = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CG

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CG - xdeg3)
                y4 = y3 + (ydeg_CG - ydeg3)
                z4 = z3 + (zdeg_CG - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CG = xdeg_CG
                yprint_CG = ydeg_CG
                zprint_CG = zdeg_CG

                xcal = xdeg_CG
                ycal = ydeg_CG
                zcal = zdeg_CG

                xrprint_CG = xdegvec + xr$
                yrprint_CG = ydegvec + yr$
                zrprint_CG = zdegvec + zr$

                if mr2$ = -1, mr2print_CG = mr2$
                else, mr2print_CG = mr2$ - toz4$
                zsecuprint = zsecu_CG - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_CG = u$ - x$
                Vy_CG = v$ - y$
                Vz_CG = w$ - z$
                @Vx_CG,@Vy_CG,@Vz_CG
                longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)

                xdegvec = (Vx_CG / longvec) * dec_axe_tete
                ydegvec = (Vy_CG / longvec) * dec_axe_tete
                zdegvec = (Vz_CG / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CG cal", axeCcalra


                xdeg_CG = xdegvec + x$
                ydeg_CG = ydegvec + y$
                zdeg_CG = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CG = z$
                xdeg1 = xdeg_CG * cos(axeccalra) - ydeg_CG * sin(axeccalra)
                ydeg1 = xdeg_CG * sin(axeccalra) + ydeg_CG * cos(axeccalra)
                zdeg1 = zdeg_CG

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CG * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CG * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CG = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CG,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CG
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CG - xdeg3)
                y4 = y3 + (ydeg_CG - ydeg3)
                z4 = z3 + (zdeg_CG - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CG = xdeg_CG
                yprint_CG = ydeg_CG
                zprint_CG = zdeg_CG

                xcal = xdeg_CG
                ycal = ydeg_CG
                zcal = zdeg_CG

                xrprint_CG = xdegvec + drl_init_x$
                yrprint_CG = ydegvec + drl_init_y$
                zrprint_CG = zdegvec + drl_init_z$
                xrprintrap_CG = xdegvec + sav_x_pmx
                yrprintrap_CG = ydegvec + sav_y_pmx
                zrprintrap_CG = zdegvec + sav_z_pmx

                xgarde_CG = xdegvec + u$
                ygarde_CG = ydegvec + v$
                zgarde_CG = zdegvec + w$


                if mr2$ = -1, mr2print_CG = mr2$
                else, mr2print_CG = mr2$ - toz4$
                zsecuprint = zsecu_CG - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_CG = x$ * -1
                        yprint_CG = y$
                        zprint_CG = z$ + dec_axe_tete

                        iprint_CG = i$ * -1
                        jprint_CG = j$
                        kprint_CG = k$ + dec_axe_tete

                        xrprint_CG = xr$ * -1
                        yrprint_CG = yr$
                        zrprint_CG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_CG = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_CG = y$*cos(tourne) - x$*sin(tourne)
                        zprint_CG = z$ + dec_axe_tete

                        iprint_CG = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_CG = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_CG = k$ + dec_axe_tete

                        xrprint_CG = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_CG = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_CG = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_CG = tox4$
                toy4print_CG = toy4$
                toz4print_CG = toz4$

                depthprint_CG = depth$ + dec_axe_tete
                refhtprint_CG = refht$ + dec_axe_tete
                inithtprint_CG = initht$ + dec_axe_tete

                if mr2$ = -1, mr2print_CG = mr2$
                else, mr2print_CG = mr2$ - toz4$
                zsecuprint = zsecu_CG - toz4$

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_CG)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_CG)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_CG)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_CG)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_CG)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_CG)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_CG)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_CG)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_CG)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_CG)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_CG = ss$
          tprint_CG =  t$
          tete_rev_CG = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_CG = x$
          yprint_CG = y$
          zprint_CG = z$

          xrprint_CG = xr$
          yrprint_CG = yr$
          zrprint_CG = zr$

          iprint_CG = i$
          jprint_CG = j$
          kprint_CG = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_CG = y$*sin(tourne) + x$*cos(tourne)
          yprint_CG = y$*cos(tourne) - x$*sin(tourne)
          zprint_CG = z$

          xrprint_CG = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_CG = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_CG = zr$

          iprint_CG = j$*sin(tourne) + i$*cos(tourne)
          jprint_CG = j$*cos(tourne) - i$*sin(tourne)
          kprint_CG = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_CG = tox4$
          toy4print_CG = toy4$
          toz4print_CG = toz4$


          if mr2$ = -1, mr2print_CG = mr2$
          else, mr2print_CG = mr2$ - toz4$
          zsecuprint = zsecu_CG - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_CG)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CG)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CG)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CG)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CG)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CG)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CG)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CG)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CG)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CG)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT AM
pprint_AM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle

        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22,
            [   # on est dans le cas renvoie d'angle  
            ssprint_AM = ss$ * 0.5

            if ssprint_AM > 2500,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_AM, 3)
                "MW_OP_COMMENT", serreurss_AM , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_AM = 1
                ]
            tete_rev_AM = 1
            dec_axe_tete = dec_tete_AM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sorti d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
            if t$ = tete_rev_ang_11 , tprint_AM = 50
            if t$ = tete_rev_ang_12 , tprint_AM = 50
            if t$ = tete_rev_ang_21 , tprint_AM = 60
            if t$ = tete_rev_ang_22 , tprint_AM = 60

             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_AM = u$ - x$
                Vy_AM = v$ - y$
                Vz_AM = w$ - z$
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)

                xdegvec  = (Vx_AM / longvec) * dec_axe_tete
                ydegvec  = (Vy_AM / longvec) * dec_axe_tete
                zdegvec  = (Vz_AM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AM cal", axeCcalra

                xdeg_AM = xdegvec  + x$
                ydeg_AM = ydegvec  + y$
                zdeg_AM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AM = z$
                xdeg1 = xdeg_AM * cos(axeccalra) - ydeg_AM * sin(axeccalra)
                ydeg1 = xdeg_AM * sin(axeccalra) + ydeg_AM * cos(axeccalra)
                zdeg1 = zdeg_AM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AM - xdeg3)
                y4 = y3 + (ydeg_AM - ydeg3)
                z4 = z3 + (zdeg_AM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AM = xdeg_AM
                yprint_AM = ydeg_AM
                zprint_AM = zdeg_AM

                xcal = xdeg_AM
                ycal = ydeg_AM
                zcal = zdeg_AM

                xrprint_AM = xdegvec + xr$
                yrprint_AM = ydegvec + yr$
                zrprint_AM = zdegvec + zr$

                if mr2$ = -1, mr2print_AM = mr2$
                else, mr2print_AM = mr2$ - toz4$
                zsecuprint = zsecu_AM - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continus avec renvoi d'angle  

            if mod5xcont = 2,
                [# on est dans le cas percage 5 axes  avec renvoi d'angle
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_AM = u$ - x$
                Vy_AM = v$ - y$
                Vz_AM = w$ - z$
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)

                xdegvec = (Vx_AM / longvec) * dec_axe_tete
                ydegvec = (Vy_AM / longvec) * dec_axe_tete
                zdegvec = (Vz_AM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_AM cal", axeCcalra


                xdeg_AM = xdegvec + x$
                ydeg_AM = ydegvec + y$
                zdeg_AM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_AM = z$
                xdeg1 = xdeg_AM * cos(axeccalra) - ydeg_AM * sin(axeccalra)
                ydeg1 = xdeg_AM * sin(axeccalra) + ydeg_AM * cos(axeccalra)
                zdeg1 = zdeg_AM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_AM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_AM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_AM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_AM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_AM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_AM - xdeg3)
                y4 = y3 + (ydeg_AM - ydeg3)
                z4 = z3 + (zdeg_AM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_AM = xdeg_AM
                yprint_AM = ydeg_AM
                zprint_AM = zdeg_AM

                xcal = xdeg_AM
                ycal = ydeg_AM
                zcal = zdeg_AM

                xrprint_AM = xdegvec + drl_init_x$
                yrprint_AM = ydegvec + drl_init_y$
                zrprint_AM = zdegvec + drl_init_z$
                xrprintrap_AM = xdegvec + sav_x_pmx
                yrprintrap_AM = ydegvec + sav_y_pmx
                zrprintrap_AM = zdegvec + sav_z_pmx

                xgarde_AM = xdegvec + u$
                ygarde_AM = ydegvec + v$
                zgarde_AM = zdegvec + w$


                if mr2$ = -1, mr2print_AM = mr2$
                else, mr2print_AM = mr2$ - toz4$
                zsecuprint = zsecu_AM - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_AM = x$ * -1
                        yprint_AM = y$
                        zprint_AM = z$ + dec_axe_tete

                        iprint_AM = i$ * -1
                        jprint_AM = j$
						xc_AM = xc$ * -1
						yc_AM = yc$
                        kprint_AM = k$ + dec_axe_tete

                        xrprint_AM = xr$ * -1
                        yrprint_AM = yr$
                        zrprint_AM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_AM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_AM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_AM = z$ + dec_axe_tete

                        iprint_AM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_AM = (j$*cos(tourne) - i$*sin(tourne))
						xc_AM = (yc$*sin(tourne) + xc$*cos(tourne)) * -1
						yc_AM = (yc$*cos(tourne) - xc$*sin(tourne))
                        kprint_AM = k$ + dec_axe_tete

                        xrprint_AM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_AM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_AM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_AM = tox4$
                toy4print_AM = toy4$
                toz4print_AM = toz4$

                depthprint_AM = depth$ + dec_axe_tete
                refhtprint_AM = refht$ + dec_axe_tete
                inithtprint_AM = initht$ + dec_axe_tete

                if mr2$ = -1, mr2print_AM = mr2$
                else, mr2print_AM = mr2$ - toz4$
                zsecuprint = zsecu_AM - toz4$

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_AM = ss$
          tprint_AM =  t$
          tete_rev_AM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_AM = x$
          yprint_AM = y$
          zprint_AM = z$

          xrprint_AM = xr$
          yrprint_AM = yr$
          zrprint_AM = zr$

          iprint_AM = i$
          jprint_AM = j$
		  xc_AM = xc$
		  yc_AM = yc$
          kprint_AM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_AM = y$*sin(tourne) + x$*cos(tourne)
          yprint_AM = y$*cos(tourne) - x$*sin(tourne)
          zprint_AM = z$

          xrprint_AM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_AM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_AM = zr$

          iprint_AM = j$*sin(tourne) + i$*cos(tourne)
          jprint_AM = j$*cos(tourne) - i$*sin(tourne)
		  xc_AM = yc$*sin(tourne) + xc$*cos(tourne)
          yc_AM = yc$*cos(tourne) - xc$*sin(tourne)
          kprint_AM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          tox4print_AM = tox4$
          toy4print_AM = toy4$
          toz4print_AM = toz4$

          if mr2$ = -1, mr2print_AM = mr2$
          else, mr2print_AM = mr2$ - toz4$
          zsecuprint = zsecu_AM - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_AM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_AM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_AM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_AM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_AM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_AM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_AM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_AM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_AM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_AM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$

#endregion
#region PPRINT BM
pprint_BM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_BM = ss$ * 1

            if ssprint_BM > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_BM, 3)
                "MW_OP_COMMENT", serreurss_BM , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_BM = 1
                ]
            tete_rev_BM = 1
            dec_axe_tete = dec_tete_BM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_BM = u$ - x$
                Vy_BM = v$ - y$
                Vz_BM = w$ - z$
                @Vx_BM,@Vy_BM,@Vz_BM
                longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)

                xdegvec  = (Vx_BM / longvec) * dec_axe_tete
                ydegvec  = (Vy_BM / longvec) * dec_axe_tete
                zdegvec  = (Vz_BM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BM cal", axeCcalra

                xdeg_BM = xdegvec  + x$
                ydeg_BM = ydegvec  + y$
                zdeg_BM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BM = z$
                xdeg1 = xdeg_BM * cos(axeccalra) - ydeg_BM * sin(axeccalra)
                ydeg1 = xdeg_BM * sin(axeccalra) + ydeg_BM * cos(axeccalra)
                zdeg1 = zdeg_BM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BM - xdeg3)
                y4 = y3 + (ydeg_BM - ydeg3)
                z4 = z3 + (zdeg_BM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BM = xdeg_BM
                yprint_BM = ydeg_BM
                zprint_BM = zdeg_BM

                xcal = xdeg_BM
                ycal = ydeg_BM
                zcal = zdeg_BM

                xrprint_BM = xdegvec + xr$
                yrprint_BM = ydegvec + yr$
                zrprint_BM = zdegvec + zr$

                if mr2$ = -1, mr2print_BM = mr2$
                else, mr2print_BM = mr2$ - toz4$
                zsecuprint = zsecu_BM - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_BM = u$ - x$
                Vy_BM = v$ - y$
                Vz_BM = w$ - z$
                @Vx_BM,@Vy_BM,@Vz_BM
                longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)

                xdegvec = (Vx_BM / longvec) * dec_axe_tete
                ydegvec = (Vy_BM / longvec) * dec_axe_tete
                zdegvec = (Vz_BM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_BM cal", axeCcalra


                xdeg_BM = xdegvec + x$
                ydeg_BM = ydegvec + y$
                zdeg_BM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_BM = z$
                xdeg1 = xdeg_BM * cos(axeccalra) - ydeg_BM * sin(axeccalra)
                ydeg1 = xdeg_BM * sin(axeccalra) + ydeg_BM * cos(axeccalra)
                zdeg1 = zdeg_BM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_BM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_BM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_BM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_BM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_BM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_BM - xdeg3)
                y4 = y3 + (ydeg_BM - ydeg3)
                z4 = z3 + (zdeg_BM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_BM = xdeg_BM
                yprint_BM = ydeg_BM
                zprint_BM = zdeg_BM

                xcal = xdeg_BM
                ycal = ydeg_BM
                zcal = zdeg_BM

                xrprint_BM = xdegvec + drl_init_x$
                yrprint_BM = ydegvec + drl_init_y$
                zrprint_BM = zdegvec + drl_init_z$
                xrprintrap_BM = xdegvec + sav_x_pmx
                yrprintrap_BM = ydegvec + sav_y_pmx
                zrprintrap_BM = zdegvec + sav_z_pmx

                xgarde_BM = xdegvec + u$
                ygarde_BM = ydegvec + v$
                zgarde_BM = zdegvec + w$


                if mr2$ = -1, mr2print_BM = mr2$
                else, mr2print_BM = mr2$ - toz4$
                zsecuprint = zsecu_BM - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_BM = x$ * -1
                        yprint_BM = y$
                        zprint_BM = z$ + dec_axe_tete

                        iprint_BM = i$ * -1
                        jprint_BM = j$
                        kprint_BM = k$ + dec_axe_tete

                        xrprint_BM = xr$ * -1
                        yrprint_BM = yr$
                        zrprint_BM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_BM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_BM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_BM = z$ + dec_axe_tete

                        iprint_BM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_BM = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_BM = k$ + dec_axe_tete

                        xrprint_BM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_BM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_BM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_BM = tox4$
                toy4print_BM = toy4$
                toz4print_BM = toz4$

                depthprint_BM = depth$ + dec_axe_tete
                refhtprint_BM = refht$ + dec_axe_tete
                inithtprint_BM = initht$ + dec_axe_tete

                if mr2$ = -1, mr2print_BM = mr2$
                else, mr2print_BM = mr2$ - toz4$
                zsecuprint = zsecu_BM - toz4$

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_BM)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_BM)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_BM)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_BM)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_BM)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_BM)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_BM)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_BM)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_BM)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_BM)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_BM = ss$
          tprint_BM =  t$
          tete_rev_BM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_BM = x$
          yprint_BM = y$
          zprint_BM = z$

          xrprint_BM = xr$
          yrprint_BM = yr$
          zrprint_BM = zr$

          iprint_BM = i$
          jprint_BM = j$
          kprint_BM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_BM = y$*sin(tourne) + x$*cos(tourne)
          yprint_BM = y$*cos(tourne) - x$*sin(tourne)
          zprint_BM = z$

          xrprint_BM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_BM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_BM = zr$

          iprint_BM = j$*sin(tourne) + i$*cos(tourne)
          jprint_BM = j$*cos(tourne) - i$*sin(tourne)
          kprint_BM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_BM = tox4$
          toy4print_BM = toy4$
          toz4print_BM = toz4$


          if mr2$ = -1, mr2print_BM = mr2$
          else, mr2print_BM = mr2$ - toz4$
          zsecuprint = zsecu_BM - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_BM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_BM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_BM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_BM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_BM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_BM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_BM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_BM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_BM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_BM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#region PPRINT CM
pprint_CM   # equivalence d'ecriture des variables de sortie pour passage en tete renvoie d'angle


        if tete_rev_ang_gauche = 1 | tete_rev_ang_droite = 1,
            [   # on est dans le cas renvoie d'angle  
            ssprint_CM = ss$ * 1

            if ssprint_CM > 3700,  # control si on depasse la vitesse de broche en renvoi d'angle 
                [
                ###subout$### = 4
                if subout$ <> 3, result = mprint(serreurss_CM, 3)
                "MW_OP_COMMENT", serreurss_CM , e$#, exitpost$ # abandonner
                ###subout$### = 3
                erreur_CM = 1
                ]
            tete_rev_CM = 1
            dec_axe_tete = dec_tete_CM + paramT3    # calcul de la valeur de deport axe broche A et bout outil sur renvoie angle paramt3 = sortie d'outil
            #"voir dec_axe_tete", *dec_axe_tete, e$
             if mod5xcont = 1,
                [# on est dans le cas 5 axes continue avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes continue avec renvoi d'angle", e$
                Vx_CM = u$ - x$
                Vy_CM = v$ - y$
                Vz_CM = w$ - z$
                @Vx_CM,@Vy_CM,@Vz_CM
                longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)

                xdegvec  = (Vx_CM / longvec) * dec_axe_tete
                ydegvec  = (Vy_CM / longvec) * dec_axe_tete
                zdegvec  = (Vz_CM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CM cal", axeCcalra

                xdeg_CM = xdegvec  + x$
                ydeg_CM = ydegvec  + y$
                zdeg_CM = zdegvec  + z$



                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CM = z$
                xdeg1 = xdeg_CM * cos(axeccalra) - ydeg_CM * sin(axeccalra)
                ydeg1 = xdeg_CM * sin(axeccalra) + ydeg_CM * cos(axeccalra)
                zdeg1 = zdeg_CM

                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CM = xdeg1 * sin(90) + zdeg1 * cos(90)

                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CM

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CM - xdeg3)
                y4 = y3 + (ydeg_CM - ydeg3)
                z4 = z3 + (zdeg_CM - zdeg3)
                #"voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CM = xdeg_CM
                yprint_CM = ydeg_CM
                zprint_CM = zdeg_CM

                xcal = xdeg_CM
                ycal = ydeg_CM
                zcal = zdeg_CM

                xrprint_CM = xdegvec + xr$
                yrprint_CM = ydegvec + yr$
                zrprint_CM = zdegvec + zr$

                if mr2$ = -1, mr2print_CM = mr2$
                else, mr2print_CM = mr2$ - toz4$
                zsecuprint = zsecu_CM - toz4$

                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas 5 axes continue avec renvoi d'angle  

            if mod5xcont = 2,  # on est dans le cas percage 5 axes  avec renvoi d'angle
                [
                #sm, paf, "on est dans le cas percage 5 axes  avec renvoi d'angle", e$
                #"voir les XYZ UVW XR YR ZR", *x$,*y$,*z$,*u$,*v$,*w$, *xr$, yr$, zr$, e$
                Vx_CM = u$ - x$
                Vy_CM = v$ - y$
                Vz_CM = w$ - z$
                @Vx_CM,@Vy_CM,@Vz_CM
                longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)

                xdegvec = (Vx_CM / longvec) * dec_axe_tete
                ydegvec = (Vy_CM / longvec) * dec_axe_tete
                zdegvec = (Vz_CM / longvec) * dec_axe_tete

                axeccalra = atan2(ydegvec,-xdegvec)
                #"voir axeC_CM cal", axeCcalra


                xdeg_CM = xdegvec + x$
                ydeg_CM = ydegvec + y$
                zdeg_CM = zdegvec + z$

                xdegrap = xdegvec + sav_x_pmx
                ydegrap = ydegvec + sav_y_pmx
                zdegrap = zdegvec + sav_z_pmx


                x1 = x$ * cos(axeccalra) - y$ * sin(axeccalra)
                y1 = x$ * sin(axeccalra) + y$ * cos(axeccalra)
                z1_CM = z$
                xdeg1 = xdeg_CM * cos(axeccalra) - ydeg_CM * sin(axeccalra)
                ydeg1 = xdeg_CM * sin(axeccalra) + ydeg_CM * cos(axeccalra)
                zdeg1 = zdeg_CM

                xdegrap1 = xdegrap * cos(axeccalra) - ydegrap * sin(axeccalra)
                ydegrap1 = xdegrap * sin(axeccalra) + ydegrap * cos(axeccalra)
                zdegrap1 = zdegrap



                #"voir new x et y version 1", *y1, *x1 , xdeg1, ydeg1, e$    

                x2 = x1 * cos(90) - z1_CM * sin(90)
                y2 = y1
                z2 = x1 * sin(90) + z1_CM * cos(90)
                xdeg2 = xdeg1 * cos(90) - zdeg1 * sin(90)
                ydeg2 = ydeg1
                zdeg2_CM = xdeg1 * sin(90) + zdeg1 * cos(90)
                xdegrap2 = xdegrap1 * cos(90) - zdegrap1 * sin(90)
                ydegrap2 = ydegrap1
                zdegrap2 = xdegrap1 * sin(90) + zdegrap1 * cos(90)



                #"voir new x et y version 2", *x2,*y2, *z2, " et", *xdeg2, *ydeg2, *zdeg2_CM,  e$            

                x3 = x2 * cos(-axeccalra) - y2 * sin(-axeccalra)
                y3 = x2 * sin(-axeccalra) + y2 * cos(-axeccalra)
                z3 = z2
                xdeg3 = xdeg2 * cos(-axeccalra) - ydeg2 * sin(-axeccalra)
                ydeg3 = xdeg2 * sin(-axeccalra) + ydeg2 * cos(-axeccalra)
                zdeg3 = zdeg2_CM
                xdegrap3 = xdegrap2 * cos(-axeccalra) - ydegrap2 * sin(-axeccalra)
                ydegrap3 = xdegrap2 * sin(-axeccalra) + ydegrap2 * cos(-axeccalra)
                zdegrap3 = zdegrap2

                #"voir new x et y version 3", *x3,*y3, *z3, " et", *xdeg3, *ydeg3, *zdeg3,  e$            

                x4 = x3 + (xdeg_CM - xdeg3)
                y4 = y3 + (ydeg_CM - ydeg3)
                z4 = z3 + (zdeg_CM - zdeg3)
               # "voir new x et y version final ", *x4,*y4, *z4,  e$         

                xprint_CM = xdeg_CM
                yprint_CM = ydeg_CM
                zprint_CM = zdeg_CM

                xcal = xdeg_CM
                ycal = ydeg_CM
                zcal = zdeg_CM

                xrprint_CM = xdegvec + drl_init_x$
                yrprint_CM = ydegvec + drl_init_y$
                zrprint_CM = zdegvec + drl_init_z$
                xrprintrap_CM = xdegvec + sav_x_pmx
                yrprintrap_CM = ydegvec + sav_y_pmx
                zrprintrap_CM = zdegvec + sav_z_pmx

                xgarde_CM = xdegvec + u$
                ygarde_CM = ydegvec + v$
                zgarde_CM = zdegvec + w$


                if mr2$ = -1, mr2print_CM = mr2$
                else, mr2print_CM = mr2$ - toz4$
                zsecuprint = zsecu_CM - toz4$


                ucal = x4
                vcal = y4
                wcal = z4


          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$

          result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid 

                ] # on sort du cas percage 5 axes avec renvoi d'angle   

          if mod5xcont = 0,
                [ # on est dans le cas 5 axes position avec renvoi d'angle
                #sm, paf, "on est dans le cas 5 axes position avec renvoi d'angle", e$

                     if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        xprint_CM = x$ * -1
                        yprint_CM = y$
                        zprint_CM = z$ + dec_axe_tete

                        iprint_CM = i$ * -1
                        jprint_CM = j$
                        kprint_CM = k$ + dec_axe_tete

                        xrprint_CM = xr$ * -1
                        yrprint_CM = yr$
                        zrprint_CM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m4$ #* -1
                        m8print = m5$ #* -1
                        m9print = m6$ #


                        ]
                    else, # on  recalcule les plan tournes
                        [
                        xprint_CM = (y$*sin(tourne) + x$*cos(tourne)) * -1
                        yprint_CM = y$*cos(tourne) - x$*sin(tourne)
                        zprint_CM = z$ + dec_axe_tete

                        iprint_CM = (j$*sin(tourne) + i$*cos(tourne)) * -1
                        jprint_CM = (j$*cos(tourne) - i$*sin(tourne))
                        kprint_CM = k$ + dec_axe_tete

                        xrprint_CM = (yr$*sin(tourne) + xr$*cos(tourne)) * -1
                        yrprint_CM = yr$*cos(tourne) - xr$*sin(tourne)
                        zrprint_CM = zr$ + dec_axe_tete


                        m1print = m1$ * -1
                        m2print = m2$ * -1
                        m3print = m3$
                        m4print = m4$
                        m5print = m5$
                        m6print = m6$
                        m7print = m7$ * -1
                        m8print = m8$ * -1
                        m9print = m9$ #   

                        #"voir =", *m7print, *m8print, e$                                                      
                        ]


                xcal = x$ * -1
                ycal = y$
                zcal = z$ + dec_axe_tete
                zrcal = zr$ + dec_axe_tete
                ucal = u$ * -1
                vcal = v$
                wcal = w$

               # m1print = m1$ * -1
               # m2print = m2$ * -1
               # m3print = m3$
               # m4print = m7$
               # m5print = m8$
               # m6print = m9$
               # m7print = m4$ * -1
               # m8print = m5$ * -1
               # m9print = m6$ 


                tox4print_CM = tox4$
                toy4print_CM = toy4$
                toz4print_CM = toz4$

                depthprint_CM = depth$ + dec_axe_tete
                refhtprint_CM = refht$ + dec_axe_tete
                inithtprint_CM = initht$ + dec_axe_tete

                if mr2$ = -1, mr2print_CM = mr2$
                else, mr2print_CM = mr2$ - toz4$
                zsecuprint = zsecu_CM - toz4$

                sx_label = "X"
                sy_label = "Z"
                sz_label = "Y"
                si_label = "I"
                sj_label = "K"
                sk_label = "J"
                sxr_label = "X"
                syr_label = "Z"
                szr_label = "Y"
                smr2_label = "Z"

                result = nwadrs(sx_label, xprint_CM)    # affectation du nom de l'axe X en i
                result = nwadrs(sy_label, yprint_CM)    # affectation du nom de l'axe y en Z
                result = nwadrs(sz_label, zprint_CM)    # affectation du nom de l'axe z en Y        
                result = nwadrs(si_label, iprint_CM)    # affectation du nom de l'axe i en i        
                result = nwadrs(sj_label, jprint_CM)    # affectation du nom de l'axe j en K
                result = nwadrs(sk_label, kprint_CM)    # affectation du nom de l'axe k en J
                result = nwadrs(sxr_label, xrprint_CM)   # affectation du nom de l'axe Xr en X
                result = nwadrs(syr_label, yrprint_CM)   # affectation du nom de l'axe Yr en Z
                result = nwadrs(szr_label, zrprint_CM)   # affectation du nom de l'axe Zr en Y           
                result = nwadrs(smr2_label, mr2print_CM)   # affectation du nom de l'axe Z en rapid pas de changement car toujours exprimer en repere origine machine      

                ] # on sort du cas 5 axes position avec renvoi d'angle

            ]  # on sort du cas renvoie d'angle 
        else,
        [  # on est dans le cas normal 3 et 5 axes, sans renvoi d'angle
            #"salut", *calculduplan, e$

          ssprint_CM = ss$
          tprint_CM =  t$
          tete_rev_CM = 0



          xcal = x$
          ycal = y$
          zcal = z$



          ucal = u$
          vcal = v$
          wcal = w$


          if calculduplan = 0, # on ne recalcule pas les plan tournes
          [
          xprint_CM = x$
          yprint_CM = y$
          zprint_CM = z$

          xrprint_CM = xr$
          yrprint_CM = yr$
          zrprint_CM = zr$

          iprint_CM = i$
          jprint_CM = j$
          kprint_CM = k$
          ]
          else, # on  recalcule les plan tournes
          [

          xprint_CM = y$*sin(tourne) + x$*cos(tourne)
          yprint_CM = y$*cos(tourne) - x$*sin(tourne)
          zprint_CM = z$

          xrprint_CM = yr$*sin(tourne) + xr$*cos(tourne)
          yrprint_CM = yr$*cos(tourne) - xr$*sin(tourne)
          zrprint_CM = zr$

          iprint_CM = j$*sin(tourne) + i$*cos(tourne)
          jprint_CM = j$*cos(tourne) - i$*sin(tourne)
          kprint_CM = k$
          ]



          m1print = m1$
          m2print = m2$
          m3print = m3$
          m4print = m4$
          m5print = m5$
          m6print = m6$
          m7print = m7$
          m8print = m8$
          m9print = m9$




          tox4print_CM = tox4$
          toy4print_CM = toy4$
          toz4print_CM = toz4$


          if mr2$ = -1, mr2print_CM = mr2$
          else, mr2print_CM = mr2$ - toz4$
          zsecuprint = zsecu_CM - toz4$
          sx_label = "X"
          sy_label = "Y"
          sz_label = "Z"
          si_label = "I"
          sj_label = "J"
          sk_label = "K"
          sxr_label = "X"
          syr_label = "Y"
          szr_label = "Z"
          smr2_label = "Z"

          result = nwadrs(sx_label, xprint_CM)      # affectation du nom de l'axe X 
          result = nwadrs(sy_label, yprint_CM)      # affectation du nom de l'axe y
          result = nwadrs(sz_label, zprint_CM)      # affectation du nom de l'axe z         
          result = nwadrs(si_label, iprint_CM)      # affectation du nom de l'axe i         
          result = nwadrs(sj_label, jprint_CM)      # affectation du nom de l'axe j
          result = nwadrs(sk_label, kprint_CM)      # affectation du nom de l'axe k
          result = nwadrs(sxr_label, xrprint_CM)    # affectation du nom de l'axe Xr 
          result = nwadrs(syr_label, yrprint_CM)    # affectation du nom de l'axe Yr 
          result = nwadrs(szr_label, zrprint_CM)    # affectation du nom de l'axe Zr          
          result = nwadrs(smr2_label, mr2print_CM)  # affectation du nom de l'axe Z en rapid          
        ]  # on sort du  cas normal 3 et 5 axes, sans renvoi d'angle
            #"voir les calcule", *xcal, *ycal, *zcal, *ucal, *vcal, *wcal, e$
#endregion
#endregion

#region   PG9 #OK
#region pg9_5x  
pg9_5x_AG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_AG = sqrt((old_x_5x_AG - x$)^2 + (old_y_5x_AG - y$)^2 + (old_z_5x_AG - z$)^2)
                long_p23_AG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_AG = sqrt((old_x_5x_AG - nextx$)^2 + (old_y_5x_AG - nexty$)^2 + (old_z_5x_AG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_AG <> 0 & long_p23_AG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AG = (long_p23_AG^2 + long_p12_AG^2 - long_p13_AG^2)/(2*long_p12_AG*long_p23_AG)
                !cosangle_AG#, e$
                if cosangle_AG <= 1 & cosangle_AG >= -1,
                [
                ang5x_AG = acos(cosangle_AG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AG, *mr7$, e$
                if ang5x_AG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_BG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_BG = sqrt((old_x_5x_BG - x$)^2 + (old_y_5x_BG - y$)^2 + (old_z_5x_BG - z$)^2)
                long_p23_BG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_BG = sqrt((old_x_5x_BG - nextx$)^2 + (old_y_5x_BG - nexty$)^2 + (old_z_5x_BG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_BG <> 0 & long_p23_BG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BG = (long_p23_BG^2 + long_p12_BG^2 - long_p13_BG^2)/(2*long_p12_BG*long_p23_BG)
                !cosangle_BG
                if cosangle_BG <= 1 & cosangle_BG >= -1,
                [
                ang5x_BG = acos(cosangle_BG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_BG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_CG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_CG = sqrt((old_x_5x_CG - x$)^2 + (old_y_5x_CG - y$)^2 + (old_z_5x_CG - z$)^2)
                long_p23_CG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_CG = sqrt((old_x_5x_CG - nextx$)^2 + (old_y_5x_CG - nexty$)^2 + (old_z_5x_CG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_CG <> 0 & long_p23_CG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CG = (long_p23_CG^2 + long_p12_CG^2 - long_p13_CG^2)/(2*long_p12_CG*long_p23_CG)
                !cosangle_CG
                if cosangle_CG <= 1 & cosangle_CG >= -1,
                [
                ang5x_CG = acos(cosangle_CG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_CG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_DG       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_DG = sqrt((old_x_5x_DG - x$)^2 + (old_y_5x_DG - y$)^2 + (old_z_5x_DG - z$)^2)
                long_p23_DG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_DG = sqrt((old_x_5x_DG - nextx$)^2 + (old_y_5x_DG - nexty$)^2 + (old_z_5x_DG - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_DG <> 0 & long_p23_DG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DG = (long_p23_DG^2 + long_p12_DG^2 - long_p13_DG^2)/(2*long_p12_DG*long_p23_DG)
                !cosangle_DG
                if cosangle_DG <= 1 & cosangle_DG >= -1,
                [
                ang5x_DG = acos(cosangle_DG)
                if mr7$ = 0, mr7$ = 45
                if ang5x_DG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]							
pg9_5x_AM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_AM = sqrt((old_x_5x_AM - x$)^2 + (old_y_5x_AM - y$)^2 + (old_z_5x_AM - z$)^2)
                long_p23_AM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_AM = sqrt((old_x_5x_AM - nextx$)^2 + (old_y_5x_AM - nexty$)^2 + (old_z_5x_AM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_AM <> 0 & long_p23_AM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AM = (long_p23_AM^2 + long_p12_AM^2 - long_p13_AM^2)/(2*long_p12_AM*long_p23_AM)
                !cosangle_AM#, e$
                if cosangle_AM <= 1 & cosangle_AM >= -1,
                [
                ang5x_AM = acos(cosangle_AM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AM, *mr7$, e$
                if ang5x_AM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_BM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_BM = sqrt((old_x_5x_BM - x$)^2 + (old_y_5x_BM - y$)^2 + (old_z_5x_BM - z$)^2)
                long_p23_BM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_BM = sqrt((old_x_5x_BM - nextx$)^2 + (old_y_5x_BM - nexty$)^2 + (old_z_5x_BM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_BM <> 0 & long_p23_BM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BM = (long_p23_BM^2 + long_p12_BM^2 - long_p13_BM^2)/(2*long_p12_BM*long_p23_BM)
                !cosangle_BM
                if cosangle_BM <= 1 & cosangle_BM >= -1,
                [
                ang5x_BM = acos(cosangle_BM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_BM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_CM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_CM = sqrt((old_x_5x_CM - x$)^2 + (old_y_5x_CM - y$)^2 + (old_z_5x_CM - z$)^2)
                long_p23_CM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_CM = sqrt((old_x_5x_CM - nextx$)^2 + (old_y_5x_CM - nexty$)^2 + (old_z_5x_CM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_CM <> 0 & long_p23_CM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CM = (long_p23_CM^2 + long_p12_CM^2 - long_p13_CM^2)/(2*long_p12_CM*long_p23_CM)
                !cosangle_CM
                if cosangle_CM <= 1 & cosangle_CM >= -1,
                [
                ang5x_CM = acos(cosangle_CM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_CM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_5x_DM       # calcul et ajout de code G9 en 5 axes continue
                # on considere un triangle forme par le point d'on on vient old_xyz, on on est xyz, ou on va nextxyz
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                long_p12_DM = sqrt((old_x_5x_DM - x$)^2 + (old_y_5x_DM - y$)^2 + (old_z_5x_DM - z$)^2)
                long_p23_DM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2 + (z$ - nextz$)^2)
                long_p13_DM = sqrt((old_x_5x_DM - nextx$)^2 + (old_y_5x_DM - nexty$)^2 + (old_z_5x_DM - nextz$)^2)
                # on a donc un triangle avec 3 cotes de longeur p12, p23 et p 13 
                if long_p12_DM <> 0 & long_p23_DM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DM = (long_p23_DM^2 + long_p12_DM^2 - long_p13_DM^2)/(2*long_p12_DM*long_p23_DM)
                !cosangle_DM
                if cosangle_DM <= 1 & cosangle_DM >= -1,
                [
                ang5x_DM = acos(cosangle_DM)
                if mr7$ = 0, mr7$ = 45
                if ang5x_DM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]				
#endregion      
#region pg9
pg9_AG           #ajout du code G9 en 2d

                long_p12_AG = sqrt((old_x_AG - x$)^2 + (old_y_AG - y$)^2)
                long_p23_AG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_AG = sqrt((old_x_AG - nextx$)^2 + (old_y_AG - nexty$)^2)

                if long_p12_AG <> 0 & long_p23_AG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AG = (long_p23_AG^2 + long_p12_AG^2 - long_p13_AG^2)/(2*long_p12_AG*long_p23_AG)
                !cosangle_AG
                if cosangle_AG <= 1 & cosangle_AG >= -1,
                [
                ang5x_AG = acos(cosangle_AG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AG, *mr7$, e$
                if ang5x_AG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_BG           #ajout du code G9 en 2d

                long_p12_BG = sqrt((old_x_BG - x$)^2 + (old_y_BG - y$)^2)
                long_p23_BG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_BG = sqrt((old_x_BG - nextx$)^2 + (old_y_BG - nexty$)^2)

                if long_p12_BG <> 0 & long_p23_BG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BG = (long_p23_BG^2 + long_p12_BG^2 - long_p13_BG^2)/(2*long_p12_BG*long_p23_BG)
                !cosangle_BG
                if cosangle_BG <= 1 & cosangle_BG >= -1,
                [
                ang5x_BG = acos(cosangle_BG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_BG, *mr7$, e$
                if ang5x_BG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_CG           #ajout du code G9 en 2d

                long_p12_CG = sqrt((old_x_CG - x$)^2 + (old_y_CG - y$)^2)
                long_p23_CG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_CG = sqrt((old_x_CG - nextx$)^2 + (old_y_CG - nexty$)^2)

                if long_p12_CG <> 0 & long_p23_CG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CG = (long_p23_CG^2 + long_p12_CG^2 - long_p13_CG^2)/(2*long_p12_CG*long_p23_CG)
                !cosangle_CG
                if cosangle_CG <= 1 & cosangle_CG >= -1,
                [
                ang5x_CG = acos(cosangle_CG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_CG, *mr7$, e$
                if ang5x_CG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]			
pg9_DG           #ajout du code G9 en 2d

                long_p12_DG = sqrt((old_x_DG - x$)^2 + (old_y_DG - y$)^2)
                long_p23_DG = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_DG = sqrt((old_x_DG - nextx$)^2 + (old_y_DG - nexty$)^2)

                if long_p12_DG <> 0 & long_p23_DG <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DG = (long_p23_DG^2 + long_p12_DG^2 - long_p13_DG^2)/(2*long_p12_DG*long_p23_DG)
                !cosangle_DG
                if cosangle_DG <= 1 & cosangle_DG >= -1,
                [
                ang5x_DG = acos(cosangle_DG)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_DG, *mr7$, e$
                if ang5x_DG <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]				
pg9_AM           #ajout du code G9 en 2d

                long_p12_AM = sqrt((old_x_AM - x$)^2 + (old_y_AM - y$)^2)
                long_p23_AM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_AM = sqrt((old_x_AM - nextx$)^2 + (old_y_AM - nexty$)^2)

                if long_p12_AM <> 0 & long_p23_AM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_AM = (long_p23_AM^2 + long_p12_AM^2 - long_p13_AM^2)/(2*long_p12_AM*long_p23_AM)
                !cosangle_AM
                if cosangle_AM <= 1 & cosangle_AM >= -1,
                [
                ang5x_AM = acos(cosangle_AM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_AM, *mr7$, e$
                if ang5x_AM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_BM           #ajout du code G9 en 2d

                long_p12_BM = sqrt((old_x_BM - x$)^2 + (old_y_BM - y$)^2)
                long_p23_BM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_BM = sqrt((old_x_BM - nextx$)^2 + (old_y_BM - nexty$)^2)

                if long_p12_BM <> 0 & long_p23_BM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_BM = (long_p23_BM^2 + long_p12_BM^2 - long_p13_BM^2)/(2*long_p12_BM*long_p23_BM)
                !cosangle_BM
                if cosangle_BM <= 1 & cosangle_BM >= -1,
                [
                ang5x_BM = acos(cosangle_BM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_BM, *mr7$, e$
                if ang5x_BM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_CM           #ajout du code G9 en 2d

                long_p12_CM = sqrt((old_x_CM - x$)^2 + (old_y_CM - y$)^2)
                long_p23_CM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_CM = sqrt((old_x_CM - nextx$)^2 + (old_y_CM - nexty$)^2)

                if long_p12_CM <> 0 & long_p23_CM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_CM = (long_p23_CM^2 + long_p12_CM^2 - long_p13_CM^2)/(2*long_p12_CM*long_p23_CM)
                !cosangle_CM
                if cosangle_CM <= 1 & cosangle_CM >= -1,
                [
                ang5x_CM = acos(cosangle_CM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_CM, *mr7$, e$
                if ang5x_CM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]
pg9_DM           #ajout du code G9 en 2d

                long_p12_DM = sqrt((old_x_DM - x$)^2 + (old_y_DM - y$)^2)
                long_p23_DM = sqrt((x$ - nextx$)^2 + (y$ - nexty$)^2)
                long_p13_DM = sqrt((old_x_DM - nextx$)^2 + (old_y_DM - nexty$)^2)

                if long_p12_DM <> 0 & long_p23_DM <> 0,
                [
                # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer
                cosangle_DM = (long_p23_DM^2 + long_p12_DM^2 - long_p13_DM^2)/(2*long_p12_DM*long_p23_DM)
                !cosangle_DM
                if cosangle_DM <= 1 & cosangle_DM >= -1,
                [
                ang5x_DM = acos(cosangle_DM)
                if mr7$ = 0, mr7$ = 45
                #"voir", *ang5x_DM, *mr7$, e$
                if ang5x_DM <= mr7$ & mr7$ <> -1, "G9"
                ]
                ]				
#endregion              
#endregion

#region   COMMMENTAIRES, PFR, PMODAL, COMPTEUR #OK
#region pcomment_descripteur

snumprog_AG : ""
fmt "num de prog" 4 num_prog_AG
pcomment_descripteur

           if gcode$ = 1054,    [
                                if compteur_descrip = 14, sprog_complet_AG = scomm$
                                if compteur_descrip = 15, sprog_complet_BG = scomm$
                                if compteur_descrip = 16, sprog_complet_CG = scomm$
                                if compteur_descrip = 18, sprog_concat_AM = scomm$
                                if compteur_descrip = 19, sprog_concat_BM = scomm$
                                if compteur_descrip = 20, sprog_concat_CM = scomm$		   
                                #if compteur_descrip = 27, snumprog_AG = scomm$
                                if compteur_descrip = 29, SDEC_X_AG = scomm$
                                if compteur_descrip = 32, SDEC_Y_AG = scomm$
                                if compteur_descrip = 35, SDEC_Z_AG = scomm$
                                if compteur_descrip = 46, SDEC_X_BG = scomm$
                                if compteur_descrip = 49, SDEC_Y_BG = scomm$
                                if compteur_descrip = 52, SDEC_Z_BG = scomm$
                                if compteur_descrip = 63, SDEC_X_CG = scomm$
                                if compteur_descrip = 66, SDEC_Y_CG = scomm$
                                if compteur_descrip = 69, SDEC_Z_CG = scomm$
                                #if compteur_descrip = 70, SPOURCENTAGE_AVANCE_CG = scomm$
								#if compteur_descrip = 71, SCLOCHE_ACTIVE_CG = scomm$
                                if compteur_descrip = 78, sdim_outillage = scomm$
                                if compteur_descrip = 82, susure_outil_1 = scomm$
                                if compteur_descrip = 83, susure_outil_2 = scomm$
                                if compteur_descrip = 84, susure_outil_3 = scomm$
                                if compteur_descrip = 85, susure_outil_4 = scomm$
                                if compteur_descrip = 86, susure_outil_5 = scomm$
                                if compteur_descrip = 87, susure_outil_6 = scomm$
                                if compteur_descrip = 88, susure_outil_7 = scomm$
                                if compteur_descrip = 89, susure_outil_8 = scomm$
                                if compteur_descrip = 90, susure_outil_9 = scomm$
                                if compteur_descrip = 91, susure_outil_10 = scomm$
                                if compteur_descrip = 92, susure_outil_11 = scomm$
                                if compteur_descrip = 93, susure_outil_12 = scomm$
                                if compteur_descrip = 94, susure_outil_13 = scomm$
                                if compteur_descrip = 95, susure_outil_14 = scomm$
                                if compteur_descrip = 96, susure_outil_15 = scomm$
                                if compteur_descrip = 97, susure_outil_16 = scomm$
                                if compteur_descrip = 98, susure_outil_17 = scomm$
                                if compteur_descrip = 99, susure_outil_18 = scomm$
                                if compteur_descrip = 100, susure_outil_19 = scomm$
                                if compteur_descrip = 101, susure_outil_20 = scomm$
                                if compteur_descrip = 102, susure_outil_21 = scomm$
                                if compteur_descrip = 103, susure_outil_22 = scomm$
                                if compteur_descrip = 104, susure_outil_23 = scomm$
                                if compteur_descrip = 105, susure_outil_24 = scomm$
                                if compteur_descrip = 106, susure_outil_25 = scomm$
                                if compteur_descrip = 107, susure_outil_26 = scomm$
                                if compteur_descrip = 108, susure_outil_27 = scomm$
                                if compteur_descrip = 109, susure_outil_28 = scomm$
                                if compteur_descrip = 110, susure_outil_29 = scomm$
                                if compteur_descrip = 111, susure_outil_30 = scomm$

                                compteur_descrip = compteur_descrip + 1

                                DEC_X_AG = rpar(SDEC_X_AG,1)
                                DEC_Y_AG = rpar(SDEC_Y_AG,1)
                                DEC_Z_AG = rpar(SDEC_Z_AG,1)

                                DEC_X_BG = rpar(SDEC_X_BG,1)
                                DEC_Y_BG = rpar(SDEC_Y_BG,1)
                                DEC_Z_BG = rpar(SDEC_Z_BG,1)

                                DEC_X_CG = rpar(SDEC_X_CG,1)
                                DEC_Y_CG = rpar(SDEC_Y_CG,1)
                                DEC_Z_CG = rpar(SDEC_Z_CG,1)

                                DEC_X_AM = rpar(SDEC_X_AG,1)
                                DEC_Y_AM = rpar(SDEC_Y_AG,1)
                                DEC_Z_AM = rpar(SDEC_Z_AG,1)

                                DEC_X_BM = rpar(SDEC_X_BG,1)
                                DEC_Y_BM = rpar(SDEC_Y_BG,1)
                                DEC_Z_BM = rpar(SDEC_Z_BG,1)

                                DEC_X_CM = rpar(SDEC_X_CG,1)
                                DEC_Y_CM = rpar(SDEC_Y_CG,1)
                                DEC_Z_CM = rpar(SDEC_Z_CG,1)
                                ]

#region pvoirdescrip
pvoirdescrip
                                SDEC_X_AG, e$
                                SDEC_Y_AG, e$
                                SDEC_Z_AG, e$

                                SDEC_X_BG, e$
                                SDEC_Y_BG, e$
                                SDEC_Z_BG, e$

                                SDEC_X_CG, e$
                                SDEC_Y_CG, e$
                                SDEC_Z_CG, e$

                                DEC_X_AG, e$
                                DEC_Y_AG, e$
                                DEC_Z_AG, e$

                                DEC_X_BG, e$
                                DEC_Y_BG, e$
                                DEC_Z_BG, e$

                                DEC_X_CG, e$
                                DEC_Y_CG, e$
                                DEC_Z_CG, e$

                                DEC_X_AM, e$
                                DEC_Y_AM, e$
                                DEC_Z_AM, e$

                                DEC_X_BM, e$
                                DEC_Y_BM, e$
                                DEC_Z_BM, e$

                                DEC_X_CM, e$
                                DEC_Y_CM, e$
                                DEC_Z_CM, e$

                                sprog_complet_AG, e$
                                sprog_complet_BG, e$
                                sprog_complet_CG, e$

                                sprog_concat_AM, e$
                                sprog_concat_BM, e$
                                sprog_concat_CM, e$

                                prog_AG, e$
                                prog_BG, e$
                                prog_CG, e$
                                prog_AM, e$
                                prog_BM, e$
                                prog_CM, e$

#endregion                              
#endregion
#region PCOMMENT
pcomment$
                            if debut_pp = 0, pcomment_descripteur
                            pcomment_AG
                            pcomment_BG
                            pcomment_CG
                            pcomment_AM
                            pcomment_BM
                            pcomment_CM

pcomment_AG
           if gcode$ = 1005, strcom_AG = strparo + scomm$ + strparf
           if gcode$ = 1006, strcom_AG = scomm$
           if gcode$ = 1007, strcom_AG = strparodeux + scomm$ + strparf
           if gcode$ = 1008, strcom_AG = strparo + scomm$ + strparf
pcomment_BG

           if gcode$ = 1005, strcom_BG = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1006, strcom_BG = scomm$
           if gcode$ = 1007, strcom_BG = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1008, strcom_BG = strmsg + sentre_cote + scomm$ + strparf
pcomment_CG
           if gcode$ = 1005, strcom_CG = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1006, strcom_CG = scomm$
           if gcode$ = 1007, strcom_CG = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1008, strcom_CG = strmsg + sentre_cote + scomm$ + strparf
pcomment_AM
           if gcode$ = 1005, strcom_AM = strparo + scomm$ + strparf
           if gcode$ = 1006, strcom_AM = scomm$
           if gcode$ = 1007, strcom_AM = strparodeux + scomm$ + strparf
           if gcode$ = 1008, strcom_AM = strparo + scomm$ + strparf
pcomment_BM
           if gcode$ = 1005, strcom_BM = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1006, strcom_BM = scomm$
           if gcode$ = 1007, strcom_BM = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1008, strcom_BM = strmsg + sentre_cote + scomm$ + strparf
pcomment_CM
           if gcode$ = 1005, strcom_CM = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1006, strcom_CM = scomm$
           if gcode$ = 1007, strcom_CM = strmsg + sentre_cote + scomm$ + strparf
           if gcode$ = 1008, strcom_CM = strmsg + sentre_cote + scomm$ + strparf
#endregion   
#region strings multi comment
strcom_AG : ""
strcom_BG : ""
strcom_CG : ""
strcom_AM : ""
strcom_BM : ""
strcom_CM : ""
strparo : "("
strparf : ")"
strparodeux : "(2"
strmsg : "MSG("
strcroch : ""
#endregion         
#region PFR

pfr_AG        # avance
            if fr$ >= 0, *fr$

pfr_BG        # avance
            if fr$ >= 0, *fr$
            if fr$ >= 0, avance_BG = fr$

pfr_CG        # avance
            if fr$ >= 0, *fr$
            if fr$ >= 0, avance_CG = fr$

pfr_AM        # avance
            fr_AM = fr$
            if fr$ >= 0, *fr_AM

pfr_BM        # avance
            fr_BM = fr$
            if fr$ >= 0, *fr_BM
            if fr$ >= 0, avance_BM = fr$

pfr_CM        # avance
            fr_CM = fr$
            if fr$ >= 0, *fr_CM
            if fr$ >= 0, avance_CM = fr$
#endregion         
#region PFR5AXE

pfr5axe_AG  # avance en 3
           if fr5axe_AG >= 0, *fr5axe_AG

pfr5axe_BG  # avance en 3
           if fr5axe_BG >= 0, *fr5axe_BG

pfr5axe_CG  # avance en 3
           if fr5axe_CG >= 0, *fr5axe_CG

pfr5axe_AM  # avance en 3
           if fr5axe_AM >= 0, *fr5axe_AM

pfr5axe_BM  # avance en 3
           if fr5axe_BM >= 0, *fr5axe_BM

pfr5axe_CM  # avance en 3
           if fr5axe_CM >= 0, *fr5axe_CM
#endregion
#region PDMODALXYZ

pdmodalxyz_AG   # demodalise temporairement xyz
        vieuxx = xprint_AG
        vieuxy = yprint_AG
        vieuxz = zprint_AG
        @vieuxx, @vieuxy, @vieuxz
        xprint_AG = 999999
        yprint_AG = 999999
        zprint_AG = 999999
        !xprint_AG,!yprint_AG,!zprint_AG
        xprint_AG = vieuxx
        yprint_AG = vieuxy
        zprint_AG = vieuxz
         @xprint_AG,@yprint_AG,@zprint_AG

pdmodalxyz_BG   # demodalise temporairement xyz
        vieuxx = xprint_BG
        vieuxy = yprint_BG
        vieuxz = zprint_BG
        @vieuxx, @vieuxy, @vieuxz
        xprint_BG = 999999
        yprint_BG = 999999
        zprint_BG = 999999
        !xprint_BG,!yprint_BG,!zprint_BG
        xprint_BG = vieuxx
        yprint_BG = vieuxy
        zprint_BG = vieuxz
         @xprint_BG,@yprint_BG,@zprint_BG

pdmodalxyz_CG   # demodalise temporairement xyz
        vieuxx = xprint_CG
        vieuxy = yprint_CG
        vieuxz = zprint_CG
        @vieuxx, @vieuxy, @vieuxz
        xprint_CG = 999999
        yprint_CG = 999999
        zprint_CG = 999999
        !xprint_CG,!yprint_CG,!zprint_CG
        xprint_CG = vieuxx
        yprint_CG = vieuxy
        zprint_CG = vieuxz
         @xprint_CG,@yprint_CG,@zprint_CG
pdmodalxyz_AM   # demodalise temporairement xyz
        vieuxx = xprint_AM
        vieuxy = yprint_AM
        vieuxz = zprint_AM
        @vieuxx, @vieuxy, @vieuxz
        xprint_AM = 999999
        yprint_AM = 999999
        zprint_AM = 999999
        !xprint_AM,!yprint_AM,!zprint_AM
        xprint_AM = vieuxx
        yprint_AM = vieuxy
        zprint_AM = vieuxz
         @xprint_AM,@yprint_AM,@zprint_AM

pdmodalxyz_BM   # demodalise temporairement xyz
        vieuxx = xprint_BM
        vieuxy = yprint_BM
        vieuxz = zprint_BM
        @vieuxx, @vieuxy, @vieuxz
        xprint_BM = 999999
        yprint_BM = 999999
        zprint_BM = 999999
        !xprint_BM,!yprint_BM,!zprint_BM
        xprint_BM = vieuxx
        yprint_BM = vieuxy
        zprint_BM = vieuxz
         @xprint_BM,@yprint_BM,@zprint_BM

pdmodalxyz_CM   # demodalise temporairement xyz
        vieuxx = xprint_CM
        vieuxy = yprint_CM
        vieuxz = zprint_CM
        @vieuxx, @vieuxy, @vieuxz
        xprint_CM = 999999
        yprint_CM = 999999
        zprint_CM = 999999
        !xprint_CM,!yprint_CM,!zprint_CM
        xprint_CM = vieuxx
        yprint_CM = vieuxy
        zprint_CM = vieuxz
         @xprint_CM,@yprint_CM,@zprint_CM
#endregion
#region PESSAICOMPTEUR

pessaicompteur_AG
        difaxecpos_AG = axeCpos_AG - oldreel_axeCpos_AG
        if difaxecpos_AG < -180,comptour_AG= comptour_AG + 360
        if difaxecpos_AG > 180,  comptour_AG = comptour_AG - 360
        naxecpos_AG = axeCpos_AG + comptour_AG
        @maxi_c_AG,@mini_c_AG
        if naxecpos_AG < mini_c_AG, comptour_AG = comptour_AG + 360
        if naxecpos_AG > maxi_c_AG, comptour_AG = comptour_AG - 360
        axeCpos_AG = axeCpos_AG + comptour_AG

pessaicompteur_BG
        difaxecpos_BG = axeCpos_BG - oldreel_axeCpos_BG
        if difaxecpos_BG <   -180,comptour_BG= comptour_BG + 360
        if difaxecpos_BG > 180,  comptour_BG = comptour_BG - 360
        naxecpos_BG = axeCpos_BG + comptour_BG
        @maxi_c_BG,@mini_c_BG
        if naxecpos_BG < mini_c_BG, comptour_BG = comptour_BG + 360
        if naxecpos_BG > maxi_c_BG, comptour_BG = comptour_BG - 360
        axeCpos_BG = axeCpos_BG + comptour_BG

pessaicompteur_CG
        difaxecpos_CG = axeCpos_CG - oldreel_axeCpos_CG
        if difaxecpos_CG <   -180,comptour_CG= comptour_CG + 360
        if difaxecpos_CG > 180,  comptour_CG = comptour_CG - 360
        naxecpos_CG = axeCpos_CG + comptour_CG
        @maxi_c_CG,@mini_c_CG
        if naxecpos_CG < mini_c_CG, comptour_CG = comptour_CG + 360
        if naxecpos_CG > maxi_c_CG, comptour_CG = comptour_CG - 360
        axeCpos_CG = axeCpos_CG + comptour_CG

pessaicompteur_AM
        difaxecpos_AM = axeCpos_AM - oldreel_axeCpos_AM
        if difaxecpos_AM < -180,comptour_AM= comptour_AM + 360
        if difaxecpos_AM > 180,  comptour_AM = comptour_AM - 360
        naxecpos_AM = axeCpos_AM + comptour_AM
        @maxi_c_AM,@mini_c_AM
        if naxecpos_AM < mini_c_AM, comptour_AM = comptour_AM + 360
        if naxecpos_AM > maxi_c_AM, comptour_AM = comptour_AM - 360
        axeCpos_AM = axeCpos_AM + comptour_AM

pessaicompteur_BM
        difaxecpos_BM = axeCpos_BM - oldreel_axeCpos_BM
        if difaxecpos_BM <   -180,comptour_BM= comptour_BM + 360
        if difaxecpos_BM > 180,  comptour_BM = comptour_BM - 360
        naxecpos_BM = axeCpos_BM + comptour_BM
        @maxi_c_BM,@mini_c_BM
        if naxecpos_BM < mini_c_BM, comptour_BM = comptour_BM + 360
        if naxecpos_BM > maxi_c_BM, comptour_BM = comptour_BM - 360
        axeCpos_BM = axeCpos_BM + comptour_BM

pessaicompteur_CM
        difaxecpos_CM = axeCpos_CM - oldreel_axeCpos_CM
        if difaxecpos_CM <   -180,comptour_CM= comptour_CM + 360
        if difaxecpos_CM > 180,  comptour_CM = comptour_CM - 360
        naxecpos_CM = axeCpos_CM + comptour_CM
        @maxi_c_CM,@mini_c_CM
        if naxecpos_CM < mini_c_CM, comptour_CM = comptour_CM + 360
        if naxecpos_CM > maxi_c_CM, comptour_CM = comptour_CM - 360
        axeCpos_CM = axeCpos_CM + comptour_CM
#endregion
prot0$
prot$
#endregion

#region   CALCUL PLANS #OK
#region panul_plan_inc

panul_plan_inc_BG   # annulation plan incliner
                    sm, paf, "TRANS", e$
                    sm, paf, "ROT", e$
panul_plan_inc_CG   # annulation plan incliner
                    if blocaxe_CG = 1, sm, paf, "M31 ; DEBLOCAGE AXE B", e$, sm, paf, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CG = 0
                    sm, paf, "TRANS", e$
                    sm, paf, "ROT", e$
panul_plan_inc_BM   # annulation plan incliner
                    sm, paf, "TRANS", e$
                    sm, paf, "ROT", e$
panul_plan_inc_CM   # annulation plan incliner
                    if blocaxe_CM = 1, sm, paf, "M31 ; DEBLOCAGE AXE B", e$, sm, paf, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CM = 0
                    sm, paf, "TRANS", e$
                    sm, paf, "ROT", e$
#endregion
#region pafichecala

pafichecala_AG   # routine pour trouver bonne angle a
                axeApos_AG = atan2(new_m8,m9print)
                "voir axeC_AG solution1=",*axeApos_AG, e$
                axeApos_AG = atan2(-new_m8,m9print)
                "voir axeC_AG solution2=",*axeApos_AG, e$
                axeApos_AG = atan2(new_m8,-m9print)
                "voir axeC_AG solution3=",*axeApos_AG, e$
                axeApos_AG = atan2(-new_m8,-m9print)
                "voir axeC_AG solution4=",*axeApos_AG, e$
                axeApos_AG = atan2(m9print,new_m8)
                "voir axeC_AG solution5=",*axeApos_AG, e$
                axeApos_AG = atan2(-m9print,new_m8)
                "voir axeC_AG solution6=",*axeApos_AG, e$
                axeApos_AG = atan2(m9print,-new_m8)
                "voir axeC_AG solution7=",*axeApos_AG, e$
                axeApos_AG = atan2(-m9print,-new_m8)
                "voir axeC_AG solution8=",*axeApos_AG, e$

pafichecala_BG   # routine pour trouver bonne angle a
                axeApos_BG = atan2(new_m8,m9print)
                "voir axeC_BG solution1=",*axeApos_BG, e$
                axeApos_BG = atan2(-new_m8,m9print)
                "voir axeC_BG solution2=",*axeApos_BG, e$
                axeApos_BG = atan2(new_m8,-m9print)
                "voir axeC_BG solution3=",*axeApos_BG, e$
                axeApos_BG = atan2(-new_m8,-m9print)
                "voir axeC_BG solution4=",*axeApos_BG, e$
                axeApos_BG = atan2(m9print,new_m8)
                "voir axeC_BG solution5=",*axeApos_BG, e$
                axeApos_BG = atan2(-m9print,new_m8)
                "voir axeC_BG solution6=",*axeApos_BG, e$
                axeApos_BG = atan2(m9print,-new_m8)
                "voir axeC_BG solution7=",*axeApos_BG, e$
                axeApos_BG = atan2(-m9print,-new_m8)
                "voir axeC_BG solution8=",*axeApos_BG, e$

pafichecala_CG   # routine pour trouver bonne angle a
                axeApos_CG = atan2(new_m8,m9print)
                "voir axeC_CG solution1=",*axeApos_CG, e$
                axeApos_CG = atan2(-new_m8,m9print)
                "voir axeC_CG solution2=",*axeApos_CG, e$
                axeApos_CG = atan2(new_m8,-m9print)
                "voir axeC_CG solution3=",*axeApos_CG, e$
                axeApos_CG = atan2(-new_m8,-m9print)
                "voir axeC_CG solution4=",*axeApos_CG, e$
                axeApos_CG = atan2(m9print,new_m8)
                "voir axeC_CG solution5=",*axeApos_CG, e$
                axeApos_CG = atan2(-m9print,new_m8)
                "voir axeC_CG solution6=",*axeApos_CG, e$
                axeApos_CG = atan2(m9print,-new_m8)
                "voir axeC_CG solution7=",*axeApos_CG, e$
                axeApos_CG = atan2(-m9print,-new_m8)
                "voir axeC_CG solution8=",*axeApos_CG, e$

pafichecala_AM   # routine pour trouver bonne angle a
                axeApos_AM = atan2(new_m8,m9print)
                "voir axeC_AM solution1=",*axeApos_AM, e$
                axeApos_AM = atan2(-new_m8,m9print)
                "voir axeC_AM solution2=",*axeApos_AM, e$
                axeApos_AM = atan2(new_m8,-m9print)
                "voir axeC_AM solution3=",*axeApos_AM, e$
                axeApos_AM = atan2(-new_m8,-m9print)
                "voir axeC_AM solution4=",*axeApos_AM, e$
                axeApos_AM = atan2(m9print,new_m8)
                "voir axeC_AM solution5=",*axeApos_AM, e$
                axeApos_AM = atan2(-m9print,new_m8)
                "voir axeC_AM solution6=",*axeApos_AM, e$
                axeApos_AM = atan2(m9print,-new_m8)
                "voir axeC_AM solution7=",*axeApos_AM, e$
                axeApos_AM = atan2(-m9print,-new_m8)
                "voir axeC_AM solution8=",*axeApos_AM, e$

pafichecala_BM   # routine pour trouver bonne angle a
                axeApos_BM = atan2(new_m8,m9print)
                "voir axeC_BM solution1=",*axeApos_BM, e$
                axeApos_BM = atan2(-new_m8,m9print)
                "voir axeC_BM solution2=",*axeApos_BM, e$
                axeApos_BM = atan2(new_m8,-m9print)
                "voir axeC_BM solution3=",*axeApos_BM, e$
                axeApos_BM = atan2(-new_m8,-m9print)
                "voir axeC_BM solution4=",*axeApos_BM, e$
                axeApos_BM = atan2(m9print,new_m8)
                "voir axeC_BM solution5=",*axeApos_BM, e$
                axeApos_BM = atan2(-m9print,new_m8)
                "voir axeC_BM solution6=",*axeApos_BM, e$
                axeApos_BM = atan2(m9print,-new_m8)
                "voir axeC_BM solution7=",*axeApos_BM, e$
                axeApos_BM = atan2(-m9print,-new_m8)
                "voir axeC_BM solution8=",*axeApos_BM, e$

pafichecala_CM   # routine pour trouver bonne angle a
                axeApos_CM = atan2(new_m8,m9print)
                "voir axeC_CM solution1=",*axeApos_CM, e$
                axeApos_CM = atan2(-new_m8,m9print)
                "voir axeC_CM solution2=",*axeApos_CM, e$
                axeApos_CM = atan2(new_m8,-m9print)
                "voir axeC_CM solution3=",*axeApos_CM, e$
                axeApos_CM = atan2(-new_m8,-m9print)
                "voir axeC_CM solution4=",*axeApos_CM, e$
                axeApos_CM = atan2(m9print,new_m8)
                "voir axeC_CM solution5=",*axeApos_CM, e$
                axeApos_CM = atan2(-m9print,new_m8)
                "voir axeC_CM solution6=",*axeApos_CM, e$
                axeApos_CM = atan2(m9print,-new_m8)
                "voir axeC_CM solution7=",*axeApos_CM, e$
                axeApos_CM = atan2(-m9print,-new_m8)
                "voir axeC_CM solution8=",*axeApos_CM, e$
#endregion  
#region pafichecalc

pafichecalc_AG   # routine pour trouver bonne angle c
                " voir solution de base = ",axeCpos_AG, e$
                "-----------------------", e$
                axeCpos_AG = atan2(m7print,m8print)
                "voir axeC_AG solution1=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m7print,-m8print)
                "voir axeC_AG solution2=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m7print,m8print)
                "voir axeC_AG solution3=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m7print,-m8print)
                "voir axeC_AG solution4=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m8print,m7print)
                "voir axeC_AG solution5=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m8print,m7print)
                "voir axeC_AG solution6=",*axeCpos_AG, e$
                axeCpos_AG = atan2(m8print,-m7print)
                "voir axeC_AG solution7=",*axeCpos_AG, e$
                axeCpos_AG = atan2(-m8print,-m7print)
                "voir axeC_AG solution8=",*axeCpos_AG, e$
                "-----------------------", e$
pafichecalc_BG   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_BG, e$
                "-----------------------", e$

                axeCpos_BG = atan2(m7print,m8print)
                "voir axeC_BG solution1=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m7print,-m8print)
                "voir axeC_BG solution2=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m7print,m8print)
                "voir axeC_BG solution3=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m7print,-m8print)
                "voir axeC_BG solution4=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m8print,m7print)
                "voir axeC_BG solution5=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m8print,m7print)
                "voir axeC_BG solution6=",*axeCpos_BG, e$
                axeCpos_BG = atan2(m8print,-m7print)
                "voir axeC_BG solution7=",*axeCpos_BG, e$
                axeCpos_BG = atan2(-m8print,-m7print)
                "voir axeC_BG solution8=",*axeCpos_BG, e$
                "-----------------------", e$
pafichecalc_CG   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_CG, e$
                "-----------------------", e$

                axeCpos_CG = atan2(m7print,m8print)
                "voir axeC_CG solution1=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m7print,-m8print)
                "voir axeC_CG solution2=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m7print,m8print)
                "voir axeC_CG solution3=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m7print,-m8print)
                "voir axeC_CG solution4=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m8print,m7print)
                "voir axeC_CG solution5=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m8print,m7print)
                "voir axeC_CG solution6=",*axeCpos_CG, e$
                axeCpos_CG = atan2(m8print,-m7print)
                "voir axeC_CG solution7=",*axeCpos_CG, e$
                axeCpos_CG = atan2(-m8print,-m7print)
                "voir axeC_CG solution8=",*axeCpos_CG, e$
                "-----------------------", e$
pafichecalc_AM   # routine pour trouver bonne angle c
                " voir solution de base = ",axeCpos_AM, e$
                "-----------------------", e$
                axeCpos_AM = atan2(m7print,m8print)
                "voir axeC_AM solution1=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m7print,-m8print)
                "voir axeC_AM solution2=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m7print,m8print)
                "voir axeC_AM solution3=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m7print,-m8print)
                "voir axeC_AM solution4=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m8print,m7print)
                "voir axeC_AM solution5=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m8print,m7print)
                "voir axeC_AM solution6=",*axeCpos_AM, e$
                axeCpos_AM = atan2(m8print,-m7print)
                "voir axeC_AM solution7=",*axeCpos_AM, e$
                axeCpos_AM = atan2(-m8print,-m7print)
                "voir axeC_AM solution8=",*axeCpos_AM, e$
                "-----------------------", e$
pafichecalc_BM   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_BM, e$
                "-----------------------", e$

                axeCpos_BM = atan2(m7print,m8print)
                "voir axeC_BM solution1=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m7print,-m8print)
                "voir axeC_BM solution2=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m7print,m8print)
                "voir axeC_BM solution3=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m7print,-m8print)
                "voir axeC_BM solution4=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m8print,m7print)
                "voir axeC_BM solution5=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m8print,m7print)
                "voir axeC_BM solution6=",*axeCpos_BM, e$
                axeCpos_BM = atan2(m8print,-m7print)
                "voir axeC_BM solution7=",*axeCpos_BM, e$
                axeCpos_BM = atan2(-m8print,-m7print)
                "voir axeC_BM solution8=",*axeCpos_BM, e$
                "-----------------------", e$
pafichecalc_CM   # routine pour trouver bonne angle c

                " voir solution de base = ",axeCpos_CM, e$
                "-----------------------", e$

                axeCpos_CM = atan2(m7print,m8print)
                "voir axeC_CM solution1=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m7print,-m8print)
                "voir axeC_CM solution2=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m7print,m8print)
                "voir axeC_CM solution3=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m7print,-m8print)
                "voir axeC_CM solution4=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m8print,m7print)
                "voir axeC_CM solution5=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m8print,m7print)
                "voir axeC_CM solution6=",*axeCpos_CM, e$
                axeCpos_CM = atan2(m8print,-m7print)
                "voir axeC_CM solution7=",*axeCpos_CM, e$
                axeCpos_CM = atan2(-m8print,-m7print)
                "voir axeC_CM solution8=",*axeCpos_CM, e$
                "-----------------------", e$
#endregion
#region prot1

prot1_AG        # Calcul des angles
                #" les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
                #" les series M print ", *m1print," ",*m2print," ",*m3print," ",*m4print," ",*m5print," ",*m6print," ",*m7print," ",*m8print," ",*m9print, e$
                @mini_a_AG, @maxi_a_AG, @mini_c_AG, @maxi_c_AG, @nbt_AG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_AG = atan2(m2print,m1print) 
                #"voir axeC_AG solution old=",*axeCpos_AG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_AG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_AG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0,axeCpos_AG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_AG = 0
                ]
                reel_axeCpos_AG = axeCpos_AG
                new_m8 = m8print * cos(axeCpos_AG) - m7print * sin(axeCpos_AG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0, axeApos_AG = atan2(-new_m8,-m9print) # pafichecala_AG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_AG = 90 # pas d'angle sur a
                else,  axeApos_AG = atan2(m9print,new_m8)
                ]
               !axeApos_AG
               if axeApos_AG > 270, axeApos_AG = axeApos_AG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_AG = axeApos_AG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_AG = axeCpos_AG
               axeApos1_AG = axeApos_AG

               if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
			   													if m9$ < 0, invers_AG = 1  # pas de choix sens A si tete a renvoi d'angle
																else,  invers_AG = 0
																]
               if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22,	[
			   													if m9$ < 0, invers_AG = 0  # inversion de A si 2 em broche des tete a renvoi d'angle
																else,  invers_AG = 1
																]
               if invers_AG = 1,
               [
                axeApos1_AG = axeApos1_AG *  -1
                if axeCpos1_AG >= 180, axeCpos1_AG = axeCpos1_AG - 180
                else, axeCpos1_AG = axeCpos1_AG + 180
               ]
               if mi1_C_base_AG =  2, axeCpos1_AG = axeCpos1_AG - 360
               !axeApos_AG, !new_m8, !axeCpos_AG         #actualise les variable
               if axeApos_AG > maxi_a_AG | axeApos_AG < mini_a_AG, psortie10_AG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a       

prot1_BG     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_BG, @maxi_a_BG, @mini_c_BG, @maxi_c_BG, @nbt_BG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_BG = atan2(m2print,m1print) 
                #"voir axeC_BG solution old=",*axeCpos_BG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_BG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_BG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_BG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_BG = 0
                ]
                reel_axeCpos_BG = axeCpos_BG
                new_m8 = m8print * cos(axeCpos_BG) - m7print * sin(axeCpos_BG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_BG = atan2(-new_m8,-m9print) # pafichecala_BG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_BG = 90 # pas d'angle sur a
                else,  axeApos_BG = atan2(m9print,new_m8)
                ]
               !axeApos_BG
               if axeApos_BG > 270, axeApos_BG = axeApos_BG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_BG = axeApos_BG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_BG = axeCpos_BG
               axeApos1_BG = axeApos_BG
               if tete_rev_ang_droite = 1,	[
			   													if m9$ < 0, invers_BG = 1  # pas de choix sens A si tete a renvoi d'angle
																else,  invers_BG = 0
																]
               if tete_rev_ang_gauche = 1,	[
			   													if m9$ < 0, invers_BG = 0  # inversion de A si 2 em broche des tete a renvoi d'angle
																else,  invers_BG = 1
																]
			   if invers_BG = 1,
               [
                axeApos1_BG = axeApos1_BG *  -1
                if axeCpos1_BG >= 180, axeCpos1_BG = axeCpos1_BG - 180
                else, axeCpos1_BG = axeCpos1_BG + 180
               ]
               if mi1_C_base_BG =  2, axeCpos1_BG = axeCpos1_BG - 360
               !axeApos_BG, !new_m8, !axeCpos_BG         #actualise les variable
               if axeApos_BG > maxi_a_BG | axeApos_BG < mini_a_BG, psortie10_BG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 

prot1_CG     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_CG, @maxi_a_CG, @mini_c_CG, @maxi_c_CG, @nbt_CG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_CG = atan2(m2print,m1print) 
                #"voir axeC_CG solution old=",*axeCpos_CG, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_CG = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_CG = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_CG = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CG = 0
                ]
                reel_axeCpos_CG = axeCpos_CG
                new_m8 = m8print * cos(axeCpos_CG) - m7print * sin(axeCpos_CG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_CG = atan2(-new_m8,-m9print) # pafichecala_CG #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_CG = 90 # pas d'angle sur a
                else,  axeApos_CG = atan2(m9print,new_m8)
                ]
               !axeApos_CG
               if axeApos_CG > 270, axeApos_CG = axeApos_CG - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_CG = axeApos_CG - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_CG = axeCpos_CG - 90
               axeApos1_CG = axeApos_CG
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CG = 0, axeCpos1_CG = 0
               if tete_rev_ang_droite = 1,	[
			   													if m9$ < 0, invers_CG = 1  # pas de choix sens A si tete a renvoi d'angle
																else,  invers_CG = 0
																]
               if tete_rev_ang_gauche = 1,	[
			   													if m9$ < 0, invers_CG = 0  # inversion de A si 2 em broche des tete a renvoi d'angle
																else,  invers_CG = 1
																]
			   
			   if invers_CG = 1,
               [
                axeApos1_CG = axeApos1_CG *  -1
                if axeCpos1_CG >= 180, axeCpos1_CG = axeCpos1_CG - 180
                else, axeCpos1_CG = axeCpos1_CG + 180
               ]
               if mi1_C_base_CG =  2, axeCpos1_CG = axeCpos1_CG - 360
               !axeApos_CG, !new_m8, !axeCpos_CG         #actualise les variable
               if axeApos_CG > maxi_a_CG | axeApos_CG < mini_a_CG, psortie10_CG # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CG = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CG = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 
prot1_AM        # Calcul des angles
                # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
                #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_AM, @maxi_a_AM, @mini_c_AM, @maxi_c_AM, @nbt_AG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_AM = atan2(m2print,m1print) 
                #"voir axeC_AM solution old=",*axeCpos_AM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_AM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_AM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0,axeCpos_AM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_AM = 0
                ]
                reel_axeCpos_AM = axeCpos_AM
                new_m8 = m8print * cos(axeCpos_AM) - m7print * sin(axeCpos_AM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (t$ = tete_rev_ang_11 | t$ = tete_rev_ang_12 | t$ = tete_rev_ang_21 | t$ = tete_rev_ang_22) & mod5xcont = 0, axeApos_AM = atan2(-new_m8,-m9print) # pafichecala_AM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_AM = 90 # pas d'angle sur a
                else,  axeApos_AM = atan2(m9print,new_m8)
                ]
               !axeApos_AM
               if axeApos_AM > 270, axeApos_AM = axeApos_AM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_AM = axeApos_AM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_AM = axeCpos_AM
               axeApos1_AM = axeApos_AM

               if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
			   													if m9$ < 0, invers_AM = 1
																else, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
																]
               if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22,	[
			   													if m9$ < 0, invers_AM = 0
																else, invers_AM = 1  # pas de choix sens A si tete a renvoi d'angle
																]
               if invers_AM = 1,
               [
                axeApos1_AM = axeApos1_AM *  -1
                if axeCpos1_AM >= 180, axeCpos1_AM = axeCpos1_AM - 180
                else, axeCpos1_AM = axeCpos1_AM + 180
               ]
               if mi1_C_base_AM =  2, axeCpos1_AM = axeCpos1_AM - 360
               !axeApos_AM, !new_m8, !axeCpos_AM         #actualise les variable
               if axeApos_AM > maxi_a_AM | axeApos_AM < mini_a_AM, psortie10_AM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_AM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a       

prot1_BM     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_BM, @maxi_a_BM, @mini_c_BM, @maxi_c_BM, @nbt_BG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_BM = atan2(m2print,m1print) 
                #"voir axeC_BM solution old=",*axeCpos_BM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_BM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_BM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_BM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_BM = 0
                ]
                reel_axeCpos_BM = axeCpos_BM
                new_m8 = m8print * cos(axeCpos_BM) - m7print * sin(axeCpos_BM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_BM = atan2(-new_m8,-m9print) # pafichecala_BM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_BM = 90 # pas d'angle sur a
                else,  axeApos_BM = atan2(m9print,new_m8)
                ]
               !axeApos_BM
               if axeApos_BM > 270, axeApos_BM = axeApos_BM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_BM = axeApos_BM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_BM = axeCpos_BM
               axeApos1_BM = axeApos_BM
               if tete_rev_ang_droite = 1,	[
			   													if m9$ < 0, invers_BM = 1  # pas de choix sens A si tete a renvoi d'angle
																else,  invers_BM = 0
																]
               if tete_rev_ang_gauche = 1,	[
			   													if m9$ < 0, invers_BM = 0  # inversion de A si 2 em broche des tete a renvoi d'angle
																else,  invers_BM = 1
																]
			   if invers_BM = 1,
               [
                axeApos1_BM = axeApos1_BM *  -1
                if axeCpos1_BM >= 180, axeCpos1_BM = axeCpos1_BM - 180
                else, axeCpos1_BM = axeCpos1_BM + 180
               ]
               if mi1_C_base_BM =  2, axeCpos1_BM = axeCpos1_BM - 360
               !axeApos_BM, !new_m8, !axeCpos_BM         #actualise les variable
               if axeApos_BM > maxi_a_BM | axeApos_BM < mini_a_BM, psortie10_BM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_BM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a 

prot1_CM     # Calcul des angles
               # " les series M ", *m1$,*m2$,*m3$,*m4$,*m5$,*m6$,*m7$,*m8$,*m9$, e$
               #" les series M print ", *m1print,*m2print,*m3print,*m4print,*m5print,*m6print,*m7print,*m8print,*m9print, e$
                @mini_a_CM, @maxi_a_CM, @mini_c_CM, @maxi_c_CM, @nbt_CG, !calculduplan     # mise a jour des butees machine ecrit au debut pst
                #axeCpos_CM = atan2(m2print,m1print) 
                #"voir axeC_CM solution old=",*axeCpos_CM, e$     
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeCpos_CM = atan2(m2print,m1print) # seul C tourne ( dessus ) donc autre matrice
                else, axeCpos_CM = atan2(m7print,-m8print)               #CALCUL AXE C
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0,axeCpos_CM = atan2(m7print,-m8print) #CALCUL AXE C en renvoie angle
                else,
                [
                    if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CM = 0
                ]
                reel_axeCpos_CM = axeCpos_CM
                new_m8 = m8print * cos(axeCpos_CM) - m7print * sin(axeCpos_CM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
                if (tete_rev_ang_droite = 1 | tete_rev_ang_gauche = 1) & mod5xcont = 0, axeApos_CM = atan2(-new_m8,-m9print) # pafichecala_CM #      #calcul axe A avec renvoie d'angle
                else,# pas en mode renvoie d'angle 
                [
                if m7$ = 0 & m8$ = 0 & m9$ = 1, axeApos_CM = 90 # pas d'angle sur a
                else,  axeApos_CM = atan2(m9print,new_m8)
                ]
               !axeApos_CM
               if axeApos_CM > 270, axeApos_CM = axeApos_CM - 360 #ajustement sur quadran 270 - 0 pour ligne suivante
               axeApos_CM = axeApos_CM - 90              #retire 90 deg car 0 pour cette machine = - 90
               axeCpos1_CM = axeCpos_CM - 90
               axeApos1_CM = axeApos_CM
               if m1$ = 1 & m5$ = 1 & m9$ = 1, axeCpos_CM = 0, axeCpos1_CM = 0
               if tete_rev_ang_droite = 1,	[
			   													if m9$ < 0, invers_CM = 1  # pas de choix sens A si tete a renvoi d'angle
																else,  invers_CM = 0
																]
               if tete_rev_ang_gauche = 1,	[
			   													if m9$ < 0, invers_CM = 0  # inversion de A si 2 em broche des tete a renvoi d'angle
																else,  invers_CM = 1
																]
			   if invers_CM = 1,
               [
                axeApos1_CM = axeApos1_CM *  -1
                if axeCpos1_CM >= 180, axeCpos1_CM = axeCpos1_CM - 180
                else, axeCpos1_CM = axeCpos1_CM + 180
               ]
               if mi1_C_base_CM =  2, axeCpos1_CM = axeCpos1_CM - 360
               !axeApos_CM, !new_m8, !axeCpos_CM         #actualise les variable
               if axeApos_CM > maxi_a_CM | axeApos_CM < mini_a_CM, psortie10_CM # verif si plan possible 
                tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CM = 0, tourne = (atan2(m3$,m6$)) *  -1
                #if invers_CM = 1, tourne = ((atan2(m3$,m6$)) *  -1)+ 180    
                if m7$ = 0 & m8$ = 0 & m9$ = 1, tourne = 0 # pas d'angle a
#endregion
pmiscparam$
#region pcalxyz3d_renvoi

pcalxyz3d_renvoi_AG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_AG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_AG) - m7$ * sin(axeCpos_AG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_AG = atan2(m9$,new_m8)
        if axeApos_AG > 270, axeApos_AG = axeApos_AG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_AG = axeApos_AG - 90
        axeacal = (90 - axeApos_AG)
        axeccal = axeCpos_AG + 270
        #"voir les rapide", *xprint_AG, *yprint_AG, *zprint_AG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_AG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_AG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]


        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AG",*z1_AG,e

        x3dprint_AG = xr$ #+ tox4print_AG
        y3dprint_AG = yr$ #+ toy4print_AG
        z3dprint_AG = zr$ #+ toz4print_AG

        prot1_AG   # remise a jour des angles

pcalxyz3d_renvoi_BG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_BG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_BG) - m7$ * sin(axeCpos_BG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_BG = atan2(m9$,new_m8)
        if axeApos_BG > 270, axeApos_BG = axeApos_BG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_BG = axeApos_BG - 90
        axeacal = (90 - axeApos_BG)
        axeccal = axeCpos_BG + 270
        #"voir les rapide", *xprint_BG, *yprint_BG, *zprint_BG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_BG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_BG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_BG = xr$ #+ tox4print_BG
        y3dprint_BG = yr$ #+ toy4print_BG
        z3dprint_BG = zr$ #+ toz4print_BG

        prot1_BG   # remise a jour des angles 

pcalxyz3d_renvoi_CG #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_CG = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_CG) - m7$ * sin(axeCpos_CG)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_CG = atan2(m9$,new_m8)
        if axeApos_CG > 270, axeApos_CG = axeApos_CG - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_CG = axeApos_CG - 90
        axeacal = (90 - axeApos_CG)
        axeccal = axeCpos_CG + 270
        #"voir les rapide", *xprint_CG, *yprint_CG, *zprint_CG, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_CG =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_CG =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_CG = xr$ #+ tox4print_CG
        y3dprint_CG = yr$ #+ toy4print_CG
        z3dprint_CG = zr$ #+ toz4print_CG

        prot1_CG   # remise a jour des angles 

pcalxyz3d_renvoi_AM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_AM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_AM) - m7$ * sin(axeCpos_AM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_AM = atan2(m9$,new_m8)
        if axeApos_AM > 270, axeApos_AM = axeApos_AM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_AM = axeApos_AM - 90
        axeacal = (90 - axeApos_AM)
        axeccal = axeCpos_AM + 270
        #"voir les rapide", *xprint_AM, *yprint_AM, *zprint_AM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_AM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_AM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]


        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AM",*z1_AM,e

        x3dprint_AM = x1 #+ tox4print_AM
        y3dprint_AM = y2 #+ toy4print_AM
        z3dprint_AM = z1_AM #+ toz4print_AM

        prot1_AM   # remise a jour des angles

pcalxyz3d_renvoi_BM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_BM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_BM) - m7$ * sin(axeCpos_BM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_BM = atan2(m9$,new_m8)
        if axeApos_BM > 270, axeApos_BM = axeApos_BM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_BM = axeApos_BM - 90
        axeacal = (90 - axeApos_BM)
        axeccal = axeCpos_BM + 270
        #"voir les rapide", *xprint_BM, *yprint_BM, *zprint_BM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_BM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_BM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_BM = x1 #+ tox4print_BM
        y3dprint_BM = y2 #+ toy4print_BM
        z3dprint_BM = z1_BM #+ toz4print_BM

        prot1_BM   # remise a jour des angles 

pcalxyz3d_renvoi_CM #calcul de x y z dans la repere origine piece 3 D avec renvoi d'angle

        axeCpos_CM = atan2(m7$,-m8$)                           #CALCUL AXE C
        new_m8 = m8$ * cos(axeCpos_CM) - m7$ * sin(axeCpos_CM)   #l'axe C tourne entrainant l'axe a donc calcule du nouveau m8 
        axeApos_CM = atan2(m9$,new_m8)
        if axeApos_CM > 270, axeApos_CM = axeApos_CM - 360          #ajustement sur quadran 270 - 0 pour ligne suivante
        axeApos_CM = axeApos_CM - 90
        axeacal = (90 - axeApos_CM)
        axeccal = axeCpos_CM + 270
        #"voir les rapide", *xprint_CM, *yprint_CM, *zprint_CM, e$
        if calculduplan = 0, # on ne recalcule pas les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - yr$ * sin(axeacal)
                        z1_CM =   zrcal * sin(axeacal) + yr$ * cos(axeacal)
                        x1 =  y1 * cos(axeccal) - xr$ * sin(axeccal)
                        y2 =  y1 * sin(axeccal) + xr$ * cos(axeccal )
                        ]
        else, # on  recalcule les plan tournes
                        [
                        y1 =   zrcal * cos(axeacal) - ((yr$*cos(tourne) - xr$*sin(tourne)) * sin(axeacal))
                        z1_CM =   zrcal * sin(axeacal) + ((yr$*cos(tourne) - xr$*sin(tourne)) * cos(axeacal))
                        x1 =  y1 * cos(axeccal) - ((yr$*sin(tourne) + xr$*cos(tourne)) * sin(axeccal))
                        y2 =  y1 * sin(axeccal) + ((yr$*sin(tourne) + xr$*cos(tourne)) * cos(axeccal ))
                        ]
        x3dprint_CM = x1 #+ tox4print_CM
        y3dprint_CM = y2 #+ toy4print_CM
        z3dprint_CM = z1_CM #+ toz4print_CM

        prot1_CM   # remise a jour des angles
#endregion
#region pcalxyz3d_normal

pcalxyz3d_normal_AG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_AG)
        axeccal = axeCpos_AG + 270
        #"voir les rapide", *xprint_AG, *yprint_AG, *zprint_AG, e$
        y1 =   zrprint_AG * cos(axeacal) - yrprint_AG * sin(axeacal)
        z1_AG =   zrprint_AG * sin(axeacal) + yrprint_AG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_AG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_AG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AG",*z1_AG,e

        x3dprint_AG = xr$ #+ tox4print_AG
        y3dprint_AG = yr$ #+ toy4print_AG
        z3dprint_AG = zr$ #+ toz4print_AG

pcalxyz3d_normal_BG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_BG)
        axeccal = axeCpos_BG + 270
        #"voir les rapide", *xprint_BG, *yprint_BG, *zprint_BG, e$
        y1 =   zrprint_BG * cos(axeacal) - yrprint_BG * sin(axeacal)
        z1_BG =   zrprint_BG * sin(axeacal) + yrprint_BG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_BG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_BG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_BG",*z1_BG,e

        x3dprint_BG = xr$ #+ tox4print_BG
        y3dprint_BG = yr$ #+ toy4print_BG
        z3dprint_BG = zr$ #+ toz4print_BG

pcalxyz3d_normal_CG #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_CG)
        axeccal = axeCpos_CG + 270
        #"voir les rapide", *xprint_CG, *yprint_CG, *zprint_CG, e$
        y1 =   zrprint_CG * cos(axeacal) - yrprint_CG * sin(axeacal)
        z1_CG =   zrprint_CG * sin(axeacal) + yrprint_CG * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_CG * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_CG * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_CG",*z1_CG,e

        x3dprint_CG = xr$ #+ tox4print_CG
        y3dprint_CG = yr$ #+ toy4print_CG
        z3dprint_CG = zr$ #+ toz4print_CG

pcalxyz3d_normal_AM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_AM)
        axeccal = axeCpos_AM + 270
        #"voir les rapide", *xprint_AM, *yprint_AM, *zprint_AM, e$
        y1 =   zrprint_AM * cos(axeacal) - yrprint_AM * sin(axeacal)
        z1_AM =   zrprint_AM * sin(axeacal) + yrprint_AM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_AM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_AM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_AM",*z1_AM,e

        x3dprint_AM = x1 #+ tox4print_AM
        y3dprint_AM = y2 #+ toy4print_AM
        z3dprint_AM = z1_AM #+ toz4print_AM

pcalxyz3d_normal_BM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_BM)
        axeccal = axeCpos_BM + 270
        #"voir les rapide", *xprint_BM, *yprint_BM, *zprint_BM, e$
        y1 =   zrprint_BM * cos(axeacal) - yrprint_BM * sin(axeacal)
        z1_BM =   zrprint_BM * sin(axeacal) + yrprint_BM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_BM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_BM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_BM",*z1_BM,e

        x3dprint_BM = x1 #+ tox4print_BM
        y3dprint_BM = y2 #+ toy4print_BM
        z3dprint_BM = z1_BM #+ toz4print_BM

pcalxyz3d_normal_CM #calcul de x y z dans la repere origine piece 3 D

        # "xryrzr",*xr,*yr,*zr, e
        axeacal = (90 - axeApos_CM)
        axeccal = axeCpos_CM + 270
        #"voir les rapide", *xprint_CM, *yprint_CM, *zprint_CM, e$
        y1 =   zrprint_CM * cos(axeacal) - yrprint_CM * sin(axeacal)
        z1_CM =   zrprint_CM * sin(axeacal) + yrprint_CM * cos(axeacal)

        x1 =  y1 * cos(axeccal) - xrprint_CM * sin(axeccal)
        y2 =  y1 * sin(axeccal) + xrprint_CM * cos(axeccal )



        #"X1",*x1,"Y1",*y1,"Y2",y2,"z1_CM",*z1_CM,e

        x3dprint_CM = x1 #+ tox4print_CM
        y3dprint_CM = y2 #+ toy4print_CM
        z3dprint_CM = z1_CM #+ toz4print_CM     
#endregion
#region pcalxyz3d

pcalxyz3d_AG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_AG = 1, pcalxyz3d_renvoi_AG
        else, pcalxyz3d_normal_AG

pcalxyz3d_BG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_BG = 1, pcalxyz3d_renvoi_BG
        else, pcalxyz3d_normal_BG

pcalxyz3d_CG #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_CG = 1, pcalxyz3d_renvoi_CG
        else, pcalxyz3d_normal_CG
pcalxyz3d_AM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_AM = 1, pcalxyz3d_renvoi_AM
        else, pcalxyz3d_normal_AM

pcalxyz3d_BM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_BM = 1, pcalxyz3d_renvoi_BM
        else, pcalxyz3d_normal_BM

pcalxyz3d_CM #calcul de x y z dans la repere origine piece 3 d
        if tete_rev_CM = 1, pcalxyz3d_renvoi_CM
        else, pcalxyz3d_normal_CM
#endregion
#region prot2

prot2_AG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_AG
            # if mr2 < z1_AG, n, pgcode_AG, z1_AG #    masque pour test
            if mr2print_AG < z3dprint_AG & mr2print_AG <>   -1,sr, *z3dprint_AG, paf, pgcode_AG, *z3dprint_AG, e$
            if nextop$ <> 11, sm, paf, "G151 EC0. EA0. EU0. EV0. EW0.", e$
			srtcpon, e$
			if mr2print_AG <> -1,	[
            						if nextop$ <> 11, sr, *xrprint_AG,*yrprint_AG,*mr2print_AG,*axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*axeCpos1_AG, *axeApos1_AG,e$
            						]
			if mr2print_AG = -1,	[
            						if nextop$ <> 11, sr, *xrprint_AG,*yrprint_AG,*zrprint_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*axeCpos1_AG, *axeApos1_AG,e$
            						]			
			
			if nextop$ <> 11, sm, paf, "G151", *axeCpos_AG, *axeApos_AG, *tox4print_AG, *toy4print_AG, *toz4print_AG, e$
            #else, n, pgcode_force_AG, *x1,*y2,e
            if axeCpos1_AG <> 0 | axeApos1_AG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_AG = 9999, zprint_AG = zrprint_AG
            if nextop$ <> 11, sr, *xrprint_AG,*yrprint_AG,*zrprint_AG, paf, pgcode_force_AG,*xrprint_AG,*yrprint_AG,*zrprint_AG, e$
            old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AG = toy4print_AG
            old_toz4_AG = toz4print_AG
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG

prot2_BG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_BG
            # if mr2 < z1_BG, n, pgcode_BG, z1_BG #    masque pour test
            if mr2print_BG < z3dprint_BG & mr2print_BG <>   -1,sr, *z3dprint_BG, paf, pgcode_BG, *z3dprint_BG, e$
            if nextop$ <> 11, panul_plan_inc_BG
			srtcpon, e$
			if mr2print_BG <> -1,	[
            						if nextop$ <> 11, sr, *xrprint_BG,*yrprint_BG,*mr2print_BG,*axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*axeCpos1_BG, *axeApos1_BG, e$
            						]
			if mr2print_BG = -1,	[
            						if nextop$ <> 11, sr, *xrprint_BG,*yrprint_BG,*zrprint_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*axeCpos1_BG, *axeApos1_BG, e$
            						]			
			
			if nextop$ <> 11, sm,paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm, paf, "AROT", *axeCpos_BG, *axeApos_BG, e$
            #else, n, pgcode_force_BG, *x1,*y2,e
            if axeCpos1_BG <> 0 | axeApos1_BG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_BG = 9999, zprint_BG = zrprint_BG
            if nextop$ <> 11, sr, *xrprint_BG,*yrprint_BG,*zrprint_BG, paf,pgcode_force_BG,*xrprint_BG,*yrprint_BG,*zrprint_BG, e$
            old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BG = toy4print_BG
            old_toz4_BG = toz4print_BG
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG

prot2_CG      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_CG
            # if mr2 < z1_CG, n, pgcode_CG, z1_CG #    masque pour test
            if mr2print_CG < z3dprint_CG & mr2print_CG <>   -1,sr, *z3dprint_CG, paf, pgcode_CG, *z3dprint_CG, e$
            if nextop$ <> 11, panul_plan_inc_CG
			if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        	if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
			srtcpon, e$
			if mr2print_CG <> -1,	[
            						if nextop$ <> 11, sr, *xrprint_CG,*yrprint_CG,*mr2print_CG,*axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*axeCpos1_CG, *axeApos1_CG, e$
            						]
			if mr2print_CG = -1,	[
            						if nextop$ <> 11, sr, *xrprint_CG,*yrprint_CG,*zrprint_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*axeCpos1_CG, *axeApos1_CG, e$
            						]
									
			if nextop$ <> 11, sm,paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm, paf, "AROT", *axeCpos_CG, *axeApos_CG, e$
            if nextop$ <> 11, sm, paf, "M32 ; BLOCAGE AXE B", e$, sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
            #else, n, pgcode_force_CG, *x1,*y2,e
            if axeCpos1_CG <> 0 | axeApos1_CG <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_CG = 9999, zprint_CG = zrprint_CG
            if nextop$ <> 11, sr, *xrprint_CG,*yrprint_CG,*zrprint_CG, paf,pgcode_force_CG,*xrprint_CG,*yrprint_CG,*zrprint_CG, e$
            old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CG = toy4print_CG
            old_toz4_CG = toz4print_CG
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG
prot2_AM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_AM
            # if mr2 < z1_AM, n, pgcode_AM, z1_AM #    masque pour test
            if mr2print_AM < z3dprint_AM & mr2print_AM <>   -1,pnumligne, pgcode_AM, z3dprint_AM, e$
            if nextop$ <> 11, pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if nextop$ <> 11, pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
            if nextop$ <> 11, pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
            #else, n, pgcode_force_AM, *x1,*y2,e
            if axeCpos1_AM <> 0 | axeApos1_AM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_AM = 9999, zprint_AM = zrprint_AM
            if nextop$ <> 11, pnumligne, pgcode_force_AM,xrprint_AM,yrprint_AM,zrprint_AM, e$
            old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AM = toy4print_AM
            old_toz4_AM = toz4print_AM
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM

prot2_BM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_BM
            # if mr2 < z1_BM, n, pgcode_BM, z1_BM #    masque pour test
            if mr2print_BM < z3dprint_BM & mr2print_BM <>   -1,pnumligne, pgcode_BM, z3dprint_BM, e$
            if nextop$ <> 11, panul_plan_inc_BM
            if nextop$ <> 11, pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
            if nextop$ <> 11, pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
            #else, n, pgcode_force_BM, *x1,*y2,e
            if axeCpos1_BM <> 0 | axeApos1_BM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_BM = 9999, zprint_BM = zrprint_BM
            if nextop$ <> 11, pnumligne, pgcode_force_BM,xrprint_BM,yrprint_BM,zrprint_BM, e$
            old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BM = toy4print_BM
            old_toz4_BM = toz4print_BM
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM

prot2_CM      # Affichage des angles pour changement d'outil
            gcode$ = 0
            #   "opcode = ", *opcode ,e
            pcalxyz3d_CM
            # if mr2 < z1_CM, n, pgcode_CM, z1_CM #    masque pour test
            if mr2print_CM < z3dprint_CM & mr2print_CM <>   -1,pnumligne, pgcode_CM, z3dprint_CM, e$
            if nextop$ <> 11, panul_plan_inc_CM
            if nextop$ <> 11, pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
            if nextop$ <> 11, pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
            if nextop$ <> 11, pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
            #else, n, pgcode_force_CM, *x1,*y2,e
            if axeCpos1_CM <> 0 | axeApos1_CM <> 0, plinc5a = 1 # Flag pour plan incline actif
            else, plinc5a = 0
            if zprint_CM = 9999, zprint_CM = zrprint_CM
            if nextop$ <> 11, pnumligne, pgcode_force_CM,xrprint_CM,yrprint_CM,zrprint_CM, e$
            old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CM = toy4print_CM
            old_toz4_CM = toz4print_CM
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM
#endregion
#region prot3

prot3_AG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         sm, paf, "G151 EC0. EA0. EU0. EV0. EW0.",e$
             if mr2print_AG = 0, mr2print_AG =zsecuprint
         pcalxyz3d_AG
		 srtcpon, e$
         if mr2print_AG < z3dprint_AG & mr2print_AG <>   -1,    [
                                                                if flag_cloche_AG = 1, sr, *z3dprint_AG, sazero, sczero, paf, pgcode_AG, *z3dprint_AG, sm, sxcloche_AG, sycloche_AG,e$, flag_cloche_AG = 0
                                                                else, sr, *z3dprint_AG, paf, pgcode_AG, *z3dprint_AG, e$
                                                                ]
         if mr2print_AG >= z3dprint_AG & mr2print_AG <>   -1,   [
                                                                if flag_cloche_AG = 1, sr, *mr2print_AG, sazero, sczero, paf,pgcode_AG, *mr2$, sm, sxcloche_AG, sycloche_AG, e$,flag_cloche_AG = 0
                                                                else, sr, *mr2print_AG, paf,pgcode_AG, *mr2$,e$
                                                                ]
             if mr2print_AG <>   -1,sr, *xrprint_AG,*yrprint_AG,*axeCpos1_AG, *axeApos1_AG, paf,pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*axeCpos1_AG, *axeApos1_AG,e$
             else, sr, *xrprint_AG,*yrprint_AG,*zrprint_AG,*axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*z3dprint_AG,*axeCpos1_AG, *axeApos1_AG,e$

             sm, paf, "G151", *axeCpos_AG, *axeApos_AG,  *tox4print_AG, *toy4print_AG, *toz4print_AG,e$
             if opcode$ = 3, sr, *xrprint_AG,*yrprint_AG,*zrprint_AG, paf, pgcode_AG, *xrprint_AG,*yrprint_AG,*zrprint_AG, e$
        #     else , n, pgcode_AG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AG = toy4print_AG
           old_toz4_AG = toz4print_AG
           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

prot3_BG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_BG
             if mr2print_BG = 0, mr2print_BG =zsecuprint
         pcalxyz3d_BG
		 srtcpon, e$
         if mr2print_BG < z3dprint_BG & mr2print_BG <>   -1,    [
                                                                if flag_cloche_BG = 1, sr, *z3dprint_BG, sazero, sczero, paf, pgcode_BG, *z3dprint_BG, sm, sxcloche_BG, sycloche_BG, e$, flag_cloche_BG = 0
                                                                else, sr, *z3dprint_BG, paf, pgcode_BG, *z3dprint_BG, e$
                                                                ]
         if mr2print_BG >= z3dprint_BG & mr2print_BG <>   -1,   [
                                                                if flag_cloche_BG = 1, sr, *mr2print_BG, sazero, sczero, paf, pgcode_BG, *mr2$, sm, sxcloche_BG, sycloche_BG,e$, flag_cloche_BG = 0
                                                                else, sr, *mr2print_BG, paf,pgcode_BG, *mr2$, e$
                                                                ]

             if mr2print_BG <>   -1,sr, *xrprint_BG,*yrprint_BG,*axeCpos1_BG, *axeApos1_BG, paf,pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*axeCpos1_BG, *axeApos1_BG, e$
             else, sr, *xrprint_BG,*yrprint_BG,*zrprint_BG,*axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*z3dprint_BG,*axeCpos1_BG, *axeApos1_BG, e$

             sm, paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm, paf, "AROT", axeCpos_BG, axeApos_BG, e$
             if opcode$ = 3, sr, *xrprint_BG,*yrprint_BG,*zrprint_BG, paf, pgcode_BG, *xrprint_BG,*yrprint_BG,*zrprint_BG, e$
        #     else , n, pgcode_BG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BG = toy4print_BG
           old_toz4_BG = toz4print_BG
           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

prot3_CG      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_CG
             if mr2print_CG = 0, mr2print_CG =zsecuprint
         pcalxyz3d_CG
		 srtcpon, e$
         					if mr2print_CG < z3dprint_CG & mr2print_CG <>   -1,	[
																				if garage_CG <> 0, sr, sbzero, *z3dprint_CG, paf, pgcode_CG, *z3dprint_CG, e$
																				else, sr, *z3dprint_CG, paf, pgcode_CG, *z3dprint_CG, e$
																				]
         					if mr2print_CG >= z3dprint_CG & mr2print_CG <>   -1,	[
																					if garage_CG <> 0, sr, sbzero, *mr2print_CG, paf,pgcode_CG, *mr2$, e$
																					else, sr, *mr2print_CG, paf,pgcode_CG, *mr2$, e$
																					]
		 	if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        	if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
             if mr2print_CG <>   -1,	[
			 							if garage_CG <> 0, sr, *axeCpos1_CG, paf,pgcode_force_CG, *axeCpos1_CG,e$
										sr, *xrprint_CG,*yrprint_CG,*axeCpos1_CG, *axeApos1_CG, paf,pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*axeCpos1_CG, *axeApos1_CG, e$
										]
             else, sr, *xrprint_CG,*yrprint_CG,*zrprint_CG,*axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*z3dprint_CG,*axeCpos1_CG, *axeApos1_CG, e$

             sm, paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm, paf, "AROT", axeCpos_CG, axeApos_CG, e$
             sm, paf, "M32 ; BLOCAGE AXE B", e$, sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
             if opcode$ = 3, sr, *xrprint_CG,*yrprint_CG,*zrprint_CG, paf, pgcode_CG, *xrprint_CG,*yrprint_CG,*zrprint_CG, e$
        #     else , n, pgcode_CG, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CG = toy4print_CG
           old_toz4_CG = toz4print_CG
           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

prot3_AM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
             if mr2print_AM = 0, mr2print_AM =zsecuprint
         pcalxyz3d_AM
         if mr2print_AM < z3dprint_AM & mr2print_AM <>   -1,pnumligne, pgcode_AM, z3dprint_AM, e$
         if mr2print_AM >= z3dprint_AM & mr2print_AM <>   -1,pnumligne,pgcode_AM, mr2print_AM, e$
             if mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
             else, pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,*z3dprint_AM,axeCpos1_AM, axeApos1_AM, e$

             pnumligne, "G151", axeCpos_AM, axeApos_AM,  tox4print_AM, toy4print_AM, toz4print_AM, e$
             if opcode$ = 3, pnumligne, pgcode_AM, xrprint_AM,yrprint_AM,zrprint_AM, e$
        #     else , n, pgcode_AM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AM = toy4print_AM
           old_toz4_AM = toz4print_AM
           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

prot3_BM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_BM
             if mr2print_BM = 0, mr2print_BM =zsecuprint
         pcalxyz3d_BM
         if mr2print_BM < z3dprint_BM & mr2print_BM <>   -1,pnumligne, pgcode_BM, z3dprint_BM, e$
         if mr2print_BM >= z3dprint_BM & mr2print_BM <>   -1,pnumligne,pgcode_BM, mr2print_BM, e$
             if mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
             else, pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,*z3dprint_BM,axeCpos1_BM, axeApos1_BM, e$

             pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
             if opcode$ = 3, pnumligne, pgcode_BM, xrprint_BM,yrprint_BM,zrprint_BM, e$
        #     else , n, pgcode_BM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BM = toy4print_BM
           old_toz4_BM = toz4print_BM
           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

prot3_CM      # Affichage des angles pour changement d'outil nul
         gcode$ = 0

         panul_plan_inc_CM
             if mr2print_CM = 0, mr2print_CM =zsecuprint
         pcalxyz3d_CM
         if mr2print_CM < z3dprint_CM & mr2print_CM <>   -1,pnumligne, pgcode_CM, z3dprint_CM, e$
         if mr2print_CM >= z3dprint_CM & mr2print_CM <>   -1,pnumligne,pgcode_CM, mr2print_CM, e$
             if mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
             else, pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,*z3dprint_CM,axeCpos1_CM, axeApos1_CM, e$

             pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
             pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
             if opcode$ = 3, pnumligne, pgcode_CM, xrprint_CM,yrprint_CM,zrprint_CM, e$
        #     else , n, pgcode_CM, zr  # desactive le 9-11-01 mais voir si cela ne gene pas ailleur

           old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CM = toy4print_CM
           old_toz4_CM = toz4print_CM
           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM
#endregion
#region pcaldrilxyzsimu #rajouté pour simulation
pcaldrilxyzsimu_AG  # calcul des point dans le plan de l'axe outil
            #"voir xyz", *x$ ," ", *y$," ", *z$," ", *u$," ", *v$," ", *w$," ", *initht$, " ",*refht$," ", *depth$,   e$ 

            v_delta_x_AG = x$ - u$
            v_delta_y_AG = y$ - v$
            v_delta_z_AG = z$ - w$
            v_delta_xyz_AG = sqrt(v_delta_x_AG^2 + v_delta_y_AG^2 + v_delta_z_AG^2)
            v_sindir_x_AG = v_delta_x_AG/v_delta_xyz_AG
            v_sindir_y_AG = v_delta_y_AG/v_delta_xyz_AG
            v_sindir_z_AG = v_delta_z_AG/v_delta_xyz_AG

            v_abs_plus_x_AG = u$#x$ - (initht$ * v_sindir_x_AG)
            v_abs_plus_y_AG = v$#y$ - (initht$ * v_sindir_y_AG)
            v_abs_plus_z_AG = w$#z$ - (initht$ * v_sindir_z_AG)

            v_abs_plus_x_sec_AG = x$ - ((depth$ * -1 + initht$) * v_sindir_x_AG)
            v_abs_plus_y_sec_AG = y$ - ((depth$ * -1 + initht$) * v_sindir_y_AG)
            v_abs_plus_z_sec_AG = z$ - ((depth$ * -1 + initht$) * v_sindir_z_AG)
            #"voir v_abs_plus_x_AG", " ",*v_abs_plus_x_AG," ", *v_abs_plus_y_AG," ", *v_abs_plus_z_AG, e$
            v_abs_plus_x_sec_fin_AG = x$ - ((depth$ * -1 + old_zinitht_AG) * v_sindir_x_AG)
            v_abs_plus_y_sec_fin_AG = y$ - ((depth$ * -1 + old_zinitht_AG) * v_sindir_y_AG)
            v_abs_plus_z_sec_fin_AG = z$ - ((depth$ * -1 + old_zinitht_AG) * v_sindir_z_AG)

            #axeccalsimu = axeC5xsimu
            #axeacalsimu = axeB5xsimu

            xprint_AG = x$
            yprint_AG = y$
            zprint_AG = z$ # + ( depth$ * -1 + initht$ )

pcaldrilxyzsimu_BG  # calcul des point dans le plan de l'axe outil
            #"voir xyz", *x$ ," ", *y$," ", *z$," ", *u$," ", *v$," ", *w$," ", *initht$, " ",*refht$," ", *depth$,   e$ 

            v_delta_x_BG = x$ - u$
            v_delta_y_BG = y$ - v$
            v_delta_z_BG = z$ - w$
            v_delta_xyz_BG = sqrt(v_delta_x_BG^2 + v_delta_y_BG^2 + v_delta_z_BG^2)
            v_sindir_x_BG = v_delta_x_BG/v_delta_xyz_BG
            v_sindir_y_BG = v_delta_y_BG/v_delta_xyz_BG
            v_sindir_z_BG = v_delta_z_BG/v_delta_xyz_BG

            v_abs_plus_x_BG = u$#x$ - (initht$ * v_sindir_x_BG)
            v_abs_plus_y_BG = v$#y$ - (initht$ * v_sindir_y_BG)
            v_abs_plus_z_BG = w$#z$ - (initht$ * v_sindir_z_BG)

            v_abs_plus_x_sec_BG = x$ - ((depth$ * -1 + initht$) * v_sindir_x_BG)
            v_abs_plus_y_sec_BG = y$ - ((depth$ * -1 + initht$) * v_sindir_y_BG)
            v_abs_plus_z_sec_BG = z$ - ((depth$ * -1 + initht$) * v_sindir_z_BG)
            #"voir v_abs_plus_x_BG", " ",*v_abs_plus_x_BG," ", *v_abs_plus_y_BG," ", *v_abs_plus_z_BG, e$
            v_abs_plus_x_sec_fin_BG = x$ - ((depth$ * -1 + old_zinitht_BG) * v_sindir_x_BG)
            v_abs_plus_y_sec_fin_BG = y$ - ((depth$ * -1 + old_zinitht_BG) * v_sindir_y_BG)
            v_abs_plus_z_sec_fin_BG = z$ - ((depth$ * -1 + old_zinitht_BG) * v_sindir_z_BG)

            #axeccalsimu = axeC5xsimu
            #axeacalsimu = axeB5xsimu

            xprint_BG = x$
            yprint_BG = y$
            zprint_BG = z$ # + ( depth$ * -1 + initht$ )

pcaldrilxyzsimu_CG  # calcul des point dans le plan de l'axe outil
            #"voir xyz", *x$ ," ", *y$," ", *z$," ", *u$," ", *v$," ", *w$," ", *initht$, " ",*refht$," ", *depth$,   e$ 

            v_delta_x_CG = x$ - u$
            v_delta_y_CG = y$ - v$
            v_delta_z_CG = z$ - w$
            v_delta_xyz_CG = sqrt(v_delta_x_CG^2 + v_delta_y_CG^2 + v_delta_z_CG^2)
            v_sindir_x_CG = v_delta_x_CG/v_delta_xyz_CG
            v_sindir_y_CG = v_delta_y_CG/v_delta_xyz_CG
            v_sindir_z_CG = v_delta_z_CG/v_delta_xyz_CG

            v_abs_plus_x_CG = u$#x$ - (initht$ * v_sindir_x_CG)
            v_abs_plus_y_CG = v$#y$ - (initht$ * v_sindir_y_CG)
            v_abs_plus_z_CG = w$#z$ - (initht$ * v_sindir_z_CG)

            v_abs_plus_x_sec_CG = x$ - ((depth$ * -1 + initht$) * v_sindir_x_CG)
            v_abs_plus_y_sec_CG = y$ - ((depth$ * -1 + initht$) * v_sindir_y_CG)
            v_abs_plus_z_sec_CG = z$ - ((depth$ * -1 + initht$) * v_sindir_z_CG)
            #"voir v_abs_plus_x_CG", " ",*v_abs_plus_x_CG," ", *v_abs_plus_y_CG," ", *v_abs_plus_z_CG, e$
            v_abs_plus_x_sec_fin_CG = x$ - ((depth$ * -1 + old_zinitht_CG) * v_sindir_x_CG)
            v_abs_plus_y_sec_fin_CG = y$ - ((depth$ * -1 + old_zinitht_CG) * v_sindir_y_CG)
            v_abs_plus_z_sec_fin_CG = z$ - ((depth$ * -1 + old_zinitht_CG) * v_sindir_z_CG)

            #axeccalsimu = axeC5xsimu
            #axeacalsimu = axeB5xsimu

            xprint_CG = x$
            yprint_CG = y$
            zprint_CG = z$ # + ( depth$ * -1 + initht$ )            
#endregion          
#endregion

#region   PSOF PHEADER OPTIONS #OK
#region premx

premx_AG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_AG, *mr1 ,e
            sm, paf, "G151 EC0. EA0. EU0. EV0. EW0.",e$
            if mr2print_AG = 0, mr2print_AG =zsecuprint
            if mr2print_AG <>   -1,     [
                                        if ((flag_cloche_AG = 1) | (arret_prog_AG = 1)),	[
																							if flag_cloche_AG = 1 & arret_prog_AG = 0, sr, *mr2print_AG, sazero, sczero, paf,pgcode_AG, *mr2$, sm, sxcloche_AG, sycloche_AG, e$, flag_cloche_AG = 0
                                        													if flag_cloche_AG = 0 & arret_prog_AG = 1, sr, *mr2print_AG, sazero, sczero, paf,pgcode_AG, *mr2$, sm, sxmach_garage_AG, symach_garage_AG, e$, arret_prog_AG = 0
																							if flag_cloche_AG = 1 & arret_prog_AG = 1, sr, *mr2print_AG, sazero, sczero, paf,pgcode_AG, *mr2$, sm, sxcloche_AG, sycloche_AG, e$, flag_cloche_AG = 0, arret_prog_AG = 0
																							]
										else, sr, *xprint_AG, *yprint_AG,*mr2print_AG, paf,pgcode_AG, *mr2$,e$
                                        ]
            axeCpos_AG = 0
            axeApos_AG = 0
            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG


premx_BG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_BG, *mr1 ,e
            panul_plan_inc_BG
            if mr2print_BG = 0, mr2print_BG =zsecuprint
            if mr2print_BG <>   -1,     [
                                        if ((flag_cloche_BG = 1) | (arret_prog_BG = 1)),	[
																							if flag_cloche_BG = 1 & arret_prog_BG = 0, sr, *mr2print_BG, sazero, sczero, paf,pgcode_BG, *mr2$, sm, sxcloche_BG, sycloche_BG, e$, flag_cloche_BG = 0
                                        													if flag_cloche_BG = 0 & arret_prog_BG = 1, sr, *mr2print_BG, sazero, sczero, paf,pgcode_BG, *mr2$, sm, sxmach_garage_BG, symach_garage_BG, e$, arret_prog_BG = 0
																							if flag_cloche_BG = 1 & arret_prog_BG = 1, sr, *mr2print_BG, sazero, sczero, paf,pgcode_BG, *mr2$, sm, sxcloche_BG, sycloche_BG, e$, flag_cloche_BG = 0, arret_prog_BG = 0
																							]
										else, sr, *xprint_BG, *yprint_BG,*mr2print_BG, paf,pgcode_BG, *mr2$, e$
                                        ]
            axeCpos_BG = 0
            axeApos_BG = 0
            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG


premx_CG     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_CG, *mr1 ,e
            panul_plan_inc_CG
            if mr2print_CG = 0, mr2print_CG =zsecuprint
            pgestionduB_cloche_CG
			#"voir",  *axeA_cloche_CG, e$
			if axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG
			
			if garage_CG <> 0,	[
								if change_cloche_CG = 1, axeA_cloche_CG = 1
								axeA_cloche_CG = 0
								if mr2print_CG <> -1 & axeA_cloche_CG = 0, 	[
                                        									sr, *mr2print_CG
																			#if garage_CG = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			#if garage_CG = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			#if garage_CG = 3, sb_moins_quatre_vingt_dix, sczero
																			#if garage_CG = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			#if garage_CG = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			#if garage_CG = 6, sb_moins_quatre_vingt_dix, sczero
																			#if garage_CG = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																			#if garage_CG = 8, sb_quatre_vingt_dix, sczero
																			#if garage_CG = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																			#if garage_CG = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																			#if garage_CG = 11, sb_quatre_vingt_dix, sczero	
																			#if garage_CG = 12, sb_moins_quatre_vingt_dix, sczero
																			sbzero
																			paf, pgcode_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																			#garage_CG = 0
																			]
														
								if mr2print_CG <> -1 & axeA_cloche_CG <> 0, [
                                        									sr, *mr2print_CG
																			#if garage_CG = 1, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																			#if garage_CG = 2, sb_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_soixante
																			#if garage_CG = 3, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante
																			#if garage_CG = 4, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																			#if garage_CG = 5, sb_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_soixante
																			#if garage_CG = 6, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante
																			#if garage_CG = 7, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																			#if garage_CG = 8, sb_soixante, sczero, string_B_CG = sb_soixante
																			#if garage_CG = 9, sb_moins_soixante, sc_cent_quatre_vingt, string_B_CG = sb_moins_soixante
																			#if garage_CG = 10, sb_moins_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_moins_soixante
																			#if garage_CG = 11, sb_soixante, sczero, string_B_CG = sb_soixante				
																			#if garage_CG = 12, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante
																			sbzero
																			#paf, pgcode_CG, *mr2print_CG, string_B_CG, sm, sxmach_garage_CG, symach_garage_CG, e$
																			paf, pgcode_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																			#garage_CG = 0
																			]								
								]
			else,	[
            		if mr2print_CG <> -1 & axeA_cloche_CG = 0, 	sr, *xprint_CG, *yprint_CG,*mr2print_CG, paf,pgcode_CG, *mr2$,e$								
					if mr2print_CG <> -1 & axeA_cloche_CG <> 0, sr, *xprint_CG, *yprint_CG,*mr2print_CG, *axeA_cloche_CG, paf,pgcode_CG, *mr2$, *axeA_cloche_CG, e$                    						
					]									
														
			flagmr2_CG = 1										
										
										
										
            axeCpos_CG = 0
            axeApos_CG = 0
            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

premx_AM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_AM, *mr1 ,e
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.",e$
            if mr2print_AM = 0, mr2print_AM =zsecuprint
            if mr2print_AM <>   -1,pnumligne,pgcode_AM, mr2print_AM,e$
            axeCpos_AM = 0
            axeApos_AM = 0
            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM


premx_BM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_BM, *mr1 ,e
            panul_plan_inc_BM
            if mr2print_BM = 0, mr2print_BM =zsecuprint
            if mr2print_BM <>   -1,pnumligne,pgcode_BM, mr2print_BM,e$
            axeCpos_BM = 0
            axeApos_BM = 0
            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM


premx_CM     # remonte pour transition entre usinage 5 axes continue
            gcode$ = 0
            # if mr1 <> 0, n, pgcode_force_CM, *mr1 ,e
            panul_plan_inc_CM
            if mr2print_CM = 0, mr2print_CM =zsecuprint
            if mr2print_CM <>   -1,pnumligne,pgcode_CM, mr2print_CM,e$
            axeCpos_CM = 0
            axeApos_CM = 0
            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM
#endregion          
#region pcord

pcord_AG     # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_BG      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_CG      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_AM     # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_BM      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"

pcord_CM      # Compensation rayon outil
           if cc$ = 41, cc$
           if cc$ = 42, cc$
           if cc$ = 140, "G40"
#endregion
#region plubrifon_old

plubrifon_old_BG
           lubrif = coolant$
           if lubrif = 1, sm, paf, "M7 ; Arrosage centre ",e$
           if lubrif = 2, sm, paf, "M8 ; Arrosage ext", e$
           if lubrif = 3, sm, paf, "M8 ; Arrosage ext", e$, sm, paf, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_CG
           lubrif = coolant$
           if lubrif = 1, sm, paf, "M7 ; Arrosage centre ",e$
           if lubrif = 2, sm, paf, "M8 ; Arrosage ext", e$
           if lubrif = 3, sm, paf, "M8 ; Arrosage ext", e$, sm, paf, "M7 ; Arrosage centre", e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_BM
           lubrif = coolant$
           if lubrif = 1, pnumligne, SDEBUT_LUB,e$
           if lubrif = 2, pnumligne, SDEBUT_LUB, e$
           if lubrif = 3, pnumligne, SDEBUT_LUB, e$, pnumligne, SDEBUT_LUB, e$
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_old_CM
           lubrif = coolant$
           if lubrif = 1, pnumligne, SDEBUT_LUB,e$
           if lubrif = 2, pnumligne, SDEBUT_LUB, e$
           if lubrif = 3, pnumligne, SDEBUT_LUB, e$, pnumligne, SDEBUT_LUB, e$
           if lubrif > 0, lub = 1
           else, lub = 0
#endregion
#region pcontrol_lubrif

pcontrol_lubrif_BG  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_CG  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
pcontrol_lubrif_BM  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$

pcontrol_lubrif_CM  # 1er passage pour controler si pas de changement
                    #"voir les etat avant",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
                 lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0, lubrif_m200 = 0
                    # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1

                #"voir les etat apres",  *old_lubrif_m7,*lubrif_m7, *old_lubrif_m8, *lubrif_m8, *old_lubrif_m207, *lubrif_m207, *old_lubrif_m200, *lubrif_m200, e$
#endregion
#region plubrifon

plubrifon_AG
           lubrif = coolant$
           if lubrif = 1, sm,paf, "M7"
           if lubrif = 2, sm,paf, "M150"
           if lubrif = 3, sm,paf, "M150", e$, sm,paf, "M7"
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_BG   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur200_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                ###subout$### = 3
                                erreur_BG = 1
                                #exitpost$ # abandonner 
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_BG <> 9 ,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur203_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                ###subout$### = 3
                                erreur_BG = 1
                                #exitpost$ # abandonner 
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_CG   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, sm,paf, "M7 ; Arrosage Centre Outil", e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, sm,paf, "M8 ; Arrosage Exterieur", e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, sm,paf, "M207 ; Soufflage Centre Outil", e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, sm,paf, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur200_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_CG <> 9 ,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur203_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_AM
           lubrif = coolant$
           if lubrif = 1, pnumligne, SDEBUT_LUB
           if lubrif = 2, pnumligne, SMARCHE_ASPI
           if lubrif = 3, pnumligne, SMARCHE_ASPI, e$, pnumligne, SDEBUT_LUB
           if lubrif > 0, lub = 1
           else, lub = 0

plubrifon_BM   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur200_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_BM <> 9 ,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur203_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200

plubrifon_CM   # gestion des commande air eau aspi
                #" coucou =", *cant_val1$,*cant_val2$,*cant_val3$,*cant_val4$,*cant_val5$,*cant_val6$,*cant_val7$,*cant_val8$,*cant_val9$,*cant_val10$, e$
                lubrif_m7 = 0,  lubrif_m8 = 0, lubrif_m207 = 0 , lubrif_m200 = 0


                # ecriture premiere valeur
                if cant_val1$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val1$ = 68 | cant_val1$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val2$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val2$ = 68 | cant_val2$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val3$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val3$ = 68 | cant_val3$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val4$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val4$ = 68 | cant_val4$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val5$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val5$ = 68 | cant_val5$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val6$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val6$ = 68 | cant_val6$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val7$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val7$ = 68 | cant_val7$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arret Controle du Vide", e$

                # ecriture premiere valeur
                if cant_val8$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val8$ = 68 | cant_val8$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val9$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val9$ = 68 | cant_val9$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$

                # ecriture premiere valeur
                if cant_val10$ = 50, lubrif_m7 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 52, lubrif_m8 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 54, lubrif_m207 = 1, lubrif = 1, pnumligne, SDEBUT_LUB, e$
                if cant_val10$ = 68 | cant_val10$ = 69, lubrif_m200 = 1, lubrif = 1, pnumligne, "M200 ; Arrêt Contrôle du Vide", e$


                if lubrif_m7 = 1 & lubrif_m207 = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur200_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                if (lubrif_m7 = 1 | lubrif_m8 = 1) & mi4_CM <> 9 ,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur203_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                if lubrif > 0, lub = 1
                else, lub = 0

                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
#endregion
#region plubrifoff

plubrifoff_AG
           if lub = 1, sm,paf, "M9", e$ , sm,paf, "M151"

plubrifoff_BG
           if lub <> 0, sm,paf, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_CG
           if lub <> 0, sm,paf, "M9 ; ARRET", e$
           lub = 0
           lubrif = 0

plubrifoff_AM
           if lub = 1, pnumligne, SARRET_LUB, e$ , pnumligne, SARRET_ASPI

plubrifoff_BM
           if lub <> 0, pnumligne, SARRET_LUB, e$
           lub = 0
           lubrif = 0

plubrifoff_CM
           if lub <> 0, pnumligne, SARRET_LUB, e$
           lub = 0
           lubrif = 0
#endregion
#region ptempo

ptempo_BG      # tempo suivant mi10$
			if mi10$ < -1, sm,paf, "M151; ARRET ASPI", e$
            tempo_BG = mi10$ / 10
            sm,paf,tempo_BG,e$

ptempo_CG      # tempo suivant mi10$
			if mi10$ < -1, sm,paf, "M302 ; ARRET ASPI 1", e$
        	if mi10$ < -1, sm,paf, "M304 ; ARRET ASPI 2", e$
            tempo_CG = mi10$ / 10
            sm,paf,tempo_CG,e$

ptempo_BM      # tempo suivant mi10$
			if mi10$ < -1, sm,paf, SARRET_ASPI, e$
            tempo_BM = mi10$ / 10
            sm,paf,tempo_BM,e$

ptempo_CM      # tempo suivant mi10$
			if mi10$ < -1, sm,paf, SARRET_ASPI, e$
            tempo_CM = mi10$ / 10
            sm,paf,tempo_CM,e$
#endregion
#region parretprog

parretprog_AG   # arret machine programmer avant op quand mi10 = 1
        sm, paf,"M5 (ARRET BROCHE)",e$
        sm, paf,"G151 S0",e$
        sm, szmach_garage_AG, paf,"G0 G52 Z-150",e$
		if mi10$ = -1, sm,paf,"M151",e$
        sm, sxmach_garage_AG, symach_garage_AG,sazero, sczero, paf, "G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_AG = 1) | (prog_AM = 1) , q10
            #sm, paf,"$", smesage_AG,e$
            #q10
            sm,paf,"$", smesage,e$
            ]
        pcantext_AG
        sm, paf,"M0",e$
        if oldstation_AG <> 0 & oldstation_AG = mi4_AG, sm, paf, *spdlon_AG, "M40", ssprint_AG,e$
        else,
        [
        if mi4_AG  <= 0 | mi4_AG > 6, sm, paf, *spdlon_AG, "M40", ssprint_AG,e$
        ]
            if mr2print_AG <= 0, mr2print_AG =zsecuprint
            prvmr2_AG = mr2print_AG
        arret_prog_AG = 1
		old_xprint_simu_AG = 2000
		old_yprint_simu_AG = 3920
		old_zprint_simu_AG = mr2print_AG
		old_axeA_simu_AG = 0
		
parretprog_BG    # arret machine programmer avant op quand mi10 = 1
        sm,paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BG
        plubrifoff_BG
        if mi10$ = -1, sm,paf, "M151; ARRET ASPI", e$
        sm, szmach_garage_BG, paf,"GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        sm, sxmach_garage_BG, symach_garage_BG,sazero, sczero, paf,"GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_BG = 1) | (prog_BM = 1), q11
            #sm, paf,"MSG(",34, smesage_BG,34,")",e$
            sm, paf,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BG
        sm,paf, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        sm,paf, "TRAORI(1)", e$
        sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
        sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        sm,paf, *spdlon_BG, ssprint_BG,e$
        arret_prog_BG = 1
		old_xprint_simu_BG = -1350
		old_yprint_simu_BG = -800
		old_zprint_simu_BG = mr2print_BG
		old_axeA_simu_BG = 0
		
parretprog_CG    # arret machine programmer avant op quand mi10 = 1
        sm,paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CG
        plubrifoff_CG
        if mi10$ = -1, sm,paf, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, sm,paf, "M304 ; ARRET ASPI 2", e$
        
		pgarage_CG

        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_CG = 1) | (prog_CM = 1), q12
            #sm, paf,"MSG(",34, smesage_CG,34,")",e$
            sm,paf,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CG
        sm,paf, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        sm,paf, "TRAORI(1)", e$
        sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
        sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        sm,paf, *spdlon_CG, ssprint_CG,e$
		
parretprog_AM   # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 (ARRET BROCHE)",e$
        pnumligne,"G151 S0",e$
        pnumligne,"G0 G52 Z-150",e$
		if mi10$ = -1, pnumligne, SARRET_ASPI, e$
        pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q10
            #pnumligne,"$", smesage_AG,e$
            pnumligne,"$", smesage,e$
            ]
        pcantext_AM
        pnumligne,"M0",e$
        if oldstation_AM <> 0 & oldstation_AM = mi4_AM, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
        else,
        [
        if mi4_AM  <= 0 | mi4_AM > 6, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
        ]
            if mr2print_AM <= 0, mr2print_AM =zsecuprint
            prvmr2_AM = mr2print_AM

parretprog_BM    # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BM
        plubrifoff_BM
        if mi10$ = -1, pnumligne, SARRET_ASPI, e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BM
        pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        pnumligne, "TRAORI(1)", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        pnumligne, *spdlon_BM, ssprint_BM,e$

parretprog_CM    # arret machine programmer avant op quand mi10 = 1
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CM
        plubrifoff_CM
        if mi10$ = -1, pnumligne, SARRET_ASPI, e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
        ( cant_val2$ = 0 | cant_val2$ > 49 )  &
        ( cant_val3$ = 0 | cant_val3$ > 49 )  &
        ( cant_val4$ = 0 | cant_val4$ > 49 )  &
        ( cant_val5$ = 0 | cant_val5$ > 49 )  &
        ( cant_val6$ = 0 | cant_val6$ > 49 )  &
        ( cant_val7$ = 0 | cant_val7$ > 49 )  &
        ( cant_val8$ = 0 | cant_val8$ > 49 )  &
        ( cant_val9$ = 0 | cant_val9$ > 49 )  &
        ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CM
        pnumligne, "M0", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - DEBUT
        pnumligne, "TRAORI(1)", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
#   MODIF EDC LE 04 NOVEMBRE 2013 - FIN        
        pnumligne, *spdlon_CM, ssprint_CM,e$
#endregion
#region parretprog2

parretprog2_AG    # arret machine programmer avant op quand mi10 = 1 et changement outil

        sm, paf,"M5 (ARRET BROCHE)",e$
        sm, paf,"G151 S0",e$
        sm, szmach_garage_AG, paf,"G0 G52 Z-150",e$
		if mi10$ = -1, sm, paf,"M151",e$
        sm, sxmach_garage_AG, symach_garage_AG,sazero, sczero, paf, "G0 G52 X2000 Y3920 A C",e$

        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_AG = 1) | (prog_AM = 1), q10
            #sm, paf,"$", smesage_AG,e$
            #q10
            sm,paf,"$", smesage,e$
            ]
        pcantext_AG
        sm,paf,"M0",e$
        arret_prog_AG = 1
		old_xprint_simu_AG = 2000
		old_yprint_simu_AG = 3920
		old_zprint_simu_AG = mr2print_AG
		old_axeA_simu_AG = 0
parretprog2_BG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        sm,paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BG
        plubrifoff_BG
        if mi10$ = -1, sm,paf, "M151; ARRET ASPI", e$
        sm, szmach_garage_BG, paf,"GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
        sm, sxmach_garage_BG, symach_garage_BG,sazero, sczero, paf,"GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_BG = 1) | (prog_BM = 1), q11
            #sm, paf,"MSG(",34, smesage_BG,34,")",e$
            sm,paf,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BG
        sm,paf, "M0", e$
        arret_prog_BG = 1
		old_xprint_simu_BG = -1350
		old_yprint_simu_BG = -800
		old_zprint_simu_BG = mr2print_BG
		old_axeA_simu_BG = 0
parretprog2_CG    # arret machine programmer avant op quand mi10 = 1 et changement outil
        sm,paf,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CG
        plubrifoff_CG
        if mi10$ = -1, sm,paf, "M302 ; ARRET ASPI 1", e$
        if mi10$ = -1, sm,paf, "M304 ; ARRET ASPI 2", e$
        
		pgarage_CG
		
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #if (prog_CG = 1) | (prog_CM = 1), q12
            #sm, paf,"MSG(",34, smesage_CG,34,")",e$
            sm,paf,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CG
        sm,paf, "M0", e$
		
parretprog2_AM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 (ARRET BROCHE)",e$
        pnumligne,"G151 S0",e$
        pnumligne,"G0 G52 Z-150",e$
		if mi10$ = -1, pnumligne, SARRET_ASPI, e$
        pnumligne,"G0 G52 X2000 Y3920 A C",e$
        if  ( cant_val1$ = 0 | cant_val1$ > 49 ) &
            ( cant_val2$ = 0 | cant_val2$ > 49 ) &
            ( cant_val3$ = 0 | cant_val3$ > 49 ) &
            ( cant_val4$ = 0 | cant_val4$ > 49 ) &
            ( cant_val5$ = 0 | cant_val5$ > 49 ) &
            ( cant_val6$ = 0 | cant_val6$ > 49 ) &
            ( cant_val7$ = 0 | cant_val7$ > 49 ) &
            ( cant_val8$ = 0 | cant_val8$ > 49 ) &
            ( cant_val9$ = 0 | cant_val9$ > 49 ) &
            ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q10
            #pnumligne,"$", smesage_AG,e$
            pnumligne,"$", smesage,e$
            ]
        pcantext_AM
        pnumligne,"M0",e$

parretprog2_BM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_BM
        plubrifoff_BM
        if mi10$ = -1,pnumligne, SARRET_ASPI, e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q11
            #pnumligne,"MSG(",34, smesage_BG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_BM
        pnumligne, "M0", e$

parretprog2_CM    # arret machine programmer avant op quand mi10 = 1 et changement outil
        pnumligne,"M5 ;(ARRET BROCHE)",e$
        panul_plan_inc_CM
        plubrifoff_CM
        if mi10$ = -1,pnumligne, SARRET_ASPI, e$
        #enlevé pour concat#pnumligne, "GARAGE ; CYCLE DE DEGAGEMENT OUTIL", e$
      if ( cant_val1$ = 0 | cant_val1$ > 49 )  &
         ( cant_val2$ = 0 | cant_val2$ > 49 )  &
         ( cant_val3$ = 0 | cant_val3$ > 49 )  &
         ( cant_val4$ = 0 | cant_val4$ > 49 )  &
         ( cant_val5$ = 0 | cant_val5$ > 49 )  &
         ( cant_val6$ = 0 | cant_val6$ > 49 )  &
         ( cant_val7$ = 0 | cant_val7$ > 49 )  &
         ( cant_val8$ = 0 | cant_val8$ > 49 )  &
         ( cant_val9$ = 0 | cant_val9$ > 49 )  &
         ( cant_val10$ = 0 | cant_val10$ > 49 ),
            [
            #q12
            #pnumligne,"MSG(",34, smesage_CG,34,")",e$
            pnumligne,"MSG(",34, smesage,34,")",e$
            ]
        pcantext_CM
        pnumligne, "M0", e$
#endregion
#region pprep
pprep$
        #err_file$ = 4
        seqno$ = 5
        seqinc$ = 5
        n$ = 5
        clearaux$
        clearext$
        clearlcc$
        newaux$
        ecrigeneral_AG = 0
        ecrigeneral_BG = 0
        ecrigeneral_CG = 0

        rotaxtyp$ = 4
        sextnc$ = sext
        result = nwadrs(sblk, n$)
		result = nwadrs(sblk, n_AG)
		result = nwadrs(sblk, n_BG)
		result = nwadrs(sblk, n_CG)
		result = nwadrs(sblk, n_AM)
		result = nwadrs(sblk, n_BM)
		result = nwadrs(sblk, n_CM)
        omitseq$ = 0
        breakarcs$ = 1
		sweep$=180

#endregion
#region ppost
ppost$
        spathnc$ = sentre_cote + spathnc$ + sentre_cote
        result = launch(sdpdir, spathnc$)
#endregion
#region pheader
pheader$
                comment$
                debut_pp = 1
                pgestion_prog
                pgestion_rep  # on part cree les repertoires machines
                #q3
                ###subout$###=0   # on ecrit dans le fichier de synthese
                 "*******************************************************************", e$
                 "SYNTHESE DES PROGRAMMES GENERES POUR LE DESSIN", smcname$,e$    # FICAM
                 "*******************************************************************", e$
                 "Généré le ", date$, " A ", time$, "par", snomprog, e$     # date du traitement post-pro
                 " ", e$
                 "***********************************", e$
                 "PROGRAMME SORTIE POUR LES MACHINES:" e$              # nom de la machine   
                 "***********************************", e$
                 if (prog_AG = 1) | (prog_AM = 1), " - ",smachine_AG, e$
                 if (prog_BG = 1) | (prog_BM = 1), " - ",smachine_BG, e$
                 if (prog_CG = 1) | (prog_CM = 1), " - ",smachine_CG, e$
                 " ", e$
                 "**************************", e$
                 "LISTE DES OUTILS UTILISER:", e$
                 "**************************", e$
                 #pvoirdescrip
                 ###subout$###=1            

                pdecomposition_mi5
                pchange_AG
                pheader_AG

                pchange_BG
                pheader_BG

                pchange_CG
                pheader_CG

                pcont_garage_AM
                pchange_AM
                pheader_AM

                pcont_garage_BM
                pchange_BM
                pheader_BM

                pcont_garage_CM
                pchange_CM
                pheader_CM

                old_numprg_garage_AM = numprg_garage_AM
                old_numprg_garage_BM = numprg_garage_BM
                old_numprg_garage_CM = numprg_garage_CM
                old_progno_AM = numprg_concat_AM
                old_progno_BM = numprg_concat_BM
                old_progno_CM = numprg_concat_CM

ppreptete
		if t$ = 51,	[
					"MW_MOUNTING head_adapter TETE_51", e$
					"MW_TOOL_NAME tool1 USE_DEFAULT", e$
					"MW_OP_POST_NAME TETE_51", e$
					]
					
		if t$ = 52,	[
					"MW_MOUNTING head_adapter TETE_52", e$
					"MW_TOOL_NAME tool2 USE_DEFAULT", e$
					"MW_OP_POST_NAME TETE_52", e$
					]
					
		if t$ = 61,	[
					"MW_MOUNTING head_adapter TETE_61", e$
					"MW_TOOL_NAME tool3 USE_DEFAULT", e$
					"MW_OP_POST_NAME TETE_61", e$
					]
					
		if t$ = 62,	[
					"MW_MOUNTING head_adapter TETE_62", e$
					"MW_TOOL_NAME tool4 USE_DEFAULT", e$
					"MW_OP_POST_NAME TETE_62", e$
					]					
					
					
					
		if t$ <> 51 & t$ <> 52 & t$ <> 61 & t$ <> 62,
					[
					"MW_TOOL_NAME tool USE_DEFAULT", e$
					"MW_OP_POST_NAME SANS_TETE", e$
					]
					
pheader_AG     # Entete

                    "MW_CL_VERSION 1.2", e$
                    " ", e$
                    "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>A<EOC>C<EOC>",34,e$
                    spaces$ = 0
                    ppreptete
                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                    spaces$ = 1
                    old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$


        if progno$ = 0, progno$ = 8999
        ppr = mi5_AG
        !ppr
		if trans_num_prg <> 0, mr1_AG = trans_num_prg
		else, mr1_AG = mr1$
        #if (mr1_AG <> 0) & (mr1_AG > 999) & (mr1_AG < 8999), sm, pafcom, mr1_AG, e$
        #else, psortie_num_prog_AG
        sm, sxmach_AG, symach_AG, szmach_AG, sazero, sczero,sentre_cloche_AG,pafcom, spaces$ = 0,*mr1_AG,"                                                                           ",e$, spaces$ = 1

        if ppr = 1, sm,paf,"G77 H9001.",e$,sm,paf,"E10000=1",e$
        if ppr = 2, sm,paf,"G77 H9002.",e$,sm,paf,"E10001=1",e$
        if ppr = 3, sm,paf,"G77 H9001. N55N65",e$,sm,paf,"G77 H9999",e$,sm,paf,"E10001=1 E10000=1",e$
        @gfr_AG
        sm,pafcom,spaces$ = 0,"(STELIA COMPOSITES)",e$, spaces$ = 1
        sm,pafcom,spaces$ = 0,"(CRENEAU 5 AXES STC9101)",e$, spaces$ = 1
        sm,pafcom,spaces$ = 0,"(ETABLI LE ",date$," A ",time$, " H)",e$, spaces$ = 1
        sm,pafcom,spaces$ = 0,"(PROG PAR ",snomprog, ")",e$, spaces$ = 1
        #"$ PIECE:", srefpiec,e$

pheader_BG     # Entete
                    "MW_CL_VERSION 1.2", e$
                    " ", e$
                    "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>A<EOC>C<EOC>",34,e$
                    spaces$ = 0
                    #pprepoutil
                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                    spaces$ = 1
                    old_corg_x_BG = tox4$, old_corg_y_BG = toy4$, old_corg_z_BG = toz4$
					if ((mi5_BG = 9) & (mr8$ < 5000)) | (mi5_BG = 1),	[
																		sxmach_BG = sxmach_Z1_BG
																		symach_BG = symach_Z1_BG
																		szmach_BG = szmach_Z1_BG
																		]
									if (mi5_BG = 9) & (mr8$ >= 5000),	[
																		sxmach_BG = sxmach_Z2_BG
																		symach_BG = symach_Z2_BG
																		szmach_BG = szmach_Z2_BG
																		]
					mr8_changeur_BG = mr8$	
        if progno$ = 0, progno$ = 8999
        sm, sxmach_BG, symach_BG, szmach_BG, sazero, sczero,sentre_cloche_BG, pafcom, spaces$ = 0,*snamenc$,"                                                                            ",e$, spaces$ = 1
        !ppr
        @gfr_BG
        sm,paf,";(",34,"STELIA COMPOSITES",34,")",e$
        sm,paf,";(",34,"CRENEAU 5 AXES STC9103",34,")",e$
        sm,paf,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        sm,paf,";(",34,"PROG PAR ",snomprog,34,")",e$
        #sm, paf,";(",34,"PIECE:", srefpiec,34,")",e$

pheader_CG     # Entete
                    "MW_CL_VERSION 1.2", e$
                    " ", e$
                    "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>B<EOC>C<EOC>",34,e$
                    spaces$ = 0
                    #pprepoutil
                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                    spaces$ = 1
                    old_corg_x_CG = tox4$, old_corg_y_CG = toy4$, old_corg_z_CG = toz4$

        if progno$ = 0, progno$ = 8999
		if mi5_CG = 1,	[
						sxmach_CG = sxmach_Z1_CG
						symach_CG = symach_Z1_CG
						szmach_CG = szmach_Z1_CG
						]
				else,	[
						sxmach_CG = sxmach_Z2_CG
						symach_CG = symach_Z2_CG
						szmach_CG = szmach_Z2_CG
						]						
        sm, sxmach_CG, symach_CG, szmach_CG, sbzero, sczero,pafcom, spaces$ = 0,*snamenc$,"                                                                           ",e$, spaces$ = 1
        !ppr
        @gfr_CG
        sm,paf,";(",34,"STELIA COMPOSITES",34,")",e$
        sm,paf,";(",34,"CRENEAU 5 AXES STC9110",34,")",e$
        sm,paf,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        sm,paf,";(",34,"PROG PAR ",snomprog,34,")",e$
        #sm, paf,";(",34,"PIECE:", srefpiec,34,")",e$

pheader_AM     # Entete
        if progno$ = 0, progno$ = 8999
        ppr = mi5_AM
        !ppr
        #enlevé pour concat#*progno$,e$
        #enlevé pour concat#if ppr = 1, pnumligne,"G77 H9001.",e$,pnumligne,"E10000=1",e$
        #enlevé pour concat#if ppr = 2, pnumligne,"G77 H9002.",e$,pnumligne,"E10001=1",e$
        #enlevé pour concat#if ppr = 3, pnumligne,"G77 H9001. N55N65",e$,pnumligne,"G77 H9999",e$,pnumligne,"E10001=1 E10000=1",e$
        @gfr_AM
        #enlevé pour concat#"(STELIA COMPOSITES)",e$
        #enlevé pour concat#"(CRENEAU 5 AXES STC9101)",e$
        #enlevé pour concat#"(ETABLI LE ",date$," A ",time$, " H)",e$
        #enlevé pour concat#"(PROG PAR ",snomprog, ")",e$ #enlevé pour concat


pheader_BM     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_BM
        #enlevé pour concat#pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"CRENEAU 5 AXES STC9103",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$


pheader_CM     # Entete

        if progno$ = 0, progno$ = 8999
        !ppr
        @gfr_CM
        #enlevé pour concat#pnumligne,";(",34,"STELIA COMPOSITES",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"CRENEAU 5 AXES STC9110",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"ETABLI LE ",date$," A ",time$, " H",34,")",e$
        #enlevé pour concat#pnumligne,";(",34,"PROG PAR ",snomprog,34,")",e$

#endregion
#region pcycle832

pcycle832_BG   # gestion du cycle 832 lissage 
        if (mi8_BG > 0) & (mi8_BG <> 9) & mi8_BG <> oldmi8_BG,
                    [
                    if mi8_BG = 1, sm,paf, scycle832_a, e$
                    if mi8_BG = 2, sm,paf, scycle832_b, e$
                    if mi8_BG = 3, sm,paf, scycle832_c, e$
                    if mi8_BG = 4, sm,paf, scycle832_d, e$
                    if mi8_BG = 5, sm,paf, scycle832_e, e$
                    if mi8_BG = 6, sm,paf, scycle832_f, e$
                    ]
        if ((mi8_BG <= 0) | (mi8_BG = 9)) & mi8_BG <> oldmi8_BG, sm,paf, scycle832_anul, e$
        oldmi8_BG = mi8_BG

pcycle832_CG   # gestion du cycle 832 lissage 
        if (mi8_CG > 0) & (mi8_CG <> 9) & mi8_CG <> oldmi8_CG,
                    [
                    if mi8_CG = 1, sm,paf, scycle832_a, e$
                    if mi8_CG = 2, sm,paf, scycle832_b, e$
                    if mi8_CG = 3, sm,paf, scycle832_c, e$
                    if mi8_CG = 4, sm,paf, scycle832_d, e$
                    if mi8_CG = 5, sm,paf, scycle832_e, e$
                    if mi8_CG = 6, sm,paf, scycle832_f, e$
                    ]
        if ((mi8_CG <= 0) | (mi8_CG = 9)) & mi8_CG <> oldmi8_CG, sm,paf, scycle832_anul, e$
        oldmi8_CG = mi8_CG

pcycle832_BM   # gestion du cycle 832 lissage 
        if (mi8_BM > 0) & (mi8_BM <> 9) & mi8_BM <> oldmi8_BM,
                    [
                    if mi8_BM = 1, pnumligne, scycle832_a, e$
                    if mi8_BM = 2, pnumligne, scycle832_b, e$
                    if mi8_BM = 3, pnumligne, scycle832_c, e$
                    if mi8_BM = 4, pnumligne, scycle832_d, e$
                    if mi8_BM = 5, pnumligne, scycle832_e, e$
                    if mi8_BM = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_BM <= 0) | (mi8_BM = 9)) & mi8_BM <> oldmi8_BM, pnumligne, scycle832_anul, e$
        oldmi8_BM = mi8_BM

pcycle832_CM   # gestion du cycle 832 lissage 
        if (mi8_CM > 0) & (mi8_CM <> 9) & mi8_CM <> oldmi8_CM,
                    [
                    if mi8_CM = 1, pnumligne, scycle832_a, e$
                    if mi8_CM = 2, pnumligne, scycle832_b, e$
                    if mi8_CM = 3, pnumligne, scycle832_c, e$
                    if mi8_CM = 4, pnumligne, scycle832_d, e$
                    if mi8_CM = 5, pnumligne, scycle832_e, e$
                    if mi8_CM = 6, pnumligne, scycle832_f, e$
                    ]
        if ((mi8_CM <= 0) | (mi8_CM = 9)) & mi8_CM <> oldmi8_CM, pnumligne, scycle832_anul, e$
        oldmi8_CM = mi8_CM
#endregion
#region ptestrenvoi_angle
fmt "outil=" 2 outil_complet
fmt "Num RA=" 4 num_ra
fmt "Num outil=" 4 num_outil

ptestrenvoi_angle_BG  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_BG = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_BG=",  tprint2_BG, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2_BG,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_BG > 0,psortie3_BG
                                            if coolant$ > 0, psortie4_BG
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2_BG,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_BG > 0,psortie3_BG
                                            if coolant$ > 0, psortie4_BG
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_CG  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_CG = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_CG=",  tprint2_CG, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2_CG,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_CG > 0,psortie3_CG
                                            if coolant$ > 0, psortie4_CG
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            sm,paf, "MSG(",34,"Outil renvoi angle num.",*tprint2_CG,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_CG > 0,psortie3_CG
                                            if coolant$ > 0, psortie4_CG
                                            ]
                    else, tete_rev_ang_gauche = 0
ptestrenvoi_angle_BM  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_BM = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_BM=",  tprint2_BM, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BM,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_BM > 0,psortie3_BM
                                            if coolant$ > 0, psortie4_BM
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_BM,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_BM > 0,psortie3_BM
                                            if coolant$ > 0, psortie4_BM
                                            ]
                    else, tete_rev_ang_gauche = 0

ptestrenvoi_angle_CM  # voir si on est avec outil a renvoie d'angle

                    # test si outil renvoie d'angle 171 => 202
                    outil_complet = t$ /10
                    num_outil = int(outil_complet)
                    tprint2_CM = t$



                    if num_outil > 16 & num_outil < 21, num_ra = frac(outil_complet) * 10 #on a un renvoi d'angle 
                    else, num_ra = 0
                    #"voir", t$, "tprint_CM=",  tprint2_CM, outil_complet, num_outil, num_ra, e$      

                    #sra = stl_chuck_com
                    #nbcaracter = 4
                    #srenvoi = brksps(nbcaracter, sra)
                    #sra = ucase (sra)
                    if num_ra = 1,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CM,"demandé",34,")",e$
                                            tete_rev_ang_droite = 1
                                            if mi4_CM > 0,psortie3_CM
                                            if coolant$ > 0, psortie4_CM
                                            ]

                    else, tete_rev_ang_droite = 0
                    if num_ra = 2,
                                            [
                                            pnumligne, "MSG(",34,"Outil renvoi angle num.",*tprint2_CM,"demandé",34,")",e$
                                            tete_rev_ang_gauche = 1
                                            if mi4_CM > 0,psortie3_CM
                                            if coolant$ > 0, psortie4_CM
                                            ]
                    else, tete_rev_ang_gauche = 0
#endregion
#region ptestcloche

ptestcloche_BG # test si num de cloche possible
                if mi4_BG <> 1 & mi4_BG <> 2 & mi4_BG <> 3 & mi4_BG <> 4 & mi4_BG <> 11 & mi4_BG <> 12 & mi4_BG <> 13 & mi4_BG <> 14 & mi4_BG <> 21 & mi4_BG <> 22 & mi4_BG <> 23 & mi4_BG <> 24 & mi4_BG > 0   , mi4_BG = 0

ptestcloche_CG # test si num de cloche possible
                if mi4_CG <> 1 & mi4_CG <> 2 & mi4_CG <> 3 & mi4_CG <> 4 & mi4_CG <> 11 & mi4_CG <> 12 & mi4_CG <> 13 & mi4_CG <> 14 & mi4_CG <> 21 & mi4_CG <> 22 & mi4_CG <> 23 & mi4_CG <> 24 & mi4_CG > 0   , mi4_CG = 0

ptestcloche_BM # test si num de cloche possible
                if mi4_BM <> 1 & mi4_BM <> 2 & mi4_BM <> 3 & mi4_BM <> 4 & mi4_BM <> 11 & mi4_BM <> 12 & mi4_BM <> 13 & mi4_BM <> 14 & mi4_BM <> 21 & mi4_BM <> 22 & mi4_BM <> 23 & mi4_BM <> 24 & mi4_BM > 0   , mi4_BM = 0

ptestcloche_CM # test si num de cloche possible
                if mi4_CM <> 1 & mi4_CM <> 2 & mi4_CM <> 3 & mi4_CM <> 4 & mi4_CM <> 11 & mi4_CM <> 12 & mi4_CM <> 13 & mi4_CM <> 14 & mi4_CM <> 21 & mi4_CM <> 22 & mi4_CM <> 23 & mi4_CM <> 24 & mi4_CM > 0   , mi4_CM = 0
#endregion
#region ptlngno

ptlngno_AG      # gestion des cloches
          if mi4_AG = 9, sm,paf, "( PAS DE CLOCHE )",e$
          if mi4_AG = 0 ,sm,paf, "M150", e$, sm,paf, *spdlon_AG, "M40", ssprint_AG, e$

          if t$ < 16,[
          if mi4_AG = 1 , pchargement_cloche_AG
          if mi4_AG = 2 , pchargement_cloche_AG
          if mi4_AG = 3 , pchargement_cloche_AG
          if mi4_AG = 4 , pchargement_cloche_AG
          if mi4_AG = 5 , pchargement_cloche_AG
          if mi4_AG = 6 , pchargement_cloche_AG
          if (mi4_AG > 6) & (mi4_AG <> 9), sm, pafcom "( CLOCHE NON VALIDE )",e$
          ]
          else, sm,paf, "( PAS DE CLOCHE )",e$
          old_mi4_AG = mi4_AG
ptlngno_BG      # gestion des cloches
          if (mi4_BG = 0) | (mi4_BG = 9), sm,paf, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_BG = 9 , sm,paf, "M151 ; ARRET ASPI", e$
          else, sm,paf, "M150 ; MARCHE ASPI ", e$

ptlngno_CG      # gestion des cloches
          if (mi4_CG = 0) | (mi4_CG = 9), sm,paf, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_CG = 9, sm,paf, "M302 ; ARRET ASPI 1", e$, sm,paf, "M304 ; ARRET ASPI 2", e$
          else, sm,paf, "M301 ; MARCHE ASPI 1 ", e$, sm,paf, "M303 ; MARCHE ASPI 2 ", e$

ptlngno_AM      # gestion des cloches
          if mi4_AM = 9, pnumligne, "( PAS DE CLOCHE )",e$
          if mi4_AM = 0 ,pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$

          if t$ < 16,[
          if mi4_AM = 1 , pnumligne, SCLOCHE, spaces$ = 0, "1", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 2 , pnumligne, SCLOCHE, spaces$ = 0, "2", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 3 , pnumligne, SCLOCHE, spaces$ = 0, "3", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 4 , pnumligne, SCLOCHE, spaces$ = 0, "4", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 5 , pnumligne, SCLOCHE, spaces$ = 0, "5", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if mi4_AM = 6 , pnumligne, SCLOCHE, spaces$ = 0, "6", spaces$ = 1, e$, pnumligne, SMARCHE_ASPI, e$, pnumligne, *spdlon_AM, "M40", ssprint_AM, e$
          if (mi4_AM > 6) & (mi4_AM <> 9), "( CLOCHE NON VALIDE )",e$
          ]
          else, pnumligne, "( PAS DE CLOCHE )",e$

ptlngno_BM      # gestion des cloches
          if (mi4_BM = 0) | (mi4_BM = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_BM = 9, pnumligne, SARRET_ASPI, e$
          else, pnumligne, SMARCHE_ASPI, e$

ptlngno_CM      # gestion des cloches
          if (mi4_CM = 0) | (mi4_CM = 9), pnumligne, "MSG(",34,"PAS DE CLOCHE",34,")",e$
          if mi4_CM = 9, pnumligne, SARRET_ASPI, e$
          else, pnumligne, SMARCHE_ASPI, e$
#endregion
#region ptlngno2

ptlngno2_AG   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          sm,paf, "G151 S0", e$
          sm,paf, "M9", e$
          sm,paf, "M151", e$
          sm,paf, "M5", e$
          if (mi4_AG <> old_mi4_AG) & (old_mi4_AG >= 1 & old_mi4_AG <= 6) & mi4_AG <> 1 & mi4_AG <> 2 & mi4_AG <> 3 & mi4_AG <> 4 & mi4_AG <> 5 & mi4_AG <> 6, pdechargement_cloche_AG
          if (mi4_AG <> old_mi4_AG) & (old_mi4_AG >= 1 & old_mi4_AG <= 6) & (mi4_AG = 1 | mi4_AG = 2 | mi4_AG = 3 | mi4_AG = 4 | mi4_AG = 5 | mi4_AG = 6), pdechargement_et_charge_cloche_AG
		  
          if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)),sm,paf, *spdlon_AG, "M40", ssprint_AG, e$

ptlngno2_BG   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          panul_plan_inc_BG
          plubrifoff_BG
          sm,paf, "M151; ARRET ASPI", e$
          sm,paf, "M5 ; ARRET BROCHE", e$
          pappeloutil_BG
          ptlngno_BG
          sm,paf, *spdlon_BG,  ssprint_BG,e$
          pcycle832_BG
            sm,paf, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           sm,paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
            sm,paf, "D1 ; PRISE DE CORRECTEUR", e$

ptlngno2_CG   # gestion cloche quand pas de nouvel outil
            if (mi4_CG > 0) & (mi4_CG <> 9), sm, paf, "STOPRE", e$, sm, sfermeture_cloche_CG, paf, "M69 ; FERMETURE CLOCHE", e$
            else, sm, paf, "STOPRE", e$, sm, souverture_cloche_CG, paf, "M68 ; OUVERTURE CLOCHE", e$
ptlngno2_AM   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          pnumligne, "G151 S0", e$
          pnumligne, SARRET_LUB, e$
          pnumligne, SARRET_ASPI, e$
          pnumligne, "M5", e$
          pnumligne, SCLOCHE, spaces$ = 0, "0", spaces$ = 1, e$
          ptlngno_AM
          if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)),pnumligne, *spdlon_AM, "M40", ssprint_AM,e$


ptlngno2_BM   # gestion cloche quand pas de nouvel outil
          gcode$ = 0
          panul_plan_inc_BM
          plubrifoff_BM
          pnumligne, SARRET_ASPI, e$
          pnumligne, "M5 ; ARRET BROCHE", e$
          pappeloutil_BM
          ptlngno_BM
          pnumligne, *spdlon_BM,  ssprint_BM,e$
          pcycle832_BM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$

ptlngno2_CM   # gestion cloche quand pas de nouvel outil
            if (mi4_CM > 0) & (mi4_CM <> 9), pnumligne, " ", SCLOCHE, "1", e$
            else, pnumligne, " ", SCLOCHE, "0", e$
#endregion
#region psof0
psof0$
            pchange_AG
            psof0_AG

            pchange_AM
            psof0_AM

            pchange_BG
            psof0_BG

            pchange_BM
            psof0_BM

            pchange_CG
            psof0_CG

            pchange_CM
            psof0_CM

psof0_AG      # Debut si pas d'outil
            psof$

psof0_BG       # Debut si pas d'outil
            psof$

psof0_CG       # Debut si pas d'outil
            psof$

psof0_AM      # Debut si pas d'outil
            psof$

psof0_BM       # Debut si pas d'outil
            psof$

psof0_CM       # Debut si pas d'outil
            psof$
#endregion
#region pugv

pugv_AG    # activation ou non du mode UGV
            if mi8_AG =  9,sm,paf, "M126", e$
            else, sm,paf, "M125", e$
pugv_AM    # activation ou non du mode UGV
            if mi8_AM =  9,pnumligne, "M126", e$
            else, pnumligne, "M125", e$
#endregion
#region pstring
fmt "valeur de string" 1 valstring

pstring_AG    # valeur de la string
             if valstring = 1, sm,paf, stringtxt1_AG, e$
             if valstring = 2, sm,paf, stringtxt2_AG, e$
             if valstring = 3, sm,paf, stringtxt3_AG, e$
             if valstring = 4, sm,paf, stringtxt4_AG, e$
             if valstring = 5, sm,paf, stringtxt5_AG, e$
             if valstring = 6, sm,paf, stringtxt6_AG, e$
             if valstring = 7, sm,paf, stringtxt7_AG, e$
             if valstring = 8, sm,paf, stringtxt8_AG, e$
             if valstring = 9, sm,paf, stringtxt9_AG, e$
             if valstring = 10, sm,paf, stringtxt10_AG, e$

pstring_BG    # valeur de la string
             spaces$=1
             if valstring = 1, sm,paf, "MSG(",34, stringtxt1_BG,34,")", e$
             if valstring = 2, sm,paf, "MSG(",34, stringtxt2_BG,34,")", e$
             if valstring = 3, sm,paf, "MSG(",34, stringtxt3_BG,34,")", e$
             if valstring = 4, sm,paf, "MSG(",34, stringtxt4_BG,34,")", e$
             if valstring = 5, sm,paf, "MSG(",34, stringtxt5_BG,34,")", e$
             if valstring = 6, sm,paf, "MSG(",34, stringtxt6_BG,34,")", e$
             if valstring = 7, sm,paf, "MSG(",34, stringtxt7_BG,34,")", e$
             if valstring = 8, sm,paf, "MSG(",34, stringtxt8_BG,34,")", e$
             if valstring = 9, sm,paf, "MSG(",34, stringtxt9_BG,34,")", e$
             if valstring = 10, sm,paf, "MSG(",34, stringtxt10_BG,34,")", e$
             #spaces$ = 0

pstring_CG    # valeur de la string
             spaces$=1
             if valstring = 1, sm,paf, "MSG(",34, stringtxt1_CG,34,")", e$
             if valstring = 2, sm,paf, "MSG(",34, stringtxt2_CG,34,")", e$
             if valstring = 3, sm,paf, "MSG(",34, stringtxt3_CG,34,")", e$
             if valstring = 4, sm,paf, "MSG(",34, stringtxt4_CG,34,")", e$
             if valstring = 5, sm,paf, "MSG(",34, stringtxt5_CG,34,")", e$
             if valstring = 6, sm,paf, "MSG(",34, stringtxt6_CG,34,")", e$
             if valstring = 7, sm,paf, "MSG(",34, stringtxt7_CG,34,")", e$
             if valstring = 8, sm,paf, "MSG(",34, stringtxt8_CG,34,")", e$
             if valstring = 9, sm,paf, "MSG(",34, stringtxt9_CG,34,")", e$
             if valstring = 10, sm,paf, "MSG(",34, stringtxt10_CG,34,")", e$
             #spaces$ = 0   

pstring_AM    # valeur de la string
             if valstring = 1, pnumligne, stringtxt1_AM, e$
             if valstring = 2, pnumligne, stringtxt2_AM, e$
             if valstring = 3, pnumligne, stringtxt3_AM, e$
             if valstring = 4, pnumligne, stringtxt4_AM, e$
             if valstring = 5, pnumligne, stringtxt5_AM, e$
             if valstring = 6, pnumligne, stringtxt6_AM, e$
             if valstring = 7, pnumligne, stringtxt7_AM, e$
             if valstring = 8, pnumligne, stringtxt8_AM, e$
             if valstring = 9, pnumligne, stringtxt9_AM, e$
             if valstring = 10, pnumligne, stringtxt10_AM, e$

pstring_BM    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_BM,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_BM,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_BM,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_BM,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_BM,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_BM,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_BM,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_BM,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_BM,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_BM,34,")", e$
             #spaces$ = 0

pstring_CM    # valeur de la string
             spaces$=1
             if valstring = 1, pnumligne, "MSG(",34, stringtxt1_CM,34,")", e$
             if valstring = 2, pnumligne, "MSG(",34, stringtxt2_CM,34,")", e$
             if valstring = 3, pnumligne, "MSG(",34, stringtxt3_CM,34,")", e$
             if valstring = 4, pnumligne, "MSG(",34, stringtxt4_CM,34,")", e$
             if valstring = 5, pnumligne, "MSG(",34, stringtxt5_CM,34,")", e$
             if valstring = 6, pnumligne, "MSG(",34, stringtxt6_CM,34,")", e$
             if valstring = 7, pnumligne, "MSG(",34, stringtxt7_CM,34,")", e$
             if valstring = 8, pnumligne, "MSG(",34, stringtxt8_CM,34,")", e$
             if valstring = 9, pnumligne, "MSG(",34, stringtxt9_CM,34,")", e$
             if valstring = 10, pnumligne, "MSG(",34, stringtxt10_CM,34,")", e$
             #spaces$ = 0                
#endregion
#region pcantext

pcantext_AG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_AG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_AG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_AG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_AG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_AG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_AG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_AG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_AG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_AG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_AG
             ]

pcantext_BG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_BG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_BG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_BG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_BG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_BG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_BG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_BG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_BG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_BG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_BG
             ]

pcantext_CG   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_CG
             if cant_val2$ > 0, valstring = cant_val2$, pstring_CG
             if cant_val3$ > 0, valstring = cant_val3$, pstring_CG
             if cant_val4$ > 0, valstring = cant_val4$, pstring_CG
             if cant_val5$ > 0, valstring = cant_val5$, pstring_CG
             if cant_val6$ > 0, valstring = cant_val6$, pstring_CG
             if cant_val7$ > 0, valstring = cant_val7$, pstring_CG
             if cant_val8$ > 0, valstring = cant_val8$, pstring_CG
             if cant_val9$ > 0, valstring = cant_val9$, pstring_CG
             if cant_val10$ > 0, valstring = cant_val10$, pstring_CG
             ]

pcantext_AM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_AM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_AM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_AM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_AM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_AM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_AM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_AM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_AM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_AM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_AM
             ]

pcantext_BM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_BM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_BM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_BM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_BM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_BM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_BM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_BM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_BM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_BM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_BM
             ]

pcantext_CM   # ecriture de texte avant 
             if cantext$ > 0,
             [
             if cant_val1$ > 0, valstring = cant_val1$, pstring_CM
             if cant_val2$ > 0, valstring = cant_val2$, pstring_CM
             if cant_val3$ > 0, valstring = cant_val3$, pstring_CM
             if cant_val4$ > 0, valstring = cant_val4$, pstring_CM
             if cant_val5$ > 0, valstring = cant_val5$, pstring_CM
             if cant_val6$ > 0, valstring = cant_val6$, pstring_CM
             if cant_val7$ > 0, valstring = cant_val7$, pstring_CM
             if cant_val8$ > 0, valstring = cant_val8$, pstring_CM
             if cant_val9$ > 0, valstring = cant_val9$, pstring_CM
             if cant_val10$ > 0, valstring = cant_val10$, pstring_CM
             ]
#endregion
#region pappeloutil
smoins : "-"
stringdebut : ""
stringfin : ""
fmt "Nb=" 4 long_string

fmt "" 15 var_1
fmt "" 15 var_2
fmt "" 15 var_3
fmt "" 15 var_4
fmt "" 15 var_5
fmt "" 15 var_6
fmt "" 15 var_7

var_1 : 0
var_2 : 0
var_3 : 0
var_4 : 0
var_5 : 0
var_6 : 0
var_7 : 0

fmt "" 2 longeur_outil
fmt "" 2 rayon_outil
fmt "" 2 dec_rayon
fmt "" 2 rayon_coin_outil
fmt "Nb" 4 nb_digit_outil

fmt "" 3 vartool_1
fmt "" 3 vartool_2

vartool_1 : 0
vartool_2 : 0

svartool_1 : ""

pappeloutil_BG
            pdecomposition_mi4
            if strtool$ = spalpeur_BG,
            [
            spaces$ = 1
            sm, paf, spaces$ = 0, " T1=",34,strtool$,34, e$, spaces$ = 1  # choix de l'outil
            pdechargement_cloche_BG, e$, sm, paf, spaces$ = 0, " T2=0",e$
            spaces$ = 1
            sm, paf, "MSG(",34, t$, strtool$,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_BG = 0

            if opcode$ <> 3, psortie7_BG
            ]
            else,
            [
            spaces$ = 1
            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            ###subout$### = 4
            serreur_visu_BG = serreurnomoutil_BG + no2str(numop_BG)
            "MW_OP_COMMENT", *serreur_visu_BG, e$
            if subout$ <> 3, result = mprint(serreur_visu_BG)
            #exitpost$ # abandonner
            ###subout$### = 3
            erreur_BG = 1

            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 1
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            sm, paf, spaces$ = 0, " T1=",34,soutil,34, e$, spaces$ = 1  # choix de l'outil
            if (mi4_BG > 0) & (mi4_BG <> 9), pchargement_cloche_BG, e$, sm, paf, spaces$ = 0, " T2=",34,"CLOCHE", *mi4_BG,34,e$,spaces$ = 1
            else, pdechargement_cloche_BG, e$, sm, paf, spaces$ = 0," T2=0",e$
            spaces$ = 1




            sm, paf, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
                        if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                    sm, paf," BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")", e$
                                    spaces$ = 1
                                    ]
                    ]
            ]

pappeloutil_CG

            if strtool$ = spalpeur_CG,
            [
             spaces$ = 1, sm, paf, *tprint_CG, e$, spaces$ = 0
			 sm, paf, "STOPRE", e$
             sm, souverture_cloche_CG, paf, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            sm, paf, "MSG(",34, t$, strtool$,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_CG = 0

            if opcode$ <> 3, psortie7_CG
            ]
            else,
            [
            spaces$ = 1
            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            ###subout$### = 4
            serreur_visu_CG = serreurnomoutil_CG + no2str(numop_CG)
            "MW_OP_COMMENT", *serreur_visu_CG, e$
            if subout$ <> 3, result = mprint(serreur_visu_CG)
            #exitpost$ # abandonner
            ###subout$### = 3
            erreur_CG = 1
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, sm, paf, *tprint_CG, e$
            sm, paf, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            sm, paf, "M6 ; CHANGEMENT OUTIL",e$
			if (mi4_CG > 0) & (mi4_CG <> 9), sm, paf, "STOPRE", e$, sm, sfermeture_cloche_CG, paf, spaces$ = 0, " M69 ; FERMETURE CLOCHE", e$, spaces$ = 1
            else, sm, paf, "STOPRE", e$, sm, souverture_cloche_CG, paf, spaces$ = 0, " M68 ; OUVERTURE CLOCHE", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
						LONG_MAX_CG = var_2 + var_3
						LONG_MIN_CG = var_2 - var_3
						sm,paf, *LONG_MAX_CG, e$
						sm,paf, *LONG_MIN_CG, e$
						sm,paf, "TEST_LONG", e$
                    ]
            ]

pappeloutil_BM
            pdecomposition_mi4
            if strtool$ = spalpeur_BM,
            [
             pnumligne, " ", SNOM_OUTIL, 34, strtool$, 34, e$  # choix de l'outil
             pnumligne, " ", SCLOCHE, 34,"CLOCHE0", 34, e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_BM = 0

            if opcode$ <> 3, psortie7_BM
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            ###subout$### = 4
            serreur_visu_BM = serreurnomoutil_BM + no2str(numop_BM)
            "MW_OP_COMMENT", serreur_visu_BM, e$
            if subout$ <> 3, result = mprint(serreur_visu_BM)
            #exitpost$ # abandonner
            ###subout$### = 3
            erreur_BM = 1
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            pnumligne, " ", SNOM_OUTIL, 34, soutil, 34, e$  # choix de l'outil
            if (mi4_BM > 0) & (mi4_BM <> 9), pnumligne, " ", SCLOCHE, 34,"CLOCHE", *mi4_BM, 34, e$
            else, pnumligne, " ", SCLOCHE, 34, "CLOCHE0", 34, e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
                        if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                    pnumligne," BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")", e$
                                    spaces$ = 1
                                    ]
                    ]
            ]

pappeloutil_CM

            if strtool$ = spalpeur_CM,
            [
            spaces$ = 1, pnumligne, *tprint_CM, e$, spaces$ = 0
             pnumligne, " ", SCLOCHE, "0", e$
            spaces$ = 1
            pnumligne, "MSG(",34, t$, strtool$,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
            ss$ = 0
            ssprint_CM = 0

            if opcode$ <> 3, psortie7_CM
            ]
            else,
            [

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil
            if vartool_1 = 0,
            [
            ###subout$### = 4
            serreur_visu_CM = serreurnomoutil_CM + no2str(numop_CM)
            "MW_OP_COMMENT", serreur_visu_CM, e$
            if subout$ <> 3, result = mprint(serreur_visu_CM)
            #exitpost$ # abandonner
            ###subout$### = 3
            erreur_CM = 1
            ]


            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            spaces$ = 1, pnumligne, *tprint_CM, e$
            pnumligne, "MSG(",34, t$, snomoutil,stl_chuck_com,34,")", e$
            pnumligne, "M6 ; CHANGEMENT OUTIL",e$
			spaces$ = 0
            if (mi4_CM > 0) & (mi4_CM <> 9), pnumligne, " ", SCLOCHE, "1", e$
            else, pnumligne, " ", SCLOCHE, "0", e$
            spaces$ = 1
            if tete_rev_ang_droite = 0 & tete_rev_ang_gauche = 0,   # test si on a pas  
                    [
                        rayon_outil = tldia$/2
                        longeur_outil = paramT3 + paramT7
                        var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
						LONG_MAX_CM = var_2 + var_3
						LONG_MIN_CM = var_2 - var_3
						sm,paf, *LONG_MAX_CM, e$
						sm,paf, *LONG_MIN_CM, e$
						sm,paf, "TEST_LONG", e$
                    ]
            ]
#endregion
#region sous programme

psub_call_s$

psub_st_s$

psub_end_s$

psub_call_mm$

psub_call_m$

psub_end_m_r$

psub_st_m$

#endregion
#region ptrans_option

fmt 17 transform_AG
fmt 17 transform_BG
fmt 17 transform_CG
fmt 17 transform_AM
fmt 17 transform_BM
fmt 17 transform_CM
transform_AG : -1
transform_BG : -1
transform_CG : -1
transform_AM : -1
transform_BM : -1
transform_CM : -1

ptrans_option_AG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_AG = 0
                    mi2_A_base_AG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_AG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_AG
					transform_AG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_AG = mi1_trans_AG, mi2_A_base_AG = mi2_trans_AG
                    if sub_trnstyp$ = 0, mi1_C_base_AG = mi1_mirro_AG, mi2_A_base_AG = mi2_mirro_AG
                    if sub_trnstyp$ = 1, mi1_C_base_AG = mi1_rotat_AG, mi2_A_base_AG = mi2_rotat_AG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_AG = 0
                    mi1_C_base_AG = mi1_trans_AG
                    mi2_A_base_AG = mi2_trans_AG
                    ]
                    #"voir",  *mi1_C_base_AG, *mi2_A_base_AG, e$

                    old_sub_trnstyp_AG = sub_trnstyp$
                    old_sub_totl_no_AG = sub_totl_no$
ptrans_option_BG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_BG = 0
                    mi2_A_base_BG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_BG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_BG
					transform_BG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_BG = mi1_trans_BG, mi2_A_base_BG = mi2_trans_BG
                    if sub_trnstyp$ = 0, mi1_C_base_BG = mi1_mirro_BG, mi2_A_base_BG = mi2_mirro_BG
                    if sub_trnstyp$ = 1, mi1_C_base_BG = mi1_rotat_BG, mi2_A_base_BG = mi2_rotat_BG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_BG = 0
                    mi1_C_base_BG = mi1_trans_BG
                    mi2_A_base_BG = mi2_trans_BG
                    ]

                    #"voir",  *mi1_C_base_BG, *mi2_A_base_BG, e$

                    old_sub_trnstyp_BG = sub_trnstyp$
                    old_sub_totl_no_BG = sub_totl_no$
ptrans_option_CG   # dev pour gerer les transformations avec les options 

                    mi1_C_base_CG = 0
                    mi2_A_base_CG = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_CG = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_CG
					transform_CG = 1
                    if sub_trnstyp$ = 3, mi1_C_base_CG = mi1_trans_CG, mi2_A_base_CG = mi2_trans_CG
                    if sub_trnstyp$ = 0, mi1_C_base_CG = mi1_mirro_CG, mi2_A_base_CG = mi2_mirro_CG
                    if sub_trnstyp$ = 1, mi1_C_base_CG = mi1_rotat_CG, mi2_A_base_CG = mi2_rotat_CG
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_CG = 0
                    mi1_C_base_CG = mi1_trans_CG
                    mi2_A_base_CG = mi2_trans_CG
                    ]

                    #"voir",  *mi1_C_base_CG, *mi2_A_base_CG, e$

                    old_sub_trnstyp_CG = sub_trnstyp$
                    old_sub_totl_no_CG = sub_totl_no$
ptrans_option_AM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_AM = 0
                    mi2_A_base_AM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_AM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_AM
					transform_AM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_AM = mi1_trans_AM, mi2_A_base_AM = mi2_trans_AM
                    if sub_trnstyp$ = 0, mi1_C_base_AM = mi1_mirro_AM, mi2_A_base_AM = mi2_mirro_AM
                    if sub_trnstyp$ = 1, mi1_C_base_AM = mi1_rotat_AM, mi2_A_base_AM = mi2_rotat_AM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_AM = 0
                    mi1_C_base_AM = mi1_trans_AM
                    mi2_A_base_AM = mi2_trans_AM
                    ]

                    #"voir",  *mi1_C_base_AM, *mi2_A_base_AM, e$

                    old_sub_trnstyp_AM = sub_trnstyp$
                    old_sub_totl_no_AM = sub_totl_no$
ptrans_option_BM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_BM = 0
                    mi2_A_base_BM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_BM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_BM
					transform_BM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_BM = mi1_trans_BM, mi2_A_base_BM = mi2_trans_BM
                    if sub_trnstyp$ = 0, mi1_C_base_BM = mi1_mirro_BM, mi2_A_base_BM = mi2_mirro_BM
                    if sub_trnstyp$ = 1, mi1_C_base_BM = mi1_rotat_BM, mi2_A_base_BM = mi2_rotat_BM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_BM = 0
                    mi1_C_base_BM = mi1_trans_BM
                    mi2_A_base_BM = mi2_trans_BM
                    ]

                    #"voir",  *mi1_C_base_BM, *mi2_A_base_BM, e$

                    old_sub_trnstyp_BM = sub_trnstyp$
                    old_sub_totl_no_BM = sub_totl_no$
ptrans_option_CM   # dev pour gerer les transformations avec les options 

                    mi1_C_base_CM = 0
                    mi2_A_base_CM = 0

                    if op_id$ <> xform_op_id$,
                    [
                    if transform_CM = 1 & (sub_trnstyp$ = 3), sub_trnstyp$ = old_sub_trnstyp_CM
					transform_CM = 1
                    if sub_trnstyp$ = 3, mi1_C_base_CM = mi1_trans_CM, mi2_A_base_CM = mi2_trans_CM
                    if sub_trnstyp$ = 0, mi1_C_base_CM = mi1_mirro_CM, mi2_A_base_CM = mi2_mirro_CM
                    if sub_trnstyp$ = 1, mi1_C_base_CM = mi1_rotat_CM, mi2_A_base_CM = mi2_rotat_CM
                    if sub_trnstyp$ <> 0 & sub_trnstyp$ <> 1 & sub_trnstyp$ <> 3, psortie_transformation
                    ]
                    else,
                    [
					transform_CM = 0
                    mi1_C_base_CM = mi1_trans_CM
                    mi2_A_base_CM = mi2_trans_CM
                    ]

                    #"voir",  *mi1_C_base_CM, *mi2_A_base_CM, e$

                    old_sub_trnstyp_CM = sub_trnstyp$
                    old_sub_totl_no_CM = sub_totl_no$
#endregion
#region psof
psof$
            if compteur_descrip = 0,    psortie_descripteur
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            psof_AG

            pchange_AM
            psof_AM

            pchange_BG
            psof_BG

            pchange_BM
            psof_BM

            pchange_CG
            psof_CG

            pchange_CM
            psof_CM

fmt 2 numpp
psof_AG        # Debut si outil
			flag_outil_AG = 1
            old_tool_AG = tlngno$
            flag_cloche_AG = 0
			flag_chargement_cloche_AG = 0
            pnumop_AG
			
			rayon_outil = tldia$/2
        	longeur_outil = paramT3 + paramT7
        	var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        	if stl_mfg_com = svide, psortietest_outil
			
            if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
            if mr2$ = -1, psortie13_AG
            if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
            ptrans_option_AG  # mise a jour des variable mi1 et mi2 
            #" voir operation_AG ", *op_id$, *xform_op_id$, *sub_trnstyp$, e$
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pcantext_AG
            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AG
          gcode$ = 0
		  spaces$ = 1
          sm,paf, "(USINAGE AVEC OUTIL", t$, ")", e$
          sm,paf, "G90 G17 G40 G80 G0 G94",e$
          mr8_AG = DEC_X_AG + mr8$
          mr9_AG = DEC_Y_AG + mr9$
          mr10_AG = DEC_Z_AG + mr10$
          sm,paf, "E60001=", *mr8_AG ,e$
          sm,paf, "E61001=", *mr9_AG ,e$
          sm,paf, "E62001=", *mr10_AG ,e$
          sm,paf, "E64001=E61001",e$
            cycle_heli_spiral_AG = 0
        vale84_AG =   -2022875+(mr3$ * 1000)
        if mr3$ <= 0 | mr3$ > 1892.875 , vale84_AG =   -130000
        if mr3$ > 0 & mr3$ < 1233.432 , vale84_AG =   -691000
          sm,paf, *vale84_AG,e$
          prvop_id_AG = op_id$
          #n, "G0 G52 Z-130"
          sm,paf, "M9",e$
          sm,paf, "M5",e$
          sm,paf, "M151",e$
          e53_AG = 53000 + tlngno$
          if mi4_AG >= 1 & mi4_AG <=6,
          [
          sm, paf, tlngno$,e$

          @e53_AG
          sm,paf,spaces$ = 0, " ", e53_AG,"=0",spaces$ = 1, e$
          nplus_AG = n_AG + ( 5 * seqinc$)

          e40 = tprint_AG
           sm,paf,spaces$ = 0, " G79 E40000=", e40," ", *nplus_AG, spaces$ = 1, e$
          spaces$ = 1
          ]
          sm, paf, "M170",e$
          if t$ > 16 & t$ < 20 | t$ > 29 ,	[
		  									if prog_AG = 1, q1
											]
          if t$ < 16 , station_tool = 1
          if t$ > 20 , station_tool = 2
         # if t$ > 20 & station_tool = 2, sm, paf, "M6 T0",e$# depose outil 
          if t$ = tete_rev_ang_11, sm,paf, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
          if t$ = tete_rev_ang_12 , sm,paf, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
          if t$ = tete_rev_ang_21 , sm,paf, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
          if t$ = tete_rev_ang_22 , sm,paf, "( Outil renvoi angle ",tete_rev_ang_22,")",e$

          #sm,paf, "M6", *tprint_AG, *tlngno$,e$
          pdebut_chagement_outil_AG
          ptlngno_AG
          mr4_AG = mr4$
          sm,paf,spaces$ = 0," ", e53_AG,"=", *mr4_AG,e$
          spaces$ = 1
          if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)) | t$ > 16, sm, paf, *spdlon_AG, "M40", ssprint_AG,e$
              old_ss = ssprint_AG
            plubrifon_AG,e$
            numpp = 1
            comment$
            "MW_OP_COMMENT", strcom_AG, e$
            if mi2_A_base_AG = 0, invers_AG = 0
            if mi2_A_base_AG = 2, invers_AG = 1

            if opcode$ = 16, pchange_AM, psof_AM
            prot1_AG
            pprint_AG
           if mr2print_AG = 0, mr2print_AG =zsecuprint
                prvmr2_AG = mr2print_AG
                pcalxyz3d_AG
			if t$ = 51 | t$ = 52 | t$ = 61 | t$ = 62,
					[
           			if  mr2print_AG <> -1,	[
                                    		if t$ = 51 | t$ = 52, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm, "X-2245.", e$
                                    		if t$ = 61 | t$ = 62, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm, "X-2005.", e$
											]
             						else,	[
                                    		if t$ = 51 | t$ = 52, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm, "X-2245.", e$
                                    		if t$ = 61 | t$ = 62, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm, "X-2005.", e$
                                    		]
					]
			else, 	[
           			if  mr2print_AG <> -1,	[
                                    		if flag_cloche_AG = 1, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm,sxcloche_AG, sycloche_AG,e$, flag_cloche_AG = 0
                                    		else, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm, sxmag_AG, symag_AG,e$
                                    		]
             						else,	[
                                    		if flag_cloche_AG = 1, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm,sxcloche_AG, sycloche_AG,e$, flag_cloche_AG = 0
                                    		else, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm,sxmag_AG, symag_AG,e$
                                    		]
					]

          spaces$ = 0
           spaces$ = 1

           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_AG
           old_x_AG=xrprint_AG
           old_y_AG=yrprint_AG
           old_z_AG=zrprint_AG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_AG = mi4_AG
       frbase_AG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       pugv_AG
       changop_AG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_BG        # Debut si outil
			flag_outil_BG = 1
            old_tool_BG = tlngno$
            flag_cloche_BG = 0
			flag_chargement_cloche_BG = 0
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_BG
			
			rayon_outil = tldia$/2
        	longeur_outil = paramT3 + paramT7
        	var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        	if stl_mfg_com = svide, psortietest_outil
			
            if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
            if mr2$ = -1, psortie13_BG
            ptrans_option_BG  # mise a jour des variable mi1 et mi2 
            pcantext_BG
            if oscilliation = 1 & mi7$ <> 0, psortie12_BG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BG
            ptestcloche_BG
          gcode$ = 0

          sm,paf, "CRENO_START", e$
          mr8_BG = DEC_X_BG + mr8$
          mr9_BG = DEC_Y_BG + mr9$
          mr10_BG = DEC_Z_BG + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          sm,paf, spaces$ = 0," $P_UIFR[1]=CTRANS(",mr8_BG,","mr9_BG,","mr10_BG,",A,0.,C,0.)",e$,spaces$ = 1
          sm,paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          sm,paf, ";(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #sm, paf, "G90 G17 G40 G80 G0 G94",e$

          prvop_id_BG = op_id$
          #n, "G0 G52 Z-130"
          #sm, paf, "=> a valider","M9",e$
          sm,paf, "TRANS ; RAZ TRANSLATION ", e$
          sm,paf, "ROT ; RAZ ROTATION ", e$
          sm,paf, "TRAFOOF ; RAZ RTCP ", e$
          sm,paf, "FFWON ; SYNCRO AVANCES ", e$
          sm,paf, "SOFT ; FONCTION DE LISSAGE", e$
          sm,paf, "M5 ; ARRET BROCHE",e$
          sm,paf, "M151 ; ARRET ASPI",e$
          tlngno$ = 1
          ptestrenvoi_angle_BG
          pdebut_chagement_outil_BG
          spaces$ = 0

          pappeloutil_BG
          mr4_BG = mr4$
          if mr4$ > 0, sm,paf, mr4_BG, e$
          ptlngno_BG
          spaces$ = 1
          sm,paf, *spdlon_BG, ssprint_BG,e$
          old_ss = ssprint_BG
          plubrifon_BG
          numpp = 2
          comment$
          "MW_OP_COMMENT", strcom_BG, e$
          if mi2_A_base_BG = 0, invers_BG = 0
          if mi2_A_base_BG = 2, invers_BG = 1
            #sm, paf, "G642 ; LISSAGE POURSUITE", e$
            #sm, paf, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_BG
            sm,paf, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           sm, paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
            sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
            if mi9$ = -1, sm,paf, "M210", e$
            else, sm,paf, "M211", e$
            if opcode$ = 16, pchange_BM, psof_BM
            prot1_BG
            pprint_BG
            if mr2print_BG = 0, mr2print_BG =zsecuprint
            prvmr2_BG = mr2print_BG
            pcalxyz3d_BG
            if  mr2print_BG <> -1,  [
                                    if flag_cloche_BG = 1, sr,*mr2print_BG,paf,pgcode_force_BG, *mr2$ ,sm, sxcloche_BG, sycloche_BG,e$, flag_cloche_BG = 0
                                    else, sr,*mr2print_BG,paf,pgcode_force_BG, *mr2$ ,sm, sxmag_BG, symag_BG,e$
                                    ]
            else,                   [
                                    if flag_cloche_BG = 1, sr,*zrprint_BG,paf, pgcode_force_BG,*z1_BG,sm, sxcloche_BG, sycloche_BG,e$, flag_cloche_BG = 0
                                    else, sr,*zrprint_BG,paf, pgcode_force_BG,*z1_BG,sm, sxmag_BG, symag_BG,e$
                                    ]
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_BG
           old_x_BG=xrprint_BG
           old_y_BG=yrprint_BG
           old_z_BG=zrprint_BG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_BG = mi4_BG
       frbase_BG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_BG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_CG        # Debut si outil
			flag_outil_CG = 1
			garage_CG = 0
			flagmr2_CG = 0
			old_opcode_cloche_CG = opcode$
			flag_cloche_CG = 0
			flag_chargement_cloche_CG = 0
            old_tool_CG = tlngno$
            if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
            else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_CG
			
			rayon_outil = tldia$/2
        	longeur_outil = paramT3 + paramT7
        	var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        	if stl_mfg_com = svide, psortietest_outil
			
            if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
            if mr2$ = -1, psortie13_CG
            ptrans_option_CG  # mise a jour des variable mi1 et mi2 
            pcantext_CG
            if oscilliation = 1 & mi7$ <> 0, psortie12_CG
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CG
            ptestcloche_CG
          gcode$ = 0

          #sm, paf, " CRENO_START", e$
          mr8_CG = DEC_X_CG + mr8$
          mr9_CG = DEC_Y_CG + mr9$
          mr10_CG = DEC_Z_CG + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          sm,paf, spaces$ = 0, " $P_UIFR[1]=CTRANS(",mr8_CG,","mr9_CG,","mr10_CG,",A,0.,C,0.)",e$, spaces$ = 1
          sm,paf, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          sm,paf, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #sm, paf, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_CG = op_id$
          #n, "G0 G52 Z-130"
          #sm, paf, "=> a valider","M9",e$
          sm,paf, "TRANS ; RAZ TRANSLATION ", e$
          sm,paf, "ROT ; RAZ ROTATION ", e$
          sm,paf, "TRAFOOF ; RAZ RTCP ", e$
          sm,paf, "FFWON ; SYNCRO AVANCES ", e$
          sm,paf, "SOFT ; FONCTION DE LISSAGE", e$
          sm,paf, "M5 ; ARRET BROCHE",e$
          sm,paf, "M302 ; ARRET ASPI 1", e$
          sm,paf, "M304 ; ARRET ASPI 2", e$
          tlngno$ = 1
          ptestrenvoi_angle_CG
          pdebut_chagement_outil_CG
          spaces$ = 0
          pappeloutil_CG
          mr4_CG = mr4$
          if mr4$ > 0, sm,paf, mr4_CG, e$
          ptlngno_CG
          spaces$ = 1
          sm,paf, *spdlon_CG, ssprint_CG,e$
          old_ss = ssprint_CG
          plubrifon_CG
          numpp = 3
          comment$
          "MW_OP_COMMENT", strcom_CG, e$
          if mi2_A_base_CG = 0, invers_CG = 0
          if mi2_A_base_CG = 2, invers_CG = 1
            #sm, paf, "G642 ; LISSAGE POURSUITE", e$
            #sm, paf, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_CG
            sm,paf, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           sm, paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
            sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, sm, paf, "M210", e$
            #else, sm, paf, "M211", e$
            if opcode$ = 16, pchange_CM, psof_CM
            prot1_CG
            pprint_CG
            if mr2print_CG = 0, mr2print_CG =zsecuprint
            prvmr2_CG = mr2print_CG
            pcalxyz3d_CG
            if  mr2print_CG <> -1, sr,*mr2print_CG,paf,pgcode_force_CG, *mr2$ ,sm, sxmag_CG, symag_CG,e$
            else, sr,*zrprint_CG,paf, pgcode_force_CG,*z1_CG,sm, sxmach_CG, symag_CG,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_CG
           old_x_CG=xrprint_CG
           old_y_CG=yrprint_CG
           old_z_CG=zrprint_CG
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_CG = mi4_CG
       frbase_CG = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_CG = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_AM        # Debut si outil
        pnumop_AM
        if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
        if mr2$ = -1, psortie13_AM
            if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
            ptrans_option_AM  # mise a jour des variable mi1 et mi2 
            #" voir operation_AM ", *op_id$, *xform_op_id$, *sub_trnstyp$, e$
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pcantext_AM
            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AM
          gcode$ = 0
          #enlevé pour concat#pnumligne, "(USINAGE AVEC OUTIL", t$, ")", e$
          #enlevé pour concat#pnumligne, "G90 G17 G40 G80 G0 G94",e$
          mr8_AM = DEC_X_AM + mr8$
          mr9_AM = DEC_Y_AM + mr9$
          mr10_AM = DEC_Z_AM + mr10$
          #enlevé pour concat#pnumligne, "E60001=", *mr8_AM ,e$
          #enlevé pour concat#pnumligne, "E61001=", *mr9_AM ,e$
          #enlevé pour concat#pnumligne, "E62001=", *mr10_AM ,e$
          #enlevé pour concat#pnumligne, "E64001=E61001",e$
            cycle_heli_spiral_AM = 0
        vale84_AM =   -2022875+(mr3$ * 1000)
        if mr3$ <= 0 | mr3$ > 1892.875 , vale84_AM =   -130000
        if mr3$ > 0 & mr3$ < 1233.432 , vale84_AM =   -691000
          #enlevé pour concat#pnumligne, *vale84_AM,e$
          prvop_id_AM = op_id$
          #n, "G0 G52 Z-130"
          #enlevé pour concat#pnumligne, SARRET_LUB,e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          e53_AM = 53000 + tlngno$
          #e53_AM = tlngno$
          if mi4_AM >= 1 & mi4_AM <=6,
          [
          tlngno_AM = tlngno$
          #enlevé pour concat#pnumligne, tlngno_AM,e$
          spaces$ = 0
          @e53_AM
          #enlevé pour concat#pnumligne," ", e53_AM,"=0",e$
          nplus_AM = n_AM + ( 5 * seqinc$)
          spaces$ = 0
          e40 = tprint_AM
           #enlevé pour concat#pnumligne," G79 E40000=", e40," ", *nplus_AM,e$
          spaces$ = 1
          ]
          #enlevé pour concat#pnumligne, SCLOCHE, spaces$ = 0, "0", spaces$ = 1, e$
          if t$ > 16 & t$ < 20 | t$ > 29,	[
											if prog_AM = 1, q4
											]
          if t$ < 16 , station_tool = 1
          if t$ > 20 , station_tool = 2
         # if t$ > 20 & station_tool = 2, pnumligne, "M6 T0",e$# depose outil 
          if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
          if t$ = tete_rev_ang_12 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
          if t$ = tete_rev_ang_21 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
          if t$ = tete_rev_ang_22 , pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
          tlngno_AM = tlngno$
          pnumligne, "M6", *tprint_AM, *tlngno_AM,e$
          ptlngno_AM
          spaces$ = 0
          mr4_AM = mr4$
          pnumligne," ", e53_AM,"=", *mr4_AM,e$
          spaces$ = 1
          if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)) | t$ > 16, pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
              old_ss = ssprint_AM
            plubrifon_AM,e$
            numpp = 4
            comment$
            pnumligne, strcom_AM, e$
            if mi2_A_base_AM = 0, invers_AM = 0
            if mi2_A_base_AM = 2, invers_AM = 1

            if opcode$ = 16, pchange_BG, psof_BG
            prot1_AM
            pprint_AM
           if mr2print_AM = 0, mr2print_AM =zsecuprint
                prvmr2_AM = mr2print_AM
                pcalxyz3d_AM
           if  mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
             else, pnumligne, pgcode_force_AM,*z1_AM,e$
          spaces$ = 0
           spaces$ = 1

           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_AM
           old_x_AM=xrprint_AM
           old_y_AM=yrprint_AM
           old_z_AM=zrprint_AM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_AM = mi4_AM
       frbase_AM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       pugv_AM
       changop_AM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_BM        # Debut si outil
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_BM
            if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
            if mr2$ = -1, psortie13_BM
            ptrans_option_BM  # mise a jour des variable mi1 et mi2 
            pcantext_BM
            if oscilliation = 1 & mi7$ <> 0, psortie12_BM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BM
            ptestcloche_BM
          gcode$ = 0
          spaces$ = 0
          #enlevé pour concat#pnumligne, " CRENO_START", e$
          mr8_BM = DEC_X_BM + mr8$
          mr9_BM = DEC_Y_BM + mr9$
          mr10_BM = DEC_Z_BM +mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          #enlevé pour concat#pnumligne, " $P_UIFR[1]=CTRANS(",mr8_BM,","mr9_BM,","mr10_BM,",A,0.,C,0.)",e$
          #enlevé pour concat#pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          #enlevé pour concat#pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_BM = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          #enlevé pour concat#pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          #enlevé pour concat#pnumligne, "ROT ; RAZ ROTATION ", e$
          #enlevé pour concat#pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          #enlevé pour concat#pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          #enlevé pour concat#pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          tlngno$ = 1
          ptestrenvoi_angle_BM
          spaces$ = 0
          pappeloutil_BM
          mr4_BM = mr4$
          if mr4$ > 0, pnumligne, mr4_BM, e$
          ptlngno_BM
          spaces$ = 1
          pnumligne, *spdlon_BM, ssprint_BM,e$
          old_ss = ssprint_BM
          plubrifon_BM
          numpp = 5
          comment$
          pnumligne, strcom_BM, e$
          if mi2_A_base_BM = 0, invers_BM = 0
          if mi2_A_base_BM = 2, invers_BM = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_BM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            if mi9$ = -1, pnumligne, "M210", e$
            else, pnumligne, "M211", e$
            if opcode$ = 16, pchange_CG, psof_CG
            prot1_BM
            pprint_BM
            if mr2print_BM = 0, mr2print_BM =zsecuprint
            prvmr2_BM = mr2print_BM
            pcalxyz3d_BM
            if  mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            else, pnumligne, pgcode_force_BM,*z1_BM,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_BM
           old_x_BM=xrprint_BM
           old_y_BM=yrprint_BM
           old_z_BM=zrprint_BM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_BM = mi4_BM
       frbase_BM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_BM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes

psof_CM        # Debut si outil
            if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
            else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM
            #"voir", cantext$, cant_pos1$,cant_val1$, cant_pos2$, cant_val2$, cant_pos3$, cant_val3$, e$
            pnumop_CM
            if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
            if mr2$ = -1, psortie13_CM
            ptrans_option_CM  # mise a jour des variable mi1 et mi2 
            pcantext_CM
            if oscilliation = 1 & mi7$ <> 0, psortie12_CM
            if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CM
            ptestcloche_CM
          gcode$ = 0
          spaces$ = 0
          #enlevé pour concat#pnumligne, " CRENO_START", e$
          mr8_CM = DEC_X_CM + mr8$
          mr9_CM = DEC_Y_CM + mr9$
          mr10_CM = DEC_Z_CM + mr10$
#   MODIF EDC LE 22 NOVEMBRE 2013 - DEBUT
          #enlevé pour concat#pnumligne, " $P_UIFR[1]=CTRANS(",mr8_CM,","mr9_CM,","mr10_CM,",A,0.,C,0.)",e$
          #enlevé pour concat#pnumligne, " DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
          #enlevé pour concat#pnumligne, " ;(",34,"USINAGE AVEC OUTIL",strtool$, 34, ")", e$
#   MODIF EDC LE 22 NOVEMBRE 2013 - FIN 
          #pnumligne, "G90 G17 G40 G80 G0 G94",e$
          spaces$ = 1
          prvop_id_CM = op_id$
          #n, "G0 G52 Z-130"
          #pnumligne, "=> a valider","M9",e$
          #enlevé pour concat#pnumligne, "TRANS ; RAZ TRANSLATION ", e$
          #enlevé pour concat#pnumligne, "ROT ; RAZ ROTATION ", e$
          #enlevé pour concat#pnumligne, "TRAFOOF ; RAZ RTCP ", e$
          #enlevé pour concat#pnumligne, "FFWON ; SYNCRO AVANCES ", e$
          #enlevé pour concat#pnumligne, "SOFT ; FONCTION DE LISSAGE", e$
          #enlevé pour concat#pnumligne, SROTATION_BROCHE_ARRET,e$
          #enlevé pour concat#pnumligne, SARRET_ASPI,e$
          tlngno$ = 1
          ptestrenvoi_angle_CM
          spaces$ = 0
          pappeloutil_CM
          mr4_CM = mr4$
          if mr4$ > 0, pnumligne, mr4_CM, e$
          ptlngno_CM
          spaces$ = 1
          pnumligne, *spdlon_CM, ssprint_CM,e$
          old_ss = ssprint_CM
          plubrifon_CM
          numpp = 6
          comment$
          pnumligne, strcom_CM, e$
          if mi2_A_base_CM = 0, invers_CM = 0
          if mi2_A_base_CM = 2, invers_CM = 1
            #pnumligne, "G642 ; LISSAGE POURSUITE", e$
            #pnumligne, "COMPCAD ; COMPRESSEUR POUR LECTURE ANTICIPEE", e$ 
            pcycle832_CM
            pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#           pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
            pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
            pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
            #if mi9$ = -1, pnumligne, "M210", e$
            #else, pnumligne, "M211", e$
            if opcode$ = 16, ex$
            prot1_CM
            pprint_CM
            if mr2print_CM = 0, mr2print_CM =zsecuprint
            prvmr2_CM = mr2print_CM
            pcalxyz3d_CM
            if  mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *mr2print_CM ,e$
            else, pnumligne, pgcode_force_CM,*z1_CM,e$
           # if xr <> 0 | yr <> 0, n, *xr, *yr
           prot2_CM
           old_x_CM=xrprint_CM
           old_y_CM=yrprint_CM
           old_z_CM=zrprint_CM
           vale53 = 0
           sens_pas = -1
           debutvar = 0
       oldstation_CM = mi4_CM
       frbase_CM = fr$
       if mr5$ <= 0, mr5$ = 0.0001
       changop_CM = 1
       retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
#endregion
#region plansecu2

plansecu2_AG    # retour au plan de retournement 
       pcalxyz3d_AG
plansecu2_BG    # retour au plan de retournement 
       pcalxyz3d_BG
plansecu2_CG    # retour au plan de retournement 
       pcalxyz3d_CG
plansecu2_AM    # retour au plan de retournement 
       pcalxyz3d_AM
plansecu2_BM    # retour au plan de retournement 
       pcalxyz3d_BM
plansecu2_CM    # retour au plan de retournement 
       pcalxyz3d_CM
#endregion
#region plansecu

plansecu_AG    # voir si pas deja passer dans premx
        pcalxyz3d_AG
        if prvop_id_AG <> op_id$,
        [
            sm,paf, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if  opcode$ <> 16  & mr2print_AG <>   -1,   [
                                                        if flag_cloche_AG = 1, sr, *mr2print_AG, sazero, sczero, paf,pgcode_force_AG, *mr2$ , sm, sxcloche_AG, sycloche_AG, e$,flag_cloche_AG = 0
                                                        else, sr, *mr2print_AG, paf, pgcode_force_AG, *mr2$, e$
                                                        ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_AG <>   -1,sm, paf,pgcode_AG,zrprint_AG,e$
            if opcode$ = 16 & mr2print_AG <>   -1,      [
                                                        if flag_cloche_AG = 1, sr, *zrprint_AG, sazero, sczero, paf,pgcode_AG,*zrprint_AG, sm, sxcloche_AG, sycloche_AG, e$,flag_cloche_AG = 0
                                                        else, sr, *zrprint_AG, paf,pgcode_AG,*zrprint_AG,e$
                                                        ]
            if nextop$ <> 11,
                         [
                         if mr2print_AG = -1,	[
						 						if opcode$ <> 3, sr, *xprint_AG, *yprint_AG, *zprint_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *x3dprint_AG, *y3dprint_AG, *z3dprint_AG, *axeCpos1_AG, *axeApos1_AG,e$
												]
                         else,  [
                                sr, *xrprint_AG, *yrprint_AG,*mr2print_AG, *axeCpos1_AG, *axeApos1_AG, paf,pgcode_force_AG, *x3dprint_AG, *y3dprint_AG, *axeCpos1_AG, *axeApos1_AG,e$
                                if opcode$ = 3 & m1$ = 1 & m5$ = 1 & m9$ = 1, sr, *xrprint_AG, *yrprint_AG, paf, pgcode_force_AG, *x3dprint_AG, *y3dprint_AG, e$
                                ]
                         ]
           else,
                        [
                         if mr2print_AG = -1,  sr, *x3dprint_AG,*y3dprint_AG,*z3dprint_AG, paf, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG,*z3dprint_AG, e$
                         else,  sr, *x3dprint_AG,*y3dprint_AG, paf, pgcode_force_AG, *x3dprint_AG,*y3dprint_AG, e$
                        ]
           sm, paf, "G151", *axeCpos_AG, *axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
        ]

plansecu_BG    # voir si pas deja passer dans premx
        pcalxyz3d_BG
        if prvop_id_BG <> op_id$,
        [
            panul_plan_inc_BG
            if  opcode$ <> 16  & mr2print_BG <>   -1,   [
                                                        if flag_cloche_BG = 1, sr, *mr2print_BG, sazero, sczero, paf, pgcode_force_BG, *mr2$ ,sm, sxcloche_BG, sycloche_BG,e$,flag_cloche_BG = 0
                                                        else, sr, *mr2print_BG, paf, pgcode_force_BG, *mr2$ ,e$
                                                        ]
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_BG <>   -1,sm, paf,pgcode_BG,zrprint_BG,e$
            if opcode$ = 16 & mr2print_BG <>   -1,      [
                                                        if flag_cloche_BG = 1, sr, *zrprint_BG, sazero, sczero, paf, pgcode_BG,*zrprint_BG,sm, sxcloche_BG, sycloche_BG,e$,flag_cloche_BG = 0
                                                        else, sr, *zrprint_BG, paf, pgcode_BG,*zrprint_BG,e$
                                                        ]

            if nextop$ <> 11,
                         [
                         if mr2print_BG = -1,   [
						 						if opcode$ <> 3, sr, *xprint_BG, *yprint_BG, *zprint_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *x3dprint_BG, *y3dprint_BG, *z3dprint_BG, *axeCpos1_BG, *axeApos1_BG, e$
												]
                         else,  [
                                sr, *xrprint_BG, *yrprint_BG,*mr2print_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *x3dprint_BG, *y3dprint_BG, *axeCpos1_BG, *axeApos1_BG, e$
                                if opcode$ = 3 & m1$ = 1 & m5$ = 1 & m9$ = 1, sr *xrprint_BG, *yrprint_BG, paf, pgcode_force_BG, *x3dprint_BG, *y3dprint_BG, e$
                                ]
                         ]
           else,
                        [
                         if mr2print_BG = -1,  sr, *x3dprint_BG,*y3dprint_BG,*z3dprint_BG, paf, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,*z3dprint_BG, e$
                         else,  sr, *x3dprint_BG,*y3dprint_BG, paf, pgcode_force_BG, *x3dprint_BG,*y3dprint_BG,e$
                        ]
           sm,paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm,paf, "AROT", axeCpos_BG, axeApos_BG, e$
        ]

plansecu_CG    # voir si pas deja passer dans premx
        pcalxyz3d_CG
        if prvop_id_CG <> op_id$,
        [
            panul_plan_inc_CG
			pgestionduB_cloche_CG
			if axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG

			if garage_CG <> 0,	[
								if change_cloche_CG = 1, axeA_cloche_CG = 1
								axeA_cloche_CG = 0
			            		if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG = 0 , 	[
																								if flagmr2_CG = 2,	[
																													sr, *mr2print_CG
																													#if garage_CG = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 3, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 6, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 8, sb_quatre_vingt_dix, sczero
																													#if garage_CG = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 11, sb_quatre_vingt_dix, sczero	
																													#if garage_CG = 12, sb_moins_quatre_vingt_dix, sczero																											
																													sbzero
																													paf, pgcode_force_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																													#garage_CG = 0
																													]

																											else,	[
																													sr, *mr2print_CG
																													#if garage_CG = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 3, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 6, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 8, sb_quatre_vingt_dix, sczero
																													#if garage_CG = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 11, sb_quatre_vingt_dix, sczero	
																													#if garage_CG = 12, sb_moins_quatre_vingt_dix, sczero
																													sbzero
																													paf, pgcode_force_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																													#garage_CG = 0
																													ptlngno2_CG
																													]
																								]
																								
								if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG <> 0 ,	[
																								if flagmr2_CG = 2,	[
																													sr, *mr2print_CG
																													#if garage_CG = 1, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 2, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 3, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 4, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 5, sb_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 6, sb_moins_quatre_vingt_dix, sczero
																													#if garage_CG = 7, sb_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 8, sb_quatre_vingt_dix, sczero
																													#if garage_CG = 9, sb_moins_quatre_vingt_dix, sc_cent_quatre_vingt
																													#if garage_CG = 10, sb_moins_quatre_vingt_dix, sc_moins_cent_quatre_vingt
																													#if garage_CG = 11, sb_quatre_vingt_dix, sczero	
																													#if garage_CG = 12, sb_moins_quatre_vingt_dix, sczero
																													sbzero
																													paf, pgcode_force_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																													#garage_CG = 0
																													]
																											else,	[
																													sr, *mr2print_CG
																													#if garage_CG = 1, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																													#if garage_CG = 2, sb_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_soixante
																													#if garage_CG = 3, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante
																													#if garage_CG = 4, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																													#if garage_CG = 5, sb_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_soixante
																													#if garage_CG = 6, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante
																													#if garage_CG = 7, sb_soixante, sc_cent_quatre_vingt, string_B_CG = sb_soixante
																													#if garage_CG = 8, sb_soixante, sczero, string_B_CG = sb_soixante
																													#if garage_CG = 9, sb_moins_soixante, sc_cent_quatre_vingt, string_B_CG = sb_moins_soixante
																													#if garage_CG = 10, sb_moins_soixante, sc_moins_cent_quatre_vingt, string_B_CG = sb_moins_soixante
																													#if garage_CG = 11, sb_soixante, sczero, string_B_CG = sb_soixante				
																													#if garage_CG = 12, sb_moins_soixante, sczero, string_B_CG = sb_moins_soixante	
																													sbzero
																													#paf, pgcode_force_CG, *mr2print_CG, string_B_CG, sm, sxmach_garage_CG, symach_garage_CG, e$
																													paf, pgcode_force_CG, *mr2$, sm, sxmach_garage_CG, symach_garage_CG, e$
																													#garage_CG = 0
																													ptlngno2_CG
																													]
																								]			
								]
		
						else,	[				
			            		if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG = 0 , 	[
																								if flagmr2_CG = 2, sr, *mr2print_CG, paf, pgcode_force_CG, *mr2$ ,e$
																								else, sr, *mr2print_CG, paf, pgcode_force_CG, *mr2$ ,e$, ptlngno2_CG
																								]
																								
								if  opcode$ <> 16  & mr2print_CG <> -1 & axeA_cloche_CG <> 0 ,	[
																								if flagmr2_CG = 2, sr, *mr2print_CG, paf, pgcode_force_CG, *mr2$ ,e$
																								else, sr, *mr2print_CG, *axeA_cloche_CG, paf, pgcode_force_CG, *mr2$, *axeA_cloche_CG, e$, ptlngno2_CG
																								]
								]						
																			
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_CG <>   -1,pnumligne,pgcode_CG,zrprint_CG,e$
            if opcode$ = 16 & mr2print_CG <> -1 & axeA_cloche_CG = 0, sr, *zrprint_CG, paf, pgcode_CG,*zrprint_CG,e$
			if opcode$ = 16 & mr2print_CG <> -1 & axeA_cloche_CG <> 0, sr, *zrprint_CG, *axeA_cloche_CG, paf, pgcode_CG,*zrprint_CG, *axeA_cloche_CG, e$, ptlngno2_CG		
			
			if nextop$ <> 11,
                         [
						 if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        				 if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
                         if mr2print_CG = -1,   [
						 						if opcode$ <> 3, sr, *xprint_CG, *yprint_CG, *zprint_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *x3dprint_CG, *y3dprint_CG, *z3dprint_CG, *axeCpos1_CG, *axeApos1_CG, e$
												]
                         else,  [
                                sr, *xrprint_CG, *yrprint_CG,*mr2print_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *x3dprint_CG, *y3dprint_CG, *axeCpos1_CG, *axeApos1_CG, e$
                                if opcode$ = 3 & m1$ = 1 & m5$ = 1 & m9$ = 1, sr, *xrprint_CG, *yrprint_CG, paf, pgcode_force_CG, *x3dprint_CG, *y3dprint_CG, e$
                                ]
                         ]
           else,
                        [
                         if mr2print_CG = -1,  sr, *x3dprint_CG,*y3dprint_CG,*z3dprint_CG, paf, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,*z3dprint_CG, e$
                         else,  sr, *x3dprint_CG,*y3dprint_CG, paf, pgcode_force_CG, *x3dprint_CG,*y3dprint_CG,e$
                        ]
           sm,paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm,paf, "AROT", axeCpos_CG, axeApos_CG, e$
		   sm, paf, "M32 ; BLOCAGE AXE B", e$,sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
        ]

plansecu_AM    # voir si pas deja passer dans premx
        pcalxyz3d_AM
        if prvop_id_AM <> op_id$,
        [
            pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            if  opcode$ <> 16  & mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_AM <>   -1,pnumligne,pgcode_AM,zrprint_AM,e$
            if opcode$ = 16 & mr2print_AM <>   -1,pnumligne,pgcode_AM,zrprint_AM,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_AM = -1,   pgcode_force_AM, *x3dprint_AM, *y3dprint_AM, *z3dprint_AM, axeCpos1_AM, axeApos1_AM, e$
                         else, pgcode_force_AM, *x3dprint_AM, *y3dprint_AM,axeCpos1_AM, axeApos1_AM, e$
                         ]
           else,
                        [
                         if mr2print_AM = -1,  pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,*z3dprint_AM, e$
                         else,  pnumligne, pgcode_force_AM, *x3dprint_AM,*y3dprint_AM,e$
                        ]
           pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
        ]

plansecu_BM    # voir si pas deja passer dans premx
        pcalxyz3d_BM
        if prvop_id_BM <> op_id$,
        [
            panul_plan_inc_BM
            if  opcode$ <> 16  & mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_BM <>   -1,pnumligne,pgcode_BM,zrprint_BM,e$
            if opcode$ = 16 & mr2print_BM <>   -1,pnumligne,pgcode_BM,zrprint_BM,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_BM = -1,   pgcode_force_BM, *x3dprint_BM, *y3dprint_BM, *z3dprint_BM, axeCpos1_BM, axeApos1_BM, e$
                         else, pgcode_force_BM, *x3dprint_BM, *y3dprint_BM,axeCpos1_BM, axeApos1_BM, e$
                         ]
           else,
                        [
                         if mr2print_BM = -1,  pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,*z3dprint_BM, e$
                         else,  pnumligne, pgcode_force_BM, *x3dprint_BM,*y3dprint_BM,e$
                        ]
           pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
        ]

plansecu_CM    # voir si pas deja passer dans premx
        pcalxyz3d_CM
        if prvop_id_CM <> op_id$,
        [
            panul_plan_inc_CM
            if  opcode$ <> 16  & mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *mr2print_CM ,e$
            #if opcode$ = 16 & mi3$ <> 0 & mr2print_CM <>   -1,pnumligne,pgcode_CM,zrprint_CM,e$
            if opcode$ = 16 & mr2print_CM <>   -1,pnumligne,pgcode_CM,zrprint_CM,e$
            if nextop$ <> 11,pnumligne,
                         [
                         if mr2print_CM = -1,   pgcode_force_CM, *x3dprint_CM, *y3dprint_CM, *z3dprint_CM, axeCpos1_CM, axeApos1_CM, e$
                         else, pgcode_force_CM, *x3dprint_CM, *y3dprint_CM,axeCpos1_CM, axeApos1_CM, e$
                         ]
           else,
                        [
                         if mr2print_CM = -1,  pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,*z3dprint_CM, e$
                         else,  pnumligne, pgcode_force_CM, *x3dprint_CM,*y3dprint_CM,e$
                        ]
           pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
		   sm, paf, "M32 ; BLOCAGE AXE B", e$,sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
        ]
#endregion      
#endregion

#region   PTLCHG PEOF #OK
#region ptlchg0
ptlchg0$
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            ptlchg0_AG

            pcont_garage_AM
            pchange_AM
            ptlchg0_AM

            pchange_BG
            ptlchg0_BG

            pcont_garage_BM
            pchange_BM
            ptlchg0_BM

            pchange_CG
            ptlchg0_CG

            pcont_garage_CM
            pchange_CM
            ptlchg0_CM

            old_numprg_garage_AM = numprg_garage_AM
            old_numprg_garage_BM = numprg_garage_BM
            old_numprg_garage_CM = numprg_garage_CM
            old_progno_AM = numprg_concat_AM
            old_progno_BM = numprg_concat_BM
            old_progno_CM = numprg_concat_CM

ptlchg0_AG     # Changement outil nul
			flag_outil_AG = 0
			flag_changement_outil_AG = 0
			arret_prog_AG = 0
            flag_cloche_AG = 0
            strcom_AG = svide
            premperc_AG = 1
            if op_id$ <> prvop_id_AG,
                                    [
                                    sf, e$
                                    spaces$ = 0
                                    ppreptete
                                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                                    spaces$ = 1
                                    @tox4$,@toy4$,@toz4$, @old_corg_x_AG, @old_corg_y_AG,@old_corg_z_AG
                                    if (tox4$ = old_corg_x_AG) & (toy4$ = old_corg_y_AG)  & (toz4$ = old_corg_z_AG),
                                                                        [
                                                                        xprintcorg_AG = xprint_AG
                                                                        yprintcorg_AG = yprint_AG
                                                                        zprintcorg_AG = zprint_AG
                                                                        ]
                                                                        else,
                                                                        [
																		dif_old_corg_x_AG = old_corg_x_AG - tox4$
																		dif_old_corg_y_AG = old_corg_y_AG - toy4$
																		dif_old_corg_z_AG = old_corg_z_AG - toz4$
                                                                        xprintcorg_AG = xprint_AG + dif_old_corg_x_AG
                                                                        yprintcorg_AG = yprint_AG + dif_old_corg_y_AG
                                                                        zprintcorg_AG = zprint_AG + dif_old_corg_z_AG
                                                                        ]
												"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
                                                if old_opcode_AG > 16,	[
																		sr, *xprintcorg_AG, *yprintcorg_AG, *zprintcorg_AG, *axeC_AG, *axeA_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$
																		old_axeC_simu_AG = axeC_AG
																		old_axeA_simu_AG = axeA_AG
																		old_xprint_simu_AG = xprintcorg_AG
																		old_yprint_simu_AG = yprintcorg_AG
																		old_zprint_simu_AG = zprintcorg_AG
																		]
																else,	[
																		sr, *xprintcorg_AG, *yprintcorg_AG, *zprintcorg_AG, *axeCpos1_AG, *axeApos1_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$
																		old_axeC_simu_AG = axeCpos1_AG
																		old_axeA_simu_AG = axeApos1_AG
																		old_xprint_simu_AG = xprintcorg_AG
																		old_yprint_simu_AG = yprintcorg_AG
																		old_zprint_simu_AG = zprintcorg_AG
																		]
                                                old_opcode_AG = 0
                                                old_corg_x_AG = tox4$, old_corg_y_AG = toy4$, old_corg_z_AG = toz4$
                                                ]

              pnumop_AG
              if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
              if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
              if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
              ptrans_option_AG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_AG = 0
                if op_id$ <> prvop_id_AG & mi10$ <> 1 & mi10$ <> -1, pcantext_AG

            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AG
         #"axeC_AG  =", axeC_AG, e

         #"cont_axe_c_AG=", cont_axe_c_AG, e


        if operation_AG = 11,[
            gfr_AG = 1
             sm, paf, *sgfr_AG,"F500",e$
        ]
        pdmodalxyz_AG
    #   "opcode",*opcode
        if mr2print_AG = 0, mr2print_AG =zsecuprint
        gcode$ = 0
        plubrifoff_AG,e$
        if drill5axes_AG = 1 | opcode$ = 3,sm,paf, "G151 EC0. EA0. EU0. EV0. EW0",e$
        if ((drill5axes_AG = 1)|(opcode$ = 3)) & mr2print_AG <>   -1,sr, *mr2print_AG, paf,pgcode_force_AG, *mr2$,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_AG = 1)|(opcode = 3),n , pgcode_force_AG, mr2
        drill5axes_AG = 0
            typcycle_AG = 0
            if op_id$ <> prvop_id_AG,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_AG
										]
            if oldstation_AG = 0 & mi4_AG = 9, sm,paf,"M151",e$
        else,
         [
         if oldstation_AG < 0 & mi4_AG = 0, sm,paf,"M150",e$
         else,[
                      if oldstation_AG <> mi4_AG, ptlngno2_AG
                      ]
            ]
            prvmr2_AG = mr2print_AG
            xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
            pasmi7 = 0
            oldstation_AG = mi4_AG
            if mi2_A_base_AG = 0, invers_AG = 0
        if mi2_A_base_AG = 2, invers_AG = 1
        if operation_AG = 11 & nextop$ = 11 & op_id$ <> prvop_id_AG, premx_AG
        #if operation_AG = 11 & nextop = 11 & op_id = prvop_id_AG, mr2 = -1
        if (oldstation_AG = mi4_AG) & (ssprint_AG <> old_ss) , sm,paf, *spdlon_AG, "M40", *ssprint_AG,e$
        old_ss = ssprint_AG
        plubrifon_AG,e$
            if opcode$ = 16,
            [
                 drill5axes_AG = 1
                 sm,paf,"G151 EC0. EA0. EU0. EV0. EW0.", e$
                  tourne = 0
                 !tourne
            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_AG, e$
								pcont_garage_AM, pchange_AM, ptlchg0_AM
								]
            prot1_AG
            pprint_AG
       # *old_axeCpos_AG, *axeCpos_AG, *old_axeApos_AG, *axeApos_AG, *old_tox4_AG,*tox4, *old_toy4_AG,toy4, *old_toz4_AG, *toz4         
            !old_axeCpos_AG, !axeCpos_AG, !old_axeApos_AG, !axeApos_AG, !old_tox4_AG, !old_toy4_AG, !old_toz4_AG, !tox4print_AG, !toy4print_AG, !toz4print_AG
            if drill5axes_AG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_AG <> axeCpos_AG) | (old_axeApos_AG <> axeApos_AG) | (old_tox4_AG <> tox4print_AG) | (old_toy4_AG <> toy4print_AG) | (old_toz4_AG <> toz4print_AG), prot3_AG,e$
                 else,
                [
                if operation_AG <> 11 | nextop$ <> 11, plansecu_AG
                ]
            ]

            if operation_AG <> 11 & nextop$ = 11, operation_AG = 1
        else, operation_AG = 0

        if prvop_id_AG <> op_id$, changop_AG = 1, pugv_AG
        else, changop_AG = 0
            prvop_id_AG = op_id$
            numpp = 1
            comment$
            "MW_OP_COMMENT", strcom_AG, e$
        frbase_AG = fr$
        debut_AG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_BG     # Changement outil nul
			flag_outil_BG = 0
			flag_changement_outil_BG = 0
			arret_prog_BG = 0
            flag_cloche_BG = 0
            strcom_BG = svide
            premperc_BG = 1
            if op_id$ <> prvop_id_BG,
                                    [
                                    sf, e$
                                    spaces$ = 0
                                    #pprepoutil
                                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                                    spaces$ = 1
                                    @tox4$,@toy4$,@toz4$, @old_corg_x_BG, @old_corg_y_BG,@old_corg_z_BG
                                    if (tox4$ = old_corg_x_BG) & (toy4$ = old_corg_y_BG)  & (toz4$ = old_corg_z_BG),
                                                                        [
                                                                        xprintcorg_BG = xprint_BG
                                                                        yprintcorg_BG = yprint_BG
                                                                        zprintcorg_BG = zprint_BG
                                                                        ]
                                                                        else,
                                                                        [
                                                                        dif_old_corg_x_BG = old_corg_x_BG - tox4$
																		dif_old_corg_y_BG = old_corg_y_BG - toy4$
																		dif_old_corg_z_BG = old_corg_z_BG - toz4$
                                                                        xprintcorg_BG = xprint_BG + dif_old_corg_x_BG
                                                                        yprintcorg_BG = yprint_BG + dif_old_corg_y_BG
                                                                        zprintcorg_BG = zprint_BG + dif_old_corg_z_BG
                                                                        ]
												"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
                                                if old_opcode_BG > 16,	[
																		sr, *xprintcorg_BG, *yprintcorg_BG, *zprintcorg_BG, *axeC_BG, *axeA_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                						old_axeC_simu_BG = axeC_BG
																		old_axeA_simu_BG = axeA_BG
																		old_xprint_simu_BG = xprintcorg_BG
																		old_yprint_simu_BG = yprintcorg_BG
																		old_zprint_simu_BG = zprintcorg_BG
																		]
																else,	[
																		sr, *xprintcorg_BG, *yprintcorg_BG, *zprintcorg_BG, *axeCpos1_BG, *axeApos1_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                						old_axeC_simu_BG = axeCpos1_BG
																		old_axeA_simu_BG = axeApos1_BG
																		old_xprint_simu_BG = xprintcorg_BG
																		old_yprint_simu_BG = yprintcorg_BG
																		old_zprint_simu_BG = zprintcorg_BG
																		]
                                                old_opcode_BG = 0
                                                old_corg_x_BG = tox4$, old_corg_y_BG = toy4$, old_corg_z_BG = toz4$
                                                ]

                pnumop_BG
                if oscilliation = 1 & mi7$ <> 0, psortie12_BG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
                ptrans_option_BG  # on est dans le cas d'une transformation 
               cycle_heli_spiral_BG = 0
                if op_id$ <> prvop_id_BG & mi10$ <> 1 & mi10$ <> -1, pcantext_BG

                if op_id$ <> prvop_id_BG,
                [
                if mi9$ = -1, sm,paf, "M210", e$
                else, sm,paf, "M211", e$
                ]

            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_BG
            ptestcloche_BG

        if operation_BG = 11,[
            gfr_BG = 1
             sm,paf,*sgfr_BG,"F500",e$
        ]
        pdmodalxyz_BG
    #   "opcode",*opcode
        if mr2print_BG = 0, mr2print_BG =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_BG,
        [
         pcontrol_lubrif_BG
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_BG
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_BG = 1 | opcode$ = 3, panul_plan_inc_BG
        if ((drill5axes_BG = 1)|(opcode$ = 3)) & mr2print_BG <>   -1,sr, *mr2print_BG, paf, pgcode_force_BG, *mr2$,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_BG = 1)|(opcode = 3),n , pgcode_force_BG, mr2
        drill5axes_BG = 0
            typcycle_BG = 0
            if op_id$ <> prvop_id_BG,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_BG
										]
            if op_id$ <> prvop_id_BG & ((mi10$ > 1) | (mi10$ < -1)), ptempo_BG
            if oldstation_BG = 0 & mi4_BG = 9, sm,paf,"M151 ; ARRET ASPI",e$
            else,
                [
                if oldstation_BG < 0 & mi4_BG = 0, sm,paf,"M150 ; MARCHE ASPI",e$
                else,[
                      if oldstation_BG <> mi4_BG, ptlngno2_BG
                     ]
                ]
        prvmr2_BG = mr2print_BG
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_BG = 0, invers_BG = 0
        if mi2_A_base_BG = 2, invers_BG = 1
        if operation_BG = 11 & nextop$ = 11 & op_id$ <> prvop_id_BG, premx_BG
        #if operation_BG = 11 & nextop = 11 & op_id = prvop_id_BG, mr2 = -1
        if (oldstation_BG = mi4_BG) & (ssprint_BG <> old_ss) , sm,paf, *spdlon_BG, *ssprint_BG,e$
        old_ss = ssprint_BG
        oldstation_BG = mi4_BG
        if op_id$ <> prvop_id_BG, plubrifon_BG
        pcycle832_BG
        #prot1_BG
            if opcode$ = 16,
            [
                 drill5axes_BG = 1
                 panul_plan_inc_BG
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_BG, e$
								pcont_garage_BM, pchange_BM, ptlchg0_BM
								]
            prot1_BG
            pprint_BG
       # *old_axeCpos_BG, *axeCpos_BG, *old_axeApos_BG, *axeApos_BG, *old_tox4_BG,*tox4, *old_toy4_BG,toy4, *old_toz4_BG, *toz4         
            !old_axeCpos_BG, !axeCpos_BG, !old_axeApos_BG, !axeApos_BG, !old_tox4_BG, !old_toy4_BG, !old_toz4_BG, !tox4print_BG, !toy4print_BG, !toz4print_BG
            if drill5axes_BG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_BG <> axeCpos_BG) | (old_axeApos_BG <> axeApos_BG) | (old_tox4_BG <> tox4print_BG) | (old_toy4_BG <> toy4print_BG) | (old_toz4_BG <> toz4print_BG), prot3_BG,e$
                 else,
                [
                if operation_BG <> 11 | nextop$ <> 11, plansecu_BG
                ]
            ]

            if operation_BG <> 11 & nextop$ = 11, operation_BG = 1
            else, operation_BG = 0

        if prvop_id_BG <> op_id$, changop_BG = 1
        else, changop_BG = 0
            prvop_id_BG = op_id$
            numpp = 2
            comment$
            "MW_OP_COMMENT", strcom_BG, e$
        frbase_BG = fr$
        debut_BG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_CG     # Changement outil nul
			flag_outil_CG = 0
			garage_CG = 0
			flag_changement_outil_CG = 0
            flag_cloche_CG = 0
            strcom_CG = svide
            premperc_CG = 1
            if op_id$ <> prvop_id_CG,
                                    [
                                    sf, e$
                                    spaces$ = 0
                                    #pprepoutil
                                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *tox4$, ",0,1,0,", *toy4$, ",0,0,1,", *toz4$, ",0,0,0,1)", e$
                                    spaces$ = 1
                                    @tox4$,@toy4$,@toz4$, @old_corg_x_CG, @old_corg_y_CG,@old_corg_z_CG
                                    if (tox4$ = old_corg_x_CG) & (toy4$ = old_corg_y_CG)  & (toz4$ = old_corg_z_CG),
                                                                        [
                                                                        xprintcorg_CG = xprint_CG
                                                                        yprintcorg_CG = yprint_CG
                                                                        zprintcorg_CG = zprint_CG
                                                                        ]
                                                                        else,
                                                                        [
                                                                        dif_old_corg_x_CG = old_corg_x_CG - tox4$
																		dif_old_corg_y_CG = old_corg_y_CG - toy4$
																		dif_old_corg_z_CG = old_corg_z_CG - toz4$
                                                                        xprintcorg_CG = xprint_CG + dif_old_corg_x_CG
                                                                        yprintcorg_CG = yprint_CG + dif_old_corg_y_CG
                                                                        zprintcorg_CG = zprint_CG + dif_old_corg_z_CG
                                                                        ]
												"MW_USE_PREVIOUS_OPERATION_AXES_AS_REFERENCE", e$
                                                if old_opcode_CG > 16,	[
																		sr, *xprintcorg_CG, *yprintcorg_CG, *zprintcorg_CG, *axeC_CG, *axeA_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$, axe_A_garage_CG = axeA_CG, axe_C_garage_CG = axeC_CG
                                                						old_axeC_simu_CG = axeC_CG
																		old_axeA_simu_CG = axeA_CG
																		old_xprint_simu_CG = xprintcorg_CG
																		old_yprint_simu_CG = yprintcorg_CG
																		old_zprint_simu_CG = zprintcorg_CG
																		]
																else,	[
																		sr, *xprintcorg_CG, *yprintcorg_CG, *zprintcorg_CG, *axeCpos1_CG, *axeApos1_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$, axe_A_garage_CG = axeApos1_CG, axe_C_garage_CG = axeCpos1_CG
                                                						old_axeC_simu_CG = axeCpos1_CG
																		old_axeA_simu_CG = axeApos1_CG
																		old_xprint_simu_CG = xprintcorg_CG
																		old_yprint_simu_CG = yprintcorg_CG
																		old_zprint_simu_CG = zprintcorg_CG
																		]
                                                old_opcode_CG = 0
												old_corg_x_CG = tox4$, old_corg_y_CG = toy4$, old_corg_z_CG = toz4$
                                                ]

                pprep_cloche_CG
                pnumop_CG
                if oscilliation = 1 & mi7$ <> 0, psortie12_CG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
                ptrans_option_CG  # on est dans le cas d'une transformation 
               cycle_heli_spiral_CG = 0
                if op_id$ <> prvop_id_CG & mi10$ <> 1 & mi10$ <> -1, pcantext_CG

                if op_id$ <> prvop_id_CG,
                [
                #if mi9$ = -1, sm, paf, "M210", e$
                #else, sm, paf, "M211", e$
                ]

            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_CG
            ptestcloche_CG

        if operation_CG = 11,[
            gfr_CG = 1
             sm,paf,*sgfr_CG,"F500",e$
        ]
        pdmodalxyz_CG
    #   "opcode",*opcode
        if mr2print_CG = 0, mr2print_CG =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_CG,
        [
         pcontrol_lubrif_CG
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_CG
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
 
		if drill5axes_CG = 1 | opcode$ = 3, panul_plan_inc_CG, pgestionduB_cloche_CG
		if ((drill5axes_CG = 1)|(opcode$ = 3)) & axeA_cloche_CG <> 0 & mr2print_CG = -1, psortie_cloche_CG
        if ((drill5axes_CG = 1)|(opcode$ = 3)) & mr2print_CG <> -1,	[
																	if axeA_cloche_CG = 0, sr, *mr2print_CG, paf, pgcode_force_CG, *mr2$,e$
																	if axeA_cloche_CG <> 0, sr, *mr2print_CG, *axeA_cloche_CG, paf, pgcode_force_CG, *mr2$, *axeA_cloche_CG, e$
																	flagmr2_CG = 1
																	]
        drill5axes_CG = 0
            typcycle_CG = 0
            if op_id$ <> prvop_id_CG,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_CG
										]
            if op_id$ <> prvop_id_CG & ((mi10$ > 1) | (mi10$ < -1)), ptempo_CG

        prvmr2_CG = mr2print_CG
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_CG = 0, invers_CG = 0
        if mi2_A_base_CG = 2, invers_CG = 1
        if operation_CG = 11 & nextop$ = 11 & op_id$ <> prvop_id_CG, premx_CG
        #if operation_CG = 11 & nextop = 11 & op_id = prvop_id_CG, mr2 = -1
		if oldstation_CG = 0 & mi4_CG = 9, sm,paf, "M302 ; ARRET ASPI 1", e$, sm,paf, "M304 ; ARRET ASPI 2", e$
        else,	[
                if oldstation_CG < 0 & mi4_CG = 0, sm,paf, "M301 ; MARCHE ASPI 1 ", e$, sm,paf, "M303 ; MARCHE ASPI 2 ", e$
                else,[
					  if flagmr2_CG = 1, ptlngno2_CG, flagmr2_CG = 2
                     ]
                ]
				
        if (oldstation_CG = mi4_CG) & (ssprint_CG <> old_ss) , sm,paf, *spdlon_CG, *ssprint_CG,e$
        old_ss = ssprint_CG
        oldstation_CG = mi4_CG
        if op_id$ <> prvop_id_CG, plubrifon_CG
        pcycle832_CG
        #prot1_CG
            if opcode$ = 16,
            [
                 drill5axes_CG = 1
                 panul_plan_inc_CG
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_CG, e$
								old_opcode_cloche_CG = 16, pcont_garage_CM, pchange_CM, ptlchg0_CM
								]
            prot1_CG
            pprint_CG
       # *old_axeCpos_CG, *axeCpos_CG, *old_axeApos_CG, *axeApos_CG, *old_tox4_CG,*tox4, *old_toy4_CG,toy4, *old_toz4_CG, *toz4         
            !old_axeCpos_CG, !axeCpos_CG, !old_axeApos_CG, !axeApos_CG, !old_tox4_CG, !old_toy4_CG, !old_toz4_CG, !tox4print_CG, !toy4print_CG, !toz4print_CG
            if drill5axes_CG <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_CG <> axeCpos_CG) | (old_axeApos_CG <> axeApos_CG) | (old_tox4_CG <> tox4print_CG) | (old_toy4_CG <> toy4print_CG) | (old_toz4_CG <> toz4print_CG), prot3_CG,e$
                 else,
                [
                if operation_CG <> 11 | nextop$ <> 11, plansecu_CG
                ]
            ]

            if operation_CG <> 11 & nextop$ = 11, operation_CG = 1
            else, operation_CG = 0

        if prvop_id_CG <> op_id$, changop_CG = 1
        else, changop_CG = 0
            prvop_id_CG = op_id$
            numpp = 3
            comment$
            "MW_OP_COMMENT", strcom_CG, e$
        frbase_CG = fr$
        debut_CG = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
			   old_opcode_CG = opcode$

ptlchg0_AM     # Changement outil nul
              pnumop_AM
              if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
              if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
              if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
              ptrans_option_AM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_AM = 0
                if op_id$ <> prvop_id_AM & mi10$ <> 1 & mi10$ <> -1, pcantext_AM

            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_AM
         #"axeC_AM  =", axeC_AM, e

         #"cont_axe_c_AM=", cont_axe_c_AM, e


        if operation_AM = 11,[
            gfr_AM = 1
             pnumligne,*sgfr_AM, "@AVANCE@500", e$
        ]
        pdmodalxyz_AM
    #   "opcode",*opcode
        if mr2print_AM = 0, mr2print_AM =zsecuprint
        gcode$ = 0
        plubrifoff_AM,e$
        if drill5axes_AM = 1 | opcode$ = 3,pnumligne, "G151 EC0. EA0. EU0. EV0. EW0",e$
        if ((drill5axes_AM = 1)|(opcode$ = 3)) & mr2print_AM <>   -1,pnumligne, pgcode_force_AM, mr2print_AM,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_AM = 1)|(opcode = 3),n , pgcode_force_AM, mr2
        drill5axes_AM = 0
            typcycle_AM = 0
            if op_id$ <> prvop_id_AM,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_AM
										]
            if oldstation_AM = 0 & mi4_AM = 9, pnumligne,SARRET_ASPI,e$
        else,
         [
         if oldstation_AM < 0 & mi4_AM = 0, pnumligne,SMARCHE_ASPI,e$
         else,[
                      if oldstation_AM <> mi4_AM, ptlngno2_AM
                      ]
            ]
            prvmr2_AM = mr2print_AM
            xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
            pasmi7 = 0
            oldstation_AM = mi4_AM
            if mi2_A_base_AM = 0, invers_AM = 0
        if mi2_A_base_AM = 2, invers_AM = 1
        if operation_AM = 11 & nextop$ = 11 & op_id$ <> prvop_id_AM, premx_AM
        #if operation_AM = 11 & nextop = 11 & op_id = prvop_id_AM, mr2 = -1
        if (oldstation_AM = mi4_AM) & (ssprint_AM <> old_ss) , pnumligne, *spdlon_AM, "M40", *ssprint_AM,e$
        old_ss = ssprint_AM
        plubrifon_AM,e$
            if opcode$ = 16,
            [
                 drill5axes_AM = 1
                 pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
                  tourne = 0
                 !tourne
            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_AM, e$
								pchange_BG, ptlchg0_BG
								]
            prot1_AM
            pprint_AM
       # *old_axeCpos_AM, *axeCpos_AM, *old_axeApos_AM, *axeApos_AM, *old_tox4_AM,*tox4, *old_toy4_AM,toy4, *old_toz4_AM, *toz4         
            !old_axeCpos_AM, !axeCpos_AM, !old_axeApos_AM, !axeApos_AM, !old_tox4_AM, !old_toy4_AM, !old_toz4_AM, !tox4print_AM, !toy4print_AM, !toz4print_AM
            if drill5axes_AM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_AM <> axeCpos_AM) | (old_axeApos_AM <> axeApos_AM) | (old_tox4_AM <> tox4print_AM) | (old_toy4_AM <> toy4print_AM) | (old_toz4_AM <> toz4print_AM), prot3_AM,e$
                 else,
                [
                if operation_AM <> 11 | nextop$ <> 11, plansecu_AM
                ]
            ]

            if operation_AM <> 11 & nextop$ = 11, operation_AM = 1
        else, operation_AM = 0

        if prvop_id_AM <> op_id$, changop_AM = 1, pugv_AM
        else, changop_AM = 0
            prvop_id_AM = op_id$
            numpp = 4
            comment$
            pnumligne, strcom_AM, e$
        frbase_AM = fr$
        debut_AM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_BM     # Changement outil nul

                pnumop_BM
                if oscilliation = 1 & mi7$ <> 0, psortie12_BM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
                ptrans_option_BM  # on est dans le cas d'une transformation 
               cycle_heli_spiral_BM = 0
                if op_id$ <> prvop_id_BM & mi10$ <> 1 & mi10$ <> -1, pcantext_BM

                if op_id$ <> prvop_id_BM,
                [
                if mi9$ = -1, pnumligne, "M210", e$
                else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_BM
            ptestcloche_BM

        if operation_BM = 11,[
            gfr_BM = 1
             pnumligne,*sgfr_BM,"@AVANCE@500",e$
        ]
        pdmodalxyz_BM
    #   "opcode",*opcode
        if mr2print_BM = 0, mr2print_BM =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_BM,
        [
         pcontrol_lubrif_BM
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_BM
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_BM = 1 | opcode$ = 3, panul_plan_inc_BM
        if ((drill5axes_BM = 1)|(opcode$ = 3)) & mr2print_BM <>   -1,pnumligne, pgcode_force_BM, mr2print_BM,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_BM = 1)|(opcode = 3),n , pgcode_force_BM, mr2
        drill5axes_BM = 0
            typcycle_BM = 0
            if op_id$ <> prvop_id_BM,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_BM
										]
            if op_id$ <> prvop_id_BM & ((mi10$ > 1) | (mi10$ < -1)), ptempo_BM
            if oldstation_BM = 0 & mi4_BM = 9, pnumligne,SARRET_ASPI,e$
            else,
                [
                if oldstation_BM < 0 & mi4_BM = 0, pnumligne,SMARCHE_ASPI,e$
                else,[
                      if oldstation_BM <> mi4_BM, ptlngno2_BM
                     ]
                ]
        prvmr2_BM = mr2print_BM
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_BM = 0, invers_BM = 0
        if mi2_A_base_BM = 2, invers_BM = 1
        if operation_BM = 11 & nextop$ = 11 & op_id$ <> prvop_id_BM, premx_BM
        #if operation_BM = 11 & nextop = 11 & op_id = prvop_id_BM, mr2 = -1
        if (oldstation_BM = mi4_BM) & (ssprint_BM <> old_ss) , pnumligne, *spdlon_BM, *ssprint_BM,e$
        old_ss = ssprint_BM
        oldstation_BM = mi4_BM
        if op_id$ <> prvop_id_BM, plubrifon_BM
        pcycle832_BM
        #prot1_BM
            if opcode$ = 16,
            [
                 drill5axes_BM = 1
                 panul_plan_inc_BM
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_BM, e$
								pchange_CG, ptlchg0_CG
								]
            prot1_BM
            pprint_BM
       # *old_axeCpos_BM, *axeCpos_BM, *old_axeApos_BM, *axeApos_BM, *old_tox4_BM,*tox4, *old_toy4_BM,toy4, *old_toz4_BM, *toz4         
            !old_axeCpos_BM, !axeCpos_BM, !old_axeApos_BM, !axeApos_BM, !old_tox4_BM, !old_toy4_BM, !old_toz4_BM, !tox4print_BM, !toy4print_BM, !toz4print_BM
            if drill5axes_BM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_BM <> axeCpos_BM) | (old_axeApos_BM <> axeApos_BM) | (old_tox4_BM <> tox4print_BM) | (old_toy4_BM <> toy4print_BM) | (old_toz4_BM <> toz4print_BM), prot3_BM,e$
                 else,
                [
                if operation_BM <> 11 | nextop$ <> 11, plansecu_BM
                ]
            ]

            if operation_BM <> 11 & nextop$ = 11, operation_BM = 1
            else, operation_BM = 0

        if prvop_id_BM <> op_id$, changop_BM = 1
        else, changop_BM = 0
            prvop_id_BM = op_id$
            numpp = 5
            comment$
            pnumligne, strcom_BM, e$
        frbase_BM = fr$
        debut_BM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg0_CM     # Changement outil nul
                if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
                else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM
                pnumop_CM
                if oscilliation = 1 & mi7$ <> 0, psortie12_CM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
                ptrans_option_CM  # on est dans le cas d'une transformation 
               cycle_heli_spiral_CM = 0
                if op_id$ <> prvop_id_CM & mi10$ <> 1 & mi10$ <> -1, pcantext_CM

                if op_id$ <> prvop_id_CM,
                [
                #if mi9$ = -1, pnumligne, "M210", e$
                #else, pnumligne, "M211", e$
                ]

            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2 # on est en percage 5 axes
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1 # on est en 5 axes continue
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0 # on est en 3 axes o 5 positionner 
            pprint_CM
            ptestcloche_CM

        if operation_CM = 11,[
            gfr_CM = 1
             pnumligne,*sgfr_CM,"@AVANCE@500",e$
        ]
        pdmodalxyz_CM
    #   "opcode",*opcode
        if mr2print_CM = 0, mr2print_CM =zsecuprint
        gcode$ = 0
        if op_id$ <> prvop_id_CM,
        [
         pcontrol_lubrif_CM
         if old_lubrif_m7 <> lubrif_m7 | old_lubrif_m8 <> lubrif_m8 | old_lubrif_m207 <> lubrif_m207 , plubrifoff_CM
         else,
                [
                old_lubrif_m7 = lubrif_m7
                old_lubrif_m8 = lubrif_m8
                old_lubrif_m207 = lubrif_m207
                old_lubrif_m200 = lubrif_m200
                ]
        ]
        if drill5axes_CM = 1 | opcode$ = 3, panul_plan_inc_CM
        if ((drill5axes_CM = 1)|(opcode$ = 3)) & mr2print_CM <>   -1,pnumligne, pgcode_force_CM, mr2print_CM,e$# modif du 30/9/02 pour pp37 
#       if (drill5axes_CM = 1)|(opcode = 3),n , pgcode_force_CM, mr2
        drill5axes_CM = 0
            typcycle_CM = 0
            if op_id$ <> prvop_id_CM,	[
										if (mi10$ = 1) | (mi10$ = -1), parretprog_CM
										]
            if op_id$ <> prvop_id_CM & ((mi10$ > 1) | (mi10$ < -1)), ptempo_CM

        prvmr2_CM = mr2print_CM
        xcor = 0
        ycor = 0
        zcor = 0
        pasn = 0
        pasmi7 = 0

        if mi2_A_base_CM = 0, invers_CM = 0
        if mi2_A_base_CM = 2, invers_CM = 1
        if operation_CM = 11 & nextop$ = 11 & op_id$ <> prvop_id_CM, premx_CM
        #if operation_CM = 11 & nextop = 11 & op_id = prvop_id_CM, mr2 = -1
		if oldstation_CM = 0 & mi4_CM = 9, pnumligne,SARRET_ASPI,e$
        else,	[
                if oldstation_CM < 0 & mi4_CM = 0, pnumligne,SMARCHE_ASPI,e$
                else,[
                      spaces$ = 0, ptlngno2_CM, spaces$ = 1
                     ]
                ]
        if (oldstation_CM = mi4_CM) & (ssprint_CM <> old_ss) , pnumligne, *spdlon_CM, *ssprint_CM,e$
        old_ss = ssprint_CM
        oldstation_CM = mi4_CM
        if op_id$ <> prvop_id_CM, plubrifon_CM
        pcycle832_CM
        #prot1_CM
            if opcode$ = 16,
            [
                 drill5axes_CM = 1
                 panul_plan_inc_CM
                 tourne = 0
                 !tourne

            ]
            if opcode$ = 16,	[
								comment$
            					"MW_OP_COMMENT", strcom_CM, e$
								ex$
								]
            prot1_CM
            pprint_CM
       # *old_axeCpos_CM, *axeCpos_CM, *old_axeApos_CM, *axeApos_CM, *old_tox4_CM,*tox4, *old_toy4_CM,toy4, *old_toz4_CM, *toz4         
            !old_axeCpos_CM, !axeCpos_CM, !old_axeApos_CM, !axeApos_CM, !old_tox4_CM, !old_toy4_CM, !old_toz4_CM, !tox4print_CM, !toy4print_CM, !toz4print_CM
            if drill5axes_CM <> 1 & nextop$ <> 11,
            [
            if (old_axeCpos_CM <> axeCpos_CM) | (old_axeApos_CM <> axeApos_CM) | (old_tox4_CM <> tox4print_CM) | (old_toy4_CM <> toy4print_CM) | (old_toz4_CM <> toz4print_CM), prot3_CM,e$
                 else,
                [
                if operation_CM <> 11 | nextop$ <> 11, plansecu_CM
                ]
            ]

            if operation_CM <> 11 & nextop$ = 11, operation_CM = 1
            else, operation_CM = 0

        if prvop_id_CM <> op_id$, changop_CM = 1
        else, changop_CM = 0
            prvop_id_CM = op_id$
            numpp = 6
            comment$
            pnumligne, strcom_CM, e$
        frbase_CM = fr$
        debut_CM = 0
        retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               if mr5$ <= 0, mr5$ = 0.0001

               vale53 = 0
               sens_pas = -1
               debutvar = 0
#endregion
#region ptlchg
ptlchg$
            pdecomposition_mi1
            pdecomposition_mi2
            pdecomposition_mi4
            pdecomposition_mi8
            pchange_AG
            ptlchg_AG

            pcont_garage_AM
            pchange_AM
            ptlchg_AM

            pchange_BG
            ptlchg_BG

            pcont_garage_BM
            pchange_BM
            ptlchg_BM

            pchange_CG
            ptlchg_CG

            pcont_garage_CM
            pchange_CM
            ptlchg_CM

            old_numprg_garage_AM = numprg_garage_AM
            old_numprg_garage_BM = numprg_garage_BM
            old_numprg_garage_CM = numprg_garage_CM
            old_progno_AM = numprg_concat_AM
            old_progno_BM = numprg_concat_BM
            old_progno_CM = numprg_concat_CM

ptlchg_AG      # Changement outil
				flag_outil_AG = 1
				flag_changement_outil_AG = 1
                old_tool_AG = tlngno$
				arret_prog_AG = 0
                flag_cloche_AG = 0
				flag_chargement_cloche_AG = 0
                strcom_AG = svide
                premperc_AG = 0
                pnumop_AG
				
				rayon_outil = tldia$/2
        		longeur_outil = paramT3 + paramT7
       	 		var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        		if stl_mfg_com = svide, psortietest_outil
				
                if oscilliation = 1 & (mi7$ <> 0), psortie12_AG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_AG
				if mr2$ = -1, psortie13_AG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AG
                 ptrans_option_AG  # on est dans le cas d'une transformation 
        #      "opcode",*opcode
            cycle_heli_spiral_AG = 0

            if mi10$ <> 1 & mi10$ <> -1, pcantext_AG
            if opcode$ = 16, drill5axes_AG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0

        pprint_AG

        if operation_AG = 11,[
            gfr_AG = 1
             sm, paf, *sgfr_AG, "F500",e$
        ]
        pdmodalxyz_AG
            drill5axes_AG = 0



        gcode$ = 0
            sm, paf, "G151 S0",e$
            if (mi10$ = 1) | (mi10$ = -1), parretprog2_AG
            else,
            [
                if  mr2print_AG <> -1 & prvmr2_AG <> -1,sr, *prvmr2_AG, paf,pgcode_force_AG, *prvmr2_AG,e$
            ]

            sm, paf,spaces$ = 0, " ", e53_AG,"=0",e$ spaces$ = 1
            sm, paf, "M9",e$
            sm, paf, "M151",e$
        sm, paf, "M5",e$
        if mi4_AG <> old_mi4_AG & (old_mi4_AG >= 1 & old_mi4_AG <= 6), pdechargement_cloche_AG
        else, sm, sentre_cloche_AG, paf, "M170",e$
        xcor = 0
        ycor = 0
        zcor = 0
            pasmi7 = 0
        pasn = 0
       # if t$ > 20 & station_tool = 1, sm, paf, "M6 T0",e$ # depose outil 
        #if t$ < 16 & station_tool = 2, sm, paf, "M6 T0",e$
        if t$ > 16 & t$ < 20 | t$ > 29,	[
										if prog_AG = 1, q1
										]
        if t$ < 16 , station_tool = 1
        if t$ > 20 , station_tool = 2
        if t$ = tete_rev_ang_11, sm,paf, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
        if t$ = tete_rev_ang_12, sm,paf, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
        if t$ = tete_rev_ang_21, sm,paf, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
        if t$ = tete_rev_ang_22, sm,paf, "( Outil renvoi angle ",tete_rev_ang_22,")",e$


        pchagement_outil_AG


        e53_AG = 53000 + tlngno$
        mr4_AG = mr4$
        sm, paf, spaces$ = 0," ", e53_AG,"=", *mr4_AG,e$, spaces$ = 1
        ptlngno_AG
            frbase_AG = fr$
        if (mi4_AG = 9) | ((mi4_AG > 6) & (mi4_AG <> 9)),  sm, paf, *spdlon_AG, "M40", ssprint_AG,e$
            old_ss = ssprint_AG
        plubrifon_AG,e$
            numpp = 1
            comment$
            "MW_OP_COMMENT", strcom_AG, e$
            debut_AG = 0
            prvop_id_AG = op_id$
            if mi2_A_base_AG = 0, invers_AG = 0
            if mi2_A_base_AG = 2 , invers_AG = 1
            if opcode$ = 16, drill5axes_AG = 1
            if opcode$ = 16, pcont_garage_AM, pchange_AM, ptlchg_AM
            prot1_AG
            pprint_AG
            gcode$ = 0
        if mr2print_AG = 0, mr2print_AG =zsecuprint
        prvmr2_AG = mr2print_AG
        pcalxyz3d_AG
				if t$ = 51 | t$ = 52 | t$ = 61 | t$ = 62,
					[
           			if  mr2print_AG <> -1,	[
                                    		if t$ = 51 | t$ = 52, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm, "X-2245.", e$
                                    		if t$ = 61 | t$ = 62, sr,*mr2print_AG,paf,pgcode_force_AG, *mr2$ ,sm, "X-2005.", e$
											]
             						else,	[
                                    		if t$ = 51 | t$ = 52, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm, "X-2245.", e$
                                    		if t$ = 61 | t$ = 62, sr,*zrprint_AG,paf, pgcode_force_AG,*z1_AG,sm, "X-2005.", e$
                                    		]
					]
			else, 	[
            		if mr2print_AG <>   -1,	[
											if (flag_cloche_AG = 1) & (flag_chargement_cloche_AG = 1), sr, *mr2print_AG, sazero, sczero, paf,pgcode_force_AG, *mr2$, sm, sxcloche_AG, sycloche_AG, e$, flag_cloche_AG = 0, flag_chargement_cloche_AG = 0	
											else, sr, *mr2print_AG, sazero, sczero, paf,pgcode_force_AG, *mr2$ ,sm, sxmag_AG, symag_AG, e$
											]
            						else,	[
											if (flag_cloche_AG = 1) & (flag_chargement_cloche_AG = 1), sr, *z1_AG, sazero, sczero, paf,pgcode_force_AG, *z1_AG, sm, sxcloche_AG, sycloche_AG, e$, flag_cloche_AG = 0, flag_chargement_cloche_AG = 0
											else, sr, *z1_AG, sazero, sczero, paf, pgcode_force_AG,*z1_AG,sm, sxmag_AG, symag_AG, e$
											]
					]	
            #if xr <> 0 | yr <> 0
            prot2_AG



            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

                operation_AG = 0

        oldstation_AG = mi4_AG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_AG = 1

               pugv_AG
               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_BG      # Changement outil
				flag_outil_BG = 1
				flag_changement_outil_BG = 1
                old_tool_AG = tlngno$
				arret_prog_BG = 0
                flag_cloche_BG = 0
				flag_chargement_cloche_BG = 0
                strcom_BG = svide
                premperc_BG = 0

                pnumop_BG
				
				rayon_outil = tldia$/2
        		longeur_outil = paramT3 + paramT7
        		var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        		if stl_mfg_com = svide, psortietest_outil
				
                if oscilliation = 1 & mi7$ <> 0, psortie12_BG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BG
				if mr2$ = -1, psortie13_BG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BG
                ptrans_option_BG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_BG = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_BG
            if opcode$ = 16, drill5axes_BG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BG
        ptestcloche_BG

        if operation_BG = 11,
            [
            gfr_BG = 1
            sm,paf,*sgfr_BG, "F500",e$
            ]
        pdmodalxyz_BG
        drill5axes_BG = 0
        gcode$ = 0
        panul_plan_inc_BG
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_BG
        else,
            [
                if  mr2print_BG <> -1 & prvmr2_BG <> -1,sr, *prvmr2_BG,paf,pgcode_force_BG, *prvmr2_BG,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_BG
            ]
        plubrifoff_BG
        sm,paf, "M151 ; ARRET ASPI",e$
        sm,paf, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_BG
        pdechargement_cloche_BG
        pchagement_outil_BG
        change_tool_cloche_BG = 1, pappeloutil_BG, change_tool_cloche_BG = 0

        mr4_BG = mr4$
        if mr4$ > 0, sm,pafcom, mr4_BG, e$

        ptlngno_BG
        frbase_BG = fr$
        sm,paf, *spdlon_BG, ssprint_BG,e$
        old_ss = ssprint_BG
        plubrifon_BG

        pcycle832_BG
        sm,paf, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       sm, paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
        sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
         if mi9$ = -1, sm,paf, "M210", e$
         else, sm,paf, "M211", e$
            numpp = 2
            comment$
            "MW_OP_COMMENT", strcom_BG, e$
            debut_BG = 0
            prvop_id_BG = op_id$
            if mi2_A_base_BG = 0, invers_BG = 0
            if mi2_A_base_BG = 2, invers_BG = 1
            if opcode$ = 16, drill5axes_BG = 1
            if opcode$ = 16, pcont_garage_BM, pchange_BM, ptlchg_BM
            prot1_BG
            pprint_BG
            gcode$ = 0
        if mr2print_BG = 0, mr2print_BG =zsecuprint
        prvmr2_BG = mr2print_BG
        pcalxyz3d_BG
            if mr2print_BG <>   -1,	[
									if (flag_cloche_BG = 1) & (flag_chargement_cloche_BG = 1), sr, *mr2print_BG, sazero, sczero, paf,pgcode_force_BG, *mr2$, sm, sxcloche_BG, sycloche_BG, e$, flag_cloche_BG = 0, flag_chargement_cloche_BG = 0	
									else, sr, *mr2print_BG, sazero, sczero, paf,pgcode_force_BG, *mr2$ ,sm, sxmag_BG, symag_BG, e$
									]
            else, 					[
			
									if (flag_cloche_BG = 1) & (flag_chargement_cloche_BG = 1), sr, *z1_BG, sazero, sczero, paf,pgcode_force_BG, *z1_BG, sm, sxcloche_BG, sycloche_BG, e$, flag_cloche_BG = 0, flag_chargement_cloche_BG = 0
									else, sr, *z1_BG, sazero, sczero, paf, pgcode_force_BG,*z1_BG,sm, sxmag_BG, symag_BG, e$
									]			
			
			
            #if xr <> 0 | yr <> 0
            prot2_BG



            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

                operation_BG = 0

        oldstation_BG = mi4_BG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_BG = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_CG      # Changement outil
				change_outil_CG = 1
				flag_outil_CG = 1
				garage_CG = 0
				flagmr2_CG = 0
				old_opcode_cloche_CG = opcode$
				flag_changement_outil_CG = 1
                old_tool_AG = tlngno$
                flag_cloche_CG = 0
				flag_chargement_cloche_CG = 0
                strcom_CG = svide
                premperc_CG = 0

                if (mi4_CG > 0) & (mi4_CG <> 9), mini_c_CG = mini_c_avec_cloche_CG, maxi_c_CG = maxi_c_avec_cloche_CG
                else, mini_c_CG = mini_c_sans_cloche_CG, maxi_c_CG = maxi_c_sans_cloche_CG
                pnumop_CG
				
				rayon_outil = tldia$/2
        		longeur_outil = paramT3 + paramT7
        		var_1 = rpar(stl_mfg_com, 5)   # extraction des variable numerique qui sont dans le champ mandrain                              
        		if stl_mfg_com = svide, psortietest_outil
				
                if oscilliation = 1 & mi7$ <> 0, psortie12_CG
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CG
				if mr2$ = -1, psortie13_CG
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CG
                ptrans_option_CG  # on est dans le cas d'une transformation 
                cycle_heli_spiral_CG = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_CG
            if opcode$ = 16, drill5axes_CG = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CG
        ptestcloche_CG

        if operation_CG = 11,
            [
            gfr_CG = 1
            sm,paf,*sgfr_CG, "F500",e$
            ]
        pdmodalxyz_CG
        drill5axes_CG = 0
        gcode$ = 0
        panul_plan_inc_CG
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_CG
        else,
            [
                if  mr2print_CG <> -1 & prvmr2_CG <> -1,sr, *prvmr2_CG, paf, pgcode_force_CG, *prvmr2_CG,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_CG
            ]
        plubrifoff_CG
        sm,paf, "M302 ; ARRET ASPI 1", e$
        sm,paf, "M304 ; ARRET ASPI 2", e$
        sm,paf, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_CG
        pchagement_outil_CG
        pappeloutil_CG

        mr4_CG = mr4$
        if mr4$ > 0, sm,pafcom,mr4_CG, e$

        ptlngno_CG
        frbase_CG = fr$
        sm,paf, *spdlon_CG, ssprint_CG,e$
        old_ss = ssprint_CG
        plubrifon_CG

        pcycle832_CG
        sm,paf, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       sm, paf, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        sm,paf, "G54 ; SELECTION NUMERO ORIGINE", e$
        sm,paf, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, sm, paf, "M210", e$
         #else, sm, paf, "M211", e$
            numpp = 3
            comment$
            "MW_OP_COMMENT", strcom_CG, e$
            debut_CG = 0
            prvop_id_CG = op_id$
            if mi2_A_base_CG = 0, invers_CG = 0
            if mi2_A_base_CG = 2, invers_CG = 1
            if opcode$ = 16, drill5axes_CG = 1
            if opcode$ = 16, pcont_garage_CM, pchange_CM, ptlchg_CM
            prot1_CG
            pprint_CG
            gcode$ = 0
        if mr2print_CG = 0, mr2print_CG =zsecuprint
        prvmr2_CG = mr2print_CG
        pcalxyz3d_CG
            if mr2print_CG <>   -1,sr, *mr2print_CG, sbzero, sczero, paf,pgcode_force_CG, *mr2$ ,sm, sxmag_CG, symag_CG, e$
            else, sr, *z1_CG, sbzero, sczero, paf, pgcode_force_CG,*z1_CG,sm, sxmag_CG, symag_CG, e$
			
            #if xr <> 0 | yr <> 0
            prot2_CG



            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

                operation_CG = 0

        oldstation_CG = mi4_CG
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_CG = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_AM      # Changement outil
                pnumop_AM
                if oscilliation = 1 & (mi7$ <> 0), psortie12_AM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_AM
				if mr2$ = -1, psortie13_AM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_AM
                 ptrans_option_AM  # on est dans le cas d'une transformation 
        #      "opcode",*opcode
            cycle_heli_spiral_AM = 0

            if mi10$ <> 1 & mi10$ <> -1, pcantext_AM
            if opcode$ = 16, drill5axes_AM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0

        pprint_AM

        if operation_AM = 11,[
            gfr_AM = 1
             pnumligne,*sgfr_AM, "@AVANCE@500", e$
        ]
        pdmodalxyz_AM
            drill5axes_AM = 0



        gcode$ = 0
            pnumligne, "G151 S0",e$
            if (mi10$ = 1) | (mi10$ = -1), parretprog2_AM
            else,
            [
                if  mr2print_AM <> -1 & prvmr2_AM <> -1,pnumligne,pgcode_force_AM, *prvmr2_AM,e$
            ]
            spaces$ = 0
            pnumligne," ", e53_AM,"=0",e$
            spaces$ = 1
            pnumligne, SARRET_LUB,e$
            pnumligne, SARRET_ASPI,e$
        pnumligne, "M5",e$
        pnumligne, SCLOCHE, spaces$ = 0, "0", spaces$ = 1, e$
        xcor = 0
        ycor = 0
        zcor = 0
            pasmi7 = 0
        pasn = 0
       # if t$ > 20 & station_tool = 1, pnumligne, "M6 T0",e$ # depose outil 
        #if t$ < 16 & station_tool = 2, pnumligne, "M6 T0",e$
        if t$ > 16 & t$ < 20 | t$ > 29,	[
										if prog_AM = 1, q4
										]
        if t$ < 16 , station_tool = 1
        if t$ > 20 , station_tool = 2
        if t$ = tete_rev_ang_11, pnumligne, "( Outil renvoi angle ",tete_rev_ang_11,")",e$
        if t$ = tete_rev_ang_12, pnumligne, "( Outil renvoi angle ",tete_rev_ang_12,")",e$
        if t$ = tete_rev_ang_21, pnumligne, "( Outil renvoi angle ",tete_rev_ang_21,")",e$
        if t$ = tete_rev_ang_22, pnumligne, "( Outil renvoi angle ",tete_rev_ang_22,")",e$
        tlngno_AM = tlngno$
        pnumligne, "M6", *tprint_AM, *tlngno_AM,e$
        spaces$ = 0
        e53_AM = 53000 + tlngno$
        #e53_AM = tlngno$
        mr4_AM = mr4$
        pnumligne, " ", e53_AM,"=", *mr4_AM,e$
        spaces$ = 1
        ptlngno_AM
            frbase_AM = fr$
        if (mi4_AM = 9) | ((mi4_AM > 6) & (mi4_AM <> 9)),  pnumligne, *spdlon_AM, "M40", ssprint_AM,e$
            old_ss = ssprint_AM
        plubrifon_AM,e$
            numpp = 4
            comment$
            pnumligne, strcom_AM, e$
            debut_AM = 0
            prvop_id_AM = op_id$
            if mi2_A_base_AM = 0, invers_AM = 0
            if mi2_A_base_AM = 2 , invers_AM = 1
            if opcode$ = 16, drill5axes_AM = 1
            if opcode$ = 16, pchange_BG, ptlchg_BG
            prot1_AM
            pprint_AM
            gcode$ = 0
        if mr2print_AM = 0, mr2print_AM =zsecuprint
        prvmr2_AM = mr2print_AM
        pcalxyz3d_AM
            if mr2print_AM <>   -1,pnumligne,pgcode_force_AM, *mr2print_AM ,e$
            else, pnumligne, pgcode_force_AM,*z1_AM,e$
            #if xr <> 0 | yr <> 0
            prot2_AM



            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

                operation_AM = 0

        oldstation_AM = mi4_AM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_AM = 1

               pugv_AM
               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_BM      # Changement outil

                pnumop_BM
                if oscilliation = 1 & mi7$ <> 0, psortie12_BM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_BM
				if mr2$ = -1, psortie13_BM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_BM
                ptrans_option_BM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_BM = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_BM
            if opcode$ = 16, drill5axes_BM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_BM
        ptestcloche_BM

        if operation_BM = 11,
            [
            gfr_BM = 1
            pnumligne,*sgfr_BM, "@AVANCE@500",e$
            ]
        pdmodalxyz_BM
        drill5axes_BM = 0
        gcode$ = 0
        panul_plan_inc_BM
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_BM
        else,
            [
                if  mr2print_BM <> -1 & prvmr2_BM <> -1,pnumligne,pgcode_force_BM, *prvmr2_BM,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_BM
            ]
        plubrifoff_BM
        pnumligne, SARRET_ASPI,e$
        pnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_BM



        pappeloutil_BM

        mr4_BM = mr4$
        if mr4$ > 0, mr4_BM, e$

        ptlngno_BM
        frbase_BM = fr$
        pnumligne, *spdlon_BM, ssprint_BM,e$
        old_ss = ssprint_BM
        plubrifon_BM

        pcycle832_BM
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         if mi9$ = -1, pnumligne, "M210", e$
         else, pnumligne, "M211", e$
            numpp = 5
            comment$
            pnumligne, strcom_BM, e$
            debut_BM = 0
            prvop_id_BM = op_id$
            if mi2_A_base_BM = 0, invers_BM = 0
            if mi2_A_base_BM = 2, invers_BM = 1
            if opcode$ = 16, drill5axes_BM = 1
            if opcode$ = 16, pchange_CG, ptlchg_CG
            prot1_BM
            pprint_BM
            gcode$ = 0
        if mr2print_BM = 0, mr2print_BM =zsecuprint
        prvmr2_BM = mr2print_BM
        pcalxyz3d_BM
            if mr2print_BM <>   -1,pnumligne,pgcode_force_BM, *mr2print_BM ,e$
            else, pnumligne, pgcode_force_BM,*z1_BM,e$
            #if xr <> 0 | yr <> 0
            prot2_BM



            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

                operation_BM = 0

        oldstation_BM = mi4_BM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_BM = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0

ptlchg_CM      # Changement outil
                if (mi4_CM > 0) & (mi4_CM <> 9), mini_c_CM = mini_c_avec_cloche_CM, maxi_c_CM = maxi_c_avec_cloche_CM
                else, mini_c_CM = mini_c_sans_cloche_CM, maxi_c_CM = maxi_c_sans_cloche_CM
                pnumop_CM
                if oscilliation = 1 & mi7$ <> 0, psortie12_CM
                if (mr2$ = 0) | (mr2$ = 1), psortie15_CM
				if mr2$ = -1, psortie13_CM
                if ((mi10$ = 1) | (mi10$ = -1)) & mr2$ = -1, psortie14_CM
                ptrans_option_CM  # on est dans le cas d'une transformation 
                cycle_heli_spiral_CM = 0


        #      "opcode",*opcode
            if mi10$ <> 1 & mi10$ <> -1, pcantext_CM
            if opcode$ = 16, drill5axes_CM = 1, mod5xcont = 2
            if nextop$ = 11 & opcode$ <> 16, mod5xcont = 1
            if nextop$ <> 11 & opcode$ <> 16, mod5xcont = 0
            pprint_CM
        ptestcloche_CM

        if operation_CM = 11,
            [
            gfr_CM = 1
            pnumligne,*sgfr_CM, "@AVANCE@500",e$
            ]
        pdmodalxyz_CM
        drill5axes_CM = 0
        gcode$ = 0
        panul_plan_inc_CM
        if (mi10$ = 1) | (mi10$ = -1), parretprog2_CM
        else,
            [
                if  mr2print_CM <> -1 & prvmr2_CM <> -1,pnumligne,pgcode_force_CM, *prvmr2_CM,e$
                if ((mi10$ > 1) | (mi10$ < -1)), ptempo_CM
            ]
        plubrifoff_CM
        pnumligne, SARRET_ASPI,e$
        pnumligne, "M5 ; ARRET BROCHE",e$

        xcor = 0
        ycor = 0
        zcor = 0
        pasmi7 = 0
        pasn = 0


        ptestrenvoi_angle_CM



        pappeloutil_CM

        mr4_CM = mr4$
        if mr4$ > 0, mr4_CM, e$

        ptlngno_CM
        frbase_CM = fr$
        pnumligne, *spdlon_CM, ssprint_CM,e$
        old_ss = ssprint_CM
        plubrifon_CM

        pcycle832_CM
        pnumligne, "TRAORI(1)", e$
#   MODIF EDC LE 30 MAI 2013
#       pnumligne, "DECALAGE ; SOUS PROG DECALAGE ORIGINE", e$
        pnumligne, "G54 ; SELECTION NUMERO ORIGINE", e$
        pnumligne, "D1 ; PRISE DE CORRECTEUR", e$
         #if mi9$ = -1, pnumligne, "M210", e$
         #else, pnumligne, "M211", e$
            numpp = 6
            comment$
            pnumligne, strcom_CM, e$
            debut_CM = 0
            prvop_id_CM = op_id$
            if mi2_A_base_CM = 0, invers_CM = 0
            if mi2_A_base_CM = 2, invers_CM = 1
            if opcode$ = 16, drill5axes_CM = 1
            if opcode$ = 16, ex$
            prot1_CM
            pprint_CM
            gcode$ = 0
        if mr2print_CM = 0, mr2print_CM =zsecuprint
        prvmr2_CM = mr2print_CM
        pcalxyz3d_CM
            if mr2print_CM <>   -1,pnumligne,pgcode_force_CM, *mr2print_CM ,e$
            else, pnumligne, pgcode_force_CM,*z1_CM,e$
            #if xr <> 0 | yr <> 0
            prot2_CM



            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

                operation_CM = 0

        oldstation_CM = mi4_CM
               if mr5$ <= 0, mr5$ = 0.0001
                retplangarde = 0 # remise a 0 du flag pour retour plan de garde en percage 5 axes
               changop_CM = 1


               vale53 = 0
               sens_pas = -1
               debutvar = 0
#endregion
#region peof0
peof0$
            pchange_AG
            peof0_AG

            pchange_AM
            peof0_AM

            pchange_BG
            peof0_BG

            pchange_BM
            peof0_BM

            pchange_CG
            peof0_CG

            pchange_CM
            peof0_CM

peof0_AG      # Fin outil nul
            peof$
peof0_BG       # Fin outil nul
            peof$
peof0_CG       # Fin outil nul
            peof$
peof0_AM      # Fin outil nul
            peof$
peof0_BM       # Fin outil nul
            peof$
peof0_CM       # Fin outil nul
            peof$
#endregion
#region peofpprdr

peofpprdr_AG     #ecriture fin prog mode passant table droite           
        sm,paf,"E10002=1",e$
        sm,paf,"G4 F0.1",e$
        sm,paf,"E10000=0",e$
        sm,paf,"E10002=0",e$
        sm, szmach_garage_AG, paf,"G0 G52 Z-150",e$
        sm, sxmach_garage_AG, symach_garage_AG,sazero, sczero, paf, "G0 G52 X2000 Y3920 A C",e$
        sm,paf,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        sm, symach_garage2_AG, paf, "G1 G52 F2500 Y4120",e$
        sm,paf,"M199",e$
        sm,paf,"M2",e$

peofpprdr_AM     #ecriture fin prog mode passant table droite           
        pnumligne,"E10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0",e$
        pnumligne,"E10002=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peofpprga

peofpprga_AG    #ecriture fin prog mode passant table gauche           
        sm,paf,"E10003=1",e$
        sm,paf,"G4 F0.1",e$
        sm,paf,"E10001=0",e$
        sm,paf,"E10003=0",e$
        sm, szmach_garage_AG, paf,"G0 G52 Z-150",e$
        sm, sxmach_garage_AG, symach_garage_AG,sazero, sczero, paf, "G0 G52 X2000 Y3920 A C",e$
        sm,paf,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        sm, symach_garage2_AG, paf, "G1 G52 F2500 Y4120",e$
        sm,paf,"M199",e$
        sm,paf,"M2",e$

peofpprga_AM    #ecriture fin prog mode passant table gauche           
        pnumligne,"E10003=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10001=0",e$
        pnumligne,"E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peofpprsy

peofpprsy_AG     #ecriture fin prog mode passant table gauche/droite           
        sm,paf,"E10003=1 E=10002=1",e$
        sm,paf,"G4 F0.1",e$
        sm,paf,"E10000=0 E10001=0",e$
        sm,paf,"E10002=0 E10003=0",e$
        sm, szmach_garage_AG, paf,"G0 G52 Z-150",e$
        sm, sxmach_garage_AG, symach_garage_AG,sazero, sczero, paf, "G0 G52 X2000 Y3920 A C",e$
        sm,paf,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        sm, symach_garage2_AG, paf, "G1 G52 F2500 Y4120",e$
        sm,paf,"M199",e$
        sm,paf,"M2",e$

peofpprsy_AM     #ecriture fin prog mode passant table gauche/droite           
        pnumligne,"E10003=1 E=10002=1",e$
        pnumligne,"G4 F0.1",e$
        pnumligne,"E10000=0 E10001=0",e$
        pnumligne,"E10002=0 E10003=0",e$
        pnumligne,"G0 G52 Z-150",e$
        pnumligne,"G0 G52 X2000. Y3920. A C ",e$
        pnumligne,"M198 $ VALIDER LE RECUL TOTAL DE LA TABLE",e$
        pnumligne,"G1 G52 F2500 Y4120",e$
        pnumligne,"M199",e$
        pnumligne,"M2",e$
#endregion
#region peof
peof$
                pchange_AG
                peof_AG

                pchange_AM
                peof_AM

                pchange_BG
                peof_BG

                pchange_BM
                peof_BM

                pchange_CG
                peof_CG

                pchange_CM
                peof_CM

                if (erreur_AG = 1) | (erreur_AM = 1) | (erreur_BG = 1) | (erreur_BM = 1) | (erreur_CG = 1) | (erreur_CM = 1),pdestruc_rep

                ###subout$### = 0  # on ecrit dans le prog de synthese
                clearext$
                " ", e$
                "*************************", e$
                "DIMENSION DE L'OUTILLAGE:", e$
                "*************************", e$
                if sdim_outillage <> svide, " - ", sdim_outillage, e$
                " ", e$
                "************************", e$
                "LISTE DES USURES OUTILS:", e$
                "************************", e$
                if susure_outil_1 <> svide, " - ", susure_outil_1, e$
                if susure_outil_2 <> svide, " - ", susure_outil_2, e$
                if susure_outil_3 <> svide, " - ", susure_outil_3, e$
                if susure_outil_4 <> svide, " - ", susure_outil_4, e$
                if susure_outil_5 <> svide, " - ", susure_outil_5, e$
                if susure_outil_6 <> svide, " - ", susure_outil_6, e$
                if susure_outil_7 <> svide, " - ", susure_outil_7, e$
                if susure_outil_8 <> svide, " - ", susure_outil_8, e$
                if susure_outil_9 <> svide, " - ", susure_outil_9, e$
                if susure_outil_10 <> svide, " - ", susure_outil_10, e$
                if susure_outil_11 <> svide, " - ", susure_outil_11, e$
                if susure_outil_12 <> svide, " - ", susure_outil_12, e$
                if susure_outil_13 <> svide, " - ", susure_outil_13, e$
                if susure_outil_14 <> svide, " - ", susure_outil_14, e$
                if susure_outil_15 <> svide, " - ", susure_outil_15, e$
                if susure_outil_16 <> svide, " - ", susure_outil_16, e$
                if susure_outil_17 <> svide, " - ", susure_outil_17, e$
                if susure_outil_18 <> svide, " - ", susure_outil_18, e$
                if susure_outil_19 <> svide, " - ", susure_outil_19, e$
                if susure_outil_20 <> svide, " - ", susure_outil_20, e$
                if susure_outil_21 <> svide, " - ", susure_outil_21, e$
                if susure_outil_22 <> svide, " - ", susure_outil_22, e$
                if susure_outil_23 <> svide, " - ", susure_outil_23, e$
                if susure_outil_24 <> svide, " - ", susure_outil_24, e$
                if susure_outil_25 <> svide, " - ", susure_outil_25, e$
                if susure_outil_26 <> svide, " - ", susure_outil_26, e$
                if susure_outil_27 <> svide, " - ", susure_outil_27, e$
                if susure_outil_28 <> svide, " - ", susure_outil_28, e$
                if susure_outil_29 <> svide, " - ", susure_outil_29, e$
                if susure_outil_30 <> svide, " - ", susure_outil_30, e$

                " ", e$
                "****************************", e$
                "LISTE DES DECALAGES MACHINE:", e$
                "****************************", e$
                mr8AF_AG = mr8_AG
                mr9AF_AG = mr9_AG
                mr10AF_AG = mr10_AG
                mr8AF_BG = mr8_BG
                mr9AF_BG = mr9_BG
                mr10AF_BG = mr10_BG
                mr8AF_CG = mr8_CG
                mr9AF_CG = mr9_CG
                mr10AF_CG = mr10_CG

                if (prog_AG = 1) | (prog_AM = 1),   [
                                                    smachine_AG, " :", e$
                                                    " - ",*mr8AF_AG, e$
                                                    " - ",*mr9AF_AG, e$
                                                    " - ",*mr10AF_AG, e$
                                                    " ", e$
                                                    ]

                if (prog_BG = 1) | (prog_BM = 1),   [
                                                    smachine_BG, " :", e$
                                                    " - ",*mr8AF_BG, e$
                                                    " - ",*mr9AF_BG, e$
                                                    " - ",*mr10AF_BG, e$
                                                    " ", e$
                                                    ]
                if (prog_CG = 1) | (prog_CM = 1),   [
                                                    smachine_CG, " :", e$
                                                    " - ",*mr8AF_CG, e$
                                                    " - ",*mr9AF_CG, e$
                                                    " - ",*mr10AF_CG, e$
                                                    " ", e$
                                                    ]
                "***************************************", e$
                "TYPE DE MODE DE TRANSFERT DU PROGRAMME:", e$
                "***************************************", e$
                if (prog_AG = 1) | (prog_AM = 1),   [
                                                    smachine_AG, " :", e$
                                                    if mi5_AG = 1," - ", "PPR DR", e$
                                                    if mi5_AG = 2," - ", "PPR GA", e$
                                                    if mi5_AG = 3," - ", "PPR*2", e$
                                                    if mi5_AG = 9," - ", "CONTINU", e$
                                                    " ", e$
                                                    ]

                if (prog_BG = 1) | (prog_BM = 1),   [
                                                    smachine_BG, " :", e$
                                                    if mi5_BG = 1, " - ", "TOUTE LE TABLE", e$
													if mi5_BG = 9 & mr8_changeur_BG < 5000, " - ", "ZONE 1", e$
                                                    if mi5_BG = 9 & mr8_changeur_BG >= 5000, " - ", "ZONE 2", e$
                                                    " ", e$
                                                    ]
                if (prog_CG = 1) | (prog_CM = 1),   [
                                                    smachine_CG, " :", e$
                                                    if mi5_CG = 1, " - ", "ZONE 1", e$
													if mi5_CG = 2, " - ", "ZONE 2", e$
                                                    if mi5_CG = 9, " - ", "TOUTE LA TABLE", e$
                                                    " ", e$
                                                    ]
                "************************************************", e$
                "LISTE DES FICHIERS CREES PAR LE POST PROCESSEUR:", e$
                "************************************************", e$
                if (erreur_AG = 0) & (erreur_AM = 0) & (erreur_BG = 0) & (erreur_BM = 0) & (erreur_CG = 0) & (erreur_CM = 0), mergeaux$   # on y rajoute la liste des programme generer
                clearaux$
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 1) | (erreur_CM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101 et ST9103 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_CG = 0) & (erreur_CM = 0)) & ((erreur_BG = 1) | (erreur_BM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9101 et ST9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_CG = 0) & (erreur_CM = 0)) & ((erreur_AG = 1) | (erreur_AM = 1)),
                [
                "- Il a des fichiers provisoires créés pour les Machines STC9103 et ST9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_AG = 0) & (erreur_AM = 0)) & ((erreur_BG = 1) | (erreur_BM = 1)) & ((erreur_CG = 1) | (erreur_CM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9101 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_BG = 0) & (erreur_BM = 0)) & ((erreur_AG = 1) | (erreur_AM = 1)) & ((erreur_CG = 1) | (erreur_CM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9103 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if ((erreur_CG = 0) & (erreur_CM = 0)) & ((erreur_AG = 1) | (erreur_AM = 1)) & ((erreur_BG = 1) | (erreur_BM = 1)),
                [
                "- Il a des fichiers provisoires créés pour la Machine STC9110 vérifier le rapport des erreurs et modifier votre programme.", e$
                ]
                if (erreur_AG = 1) | (erreur_AM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9101, vérifier le rapport des erreurs et modifier votre programme.", e$
                if (erreur_BG = 1) | (erreur_BM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9103, vérifier le rapport des erreurs et modifier votre programme.", e$
                if (erreur_CG = 1) | (erreur_CM = 1), "- Il n'y a aucun fichier créé pour la Machine STC9110, vérifier le rapport des erreurs et modifier votre programme.", e$
                " ", e$
                "***************************************", e$
                "RAPPORT DES ERREURS DE POST TRAITEMENT:", e$
                "***************************************", e$
                mergelcc$
                if (erreur_AG = 0) & (erreur_AM = 0) & (erreur_BG = 0) & (erreur_BM = 0) & (erreur_CG = 0) & (erreur_CM = 0),
                [
                " ", e$
                "Il n'y a aucune erreur à signaler.", e$
                " ", e$
                ]
                clearlcc$
                "*******************************************************************", e$
                "Fin de fichier de synthèse", e$

peof_AG        # Fin 
                pprint_AG

            if typcycle_AG = 1 & cycle_heli_spiral_AG = 0, sr, *initht$, paf, "G80", *initht$,e$
            typcycle_AG = 0
            if operation_AG = 11,[
             gfr_AG = 1
             sm, paf, *sgfr_AG,"F500",e$
            ]
            sm, paf, "G151 S0",e$

            if prvmr2_AG <>   -1 & mr2print_AG <>   -1,sr, *prvmr2_AG, paf, "G0", *prvmr2_AG,e$

        sm, paf, spaces$ = 0," ", e53_AG,"=0",e$
        spaces$ = 1
            sm, paf, "M09",e$
            sm, paf,, "M05",e$
            sm, paf, "M151",e$
            sm, paf,"E60001=0",e$
            sm, paf,"E61001=0",e$
        sm, paf,"E62001=0",e$
        sm, paf,"E64001=E61001",e$
        sm, paf,"E80004=-130000.",e$

          # n, "M170"
          # n, "G0 A0 C0"
            if ppr = 1, peofpprdr_AG
            if ppr = 2, peofpprga_AG
            if ppr = 3, peofpprsy_AG

            sf, e$
peof_BG        # Fin 
                pprint_BG
            gcode$ = 0
            if typcycle_BG = 1, sm,paf, "MCALL", e$, sr, *initht$, paf, pgcode_force_BG, *initht$,e$
            typcycle_BG = 0
            if operation_BG = 11,[
             gfr_BG = 1
             sm,paf,*sgfr_BG,"F500",e$
            ]
            panul_plan_inc_BG
            if prvmr2_BG <>   -1 & mr2print_BG <>   -1,sr, *prvmr2_BG, paf, pgcode_BG, *prvmr2_BG,e$
            spaces$ = 0
            #sm, paf," ", e53,"=0",e$
            spaces$ = 1
            sm,paf, "TRAFOOF",e$
            sm,paf, "M9 ; ARRET LUBRIFIANT",e$
            sm,paf, "M5 ; ARRET BROCHE",e$
            sm,paf, "M201 ; CONTROLE DU VIDE",e$
            sm,paf, "CRENO_END ; MACRO FIN DE PROG", e$
            sm,paf, "M151 ; ARRET ASPI",e$
            sm,paf, "M2 ; FIN DE PROGRAMME", e$
            sf, e$
peof_CG        # Fin 
                pprint_CG
            gcode$ = 0
            if typcycle_CG = 1, sm,paf, "MCALL", e$, sr, *initht$, paf, pgcode_force_CG, *initht$,e$
            typcycle_CG = 0
            if operation_CG = 11,[
             gfr_CG = 1
             sm,paf,*sgfr_CG,"F500",e$
            ]
            panul_plan_inc_CG
            if prvmr2_CG <>   -1 & mr2print_CG <>   -1,sr, *prvmr2_CG, paf, pgcode_CG, *prvmr2_CG,e$
            spaces$ = 0
            #sm, paf," ", e53,"=0",e$
            spaces$ = 1
            sm,paf, "TRAFOOF",e$
            sm,paf, "M9 ; ARRET LUBRIFIANT",e$
            sm,paf, "M5 ; ARRET BROCHE",e$
            #sm,paf, "M201 ; CONTROLE DU VIDE",e$
            sm,paf, "CMS_END ; MACRO FIN DE PROG", e$
            sm,paf, "M302 ; ARRET ASPI 1", e$
            sm,paf, "M304 ; ARRET ASPI 2", e$
            sm,paf, "M2 ; FIN DE PROGRAMME", e$
            sm,paf, "M17", e$
            sm,paf, ";END", e$
            sf, e$
peof_AM        # Fin 
                pprint_AM

            if typcycle_AM = 1 & cycle_heli_spiral_AM = 0, pnumligne, "G80", initht$,e$
            typcycle_AM = 0
            if operation_AM = 11,[
             gfr_AM = 1
             pnumligne,*sgfr_AM, "@AVANCE@500", e$
            ]
            pnumligne, "G151 S0",e$

            if prvmr2_AM <>   -1 & mr2print_AM <>   -1,pnumligne,"G0", *prvmr2_AM,e$
            spaces$ = 0
            pnumligne," ", e53_AM,"=0",e$
            spaces$ = 1
            pnumligne, SARRET_LUB,e$
            pnumligne, "M05",e$
            pnumligne, SARRET_ASPI,e$
            #enlevé pour concat#pnumligne,"E60001=0",e$
            #enlevé pour concat#pnumligne,"E61001=0",e$
            #enlevé pour concat#pnumligne,"E62001=0",e$
            #enlevé pour concat#pnumligne,"E64001=E61001",e$
            #enlevé pour concat#pnumligne,"E80004=-130000.",e$

            #enlevé pour concat#if ppr = 1, peofpprdr_AM
            #enlevé pour concat#if ppr = 2, peofpprga_AM
            #enlevé pour concat#if ppr = 3, peofpprsy_AM

peof_BM        # Fin 
                pprint_BM
            gcode$ = 0
            if typcycle_BM = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_BM, initht$,e$
            typcycle_BM = 0
            if operation_BM = 11,[
             gfr_BM = 1
             pnumligne,*sgfr_BM,"@AVANCE@500",e$
            ]
            panul_plan_inc_BM
            if prvmr2_BM <>   -1 & mr2print_BM <>   -1,pnumligne, pgcode_BM, *prvmr2_BM,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            pnumligne, "TRAFOOF",e$
            pnumligne, SARRET_LUB,e$
            pnumligne, "M5 ; ARRET BROCHE",e$
            #enlevé pour concat#pnumligne, "M201 ; CONTROLE DU VIDE",e$
            #enlevé pour concat#pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            pnumligne, SARRET_ASPI,e$
            #enlevé pour concat#pnumligne, "M2 ; FIN DE PROGRAMME", e$         

peof_CM        # Fin 
                pprint_CM
            gcode$ = 0
            if typcycle_CM = 1, pnumligne, "MCALL", e$, pnumligne, pgcode_force_CM, initht$,e$
            typcycle_CM = 0
            if operation_CM = 11,[
             gfr_CM = 1
             pnumligne,*sgfr_CM,"@AVANCE@500",e$
            ]
            panul_plan_inc_CM
            if prvmr2_CM <>   -1 & mr2print_CM <>   -1,pnumligne, pgcode_CM, *prvmr2_CM,e$
            spaces$ = 0
            #pnumligne," ", e53,"=0",e$
            spaces$ = 1
            pnumligne, "TRAFOOF",e$
            pnumligne, SARRET_LUB,e$
            pnumligne, "M5 ; ARRET BROCHE",e$
            #enlevé pour concat#pnumligne, "M201 ; CONTROLE DU VIDE",e$
            #enlevé pour concat#pnumligne, "CRENO_END ; MACRO FIN DE PROG", e$
            pnumligne, SARRET_ASPI,e$
            #enlevé pour concat#pnumligne, "M2 ; FIN DE PROGRAMME", e$         
#endregion
#endregion

#region   PLIN, PCIR #OK
#region prapid
prapid$
            pchange_AG
            prapid_AG

            pchange_AM
            prapid_AM

            pchange_BG
            prapid_BG

            pchange_BM
            prapid_BM

            pchange_CG
            prapid_CG

            pchange_CM
            prapid_CM

prapid_AG     # Ligne rapide
            pprint_AG
           sr, *xprint_AG, *yprint_AG , *zprint_AG, paf, pgcode_AG, xaff, yaff , zaff, e$
           old_x_AG=xprint_AG
           old_y_AG=yprint_AG
           old_z_AG=zprint_AG

prapid_BG     # Ligne rapide
            pprint_BG
           sr, *xprint_BG, *yprint_BG , *zprint_BG, paf, pgcode_BG, xaff, yaff , zaff, e$
           old_x_BG=xprint_BG
           old_y_BG=yprint_BG
           old_z_BG=zprint_BG

prapid_CG     # Ligne rapide
            pprint_CG
           sr, *xprint_CG, *yprint_CG , *zprint_CG, paf, pgcode_CG, xaff, yaff , zaff, e$
           old_x_CG=xprint_CG
           old_y_CG=yprint_CG
           old_z_CG=zprint_CG

prapid_AM     # Ligne rapide
            pprint_AM
           pnumligne, pgcode_AM, xprint_AM, yprint_AM , zprint_AM,e$
           old_x_AM=xprint_AM
           old_y_AM=yprint_AM
           old_z_AM=zprint_AM

prapid_BM     # Ligne rapide
            pprint_BM
           pnumligne, pgcode_BM, xprint_BM, yprint_BM , zprint_BM,e$
           old_x_BM=xprint_BM
           old_y_BM=yprint_BM
           old_z_BM=zprint_BM

prapid_CM     # Ligne rapide
            pprint_CM
           pnumligne, pgcode_CM, xprint_CM, yprint_CM , zprint_CM,e$
           old_x_CM=xprint_CM
           old_y_CM=yprint_CM
           old_z_CM=zprint_CM
#endregion
#region pzrapid
pzrapid$
            pchange_AG
            pzrapid_AG

            pchange_AM
            pzrapid_AM

            pchange_BG
            pzrapid_BG

            pchange_BM
            pzrapid_BM

            pchange_CG
            pzrapid_CG

            pchange_CM
            pzrapid_CM

pzrapid_AG    # Ligne Z rapide

            pprint_AG
           sr, *zprint_AG, paf, pgcode_AG, *zprint_AG,e$
           old_z_AG=zprint_AG

pzrapid_BG    # Ligne Z rapide

            pprint_BG
           sr, *zprint_BG, paf, pgcode_BG, *zprint_BG,e$
           old_z_BG=zprint_BG

pzrapid_CG    # Ligne Z rapide

            pprint_CG
           sr, *zprint_CG, paf, pgcode_CG, *zprint_CG,e$
           old_z_CG=zprint_CG

pzrapid_AM    # Ligne Z rapide

            pprint_AM
           pnumligne, pgcode_AM, zprint_AM,e$
           old_z_AM=zprint_AM

pzrapid_BM    # Ligne Z rapide

            pprint_BM
           pnumligne, pgcode_BM, zprint_BM,e$
           old_z_BM=zprint_BM

pzrapid_CM    # Ligne Z rapide

            pprint_CM
           pnumligne, pgcode_CM, zprint_CM,e$
           old_z_CM=zprint_CM
#endregion
#region plin
plin$
            pchange_AG
            plin_AG

            pchange_AM
            plin_AM

            pchange_BG
            plin_BG

            pchange_BM
            plin_BM

            pchange_CG
            plin_CG

            pchange_CM
            plin_CM

plin_AG       # Ligne travail       
            pprint_AG
            gfr_AG = 1
           sm, paf, sgfr_AG,e$
           sl, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, pcord_AG, xaff, yaff, zaff, pfr_AG, pg9_AG,e$
           old_x_AG=xprint_AG
           old_y_AG=yprint_AG
           old_z_AG=zprint_AG

plin_BG       # Ligne travail
            pprint_BG
            gfr_BG = 1
           sm, paf, sgfr_BG,e$
           sl, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, pcord_BG, xaff, yaff, zaff, pfr_BG, pg9_BG,e$
           old_x_BG=xprint_BG
           old_y_BG=yprint_BG
           old_z_BG=zprint_BG

plin_CG       # Ligne travail
            pprint_CG
            gfr_CG = 1
           sm, paf, sgfr_CG,e$
           sl, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, pcord_CG, xaff, yaff, zaff, pfr_CG, pg9_CG,e$
           old_x_CG=xprint_CG
           old_y_CG=yprint_CG
           old_z_CG=zprint_CG

plin_AM       # Ligne travail       
            pprint_AM
            gfr_AM = 1
           pnumligne, sgfr_AM,e$
           pnumligne, pgcode_AM, pcord_AM, xprint_AM, yprint_AM, zprint_AM, pfr_AM, pg9_AM,e$
           old_x_AM=xprint_AM
           old_y_AM=yprint_AM
           old_z_AM=zprint_AM

plin_BM       # Ligne travail
            pprint_BM
            gfr_BM = 1
           pnumligne, sgfr_BM,e$
           pnumligne, pgcode_BM, pcord_BM, xprint_BM, yprint_BM, zprint_BM, pfr_BM, pg9_BM,e$
           old_x_BM=xprint_BM
           old_y_BM=yprint_BM
           old_z_BM=zprint_BM

plin_CM       # Ligne travail
            pprint_CM
            gfr_CM = 1
           pnumligne, sgfr_CM,e$
           pnumligne, pgcode_CM, pcord_CM, xprint_CM, yprint_CM, zprint_CM, pfr_CM, pg9_CM,e$
           old_x_CM=xprint_CM
           old_y_CM=yprint_CM
           old_z_CM=zprint_CM
#endregion
#region pz
pz$
            pchange_AG
            pz_AG

            pchange_AM
            pz_AM

            pchange_BG
            pz_BG

            pchange_BM
            pz_BM

            pchange_CG
            pz_CG

            pchange_CM
            pz_CM

pz_AG         # z en avance rapide
            pprint_AG
           sr, *zprint_AG, paf, pgcode_AG, *zprint_AG,e$
           old_z_AG=zprint_AG

pz_BG         # z en avance rapide
            pprint_BG
           sr, *zprint_BG, paf, pgcode_BG, *zprint_BG,e$
           old_z_BG=zprint_BG

pz_CG         # z en avance rapide
            pprint_CG
           sr, *zprint_CG, paf, pgcode_CG, *zprint_CG,e$
           old_z_CG=zprint_CG

pz_AM         # z en avance rapide
            pprint_AM
           pnumligne, pgcode_AM, zprint_AM,e$
           old_z_AM=zprint_AM

pz_BM         # z en avance rapide
            pprint_BM
           pnumligne, pgcode_BM, zprint_BM,e$
           old_z_BM=zprint_BM

pz_CM         # z en avance rapide
            pprint_CM
           pnumligne, pgcode_CM, zprint_CM,e$
           old_z_CM=zprint_CM
#endregion
#region pcir
pcir$
            pchange_AG
            pcir_AG

            pchange_AM
            pcir_AM

            pchange_BG
            pcir_BG

            pchange_BM
            pcir_BM

            pchange_CG
            pcir_CG

            pchange_CM
            pcir_CM

pcir_AG     # Circulaire
            pprint_AG
            gfr_AG = 1
            sm,paf, sgfr_AG,e$
            iprint_AG = xc_AG
            jprint_AG = yc_AG
            rayon_AG = arcrad$
            if gcode$ = 2, stype_arc = "CW"
            if gcode$ = 3, stype_arc = "CCW"
            if tete_rev_AG = 1,
            [
            plane$ = 2
            sc, *xprint_AG, *yprint_AG, *zprint_AG, rayon_AG, stype_arc, pfr_AG, paf, splcode_AG, pgcode_force_AG, *xaff, *yaff, zaff, *iprint_AG,*jprint_AG, pfr_AG, pg9_AG,  e$
            ]
            else,
            [
            if plane$ = 0, sc, *xprint_AG, *yprint_AG, *zprint_AG, rayon_AG, stype_arc, pfr_AG, paf, splcode_AG, pgcode_force_AG, *xaff, *yaff, zaff, *iprint_AG,*jprint_AG, pfr_AG,e$
            if plane$ = 2, sc, *xprint_AG, *zprint_AG, *yprint_AG, rayon_AG, stype_arc, pfr_AG, paf, splcode_AG, pgcode_force_AG, *xaff, *zaff, yaff, *iprint_AG,*kprint_AG, pfr_AG,e$
            if plane$ = 1, sc, *yprint_AG, *zprint_AG, *xprint_AG, rayon_AG, stype_arc, pfr_AG, paf, splcode_AG, pgcode_force_AG, *yaff, *zaff, xaff, *jprint_AG,*kprint_AG, pfr_AG,e$
            ]
            old_x_AG=xprint_AG
            old_y_AG=yprint_AG
            old_z_AG=zprint_AG

pcir_BG     # Circulaire
            pprint_BG
            gfr_BG = 1
            sm,paf, sgfr_BG,e$
            rayon_BG = arcrad$
            if gcode$ = 2, stype_arc = "CW"
            if gcode$ = 3, stype_arc = "CCW"
            if tete_rev_BG = 1,
            [
            plane$ = 2
            sc, *xprint_BG, *yprint_BG, *zprint_BG, rayon_BG, stype_arc, pfr_BG, paf, splcode_BG, pgcode_force_BG, *xaff, *yaff, zaff, *iprint_BG,*jprint_BG, pfr_BG, pg9_BG,  e$
            ]
            else,
            [
            if plane$ = 0, sc, *xprint_BG, *yprint_BG, *zprint_BG, rayon_BG, stype_arc, pfr_BG, paf, splcode_BG, pgcode_force_BG, *xaff, *yaff, zaff, *iprint_BG,*jprint_BG, pfr_BG,e$
            if plane$ = 2, sc, *xprint_BG, *zprint_BG, *yprint_BG, rayon_BG, stype_arc, pfr_BG, paf, splcode_BG, pgcode_force_BG, *xaff, *zaff, yaff, *iprint_BG,*kprint_BG, pfr_BG,e$
            if plane$ = 1, sc, *yprint_BG, *zprint_BG, *xprint_BG, rayon_BG, stype_arc, pfr_BG, paf, splcode_BG, pgcode_force_BG, *yaff, *zaff, xaff, *jprint_BG,*kprint_BG, pfr_BG,e$
            ]
            old_x_BG=xprint_BG
            old_y_BG=yprint_BG
            old_z_BG=zprint_BG

pcir_CG     # Circulaire
            pprint_CG
            gfr_CG = 1
            sm,paf, sgfr_CG,e$
            rayon_CG = arcrad$
            if gcode$ = 2, stype_arc = "CW"
            if gcode$ = 3, stype_arc = "CCW"
            if tete_rev_CG = 1,
            [
            plane$ = 2
            sc, *xprint_CG, *yprint_CG, *zprint_CG, rayon_CG, stype_arc, pfr_CG, paf, splcode_CG, pgcode_force_CG, *xaff, *yaff, zaff, *iprint_CG,*jprint_CG, pfr_CG, pg9_CG,  e$
            ]
            else,
            [
            if plane$ = 0, sc, *xprint_CG, *yprint_CG, *zprint_CG, rayon_CG, stype_arc, pfr_CG, paf, splcode_CG, pgcode_force_CG, *xaff, *yaff, zaff, *iprint_CG,*jprint_CG, pfr_CG,e$
            if plane$ = 2, sc, *xprint_CG, *zprint_CG, *yprint_CG, rayon_CG, stype_arc, pfr_CG, paf, splcode_CG, pgcode_force_CG, *xaff, *zaff, yaff, *iprint_CG,*kprint_CG, pfr_CG,e$
            if plane$ = 1, sc, *yprint_CG, *zprint_CG, *xprint_CG, rayon_CG, stype_arc, pfr_CG, paf, splcode_CG, pgcode_force_CG, *yaff, *zaff, xaff, *jprint_CG,*kprint_CG, pfr_CG,e$
            ]
            old_x_CG=xprint_CG
            old_y_CG=yprint_CG
            old_z_CG=zprint_CG

pcir_AM     # Circulaire
            pprint_AM
            gfr_AM = 1
            pnumligne, sgfr_AM,e$
            iprint_AM = xc_AM
            jprint_AM = yc_AM
            if tete_rev_AM = 1,
            [
            plane$ = 2
            pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *yprint_AM, zprint_AM, *iprint_AM,*jprint_AM, pfr_AM, pg9_AM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *yprint_AM, zprint_AM, *iprint_AM,*jprint_AM, pfr_AM,e$
            if plane$ = 2, pnumligne, splcode_AM, pgcode_force_AM, *xprint_AM, *zprint_AM, yprint_AM, *iprint_AM,*kprint_AM, pfr_AM,e$
            if plane$ = 1, pnumligne, splcode_AM, pgcode_force_AM, *yprint_AM, *zprint_AM, xprint_AM, *jprint_AM,*kprint_AM, pfr_AM,e$
            ]
            old_x_AM=xprint_AM
            old_y_AM=yprint_AM
            old_z_AM=zprint_AM

pcir_BM     # Circulaire
            pprint_BM
            gfr_BM = 1
            pnumligne, sgfr_BM,e$
            if tete_rev_BM = 1,
            [
            plane$ = 2
            pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *yprint_BM, zprint_BM, *iprint_BM,*jprint_BM, pfr_BM, pg9_BM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *yprint_BM, zprint_BM, *iprint_BM,*jprint_BM, pfr_BM,e$
            if plane$ = 2, pnumligne, splcode_BM, pgcode_force_BM, *xprint_BM, *zprint_BM, yprint_BM, *iprint_BM,*kprint_BM, pfr_BM,e$
            if plane$ = 1, pnumligne, splcode_BM, pgcode_force_BM, *yprint_BM, *zprint_BM, xprint_BM, *jprint_BM,*kprint_BM, pfr_BM,e$
            ]
            old_x_BM=xprint_BM
            old_y_BM=yprint_BM
            old_z_BM=zprint_BM

pcir_CM     # Circulaire
            pprint_CM
            gfr_CM = 1
            pnumligne, sgfr_CM,e$
            if tete_rev_CM = 1,
            [
            plane$ = 2
            pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *yprint_CM, zprint_CM, *iprint_CM,*jprint_CM, pfr_CM, pg9_CM,  e$
            ]
            else,
            [
            if plane$ = 0, pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *yprint_CM, zprint_CM, *iprint_CM,*jprint_CM, pfr_CM,e$
            if plane$ = 2, pnumligne, splcode_CM, pgcode_force_CM, *xprint_CM, *zprint_CM, yprint_CM, *iprint_CM,*kprint_CM, pfr_CM,e$
            if plane$ = 1, pnumligne, splcode_CM, pgcode_force_CM, *yprint_CM, *zprint_CM, xprint_CM, *jprint_CM,*kprint_CM, pfr_CM,e$
            ]
            old_x_CM=xprint_CM
            old_y_CM=yprint_CM
            old_z_CM=zprint_CM
#endregion         
#endregion

#region   PCONT, PMX,... #OK
#region pcont
#-------------------5 axes continue---------------------------------------------------------

pcont_AG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_AG",*cont_axe_c_AG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_AG = cont_axe_c_AG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_AG = cont_axe_c_AG + 360    # retrait de 360 deg    
         axeC_AG = atan2(Vx_AG,Vy_AG)
     #    "voir axeC_AG pur de pcont",*axeC_AG,e
      #   "voir reel axeCpos_AG",*reel_axeCpos_AG,e
         axeC_AG = cont_axe_c_AG + reel_axeCpos_AG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_AG + axeC_AG",*axeC_AG,e  

pcont_BG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_BG",*cont_axe_c_BG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_BG = cont_axe_c_BG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_BG = cont_axe_c_BG + 360    # retrait de 360 deg    
         axeC_BG = atan2(Vx_BG,Vy_BG)
     #    "voir axeC_BG pur de pcont",*axeC_BG,e
      #   "voir reel axeCpos_BG",*reel_axeCpos_BG,e
         axeC_BG = cont_axe_c_BG + reel_axeCpos_BG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_BG + axeC_BG",*axeC_BG,e  

pcont_CG     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_CG",*cont_axe_c_CG,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_CG = cont_axe_c_CG - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_CG = cont_axe_c_CG + 360    # retrait de 360 deg    
         axeC_CG = atan2(-Vy_CG,Vx_CG)
     #    "voir axeC_CG pur de pcont",*axeC_CG,e
      #   "voir reel axeCpos_CG",*reel_axeCpos_CG,e
         axeC_CG = cont_axe_c_CG + reel_axeCpos_CG               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_CG + axeC_CG",*axeC_CG,e         

pcont_AM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_AM",*cont_axe_c_AM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_AM = cont_axe_c_AM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_AM = cont_axe_c_AM + 360    # retrait de 360 deg    
         axeC_AM = atan2(Vx_AM,Vy_AM)
     #    "voir axeC_AM pur de pcont",*axeC_AM,e
      #   "voir reel axeCpos_AM",*reel_axeCpos_AM,e
         axeC_AM = cont_axe_c_AM + reel_axeCpos_AM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_AM + axeC_AM",*axeC_AM,e  

pcont_BM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_BM",*cont_axe_c_BM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_BM = cont_axe_c_BM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_BM = cont_axe_c_BM + 360    # retrait de 360 deg    
         axeC_BM = atan2(Vx_BM,Vy_BM)
     #    "voir axeC_BM pur de pcont",*axeC_BM,e
      #   "voir reel axeCpos_BM",*reel_axeCpos_BM,e
         axeC_BM = cont_axe_c_BM + reel_axeCpos_BM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_BM + axeC_BM",*axeC_BM,e  

pcont_CM     # ajout de plus ou moin 360 sur C
    #   "cont_axe_c_CM",*cont_axe_c_CM,e
    #    "dif_axe-c",*dif_axe_c,e
         if dif_axe_c > 0, cont_axe_c_CM = cont_axe_c_CM - 360    # ajout de 360 deg 
         if dif_axe_c < 0, cont_axe_c_CM = cont_axe_c_CM + 360    # retrait de 360 deg    
         axeC_CM = atan2(-Vy_CM,Vx_CM)
     #    "voir axeC_CM pur de pcont",*axeC_CM,e
      #   "voir reel axeCpos_CM",*reel_axeCpos_CM,e
         axeC_CM = cont_axe_c_CM + reel_axeCpos_CM               # actualisation de l'angle
       #  "vour avec ajout cont_axe_c_CM + axeC_CM",*axeC_CM,e         
#endregion
#region pderoul

pderoul_AG    # retrait de 360 deg sur axeC_AG
         cont_axe_c_AG = cont_axe_c_AG - (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AG = prvaxec_AG - (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AG = atan2(Vx_AG,Vy_AG)
   #         "axeC_AG  =", axeC_AG, e
    #     "cont_axe_c_AG=", cont_axe_c_AG, e
         axeC_AG = cont_axe_c_AG + axeC_AG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AG = mr2print_AG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AG = (deltax / old_longvec) * vectdeg
         ydeg_AG = (deltay / old_longvec) * vectdeg
         zdeg_AG = (deltaz / old_longvec) * vectdeg
         xdeg_AG = xdeg_AG + old_x_AG
         ydeg_AG = ydeg_AG + old_y_AG
         zdeg_AG = zdeg_AG + old_z_AG
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post processeur suite buttée axe C plus",e$#, exitpost$ # abandonner
         sm,paf, "(RATRAPPAGE D ANGLE DEROULE )",e$
         gfr_AG = 1

         sm,paf,*sgfr_AG , *frbase_AG ,e$
         sr, *xdeg_AG, *ydeg_AG, *zdeg_AG, paf, pgcode_AG, *xdeg_AG, *ydeg_AG, *zdeg_AG,e$
         if mr2print_AG <>   -1 & mr2print_AG > zdeg_AG, sr, *zdeg2_AG, paf,pgcode_AG, *zdeg2_AG,e$
         sr, *prvaxec_AG, paf ,pgcode_AG, *prvaxec_AG , "(RATRAPPAGE D ANGLE DEROULE )", e$
         sr, *zdeg_AG, paf ,pgcode_AG, *zdeg_AG,e$
         gcode$ = 1
         sl, *old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, paf,pgcode_AG,*sgfr_AG,*old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, e$
         gfr_AG = 0

pderoul_BG    # retrait de 360 deg sur axeC_BG
         cont_axe_c_BG = cont_axe_c_BG - (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BG = prvaxec_BG - (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BG = atan2(Vx_BG,Vy_BG)
   #         "axeC_BG  =", axeC_BG, e
    #     "cont_axe_c_BG=", cont_axe_c_BG, e
         axeC_BG = cont_axe_c_BG + axeC_BG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BG = mr2print_BG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BG = (deltax / old_longvec) * vectdeg
         ydeg_BG = (deltay / old_longvec) * vectdeg
         zdeg_BG = (deltaz / old_longvec) * vectdeg
         xdeg_BG = xdeg_BG + old_x_BG
         ydeg_BG = ydeg_BG + old_y_BG
         zdeg_BG = zdeg_BG + old_z_BG
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         sm, paf, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         gfr_BG = 1

         sm, paf,*sgfr_BG , *frbase_BG ,e$
         sr, *xdeg_BG, *ydeg_BG, *zdeg_BG, paf, pgcode_BG, *xdeg_BG, *ydeg_BG, *zdeg_BG,e$
         if mr2print_BG <>   -1 & mr2print_BG > zdeg_BG, sr, *zdeg2_BG, paf, pgcode_BG, *zdeg2_BG,e$
         sr, *prvaxec_BG, paf, pgcode_BG, *prvaxec_BG ,"MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         sr, *zdeg_BG, paf, pgcode_BG, *zdeg_BG,e$
         gcode$ = 1
         sl, *old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, paf,pgcode_BG,*sgfr_BG,*old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, e$
         gfr_BG = 0

pderoul_CG    # retrait de 360 deg sur axeC_CG
         cont_axe_c_CG = cont_axe_c_CG - (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CG = prvaxec_CG - (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CG = atan2(-Vy_CG,Vx_CG)
   #         "axeC_CG  =", axeC_CG, e
    #     "cont_axe_c_CG=", cont_axe_c_CG, e
         axeC_CG = cont_axe_c_CG + axeC_CG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CG = mr2print_CG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CG = (deltax / old_longvec) * vectdeg
         ydeg_CG = (deltay / old_longvec) * vectdeg
         zdeg_CG = (deltaz / old_longvec) * vectdeg
         xdeg_CG = xdeg_CG + old_x_CG
         ydeg_CG = ydeg_CG + old_y_CG
         zdeg_CG = zdeg_CG + old_z_CG
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         sm, paf, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         gfr_CG = 1

         sm, paf,*sgfr_CG , *frbase_CG ,e$
         sr, *xdeg_CG, *ydeg_CG, *zdeg_CG, paf, ,pgcode_CG, *xdeg_CG, *ydeg_CG, *zdeg_CG,e$
         if mr2print_CG <>   -1 & mr2print_CG > zdeg_CG, sr, *zdeg2_CG, paf, pgcode_CG, *zdeg2_CG,e$
         sr, *prvaxec_CG, paf,pgcode_CG, *prvaxec_CG ,"MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         sr, *zdeg_CG, paf, pgcode_CG, *zdeg_CG,e$
         gcode$ = 1
         sl, *old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, paf,pgcode_CG,*sgfr_CG,*old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, e$
         gfr_CG = 0

pderoul_AM    # retrait de 360 deg sur axeC_AM
         cont_axe_c_AM = cont_axe_c_AM - (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AM = prvaxec_AM - (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AM = atan2(Vx_AM,Vy_AM)
   #         "axeC_AM  =", axeC_AM, e
    #     "cont_axe_c_AM=", cont_axe_c_AM, e
         axeC_AM = cont_axe_c_AM + axeC_AM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AM = mr2print_AM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AM = (deltax / old_longvec) * vectdeg
         ydeg_AM = (deltay / old_longvec) * vectdeg
         zdeg_AM = (deltaz / old_longvec) * vectdeg
         xdeg_AM = xdeg_AM + old_x_AM
         ydeg_AM = ydeg_AM + old_y_AM
         zdeg_AM = zdeg_AM + old_z_AM
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post processeur suite buttée axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "(RATRAPPAGE D ANGLE DEROULE )",e$
         gfr_AM = 1

         pnumligne,*sgfr_AM , *frbase_AM ,e$
         pnumligne,pgcode_AM, *xdeg_AM, *ydeg_AM, *zdeg_AM,e$
         if mr2print_AM <>   -1 & mr2print_AM > zdeg_AM, pnumligne,pgcode_AM, *zdeg2_AM,e$
         pnumligne,pgcode_AM, *prvaxec_AM ,e$
         pnumligne,pgcode_AM, *zdeg_AM,e$
         gcode$ = 1
         pnumligne,pgcode_AM,*sgfr_AM,*old_x_AM, *old_y_AM, *old_z_AM, *frbase_AM, e$
         gfr_AM = 0

pderoul_BM    # retrait de 360 deg sur axeC_BM
         cont_axe_c_BM = cont_axe_c_BM - (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BM = prvaxec_BM - (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BM = atan2(Vx_BM,Vy_BM)
   #         "axeC_BM  =", axeC_BM, e
    #     "cont_axe_c_BM=", cont_axe_c_BM, e
         axeC_BM = cont_axe_c_BM + axeC_BM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BM = mr2print_BM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BM = (deltax / old_longvec) * vectdeg
         ydeg_BM = (deltay / old_longvec) * vectdeg
         zdeg_BM = (deltaz / old_longvec) * vectdeg
         xdeg_BM = xdeg_BM + old_x_BM
         ydeg_BM = ydeg_BM + old_y_BM
         zdeg_BM = zdeg_BM + old_z_BM
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         gfr_BM = 1

         pnumligne,*sgfr_BM , *frbase_BM ,e$
         pnumligne,pgcode_BM, *xdeg_BM, *ydeg_BM, *zdeg_BM,e$
         if mr2print_BM <>   -1 & mr2print_BM > zdeg_BM, pnumligne,pgcode_BM, *zdeg2_BM,e$
         pnumligne,pgcode_BM, *prvaxec_BM ,e$
         pnumligne,pgcode_BM, *zdeg_BM,e$
         gcode$ = 1
         pnumligne,pgcode_BM,*sgfr_BM,*old_x_BM, *old_y_BM, *old_z_BM, *frbase_BM, e$
         gfr_BM = 0

pderoul_CM    # retrait de 360 deg sur axeC_CM
         cont_axe_c_CM = cont_axe_c_CM - (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CM = prvaxec_CM - (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CM = atan2(-Vy_CM,Vx_CM)
   #         "axeC_CM  =", axeC_CM, e
    #     "cont_axe_c_CM=", cont_axe_c_CM, e
         axeC_CM = cont_axe_c_CM + axeC_CM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CM = mr2print_CM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CM = (deltax / old_longvec) * vectdeg
         ydeg_CM = (deltay / old_longvec) * vectdeg
         zdeg_CM = (deltaz / old_longvec) * vectdeg
         xdeg_CM = xdeg_CM + old_x_CM
         ydeg_CM = ydeg_CM + old_y_CM
         zdeg_CM = zdeg_CM + old_z_CM
         gcode$ = 0

         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C plus",e$#, exitpost$ # abandonner
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE DEROULE", 34,")",e$
         gfr_CM = 1

         pnumligne,*sgfr_CM , *frbase_CM ,e$
         pnumligne,pgcode_CM, *xdeg_CM, *ydeg_CM, *zdeg_CM,e$
         if mr2print_CM <>   -1 & mr2print_CM > zdeg_CM, pnumligne,pgcode_CM, *zdeg2_CM,e$
         pnumligne,pgcode_CM, *prvaxec_CM ,e$
         pnumligne,pgcode_CM, *zdeg_CM,e$
         gcode$ = 1
         pnumligne,pgcode_CM,*sgfr_CM,*old_x_CM, *old_y_CM, *old_z_CM, *frbase_CM, e$
         gfr_CM = 0
#endregion
#region penroul

penroul_AG    # retrait de 360 deg sur axeC_AG
    #     "voir",*axeC_AG,e
         cont_axe_c_AG = cont_axe_c_AG + (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AG = prvaxec_AG + (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AG = atan2(Vx_AG,Vy_AG)

         axeC_AG = cont_axe_c_AG + axeC_AG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AG = mr2print_AG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AG = (deltax / old_longvec) * vectdeg
         ydeg_AG = (deltay / old_longvec) * vectdeg
         zdeg_AG = (deltaz / old_longvec) * vectdeg
         xdeg_AG = xdeg_AG + old_x_AG
         ydeg_AG = ydeg_AG + old_y_AG
         zdeg_AG = zdeg_AG + old_z_AG
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post processeur suite buttée axe C moins", e$#, exitpost$ # abandonner 
         sm,paf, "(RATRAPPAGE D ANGLE ENROULE )", e$
         gfr_AG = 1

         sm,paf,*sgfr_AG , *frbase_AG ,e$
         sr, *xdeg_AG, *ydeg_AG, *zdeg_AG, paf, pgcode_AG, *xdeg_AG, *ydeg_AG, *zdeg_AG,e$
         if mr2print_AG <>   -1 & mr2print_AG > zdeg_AG, sr, *zdeg2_AG, paf,pgcode_AG, *zdeg2_AG,e$
         sr, *prvaxec_AG, paf ,pgcode_AG, *prvaxec_AG ,"(RATRAPPAGE D ANGLE ENROULE )", e$
         sr, *zdeg_AG, paf ,pgcode_AG, *zdeg_AG,e$
         gcode$ = 1
         gfr_AG = 0
         sl, *old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, paf,pgcode_AG,*sgfr_AG,*old_x_AG, *old_y_AG, *old_z_AG, *frbase_AG, e$
       #  "voir",*axeC_AG,e   

penroul_BG    # retrait de 360 deg sur axeC_BG
    #     "voir",*axeC_BG,e
         cont_axe_c_BG = cont_axe_c_BG + (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BG = prvaxec_BG + (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BG = atan2(Vx_BG,Vy_BG)

         axeC_BG = cont_axe_c_BG + axeC_BG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BG = mr2print_BG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BG = (deltax / old_longvec) * vectdeg
         ydeg_BG = (deltay / old_longvec) * vectdeg
         zdeg_BG = (deltaz / old_longvec) * vectdeg
         xdeg_BG = xdeg_BG + old_x_BG
         ydeg_BG = ydeg_BG + old_y_BG
         zdeg_BG = zdeg_BG + old_z_BG
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         sm, paf, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         gfr_BG = 1

         sm,paf,*sgfr_BG , *frbase_BG ,e$
         sr, *xdeg_BG, *ydeg_BG, *zdeg_BG, paf, pgcode_BG, *xdeg_BG, *ydeg_BG, *zdeg_BG,e$
         if mr2print_BG <>   -1 & mr2print_BG > zdeg_BG, sr, *zdeg2_BG, paf, pgcode_BG, *zdeg2_BG,e$
         sr, *prvaxec_BG, paf ,pgcode_BG, *prvaxec_BG ,"MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         sr, *zdeg_BG, paf ,pgcode_BG, *zdeg_BG,e$
         gcode$ = 1
         gfr_BG = 0
         sl, *old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, paf,pgcode_BG,*sgfr_BG,*old_x_BG, *old_y_BG, *old_z_BG, *frbase_BG, e$
       #  "voir",*axeC_BG,e

penroul_CG    # retrait de 360 deg sur axeC_CG
    #     "voir",*axeC_CG,e
         cont_axe_c_CG = cont_axe_c_CG + (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CG = prvaxec_CG + (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CG = atan2(-Vy_CG,Vx_CG)

         axeC_CG = cont_axe_c_CG + axeC_CG
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CG = mr2print_CG
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CG = (deltax / old_longvec) * vectdeg
         ydeg_CG = (deltay / old_longvec) * vectdeg
         zdeg_CG = (deltaz / old_longvec) * vectdeg
         xdeg_CG = xdeg_CG + old_x_CG
         ydeg_CG = ydeg_CG + old_y_CG
         zdeg_CG = zdeg_CG + old_z_CG
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         sm, paf, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         gfr_CG = 1

         sm,paf,*sgfr_CG , *frbase_CG ,e$
         sr, *xdeg_CG, *ydeg_CG, *zdeg_CG, paf, pgcode_CG, *xdeg_CG, *ydeg_CG, *zdeg_CG,e$
         if mr2print_CG <>   -1 & mr2print_CG > zdeg_CG, sr, *zdeg2_CG, paf, pgcode_CG, *zdeg2_CG,e$
         sr, *prvaxec_CG, paf ,pgcode_CG, *prvaxec_CG ,"MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         sr, *zdeg_CG, paf ,pgcode_CG, *zdeg_CG,e$
         gcode$ = 1
         gfr_CG = 0
         sl, *old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, paf,pgcode_CG,*sgfr_CG,*old_x_CG, *old_y_CG, *old_z_CG, *frbase_CG, e$
       #  "voir",*axeC_CG,e    

penroul_AM    # retrait de 360 deg sur axeC_AM
    #     "voir",*axeC_AM,e
         cont_axe_c_AM = cont_axe_c_AM + (360 * nbt_AG)  # retrait de 360 deg 
         prvaxec_AM = prvaxec_AM + (360 * nbt_AG)    # retrait de 360 deg 
         axeC_AM = atan2(Vx_AM,Vy_AM)

         axeC_AM = cont_axe_c_AM + axeC_AM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_AM = mr2print_AM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_AM = (deltax / old_longvec) * vectdeg
         ydeg_AM = (deltay / old_longvec) * vectdeg
         zdeg_AM = (deltaz / old_longvec) * vectdeg
         xdeg_AM = xdeg_AM + old_x_AM
         ydeg_AM = ydeg_AM + old_y_AM
         zdeg_AM = zdeg_AM + old_z_AM
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post processeur suite buttée axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "(RATRAPPAGE D ANGLE ENROULE )", e$
         gfr_AM = 1

         pnumligne, *sgfr_AM,*frbase_AM ,e$
         pnumligne,pgcode_AM, *xdeg_AM, *ydeg_AM, *zdeg_AM, e$
         if mr2print_AM <>   -1 & mr2print_AM > zdeg_AM, pnumligne,pgcode_AM, *zdeg2_AM, e$
         pnumligne,pgcode_AM, *prvaxec_AM, e$
         pnumligne,pgcode_AM, *zdeg_AM, e$
         gcode$ = 1
         gfr_AM = 0
         pnumligne,pgcode_AM,*sgfr_AM, *old_x_AM, *old_y_AM, *old_z_AM, *frbase_AM, e$
       #  "voir",*axeC_AM,e

penroul_BM    # retrait de 360 deg sur axeC_BM
    #     "voir",*axeC_BM,e
         cont_axe_c_BM = cont_axe_c_BM + (360 * nbt_BG)  # retrait de 360 deg 
         prvaxec_BM = prvaxec_BM + (360 * nbt_BG)    # retrait de 360 deg 
         axeC_BM = atan2(Vx_BM,Vy_BM)

         axeC_BM = cont_axe_c_BM + axeC_BM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_BM = mr2print_BM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_BM = (deltax / old_longvec) * vectdeg
         ydeg_BM = (deltay / old_longvec) * vectdeg
         zdeg_BM = (deltaz / old_longvec) * vectdeg
         xdeg_BM = xdeg_BM + old_x_BM
         ydeg_BM = ydeg_BM + old_y_BM
         zdeg_BM = zdeg_BM + old_z_BM
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         gfr_BM = 1

         pnumligne, *sgfr_BM,*frbase_BM ,e$
         pnumligne,pgcode_BM, *xdeg_BM, *ydeg_BM, *zdeg_BM, e$
         if mr2print_BM <>   -1 & mr2print_BM > zdeg_BM, pnumligne,pgcode_BM, *zdeg2_BM, e$
         pnumligne,pgcode_BM, *prvaxec_BM, e$
         pnumligne,pgcode_BM, *zdeg_BM, e$
         gcode$ = 1
         gfr_BM = 0
         pnumligne,pgcode_BM,*sgfr_BM, *old_x_BM, *old_y_BM, *old_z_BM, *frbase_BM, e$
       #  "voir",*axeC_BM,e

penroul_CM    # retrait de 360 deg sur axeC_CM
    #     "voir",*axeC_CM,e
         cont_axe_c_CM = cont_axe_c_CM + (360 * nbt_CG)  # retrait de 360 deg 
         prvaxec_CM = prvaxec_CM + (360 * nbt_CG)    # retrait de 360 deg 
         axeC_CM = atan2(-Vy_CM,Vx_CM)

         axeC_CM = cont_axe_c_CM + axeC_CM
         #q2
         #q3
         #vectdeg = mr1$
         vectdeg = 1
         zdeg2_CM = mr2print_CM
         deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xdeg_CM = (deltax / old_longvec) * vectdeg
         ydeg_CM = (deltay / old_longvec) * vectdeg
         zdeg_CM = (deltaz / old_longvec) * vectdeg
         xdeg_CM = xdeg_CM + old_x_CM
         ydeg_CM = ydeg_CM + old_y_CM
         zdeg_CM = zdeg_CM + old_z_CM
         gcode$ = 0
         if subout$ <> 3, result = mprint(sderoul, 3)
         if result = 3, "MW_OP_COMMENT", "Sortie du post-processeur suite butte axe C moins", e$#, exitpost$ # abandonner 
         pnumligne, "MSG(",34,"RATRAPPAGE D ANGLE ENROULE ", 34,")", e$
         gfr_CM = 1

         pnumligne, *sgfr_CM,*frbase_CM ,e$
         pnumligne,pgcode_CM, *xdeg_CM, *ydeg_CM, *zdeg_CM, e$
         if mr2print_CM <>   -1 & mr2print_CM > zdeg_CM, pnumligne,pgcode_CM, *zdeg2_CM, e$
         pnumligne,pgcode_CM, *prvaxec_CM, e$
         pnumligne,pgcode_CM, *zdeg_CM, e$
         gcode$ = 1
         gfr_CM = 0
         pnumligne,pgcode_CM,*sgfr_CM, *old_x_CM, *old_y_CM, *old_z_CM, *frbase_CM, e$
       #  "voir",*axeC_CM,e 
#endregion
#region pdebut2

pdebut2_AG    # retour car angle trop grand ou trop petit          
         if prog_AG = 1, q19
         if prog_AG = 1, q13
          cont_axe_c_AG = 360 * trplus_AG
                axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.998, axeC_AG = 0
        axeC_AG = cont_axe_c_AG + axeC_AG
pdebut2_BG    # retour car angle trop grand ou trop petit          
         if prog_BG = 1, q20
         if prog_BG = 1, q14
          cont_axe_c_BG = 360 * trplus_BG
                axeC_BG = atan2(Vx_BG,Vy_BG)
                if abs(axeC_BG) > 359.998, axeC_BG = 0
        axeC_BG = cont_axe_c_BG + axeC_BG
pdebut2_CG    # retour car angle trop grand ou trop petit          
         if prog_CG = 1, q21
         if prog_CG = 1, q15
          cont_axe_c_CG = 360 * trplus_CG
                axeC_CG = atan2(-Vy_CG,Vx_CG)
                if abs(axeC_CG) > 359.998, axeC_CG = 0
        axeC_CG = cont_axe_c_CG + axeC_CG


pdebut2_AM    # retour car angle trop grand ou trop petit          
         if prog_AM = 1, q22
         if prog_AM = 1, q16
          cont_axe_c_AM = 360 * trplus_AM
                axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.998, axeC_AM = 0
        axeC_AM = cont_axe_c_AM + axeC_AM
pdebut2_BM    # retour car angle trop grand ou trop petit          
         if prog_BM = 1, q23
         if prog_BM = 1, q17
          cont_axe_c_BM = 360 * trplus_BM
                axeC_BM = atan2(Vx_BM,Vy_BM)
                if abs(axeC_BM) > 359.998, axeC_BM = 0
        axeC_BM = cont_axe_c_BM + axeC_BM
pdebut2_CM    # retour car angle trop grand ou trop petit          
         if prog_CM = 1, q24
         if prog_CM = 1, q18
          cont_axe_c_CM = 360 * trplus_CM
                axeC_CM = atan2(-Vy_CM,Vx_CM)
                if abs(axeC_CM) > 359.998, axeC_CM = 0
        axeC_CM = cont_axe_c_CM + axeC_CM
#endregion
#region pdebut

pdebut_AG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
          if mi1_C_base_AG = 1, trplus_AG = 1
          if mi1_C_base_AG = 2, trplus_AG = -1
          if mi1_C_base_AG = 0, trplus_AG = 0
         !trplus_AG
             cont_axe_c_AG = 360 * trplus_AG


             if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
             else, axeC_AG = atan2(Vx_AG,Vy_AG)
         if abs(axeC_AG) > 359.998, axeC_AG = 0
         reel_axeCpos_AG = axeC_AG
         axeC_AG = cont_axe_c_AG + axeC_AG

         @maxi_c_AG,@mini_c_AG
         if axeC_AG > maxi_c_AG, axeC_AG = axeC_AG - 360
         if axeC_AG < mini_c_AG, axeC_AG = axeC_AG + 360

pdebut_BG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_BG = 1, trplus_BG = 1
          if mi1_C_base_BG = 2, trplus_BG = -1
          if mi1_C_base_BG = 0, trplus_BG = 0
         !trplus_BG
             cont_axe_c_BG = 360 * trplus_BG
             if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
                 else, axeC_BG = atan2(Vx_BG,Vy_BG)

                 if abs(axeC_BG) > 359.998, axeC_BG = 0
         reel_axeCpos_BG = axeC_BG
         axeC_BG = cont_axe_c_BG + axeC_BG

         @maxi_c_BG,@mini_c_BG
         if axeC_BG > maxi_c_BG, axeC_BG = axeC_BG - 360
         if axeC_BG < mini_c_BG, axeC_BG = axeC_BG + 360

pdebut_CG     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_CG = 1, trplus_CG = 1
          if mi1_C_base_CG = 2, trplus_CG = -1
          if mi1_C_base_CG = 0, trplus_CG = 0
         !trplus_CG
             cont_axe_c_CG = 360 * trplus_CG
             if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
                 else, axeC_CG = atan2(-Vy_CG,Vx_CG)

                 if abs(axeC_CG) > 359.998, axeC_CG = 0
         reel_axeCpos_CG = axeC_CG
         axeC_CG = cont_axe_c_CG + axeC_CG

         @maxi_c_CG,@mini_c_CG
         if axeC_CG > maxi_c_CG, axeC_CG = axeC_CG - 360
         if axeC_CG < mini_c_CG, axeC_CG = axeC_CG + 360

pdebut_AM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
          if mi1_C_base_AM = 1, trplus_AM = 1
          if mi1_C_base_AM = 2, trplus_AM = -1
          if mi1_C_base_AM = 0, trplus_AM = 0
         !trplus_AM
             cont_axe_c_AM = 360 * trplus_AM


             if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
             else, axeC_AM = atan2(Vx_AM,Vy_AM)
         if abs(axeC_AM) > 359.998, axeC_AM = 0
         reel_axeCpos_AM = axeC_AM
         axeC_AM = cont_axe_c_AM + axeC_AM

         @maxi_c_AM,@mini_c_AM
         if axeC_AM > maxi_c_AM, axeC_AM = axeC_AM - 360
         if axeC_AM < mini_c_AM, axeC_AM = axeC_AM + 360

pdebut_BM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_BM = 1, trplus_BM = 1
          if mi1_C_base_BM = 2, trplus_BM = -1
          if mi1_C_base_BM = 0, trplus_BM = 0
         !trplus_BM
             cont_axe_c_BM = 360 * trplus_BM
             if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
                 else, axeC_BM = atan2(Vx_BM,Vy_BM)

                 if abs(axeC_BM) > 359.998, axeC_BM = 0
         reel_axeCpos_BM = axeC_BM
         axeC_BM = cont_axe_c_BM + axeC_BM

         @maxi_c_BM,@mini_c_BM
         if axeC_BM > maxi_c_BM, axeC_BM = axeC_BM - 360
         if axeC_BM < mini_c_BM, axeC_BM = axeC_BM + 360

pdebut_CM     # choix pour ajout de + ou - 1 tour au debut
         #Q4
         if mi1_C_base_CM = 1, trplus_CM = 1
          if mi1_C_base_CM = 2, trplus_CM = -1
          if mi1_C_base_CM = 0, trplus_CM = 0
         !trplus_CM
             cont_axe_c_CM = 360 * trplus_CM
             if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
                 else, axeC_CM = atan2(-Vy_CM,Vx_CM)

                 if abs(axeC_CM) > 359.998, axeC_CM = 0
         reel_axeCpos_CM = axeC_CM
         axeC_CM = cont_axe_c_CM + axeC_CM

         @maxi_c_CM,@mini_c_CM
         if axeC_CM > maxi_c_CM, axeC_CM = axeC_CM - 360
         if axeC_CM < mini_c_CM, axeC_CM = axeC_CM + 360
#endregion
#region ptest_axec

ptest_axec_AG   # routine pour savoir les axes 
             axeC_AG = atan2(Vx_AG,Vy_AG)
            "voir solution 1 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vx_AG,Vy_AG)
            "voir solution 2 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vx_AG,-Vy_AG)
            "voir solution 3 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vx_AG,-Vy_AG)
            "voir solution 4 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vy_AG,Vx_AG)
            "voir solution 5 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vy_AG,Vx_AG)
            "voir solution 6 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(Vy_AG,-Vx_AG)
            "voir solution 7 pour C dans pmxinvg=", *axeC_AG, e$
            axeC_AG = atan2(-Vy_AG,-Vx_AG)
            "voir solution 8 pour C dans pmxinvg=", *axeC_AG, e$

ptest_axec_AM   # routine pour savoir les axes 
             axeC_AM = atan2(Vx_AM,Vy_AM)
            "voir solution 1 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vx_AM,Vy_AM)
            "voir solution 2 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vx_AM,-Vy_AM)
            "voir solution 3 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vx_AM,-Vy_AM)
            "voir solution 4 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vy_AM,Vx_AM)
            "voir solution 5 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vy_AM,Vx_AM)
            "voir solution 6 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(Vy_AM,-Vx_AM)
            "voir solution 7 pour C dans pmxinvg=", *axeC_AM, e$
            axeC_AM = atan2(-Vy_AM,-Vx_AM)
            "voir solution 8 pour C dans pmxinvg=", *axeC_AM, e$
#endregion
#region pmxinvd

pmxinvd_AG   # ecriture de axes A positif 
            #"on est dans  pmxinvd_AG", e$    
           Vx_AG = ucal - xcal
           Vy_AG = ycal - vcal
           Vz_AG = wcal - zcal
           vertical_z = z$ - w$
           !vertical_z
           #"Voir ", vertical_z ,e$ 
          # "voir ", *Vx_AG, *Vy_AG, *Vz_AG, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
           if tete_rev_AG = 1 & ((Vx_AG = 0 & Vy_AG = 0) | vertical_z = 0 ),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc.
                [
                # "on y est", e$        
                axeA_AG = 0
                Vx_AG = x$ - u$
                Vy_AG = v$ - y$
                axeC_AG = atan2(Vx_AG,Vy_AG)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AG) < cone_mini & abs(Vy_AG) < cone_mini & tete_rev_AG = 0, Vx_AG = 0, Vy_AG = 0
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)
                if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
                else, axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.999, axeC_AG = 0
                reel_axeCpos_AG = axeC_AG
                if longvec = 0, longvec = 1
                axeA_AG = acos(Vz_AG / longvec)
                ]

           invers_AG = 0
           deja_AG = 1

pmxinvd_BG   # ecriture de axes A positif      
             Vx_BG = ucal - xcal
             Vy_BG = ycal - vcal
             Vz_BG = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_BG = 1 & ((Vx_BG = 0 & Vy_BG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BG = 0
            Vx_BG = x$ - u$
            Vy_BG = v$ - y$
            axeC_BG = atan2(Vx_BG,Vy_BG)
            #"voir C pmxinvd_BG", *axeC_BG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
           if abs(Vx_BG) < cone_mini & abs(Vy_BG) < cone_mini, Vx_BG = 0, Vy_BG = 0
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
       @Vx_BG,@Vy_BG,@Vz_BG
       longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)
       if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
           else, axeC_BG = atan2(Vx_BG,Vy_BG)

           if abs(axeC_BG) > 359.999, axeC_BG = 0

           reel_axeCpos_BG = axeC_BG
           if longvec = 0, longvec = 1
           axeA_BG = acos(Vz_BG / longvec)
           ]
           invers_BG = 0
           deja_BG = 1

pmxinvd_CG   # ecriture de axes A positif      
             Vx_CG = ucal - xcal
             Vy_CG = ycal - vcal
             Vz_CG = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_CG = 1 & ((Vx_CG = 0 & Vy_CG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CG = 0
            Vx_CG = x$ - u$
            Vy_CG = v$ - y$
            axeC_CG = atan2(-Vy_CG,Vx_CG)
            #"voir C pmxinvd_CG", *axeC_CG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
           if abs(Vx_CG) < cone_mini & abs(Vy_CG) < cone_mini, Vx_CG = 0, Vy_CG = 0
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
       @Vx_CG,@Vy_CG,@Vz_CG
       longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)
       if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
           else, axeC_CG = atan2(-Vy_CG,Vx_CG)

           if abs(axeC_CG) > 359.999, axeC_CG = 0

           reel_axeCpos_CG = axeC_CG
           if longvec = 0, longvec = 1
           axeA_CG = acos(Vz_CG / longvec)
           ]
           invers_CG = 0
           deja_CG = 1

pmxinvd_AM   # ecriture de axes A positif 
            #"on est dans  pmxinvd_AM", e$    
           Vx_AM = ucal - xcal
           Vy_AM = ycal - vcal
           Vz_AM = wcal - zcal
           vertical_z = z$ - w$
           !vertical_z
           #"Voir ", vertical_z ,e$ 
          # "voir ", *Vx_AM, *Vy_AM, *Vz_AM, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
           if tete_rev_AM = 1 & ((Vx_AM = 0 & Vy_AM = 0) | vertical_z = 0 ),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc.
                [
                # "on y est", e$        
                axeA_AM = 0
                Vx_AM = x$ - u$
                Vy_AM = v$ - y$
                axeC_AM = atan2(Vx_AM,Vy_AM)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AM) < cone_mini & abs(Vy_AM) < cone_mini & tete_rev_AM = 0, Vx_AM = 0, Vy_AM = 0
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)
                if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
                else, axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.999, axeC_AM = 0
                reel_axeCpos_AM = axeC_AM
                if longvec = 0, longvec = 1
                axeA_AM = acos(Vz_AM / longvec)
                ]

           invers_AM = 0
           deja_AM = 1

pmxinvd_BM   # ecriture de axes A positif      
             Vx_BM = ucal - xcal
             Vy_BM = ycal - vcal
             Vz_BM = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_BM = 1 & ((Vx_BM = 0 & Vy_BM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BM = 0
            Vx_BM = x$ - u$
            Vy_BM = v$ - y$
            axeC_BM = atan2(Vx_BM,Vy_BM)
            #"voir C pmxinvd_BM", *axeC_BM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
           if abs(Vx_BM) < cone_mini & abs(Vy_BM) < cone_mini, Vx_BM = 0, Vy_BM = 0
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
       @Vx_BM,@Vy_BM,@Vz_BM
       longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)
       if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
           else, axeC_BM = atan2(Vx_BM,Vy_BM)

           if abs(axeC_BM) > 359.999, axeC_BM = 0

           reel_axeCpos_BM = axeC_BM
           if longvec = 0, longvec = 1
           axeA_BM = acos(Vz_BM / longvec)
           ]
           invers_BM = 0
           deja_BM = 1

pmxinvd_CM   # ecriture de axes A positif      
             Vx_CM = ucal - xcal
             Vy_CM = ycal - vcal
             Vz_CM = wcal - zcal
             vertical_z = z$ - w$
            !vertical_z
            if tete_rev_CM = 1 & ((Vx_CM = 0 & Vy_CM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CM = 0
            Vx_CM = x$ - u$
            Vy_CM = v$ - y$
            axeC_CM = atan2(-Vy_CM,Vx_CM)
            #"voir C pmxinvd_CM", *axeC_CM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
           if abs(Vx_CM) < cone_mini & abs(Vy_CM) < cone_mini, Vx_CM = 0, Vy_CM = 0
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
       @Vx_CM,@Vy_CM,@Vz_CM
       longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)
       if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
           else, axeC_CM = atan2(-Vy_CM,Vx_CM)

           if abs(axeC_CM) > 359.999, axeC_CM = 0

           reel_axeCpos_CM = axeC_CM
           if longvec = 0, longvec = 1
           axeA_CM = acos(Vz_CM / longvec)
           ]
           invers_CM = 0
           deja_CM = 1
#endregion
#region pmxinvg

pmxinvg_AG   # ecriture de axes A negatif    
            #"on est dans  pmxinvg_AG", e$  
            Vx_AG = xcal - ucal
            Vy_AG = vcal - ycal
            Vz_AG = wcal - zcal
            vertical_z = z$ - w$
            !vertical_z
           # "Voir ", vertical_z ,e$ 
           # "voir ", *Vx_AG, *Vy_AG, *Vz_AG, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
            if tete_rev_AG = 1 & ((Vx_AG = 0 & Vy_AG = 0) | vertical_z = 0),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc..
                [
                # "on y est aussi", e$      
                axeA_AG = 0
                Vx_AG = u$ - x$
                Vy_AG = y$ - v$
                axeC_AG = atan2(Vx_AG,Vy_AG)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AG) < cone_mini & abs(Vy_AG) < cone_mini & tete_rev_AG = 0, Vx_AG = 0, Vy_AG = 0
                @Vx_AG,@Vy_AG,@Vz_AG
                longvec=sqrt(Vx_AG * Vx_AG + Vy_AG * Vy_AG + Vz_AG * Vz_AG)
                if Vx_AG = 0 & Vy_AG = 0, axeC_AG = prvaxec_AG
                else, axeC_AG = atan2(Vx_AG,Vy_AG)
                if abs(axeC_AG) > 359.999, axeC_AG = 0
                reel_axeCpos_AG = axeC_AG
                if longvec = 0, longvec = 1
                axeA_AG = acos(Vz_AG / longvec) *   -1
                ]

            invers_AG = 1
            deja_AG = 1

pmxinvg_BG   # ecriture de axes A negatif    
            Vx_BG = xcal - ucal
            Vy_BG = vcal - ycal
            Vz_BG = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_BG = 1 & ((Vx_BG = 0 & Vy_BG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BG = 0
            Vx_BG = u$ - x$
            Vy_BG = y$ - v$
            axeC_BG = atan2(Vx_BG,Vy_BG)
            #"voir C dans pmxinvg_BG", *axeC_BG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
           if abs(Vx_BG) < cone_mini & abs(Vy_BG) < cone_mini, Vx_BG = 0, Vy_BG = 0
          # "--------------------voirvxvyvz",*Vx_BG,*Vy_BG,*Vz_BG, e$
            @Vx_BG,@Vy_BG,@Vz_BG
            longvec=sqrt(Vx_BG * Vx_BG + Vy_BG * Vy_BG + Vz_BG * Vz_BG)
            if Vx_BG = 0 & Vy_BG = 0, axeC_BG = prvaxec_BG
            else, axeC_BG = atan2(Vx_BG,Vy_BG)

            if abs(axeC_BG) > 359.999, axeC_BG = 0

            reel_axeCpos_BG = axeC_BG
            if longvec = 0, longvec = 1
            axeA_BG = acos(Vz_BG / longvec) *   -1
            ]
            invers_BG = 1
            deja_BG = 1

pmxinvg_CG   # ecriture de axes A negatif    
            Vx_CG = xcal - ucal
            Vy_CG = vcal - ycal
            Vz_CG = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_CG = 1 & ((Vx_CG = 0 & Vy_CG = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CG = 0
            Vx_CG = u$ - x$
            Vy_CG = y$ - v$
            axeC_CG = atan2(-Vy_CG,Vx_CG)
            #"voir C dans pmxinvg_CG", *axeC_CG, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
           if abs(Vx_CG) < cone_mini & abs(Vy_CG) < cone_mini, Vx_CG = 0, Vy_CG = 0
          # "--------------------voirvxvyvz",*Vx_CG,*Vy_CG,*Vz_CG, e$
            @Vx_CG,@Vy_CG,@Vz_CG
            longvec=sqrt(Vx_CG * Vx_CG + Vy_CG * Vy_CG + Vz_CG * Vz_CG)
            if Vx_CG = 0 & Vy_CG = 0, axeC_CG = prvaxec_CG
            else, axeC_CG = atan2(-Vy_CG,Vx_CG)

            if abs(axeC_CG) > 359.999, axeC_CG = 0

            reel_axeCpos_CG = axeC_CG
            if longvec = 0, longvec = 1
            axeA_CG = acos(Vz_CG / longvec) *   -1
            ]
            invers_CG = 1
            deja_CG = 1

pmxinvg_AM   # ecriture de axes A negatif    
            #"on est dans  pmxinvg_AM", e$  
            Vx_AM = xcal - ucal
            Vy_AM = vcal - ycal
            Vz_AM = wcal - zcal
            vertical_z = z$ - w$
            !vertical_z
           # "Voir ", vertical_z ,e$ 
           # "voir ", *Vx_AM, *Vy_AM, *Vz_AM, e$
           #"voir ", *x$,*y$,*z$,*u$,*v$,*w$, e$ 
            if tete_rev_AM = 1 & ((Vx_AM = 0 & Vy_AM = 0) | vertical_z = 0),  # nous sommes dans le cas ou axe outil horizontal, exemple usine face cote devant, etc..
                [
                # "on y est aussi", e$      
                axeA_AM = 0
                Vx_AM = u$ - x$
                Vy_AM = y$ - v$
                axeC_AM = atan2(Vx_AM,Vy_AM)
                ]
            else,
                [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
                if abs(Vx_AM) < cone_mini & abs(Vy_AM) < cone_mini & tete_rev_AM = 0, Vx_AM = 0, Vy_AM = 0
                @Vx_AM,@Vy_AM,@Vz_AM
                longvec=sqrt(Vx_AM * Vx_AM + Vy_AM * Vy_AM + Vz_AM * Vz_AM)
                if Vx_AM = 0 & Vy_AM = 0, axeC_AM = prvaxec_AM
                else, axeC_AM = atan2(Vx_AM,Vy_AM)
                if abs(axeC_AM) > 359.999, axeC_AM = 0
                reel_axeCpos_AM = axeC_AM
                if longvec = 0, longvec = 1
                axeA_AM = acos(Vz_AM / longvec) *   -1
                ]

            invers_AM = 1
            deja_AM = 1

pmxinvg_BM   # ecriture de axes A negatif    
            Vx_BM = xcal - ucal
            Vy_BM = vcal - ycal
            Vz_BM = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_BM = 1 & ((Vx_BM = 0 & Vy_BM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_BM = 0
            Vx_BM = u$ - x$
            Vy_BM = y$ - v$
            axeC_BM = atan2(Vx_BM,Vy_BM)
            #"voir C dans pmxinvg_BM", *axeC_BM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
           if abs(Vx_BM) < cone_mini & abs(Vy_BM) < cone_mini, Vx_BM = 0, Vy_BM = 0
          # "--------------------voirvxvyvz",*Vx_BM,*Vy_BM,*Vz_BM, e$
            @Vx_BM,@Vy_BM,@Vz_BM
            longvec=sqrt(Vx_BM * Vx_BM + Vy_BM * Vy_BM + Vz_BM * Vz_BM)
            if Vx_BM = 0 & Vy_BM = 0, axeC_BM = prvaxec_BM
            else, axeC_BM = atan2(Vx_BM,Vy_BM)

            if abs(axeC_BM) > 359.999, axeC_BM = 0

            reel_axeCpos_BM = axeC_BM
            if longvec = 0, longvec = 1
            axeA_BM = acos(Vz_BM / longvec) *   -1
            ]
            invers_BM = 1
            deja_BM = 1

pmxinvg_CM   # ecriture de axes A negatif    
            Vx_CM = xcal - ucal
            Vy_CM = vcal - ycal
            Vz_CM = wcal - zcal
            vertical_z = z$ - w$
           !vertical_z
            if tete_rev_CM = 1 & ((Vx_CM = 0 & Vy_CM = 0) | vertical_z) = 0 ,
            [
            #"c'est la cas", e$ 
            axeA_CM = 0
            Vx_CM = u$ - x$
            Vy_CM = y$ - v$
            axeC_CM = atan2(-Vy_CM,Vx_CM)
            #"voir C dans pmxinvg_CM", *axeC_CM, e$ 
            ]
            else, [
                if mi3$ > 0, cone_mini = mi3$ * 0.001
           #"--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
           if abs(Vx_CM) < cone_mini & abs(Vy_CM) < cone_mini, Vx_CM = 0, Vy_CM = 0
          # "--------------------voirvxvyvz",*Vx_CM,*Vy_CM,*Vz_CM, e$
            @Vx_CM,@Vy_CM,@Vz_CM
            longvec=sqrt(Vx_CM * Vx_CM + Vy_CM * Vy_CM + Vz_CM * Vz_CM)
            if Vx_CM = 0 & Vy_CM = 0, axeC_CM = prvaxec_CM
            else, axeC_CM = atan2(-Vy_CM,Vx_CM)

            if abs(axeC_CM) > 359.999, axeC_CM = 0

            reel_axeCpos_CM = axeC_CM
            if longvec = 0, longvec = 1
            axeA_CM = acos(Vz_CM / longvec) *   -1
            ]
            invers_CM = 1
            deja_CM = 1
#endregion
#region pmxinvgd

pmxinvgd_AG   # droite ou gauche
        #"voir",*invers_AG ,e
        if invers_AG = 0, pmxinvg_AG
             else, pmxinvd_AG
pmxinvgd_BG   # droite ou gauche
        #"voir",*invers_BG ,e
        if invers_BG = 0, pmxinvg_BG
             else, pmxinvd_BG
pmxinvgd_CG   # droite ou gauche
        #"voir",*invers_CG ,e
        if invers_CG = 0, pmxinvg_CG
             else, pmxinvd_CG

pmxinvgd_AM   # droite ou gauche
        #"voir",*invers_AM ,e
        if invers_AM = 0, pmxinvg_AM
             else, pmxinvd_AM
pmxinvgd_BM   # droite ou gauche
        #"voir",*invers_BM ,e
        if invers_BM = 0, pmxinvg_BM
             else, pmxinvd_BM
pmxinvgd_CM   # droite ou gauche
        #"voir",*invers_CM ,e
        if invers_CM = 0, pmxinvg_CM
             else, pmxinvd_CM
#endregion
#region pmxsens

pmxsens_AG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_AG,*Vx_AG," et ",*old_vy_AG,*Vy_AG  ,e
        if Vx_AG >=   -0.002& Vx_AG <= 0.002, Vx_AG = 0
        if Vy_AG >=   -0.002& Vy_AG <= 0.002, Vy_AG = 0

        deja_AG = 0
		if axeA_AG <> 0 | axeC_AG <> 0,	[
        if deja_AG = 0 & old_vx_AG <= 0 & Vx_AG > 0 & old_vy_AG = 0 & Vy_AG = 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG >= 0 & Vx_AG < 0 & old_vy_AG = 0 & Vy_AG = 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG = 0 & Vx_AG = 0 & old_vy_AG >= 0 & Vy_AG < 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG = 0 & Vx_AG = 0 & old_vy_AG <= 0 & Vy_AG > 0 , pmxinvgd_AG

        if deja_AG = 0 & old_vx_AG < 0 & Vx_AG > 0 & old_vy_AG < 0 & Vy_AG > 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG > 0 & Vx_AG < 0 & old_vy_AG > 0 & Vy_AG < 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG <= 0 & Vx_AG >= 0 & old_vy_AG >= 0 & Vy_AG <= 0 , pmxinvgd_AG
        if deja_AG = 0 & old_vx_AG >= 0 & Vx_AG <= 0 & old_vy_AG <= 0 & Vy_AG >= 0 , pmxinvgd_AG
		]
        deja_AG = 0


pmxsens_BG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_BG,*Vx_BG," et ",*old_vy_BG,*Vy_BG  ,e
        if Vx_BG >=   -0.002&Vx_BG <= 0.002, Vx_BG = 0
        if Vy_BG >=   -0.002&Vy_BG <= 0.002, Vy_BG = 0

        deja_BG = 0
		if axeA_BG <> 0 | axeC_BG <> 0,	[
        if deja_BG = 0 & old_vx_BG <= 0 & Vx_BG > 0 & old_vy_BG = 0 & Vy_BG = 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG >= 0 & Vx_BG < 0 & old_vy_BG = 0 & Vy_BG = 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG = 0 & Vx_BG = 0 & old_vy_BG >= 0 & Vy_BG < 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG = 0 & Vx_BG = 0 & old_vy_BG <= 0 & Vy_BG > 0 , pmxinvgd_BG

        if deja_BG = 0 & old_vx_BG < 0 & Vx_BG > 0 & old_vy_BG < 0 & Vy_BG > 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG > 0 & Vx_BG < 0 & old_vy_BG > 0 & Vy_BG < 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG <= 0 & Vx_BG >= 0 & old_vy_BG >= 0 & Vy_BG <= 0 , pmxinvgd_BG
        if deja_BG = 0 & old_vx_BG >= 0 & Vx_BG <= 0 & old_vy_BG <= 0 & Vy_BG >= 0 , pmxinvgd_BG
		]
        deja_BG = 0


pmxsens_CG    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_CG,*Vx_CG," et ",*old_vy_CG,*Vy_CG  ,e
        if Vx_CG >=   -0.002&Vx_CG <= 0.002, Vx_CG = 0
        if Vy_CG >=   -0.002&Vy_CG <= 0.002, Vy_CG = 0

        deja_CG = 0
		if axeA_CG <> 0 | axeC_CG <> 0,	[
        if deja_CG = 0 & old_vx_CG <= 0 & Vx_CG > 0 & old_vy_CG = 0 & Vy_CG = 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG >= 0 & Vx_CG < 0 & old_vy_CG = 0 & Vy_CG = 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG = 0 & Vx_CG = 0 & old_vy_CG >= 0 & Vy_CG < 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG = 0 & Vx_CG = 0 & old_vy_CG <= 0 & Vy_CG > 0 , pmxinvgd_CG

        if deja_CG = 0 & old_vx_CG < 0 & Vx_CG > 0 & old_vy_CG < 0 & Vy_CG > 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG > 0 & Vx_CG < 0 & old_vy_CG > 0 & Vy_CG < 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG <= 0 & Vx_CG >= 0 & old_vy_CG >= 0 & Vy_CG <= 0 , pmxinvgd_CG
        if deja_CG = 0 & old_vx_CG >= 0 & Vx_CG <= 0 & old_vy_CG <= 0 & Vy_CG >= 0 , pmxinvgd_CG
        ]
        deja_CG = 0

pmxsens_AM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_AM,*Vx_AM," et ",*old_vy_AM,*Vy_AM  ,e
        if Vx_AM >=   -0.002&Vx_AM <= 0.002, Vx_AM = 0
        if Vy_AM >=   -0.002&Vy_AM <= 0.002, Vy_AM = 0

        deja_AM = 0
		if axeA_AM <> 0 | axeC_AM <> 0,	[
        if deja_AM = 0 & old_vx_AM <= 0 & Vx_AM > 0 & old_vy_AM = 0 & Vy_AM = 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM >= 0 & Vx_AM < 0 & old_vy_AM = 0 & Vy_AM = 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM = 0 & Vx_AM = 0 & old_vy_AM >= 0 & Vy_AM < 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM = 0 & Vx_AM = 0 & old_vy_AM <= 0 & Vy_AM > 0 , pmxinvgd_AM

        if deja_AM = 0 & old_vx_AM < 0 & Vx_AM > 0 & old_vy_AM < 0 & Vy_AM > 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM > 0 & Vx_AM < 0 & old_vy_AM > 0 & Vy_AM < 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM <= 0 & Vx_AM >= 0 & old_vy_AM >= 0 & Vy_AM <= 0 , pmxinvgd_AM
        if deja_AM = 0 & old_vx_AM >= 0 & Vx_AM <= 0 & old_vy_AM <= 0 & Vy_AM >= 0 , pmxinvgd_AM
        ]
        deja_AM = 0


pmxsens_BM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_BM,*Vx_BM," et ",*old_vy_BM,*Vy_BM  ,e
        if Vx_BM >=   -0.002&Vx_BM <= 0.002, Vx_BM = 0
        if Vy_BM >=   -0.002&Vy_BM <= 0.002, Vy_BM = 0

        deja_BM = 0
		if axeA_BM <> 0 | axeC_BM <> 0,	[
        if deja_BM = 0 & old_vx_BM <= 0 & Vx_BM > 0 & old_vy_BM = 0 & Vy_BM = 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM >= 0 & Vx_BM < 0 & old_vy_BM = 0 & Vy_BM = 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM = 0 & Vx_BM = 0 & old_vy_BM >= 0 & Vy_BM < 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM = 0 & Vx_BM = 0 & old_vy_BM <= 0 & Vy_BM > 0 , pmxinvgd_BM

        if deja_BM = 0 & old_vx_BM < 0 & Vx_BM > 0 & old_vy_BM < 0 & Vy_BM > 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM > 0 & Vx_BM < 0 & old_vy_BM > 0 & Vy_BM < 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM <= 0 & Vx_BM >= 0 & old_vy_BM >= 0 & Vy_BM <= 0 , pmxinvgd_BM
        if deja_BM = 0 & old_vx_BM >= 0 & Vx_BM <= 0 & old_vy_BM <= 0 & Vy_BM >= 0 , pmxinvgd_BM
        ]
        deja_BM = 0


pmxsens_CM    # maintien de axes c quand a passe en negatif 
        #"--------",*old_vx_CM,*Vx_CM," et ",*old_vy_CM,*Vy_CM  ,e
        if Vx_CM >=   -0.002&Vx_CM <= 0.002, Vx_CM = 0
        if Vy_CM >=   -0.002&Vy_CM <= 0.002, Vy_CM = 0

        deja_CM = 0
		if axeA_CM <> 0 | axeC_CM <> 0,	[
        if deja_CM = 0 & old_vx_CM <= 0 & Vx_CM > 0 & old_vy_CM = 0 & Vy_CM = 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM >= 0 & Vx_CM < 0 & old_vy_CM = 0 & Vy_CM = 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM = 0 & Vx_CM = 0 & old_vy_CM >= 0 & Vy_CM < 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM = 0 & Vx_CM = 0 & old_vy_CM <= 0 & Vy_CM > 0 , pmxinvgd_CM

        if deja_CM = 0 & old_vx_CM < 0 & Vx_CM > 0 & old_vy_CM < 0 & Vy_CM > 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM > 0 & Vx_CM < 0 & old_vy_CM > 0 & Vy_CM < 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM <= 0 & Vx_CM >= 0 & old_vy_CM >= 0 & Vy_CM <= 0 , pmxinvgd_CM
        if deja_CM = 0 & old_vx_CM >= 0 & Vx_CM <= 0 & old_vy_CM <= 0 & Vy_CM >= 0 , pmxinvgd_CM
        ]
        deja_CM = 0
#endregion
#region pvariok

pvariok_AG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_BG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_CG   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_AM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_BM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53

pvariok_CM   #  ecriture de E5300xx

        deltax = ucal - xcal
         deltay = vcal - ycal
         deltaz = wcal - zcal
         #"voir",*deltax,*deltay,*deltaz,*old_longvec , e

         xcor = (deltax / old_longvec) * vale53
         ycor = (deltay / old_longvec) * vale53
         zcor = (deltaz / old_longvec) * vale53
#endregion
#region pvarioutil
fmt "demi periode" 1 moit_per
#fmt "pasn" 1 pasn
#fmt "moitier de periode" 1 moit_per
fmt "pas de base" 1 pas_base
fmt "val_pas" 1 val_pas
fmt "sens du pas" 1 sens_pas
fmt "dbut de variation" 1 debutvar
fmt "" 3 vale53abs

pvarioutil_AG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_AG
         pasn = 1 + pasn

pvarioutil_BG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_BG
         pasn = 1 + pasn

pvarioutil_CG   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_CG
         pasn = 1 + pasn

pvarioutil_AM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_AM
         pasn = 1 + pasn

pvarioutil_BM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_BM
         pasn = 1 + pasn

pvarioutil_CM   # application d'une correction de longeur
            # mi7$ = 0 pas de var, 1 sinus, 2 dent
            # Mr6 = hauteur du pas
            # mi6 = frequance en nb de point block
          if mi7$ = 0 | mr6$ = 0, mi6$ = 0

          #"voir","pasmi7=",*pasmi7,"pasn=",*pasn,"val53=",*vale53,e

         if mi7$ = 1,vale53 = (1-cos((2*3.14159)*(pasn/mi6$)*(180/3.14159)))*(mr6$)*  -0.5
         if mi7$ = 2,
         [
            moit_per = mi6$/2
            val_pas = (abs(mr6$))/moit_per
            vale53abs = vale53abs + ( val_pas * sens_pas )
            if vale53abs > 0,
            [
             sens_pas = -1
             vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
            if vale53abs < ( (abs(mr6$)) * -1),
            [
            sens_pas = 1
            vale53abs = vale53abs + ( 2 * val_pas * sens_pas )
            ]
         if debutvar = 0, vale53abs = 0
         debutvar = 1
         if mr6$ >= 0, vale53 = vale53abs
         if mr6$ < 0,  vale53 = vale53abs * -1
         ]

         pvariok_CM
         pasn = 1 + pasn
#endregion
#region pmx
pmx$
            pchange_AG
            pmx_AG

            pchange_AM
            pmx_AM

            pchange_BG
            pmx_BG

            pchange_BM
            pmx_BM

            pchange_CG
            pmx_CG

            pchange_CM
            pmx_CM

pmx_AG        # 5 axes

            pprint_AG
            @xprint_AG, @yprint_AG,@zprint_AG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                pchange_AM
                pmx_AM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_AG = 0
		Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AG < 0, invers_AG = 1
														else, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AG < 0, invers_AG = 0
														else, invers_AG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
            if invers_AG = 0, pmxinvd_AG
            if invers_AG = 1, pmxinvg_AG
			
             if debut_AG = 1, pmxsens_AG
             !maxi_c_AG, !mini_c_AG

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_AG
           Dy = ycal - old_y_AG
           Dz = zcal - old_z_AG
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)

            if fr$ =   -1,fr$= frbase_AG
            if fr$ > 0, frbase_AG = fr$

            if deltaXYZ < mr5$ & debut_AG = 1, pchange_AM, pmx_AM   # modif du 30/10/02
            else,
                [
                if fr$ > 0 & deltaXYZ <> 0,fr5axe_AG = fr$ / deltaXYZ
                ]

            if debut_AG = 0 & changop_AG <> 0, cont_axe_c_AG = 0
            if debut_AG = 0 & changop_AG <> 0, prvaxec_AG = axeC_AG


        #"Voir cont_axe_c_AG=", *cont_axe_c_AG, e$

         axeC_AG = cont_axe_c_AG + axeC_AG       # cumul du compteur avec c   

         dif_axe_c = axeC_AG - prvaxec_AG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)

         if absdif > 180,  pcont_AG         # ajout + - 360
		 dif_axe_c2 = axeC_AG - prvaxec_AG
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_AG
		 
		 		 
        if axeC_AG > maxi_c_AG & debut_AG <> 0, pderoul_AG
        if axeC_AG < mini_c_AG & debut_AG <> 0, penroul_AG

        if debut_AG = 0,
                [
                if axeC_AG >= (360+mini_c_AG) & changop_AG <> 0, pdebut_AG
                if axeC_AG <= (maxi_c_AG - 360) & changop_AG <> 0, pdebut_AG
                #if debut = 0, n, pgcode_force_AG, *axeC_AG, *axeA_AG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
                gcode$ = 0
                sm, paf, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
				if flag_outil_AG <> 1, prtcp_simu_AG
				
                if mr2print_AG <>   -1,
                            [
                             #"voir operation_AG", *operation_AG,e
                            if operation_AG = 1 ,   [
                                                    if flag_cloche_AG = 1, sr, *mr2print_AG, sazero, sczero, paf,pgcode_force_AG, *mr2$, sm, sxcloche_AG, sycloche_AG, e$, flag_cloche_AG = 0
                                                    else, sr, *mr2print_AG, paf, pgcode_force_AG, *mr2$,e$
                                                    ]
                            if changop_AG = 1, sr, *xprint_AG, *yprint_AG,*mr2print_AG,*axeC_AG, *axeA_AG, paf,pgcode_force_AG, *xprint_AG, *yprint_AG,*axeC_AG, *axeA_AG, e$, sr, *xprint_AG, *yprint_AG,*zprint_AG,paf,*zprint_AG,e$


                            else, sr, *xprint_AG, *yprint_AG, *zprint_AG,*axeC_AG, *axeA_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,*axeC_AG, *axeA_AG,e$
                            ]
                 else,
                            [
                            sr, *xprint_AG, *yprint_AG,*zprint_AG, *axeC_AG, *axeA_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG,*zprint_AG, *axeC_AG, *axeA_AG,e$
                            ]

                pasmi7 = 0
                pasn = 0
                vale53 = 0
                ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_AG = 1
        if deltaXYZ < mr5$ , fr5axe_AG = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53_AG,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_AG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_AG
          old_x_AG = xcal
          old_y_AG = ycal
          old_z_AG = zcal
         xprint_AG = xcor + xprint_AG
         yprint_AG = ycor + yprint_AG
         zprint_AG = zcor + zprint_AG
         if (xnci$ = 0) & (ynci$ = 0) & (znci$ = 0) & (u$ = 0) & (v$ = 0) & (w$ = 0), psortie11_AG
         if axeA_AG > maxi_a_AG | axeA_AG < mini_a_AG, psortie10_AG
         if gcode$ = 1 ,
                [
                if tete_rev_AG = 1,
                    [
                    gfr_AG = 1
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG, *axeA_AG ,pfr_AG, paf, sgfr_AG, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG,*axeA_AG ,pfr_AG, e$
                    ]
                else,
                    [
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG, *axeA_AG, *fr5axe_AG, paf, sgfr_AG, *fr5axe_AG, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG, *axeA_AG, pg9_5x_AG, e$
                    ]
                 ]
        else, sr, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG, *axeA_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, *axeC_AG, *axeA_AG,e$

        debut_AG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_AG = Vx_AG
           old_vy_AG = Vy_AG
           old_vz_AG = Vz_AG
       old_longvec = longvec
       prvaxec_AG = axeC_AG
       prvaxea = axeA_AG
       operation_AG = 11
       old_x_5x_AG = x$
       old_y_5x_AG = y$
       old_z_5x_AG = z$
	old_axeC_simu_AG = axeC_AG
	old_axeA_simu_AG = axeA_AG
	old_xprint_simu_AG = xprint_AG
	old_yprint_simu_AG = yprint_AG
	old_zprint_simu_AG = zprint_AG

        old_opcode_AG = opcode$
pmx_BG        # 5 axes

            pprint_BG
            @xprint_BG, @yprint_BG,@zprint_BG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_BM
                pmx_BM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_BG = 0
			Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BG < 0, invers_BG = 1
														else, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BG < 0, invers_BG = 0
														else, invers_BG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
            if invers_BG = 0, pmxinvd_BG
            if invers_BG = 1, pmxinvg_BG
         #"voir dans pmx",*axeC_BG,e 

             if debut_BG = 1, pmxsens_BG
         !maxi_c_BG, !mini_c_BG


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_BG
           Dy = ycal - old_y_BG
           Dz = zcal - old_z_BG

           #"voir x,y,z,old_x_BG,old_y_BG,old_z_BG",*x,*y,*z,*old_x_BG,*old_y_BG,*old_z_BG,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_BG
         if fr$ > 0, frbase_BG = fr$

         if deltaXYZ < mr5$ & debut_BG = 1, pchange_BM, pmx_BM   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe_BG = fr$ / deltaXYZ
        ]




            if debut_BG = 0 & changop_BG <> 0, cont_axe_c_BG = 0
            if debut_BG = 0 & changop_BG <> 0, prvaxec_BG = axeC_BG



         axeC_BG = cont_axe_c_BG + axeC_BG       # cumul du compteur avec c   

         dif_axe_c = axeC_BG - prvaxec_BG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_BG         # ajout + - 360
 		 dif_axe_c2 = axeC_BG - prvaxec_BG
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_BG


        if axeC_BG > maxi_c_BG & debut_BG <> 0, pderoul_BG
        if axeC_BG < mini_c_BG & debut_BG <> 0, penroul_BG
        if debut_BG = 0,
        [

        if axeC_BG >= (360+mini_c_BG) & changop_BG <> 0, pdebut_BG

        if axeC_BG <= (maxi_c_BG - 360) & changop_BG <> 0, pdebut_BG

        #if debut = 0, n, pgcode_force_BG, *axeC_BG, *axeA_BG,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             sm, paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm, paf, "AROT", axeCpos_BG, axeApos_BG, e$
             
			 if flag_outil_BG <> 1, prtcp_simu_BG
			 
             if mr2print_BG <>   -1,
            [
            #"voir operation_BG", *operation_BG,e
            if operation_BG = 1 ,   [
                                    if flag_cloche_BG = 1, sr, *mr2print_BG, sazero, sczero, paf, pgcode_force_BG, *mr2$,sm, sxcloche_BG, sycloche_BG,e$, flag_cloche_BG = 0
                                    else, sr, *mr2print_BG, paf, pgcode_force_BG, *mr2$,e$
                                    ]
            if changop_BG = 1, sr, *xprint_BG, *yprint_BG,*mr2print_BG,*axeC_BG, *axeA_BG, paf,pgcode_force_BG, *xprint_BG, *yprint_BG,*axeC_BG, *axeA_BG, e$, sr, *xprint_BG, *yprint_BG,*zprint_BG,paf,*zprint_BG,e$
            else, sr, *xprint_BG, *yprint_BG, *zprint_BG,*axeC_BG, *axeA_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,*axeC_BG, *axeA_BG,e$
                ]
             else,
            [
            sr, *xprint_BG, *yprint_BG,*zprint_BG, *axeC_BG, *axeA_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG,*zprint_BG, *axeC_BG, *axeA_BG,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_BG = 1
        if deltaXYZ < mr5$ , fr5axe_BG = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_BG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_BG
          old_x_BG = xcal
          old_y_BG = ycal
          old_z_BG = zcal
         xprint_BG = xcor + xprint_BG
         yprint_BG = ycor + yprint_BG
         zprint_BG = zcor + zprint_BG
        if axeA_BG > maxi_a_BG | axeA_BG < mini_a_BG, psortie10_BG # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_BG
         if gcode$ = 1 ,
                [
                if tete_rev_BG = 1,
                    [
                    gfr_BG = 1
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG, *axeA_BG ,pfr_BG, paf, sgfr_BG, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG,*axeA_BG ,pfr_BG, e$
                    ]
                else,
                    [
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG, *axeA_BG, *fr5axe_BG, paf, sgfr_BG, *fr5axe_BG, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG, *axeA_BG, pg9_5x_BG, e$
                    ]
                 ]
        else, sr, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG, *axeA_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, *axeC_BG, *axeA_BG,e$
        debut_BG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_BG = Vx_BG
           old_vy_BG = Vy_BG
           old_vz_BG = Vz_BG
       old_longvec = longvec
       prvaxec_BG = axeC_BG
       prvaxea = axeA_BG
       operation_BG = 11
       old_x_5x_BG = x$
       old_y_5x_BG = y$
       old_z_5x_BG = z$
	old_axeC_simu_BG = axeC_BG
	old_axeA_simu_BG = axeA_BG
	old_xprint_simu_BG = xprint_BG
	old_yprint_simu_BG = yprint_BG
	old_zprint_simu_BG = zprint_BG
            old_opcode_BG = opcode$
			
pmx_CG        # 5 axes

            pprint_CG
            @xprint_CG, @yprint_CG,@zprint_CG
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_CM
                pmx_CM
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_CG = 0
			Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CG < 0, invers_CG = 1
														else, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CG < 0, invers_CG = 0
														else, invers_CG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
            if invers_CG = 0, pmxinvd_CG
            if invers_CG = 1, pmxinvg_CG
         #"voir dans pmx",*axeC_CG,e 

             if debut_CG = 1, pmxsens_CG
         !maxi_c_CG, !mini_c_CG


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_CG
           Dy = ycal - old_y_CG
           Dz = zcal - old_z_CG

           #"voir x,y,z,old_x_CG,old_y_CG,old_z_CG",*x,*y,*z,*old_x_CG,*old_y_CG,*old_z_CG,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_CG
         if fr$ > 0, frbase_CG = fr$

         if deltaXYZ < mr5$ & debut_CG = 1, pchange_CM, pmx_CM   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe_CG = fr$ / deltaXYZ
        ]




            if debut_CG = 0 & changop_CG <> 0, cont_axe_c_CG = 0
            if debut_CG = 0 & changop_CG <> 0, prvaxec_CG = axeC_CG



         axeC_CG = cont_axe_c_CG + axeC_CG       # cumul du compteur avec c   

         dif_axe_c = axeC_CG - prvaxec_CG     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_CG         # ajout + - 360
		 dif_axe_c2 = axeC_CG - prvaxec_CG
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_CG


        if axeC_CG > maxi_c_CG & debut_CG <> 0, pderoul_CG
        if axeC_CG < mini_c_CG & debut_CG <> 0, penroul_CG
        if debut_CG = 0,
        [

        if axeC_CG >= (360+mini_c_CG) & changop_CG <> 0, pdebut_CG

        if axeC_CG <= (maxi_c_CG - 360) & changop_CG <> 0, pdebut_CG

         gcode$ = 0

             sm, paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm, paf, "AROT", axeCpos_CG, axeApos_CG, e$
			if axeA_cloche_CG <> 0, old_axeA_simu_CG = axeA_cloche_CG, axeA_cloche_CG = 0, e$
			if flag_outil_CG <> 1 & changop_CG <> 1, prtcp_simu_CG
			 
             if mr2print_CG <>   -1,
            [
            if operation_CG = 1 , sr, *mr2print_CG, paf, pgcode_force_CG, *mr2$,e$
            if changop_CG = 1,	[
								if garage_CG <> 0 & change_outil_CG = 0, sr, *axeC_CG, paf,pgcode_force_CG, *axeC_CG, e$, old_axeC_simu_CG = axeC_CG
								if flag_outil_CG <> 1, prtcp_simu_CG
								sr, *xprint_CG, *yprint_CG,*mr2print_CG,*axeC_CG, *axeA_CG, paf,pgcode_force_CG, *xprint_CG, *yprint_CG,*axeC_CG, *axeA_CG, e$
								sr, *xprint_CG, *yprint_CG,*zprint_CG,paf,*zprint_CG,e$
            					change_outil_CG = 0
            					]
            else, sr, *xprint_CG, *yprint_CG, *zprint_CG,*axeC_CG, *axeA_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,*axeC_CG, *axeA_CG,e$
                ]
             else,
            [
            sr, *xprint_CG, *yprint_CG,*zprint_CG, *axeC_CG, *axeA_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG,*zprint_CG, *axeC_CG, *axeA_CG,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_CG = 1
        if deltaXYZ < mr5$ , fr5axe_CG = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_CG <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_CG
          old_x_CG = xcal
          old_y_CG = ycal
          old_z_CG = zcal
         xprint_CG = xcor + xprint_CG
         yprint_CG = ycor + yprint_CG
         zprint_CG = zcor + zprint_CG
        if axeA_CG > maxi_a_CG | axeA_CG < mini_a_CG, psortie10_CG # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_CG
         if gcode$ = 1 ,
                [
                if tete_rev_CG = 1,
                    [
                    gfr_CG = 1
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG, *axeA_CG ,pfr_CG, paf, sgfr_CG, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG,*axeA_CG ,pfr_CG, e$
                    ]
                else,
                    [
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG, *axeA_CG, *fr5axe_CG, paf, sgfr_CG, *fr5axe_CG, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG, *axeA_CG, pg9_5x_CG, e$
                    ]
                 ]
        else, sr, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG, *axeA_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, *axeC_CG, *axeA_CG,e$
        debut_CG = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_CG = Vx_CG
           old_vy_CG = Vy_CG
           old_vz_CG = Vz_CG
       old_longvec = longvec
       prvaxec_CG = axeC_CG
       prvaxea = axeA_CG
       operation_CG = 11
       old_x_5x_CG = x$
       old_y_5x_CG = y$
       old_z_5x_CG = z$
	old_axeC_simu_CG = axeC_CG
	old_axeA_simu_CG = axeA_CG
	old_xprint_simu_CG = xprint_CG
	old_yprint_simu_CG = yprint_CG
	old_zprint_simu_CG = zprint_CG

        old_opcode_CG = opcode$
pmx_AM        # 5 axes

            pprint_AM
            @xprint_AM, @yprint_AM,@zprint_AM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                pchange_BG
                pmx_BG
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_AM = 0
		Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AM < 0, invers_AM = 1
														else, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AM < 0, invers_AM = 0
														else, invers_AM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
            if invers_AM = 0, pmxinvd_AM
            if invers_AM = 1, pmxinvg_AM
			
             if debut_AM = 1, pmxsens_AM
             !maxi_c_AM, !mini_c_AM

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_AM
           Dy = ycal - old_y_AM
           Dz = zcal - old_z_AM
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)

            if fr$ =   -1,fr$= frbase_AM
            if fr$ > 0, frbase_AM = fr$

            if deltaXYZ < mr5$ & debut_AM = 1, pchange_BG, pmx_BG   # modif du 30/10/02
            else,
                [
                if fr$ > 0 & deltaXYZ <> 0,fr5axe_AM = fr$ / deltaXYZ
                ]

            if debut_AM = 0 & changop_AM <> 0, cont_axe_c_AM = 0
            if debut_AM = 0 & changop_AM <> 0, prvaxec_AM = axeC_AM


        #"Voir cont_axe_c_AM=", *cont_axe_c_AM, e$

         axeC_AM = cont_axe_c_AM + axeC_AM       # cumul du compteur avec c   

         dif_axe_c = axeC_AM - prvaxec_AM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)

         if absdif > 180,  pcont_AM         # ajout + - 360
		 dif_axe_c2 = axeC_AM - prvaxec_AM
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_AM
		 
		 		 
        if axeC_AM > maxi_c_AM & debut_AM <> 0, pderoul_AM
        if axeC_AM < mini_c_AM & debut_AM <> 0, penroul_AM

        if debut_AM = 0,
                [
                if axeC_AM >= (360+mini_c_AM) & changop_AM <> 0, pdebut_AM
                if axeC_AM <= (maxi_c_AM - 360) & changop_AM <> 0, pdebut_AM
                #if debut = 0, n, pgcode_force_AM, *axeC_AM, *axeA_AM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
                gcode$ = 0
                pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
                if mr2print_AM <>   -1,
                            [
                             #"voir operation_AM", *operation_AM,e
                            if operation_AM = 1 , pnumligne , pgcode_force_AM, mr2print_AM,e$
                            if changop_AM = 1, pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM,*axeC_AM, *axeA_AM, e$, pnumligne, *zprint_AM,e$
                            else, pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,*axeC_AM, *axeA_AM,e$
                            ]
                 else,
                            [
                            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM,*zprint_AM, *axeC_AM, *axeA_AM,e$
                            ]

                pasmi7 = 0
                pasn = 0
                vale53 = 0
                ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_AM = 1
        if deltaXYZ < mr5$ , fr5axe_AM = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53_AM,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_AM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_AM
          old_x_AM = xcal
          old_y_AM = ycal
          old_z_AM = zcal
         xprint_AM = xcor + xprint_AM
         yprint_AM = ycor + yprint_AM
         zprint_AM = zcor + zprint_AM
         if (xnci$ = 0) & (ynci$ = 0) & (znci$ = 0) & (u$ = 0) & (v$ = 0) & (w$ = 0), psortie11_AM
         if axeA_AM > maxi_a_AM | axeA_AM < mini_a_AM, psortie10_AM
         if gcode$ = 1 ,
                [
                if tete_rev_AM = 1,
                    [
                    gfr_AM = 1
                    pnumligne,sgfr_AM, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, *axeC_AM, axeA_AM ,pfr_AM, e$
                    ]
                else,
                    [
                    pnumligne, sgfr_AM, *fr5axe_AM, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, *axeC_AM, axeA_AM, pg9_5x_AM, e$
                    ]
                 ]
        else, pnumligne, pgcode_AM, xprint_AM, yprint_AM, zprint_AM, axeC_AM, axeA_AM,e$

        debut_AM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_AM = Vx_AM
           old_vy_AM = Vy_AM
           old_vz_AM = Vz_AM
       old_longvec = longvec
       prvaxec_AM = axeC_AM
       prvaxea = axeA_AM
       operation_AM = 11
       old_x_5x_AM = x$
       old_y_5x_AM = y$
       old_z_5x_AM = z$

pmx_BM        # 5 axes

            pprint_BM
            @xprint_BM, @yprint_BM,@zprint_BM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                pchange_CG
                pmx_CG
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_BM = 0
			Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BM < 0, invers_BM = 1
														else, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BM < 0, invers_BM = 0
														else, invers_BM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
            if invers_BM = 0, pmxinvd_BM
            if invers_BM = 1, pmxinvg_BM
         #"voir dans pmx",*axeC_BM,e 

             if debut_BM = 1, pmxsens_BM
         !maxi_c_BM, !mini_c_BM


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_BM
           Dy = ycal - old_y_BM
           Dz = zcal - old_z_BM

           #"voir x,y,z,old_x_BM,old_y_BM,old_z_BM",*x,*y,*z,*old_x_BM,*old_y_BM,*old_z_BM,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_BM
         if fr$ > 0, frbase_BM = fr$

         if deltaXYZ < mr5$ & debut_BM = 1, pchange_CG, pmx_CG   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe_BM = fr$ / deltaXYZ
        ]




            if debut_BM = 0 & changop_BM <> 0, cont_axe_c_BM = 0
            if debut_BM = 0 & changop_BM <> 0, prvaxec_BM = axeC_BM



         axeC_BM = cont_axe_c_BM + axeC_BM       # cumul du compteur avec c   

         dif_axe_c = axeC_BM - prvaxec_BM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_BM         # ajout + - 360
		 dif_axe_c2 = axeC_BM - prvaxec_BM
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_BM


        if axeC_BM > maxi_c_BM & debut_BM <> 0, pderoul_BM
        if axeC_BM < mini_c_BM & debut_BM <> 0, penroul_BM
        if debut_BM = 0,
        [

        if axeC_BM >= (360+mini_c_BM) & changop_BM <> 0, pdebut_BM

        if axeC_BM <= (maxi_c_BM - 360) & changop_BM <> 0, pdebut_BM

        #if debut = 0, n, pgcode_force_BM, *axeC_BM, *axeA_BM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
             if mr2print_BM <>   -1,
            [
            #"voir operation_BM", *operation_BM,e
            if operation_BM = 1 , pnumligne , pgcode_force_BM, mr2print_BM,e$
            if changop_BM = 1, pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM,*axeC_BM, *axeA_BM,e$, pnumligne, *zprint_BM,e$
            else, pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,*axeC_BM, *axeA_BM,e$
                ]
             else,
            [
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM,*zprint_BM, *axeC_BM, *axeA_BM,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_BM = 1
        if deltaXYZ < mr5$ , fr5axe_BM = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_BM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_BM
          old_x_BM = xcal
          old_y_BM = ycal
          old_z_BM = zcal
         xprint_BM = xcor + xprint_BM
         yprint_BM = ycor + yprint_BM
         zprint_BM = zcor + zprint_BM
        if axeA_BM > maxi_a_BM | axeA_BM < mini_a_BM, psortie10_BM # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_BM
         if gcode$ = 1 ,
                [
                if tete_rev_BM = 1,
                    [
                    gfr_BM = 1
                    pnumligne, sgfr_BM, pgcode_BM, xprint_BM, yprint_BM, zprint_BM, *axeC_BM, axeA_BM ,pfr_BM, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_BM, sgfr_BM, *fr5axe_BM, xprint_BM, yprint_BM, zprint_BM, *axeC_BM, axeA_BM, pg9_5x_BM, e$
                    ]
                 ]
        else, pnumligne, pgcode_BM, xprint_BM, yprint_BM, zprint_BM, axeC_BM, axeA_BM,e$
        debut_BM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_BM = Vx_BM
           old_vy_BM = Vy_BM
           old_vz_BM = Vz_BM
       old_longvec = longvec
       prvaxec_BM = axeC_BM
       prvaxea = axeA_BM
       operation_BM = 11
       old_x_5x_BM = x$
       old_y_5x_BM = y$
       old_z_5x_BM = z$

pmx_CM        # 5 axes

            pprint_CM
            @xprint_CM, @yprint_CM,@zprint_CM
            if opcode$ = 16,
            [
                sav_x_pmx = x$
                sav_y_pmx = y$
                sav_z_pmx = z$
                sav_u_pmx = u$
                sav_v_pmx = v$
                sav_w_pmx = w$
                !sav_x_pmx,!sav_y_pmx,!sav_z_pmx,!sav_u_pmx,!sav_v_pmx,!sav_w_pmx
                # "voir xyz=",x$,y$,z$,e$
                  ex$
            ]
            if fr$ =   -2,gcode$= 0
            else, gcode$ = 1
            gfr_CM = 0
			Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CM < 0, invers_CM = 1
														else, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CM < 0, invers_CM = 0
														else, invers_CM = 1  # pas de choix sens A si tete a renvoi d'angle
														]	
            if invers_CM = 0, pmxinvd_CM
            if invers_CM = 1, pmxinvg_CM
         #"voir dans pmx",*axeC_CM,e 

             if debut_CM = 1, pmxsens_CM
         !maxi_c_CM, !mini_c_CM


    # calcul des longeur des vecteurs 

           Du = ucal - old_u
           Dv = vcal - old_v
           Dw = wcal - old_w
           deltaUVW = sqrt(Du * Du + Dv * Dv + Dw * Dw)

           Dx = xcal - old_x_CM
           Dy = ycal - old_y_CM
           Dz = zcal - old_z_CM

           #"voir x,y,z,old_x_CM,old_y_CM,old_z_CM",*x,*y,*z,*old_x_CM,*old_y_CM,*old_z_CM,e
           deltaXYZ = sqrt(Dx * Dx + Dy * Dy + Dz * Dz)
        #"voir deltaxyz",*deltaXYZ,e                      

             if fr$ =   -1,fr$= frbase_CM
         if fr$ > 0, frbase_CM = fr$

         if deltaXYZ < mr5$ & debut_CM = 1, ex$   # modif du 30/10/02
         else,
        [
        if fr$ > 0 & deltaXYZ <> 0,fr5axe_CM = fr$ / deltaXYZ
        ]




            if debut_CM = 0 & changop_CM <> 0, cont_axe_c_CM = 0
            if debut_CM = 0 & changop_CM <> 0, prvaxec_CM = axeC_CM



         axeC_CM = cont_axe_c_CM + axeC_CM       # cumul du compteur avec c   

         dif_axe_c = axeC_CM - prvaxec_CM     # difference entre ancient angle et nouveau
         absdif = abs(dif_axe_c)
        # "absdif",*absdif,e
         if absdif > 180,  pcont_CM         # ajout + - 360
		 dif_axe_c2 = axeC_CM - prvaxec_CM
		 absdif2 = abs(dif_axe_c2)
		 if absdif2 > delta_rot_C, psortie_axeC_5X_CM


        if axeC_CM > maxi_c_CM & debut_CM <> 0, pderoul_CM
        if axeC_CM < mini_c_CM & debut_CM <> 0, penroul_CM
        if debut_CM = 0,
        [

        if axeC_CM >= (360+mini_c_CM) & changop_CM <> 0, pdebut_CM

        if axeC_CM <= (maxi_c_CM - 360) & changop_CM <> 0, pdebut_CM

        #if debut = 0, n, pgcode_force_CM, *axeC_CM, *axeA_CM,  e, n, x, y, e,n, *z,e # a valide si on veux en premier une position c a puis xyz
         gcode$ = 0

             pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
             if mr2print_CM <>   -1,
            [
            #"voir operation_CM", *operation_CM,e
            if operation_CM = 1 , pnumligne , pgcode_force_CM, mr2print_CM,e$
            if changop_CM = 1, pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM,*axeC_CM, *axeA_CM,e$, pnumligne, *zprint_CM,e$
            else, pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,*axeC_CM, *axeA_CM,e$
                ]
             else,
            [
            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM,*zprint_CM, *axeC_CM, *axeA_CM,e$
            ]


         pasmi7 = 0
         pasn = 0
         vale53 = 0
         ]
        # "delta",*deltaxyz, e
        if deltaXYZ < mr5$ | gcode$ = 0, gfr_CM = 1
        if deltaXYZ < mr5$ , fr5axe_CM = fr$
        spaces$ = 0

#       if gcode = 0 & vale53 <> 0 & mr6 <> 0, n," ",*e53,"=0",e
          if gcode$ = 0 , vale53 = 0
              if gcode$ = 0 , xcor = 0
              if gcode$ = 0 , ycor = 0
              if gcode$ = 0 , zcor = 0
              if gcode$ = 0 , pasn = 0
              if gcode$ = 0 , pasmi7 = 0
        spaces$ = 1
        if gcode$ = 1 & debut_CM <> 0 & mr6$ <> 0 & mi7$ <> 0, pvarioutil_CM
          old_x_CM = xcal
          old_y_CM = ycal
          old_z_CM = zcal
         xprint_CM = xcor + xprint_CM
         yprint_CM = ycor + yprint_CM
         zprint_CM = zcor + zprint_CM
        if axeA_CM > maxi_a_CM | axeA_CM < mini_a_CM, psortie10_CM # verif si plan possible

        if xnci$ = 0 & ynci$ = 0 & znci$ = 0 & u$ = 0 & v$ = 0 & w$ = 0, psortie11_CM
         if gcode$ = 1 ,
                [
                if tete_rev_CM = 1,
                    [
                    gfr_CM = 1
                    pnumligne, sgfr_CM, pgcode_CM, xprint_CM, yprint_CM, zprint_CM, *axeC_CM, axeA_CM ,pfr_CM, e$
                    ]
                else,
                    [
                    pnumligne, pgcode_CM, sgfr_CM, *fr5axe_CM, xprint_CM, yprint_CM, zprint_CM, *axeC_CM, axeA_CM, pg9_5x_CM, e$
                    ]
                 ]
        else, pnumligne, pgcode_CM, xprint_CM, yprint_CM, zprint_CM, axeC_CM, axeA_CM,e$
        debut_CM = 1

      #    memmoriser les valeurs uvwxyzvxvyvzlongvec
           old_u = ucal
           old_v = vcal
           old_w = wcal

           old_vx_CM = Vx_CM
           old_vy_CM = Vy_CM
           old_vz_CM = Vz_CM
       old_longvec = longvec
       prvaxec_CM = axeC_CM
       prvaxea = axeA_CM
       operation_CM = 11
       old_x_5x_CM = x$
       old_y_5x_CM = y$
       old_z_5x_CM = z$
#endregion
#region pmx2
pmx2$
            pchange_AG
            pmx2_AG

            pchange_AM
            pmx2_AM

            pchange_BG
            pmx2_BG

            pchange_BM
            pmx2_BM

            pchange_CG
            pmx2_CG

            pchange_CM
            pmx2_CM

pmx2_AG     # 1 er mouv 5 axes

           if opcode$ = 16,  pchange_AM, pmx2_AM
       pmx$

pmx2_BG     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_BM, pmx2_BM
       pmx$

pmx2_CG     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_CM, pmx2_CM
       pmx$

pmx2_AM     # 1 er mouv 5 axes

           if opcode$ = 16,  pchange_BG, pmx2_BG
       pmx$

pmx2_BM     # 1 er mouv 5 axes


           if opcode$ = 16,  pchange_CG, pmx2_CG
       pmx$

pmx2_CM     # 1 er mouv 5 axes


           if opcode$ = 16,  ex$
       pmx$
#endregion
#endregion

#region   PERCAGES #OK
#region pdrl5

pdrl5_AG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_AG
        gcode$ = 0
		Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AG < 0, invers_AG = 1
														else, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AG < 0, invers_AG = 0
														else, invers_AG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_AG = 0, pmxinvd_AG
        if invers_AG = 1, pmxinvg_AG
        pdebut_AG
        Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        axeCpos_AG = axeC_AG
        axeApos_AG = axeA_AG

        if mi1_C_base_AG <> 1 & mi1_C_base_AG <> 2, pessaicompteur_AG
        axeCpos1_AG = axeCpos_AG
        axeApos1_AG = axeApos_AG
       !axeApos1_AG,!axeCpos_AG
       if mr2print_AG = 0, mr2print_AG =zsecuprint
       prvmr2_AG = mr2print_AG

       if mr2print_AG <> -1,	[
	   							if flag_changement_outil_AG = 1,	[
																	if t$ = 51 | t$ = 52,sr, *mr2print_AG, sazero, sczero, paf, *mr2$, sm, "X-2245.", e$
																	if t$ = 61 | t$ = 62,sr, *mr2print_AG, sazero, sczero, paf, *mr2$, sm, "X-2005.", e$
																	if t$ <> 51 & t$ <> 52 & t$ <> 61 & t$ <> 62, sr, *mr2print_AG, sazero, sczero, paf, *mr2$, sm, sxmag_AG, symag_AG ,e$
																	]
								else, sr, *mr2print_AG, paf, *mr2$,e$
								]

       gcode$ = 0

       tox4print_AG = (((Vx_AG/longvec) * (depth$ * -1)) + x$)
       toy4print_AG = (((Vy_AG/longvec) * (depth$ * -1)) + y$)
       toz4print_AG = (((Vz_AG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_AG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           sm,paf,"G151 EC0. EA0. EU0. EV0. EW0.", e$
			srtcpon, e$
           if mr2print_AG =  -1,sr, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, *axeCpos1_AG, *axeApos1_AG, paf,pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, *axeCpos1_AG, *axeApos1_AG, e$     #orientationtete 
           else, sr, *xrprintrap_AG, *yrprintrap_AG, *axeCpos1_AG, *axeApos1_AG paf, pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, *axeCpos1_AG, *axeApos1_AG,e$, sr, *zrprintrap_AG, paf, *zrprintrap_AG, e$     #orientationtete
           #if mr2print_AG =  -1,sm, paf,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, axeCpos1_AG, axeApos1_AG, e$     #orientationtete 
           #else, sm, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, axeCpos1_AG, axeApos1_AG,e$, sm, paf, *zrprint_AG, e$     #orientationtete
           #sm, paf,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, e$     #orientationtete 

           sr, *xgarde_AG, *ygarde_AG, *zgarde_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$                         # dep au plan garde 
           gcode$ = 1
           sl, *xprint_AG, *yprint_AG, *zprint_AG,*frplunge$, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,*frplunge$, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, sr, *xrprint_AG, *yrprint_AG, *zrprint_AG, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, e$            # retour plan de secu
            else, sr, *xgarde_AG, *ygarde_AG, *zgarde_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

        oldstation_AG = mi4_AG
        frbase_AG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_AG
       xprint_AG = 0
       yprint_AG = 0
       #zinitht_AG = dest_ret_5x_AG
       #*sav_x_pmx, *tox4print_AG, e$
       #*sav_y_pmx,  *toy4print_AG, e$
       #*sav_z_pmx, *toz4print_AG, e$
       zinitht_AG = sqrt((sav_x_pmx - tox4print_AG)^2 + (sav_y_pmx - toy4print_AG)^2 + (sav_z_pmx - toz4print_AG)^2)
       old_zinitht_AG = zinitht_AG

       @initht$
       @zinitht_AG
       zprint_AG = refht$
       sm,paf,"G151 EC0. EA0. EU0. EV0. EW0.", e$
       if (x$ = u$) & (y$ = v$), [axeCpos1_AG = 0, axeApos1_AG = 0, axeCpos_AG = 0, axeApos_AG = 0]
       if axeApos1_AG > maxi_a_AG | axeApos1_AG < mini_a_AG, psortie10_AG
	   srtcpon, e$
           if mr2print_AG =  -1,sr, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, paf,pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, e$     #orientationtete
           else, sr, *xrprint_AG, *yrprint_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *axeCpos1_AG, *axeApos1_AG, e$     #orientationtete
           sm, paf, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$

                        xprint_AG = xr$
                        yprint_AG = yr$
                        zprint_AG = zr$
                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,e$ #
                        pcaldrilxyzsimu_AG
                        xprint_AG = v_abs_plus_x_sec_AG
                        yprint_AG = v_abs_plus_y_sec_AG
                        zprint_AG = v_abs_plus_z_sec_AG
                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,e$ # dep au plan garde  
                        old_v_abs_plus_x_sec_AG = v_abs_plus_x_sec_AG
                        old_v_abs_plus_y_sec_AG = v_abs_plus_y_sec_AG
                        old_v_abs_plus_z_sec_AG = v_abs_plus_z_sec_AG

            #sr, *xprint_AG, *yprint_AG, *zinitht_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zinitht_AG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AG = toy4print_AG
           old_toz4_AG = toz4print_AG
           old_axeCpos_AG = axeCpos_AG
           old_axeApos_AG = axeApos_AG
           oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG
         xprint_AG = 0
         yprint_AG = 0

        oldstation_AG = mi4_AG
        frbase_AG = fr$
       ]
      old_opcode_AG = opcode$
pdrl5_BG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_BG
        gcode$ = 0
		Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BG < 0, invers_BG = 1
														else, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BG < 0, invers_BG = 0
														else, invers_BG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_BG = 0, pmxinvd_BG
        if invers_BG = 1, pmxinvg_BG
        pdebut_BG
        Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        axeCpos_BG = axeC_BG
        axeApos_BG = axeA_BG

        if mi1_C_base_BG <> 1 & mi1_C_base_BG <> 2, pessaicompteur_BG
        axeCpos1_BG = axeCpos_BG
        axeApos1_BG = axeApos_BG
       !axeApos1_BG,!axeCpos_BG
       if mr2print_BG = 0, mr2print_BG =zsecuprint
       prvmr2_BG = mr2print_BG
	   
       if mr2print_BG <> -1,	[
	   							if flag_changement_outil_BG = 1, sr, *mr2print_BG, sazero, sczero, paf, *mr2$, sm, sxmag_BG, symag_BG ,e$
								else, sr, *mr2print_BG, paf, *mr2$, e$
								]	   

       gcode$ = 0

       tox4print_BG = (((Vx_BG/longvec) * (depth$ * -1)) + x$)
       toy4print_BG = (((Vy_BG/longvec) * (depth$ * -1)) + y$)
       toz4print_BG = (((Vz_BG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_BG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_BG
			srtcpon, e$
           if mr2print_BG =  -1,sr, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, *axeCpos1_BG, *axeApos1_BG, paf,pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, *axeCpos1_BG, *axeApos1_BG, e$     #orientationtete 
           else, sr, *xrprintrap_BG, *yrprintrap_BG, *axeCpos1_BG, *axeApos1_BG paf, pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, *axeCpos1_BG, *axeApos1_BG,e$, sr, *zrprintrap_BG, paf, *zrprintrap_BG, e$     #orientationtete
           #if mr2print_BG =  -1,sm, paf,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, axeCpos1_BG, axeApos1_BG, e$     #orientationtete 
           #else, sm, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, axeCpos1_BG, axeApos1_BG,e$, sm, paf, *zrprint_BG, e$     #orientationtete
           #sm, paf,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$     #orientationtete 

           sr, *xgarde_BG, *ygarde_BG, *zgarde_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
           gcode$ = 1
           sl, *xprint_BG, *yprint_BG, *zprint_BG,*frplunge$, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,*frplunge$, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, sr, *xrprint_BG, *yrprint_BG, *zrprint_BG, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$            # retour plan de secu
            else, sr, *xgarde_BG, *ygarde_BG, *zgarde_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

        oldstation_BG = mi4_BG
        frbase_BG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_BG
       xprint_BG = 0
       yprint_BG = 0
       #zinitht_BG = dest_ret_5x_BG
       #*sav_x_pmx, *tox4print_BG, e$
       #*sav_y_pmx,  *toy4print_BG, e$
       #*sav_z_pmx, *toz4print_BG, e$
       zinitht_BG = sqrt((sav_x_pmx - tox4print_BG)^2 + (sav_y_pmx - toy4print_BG)^2 + (sav_z_pmx - toz4print_BG)^2)
       old_zinitht_BG = zinitht_BG

       @initht$
       @zinitht_BG
       zprint_BG = refht$
       panul_plan_inc_BG
            if (x$ = u$) & (y$ = v$), [axeCpos1_BG = 0, axeApos1_BG = 0, axeCpos_BG = 0, axeApos_BG = 0]
            if axeApos1_BG > maxi_a_BG | axeApos1_BG < mini_a_BG, psortie10_BG
			srtcpon, e$
           if mr2print_BG =  -1,sr, *xrprint_BG, *yrprint_BG, *zrprint_BG, *axeCpos1_BG, *axeApos1_BG, paf,pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, *axeCpos1_BG, *axeApos1_BG, e$     #orientationtete
           else, sr, *xrprint_BG, *yrprint_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *axeCpos1_BG, *axeApos1_BG, e$     #orientationtete
           sm,paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm, paf, "AROT", axeCpos_BG, axeApos_BG, e$

                        xprint_BG = xr$
                        yprint_BG = yr$
                        zprint_BG = zr$
                        sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,e$ #
                        pcaldrilxyzsimu_BG
                        xprint_BG = v_abs_plus_x_sec_BG
                        yprint_BG = v_abs_plus_y_sec_BG
                        zprint_BG = v_abs_plus_z_sec_BG
                        sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,e$ # dep au plan garde  
                        old_v_abs_plus_x_sec_BG = v_abs_plus_x_sec_BG
                        old_v_abs_plus_y_sec_BG = v_abs_plus_y_sec_BG
                        old_v_abs_plus_z_sec_BG = v_abs_plus_z_sec_BG

            #sm, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zinitht_BG,e$                         # dep au plan garde          
          # n, *z, e

           old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BG = toy4print_BG
           old_toz4_BG = toz4print_BG
           old_axeCpos_BG = axeCpos_BG
           old_axeApos_BG = axeApos_BG
           oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG
         xprint_BG = 0
         yprint_BG = 0

        oldstation_BG = mi4_BG
        frbase_BG = fr$
       ]
       old_opcode_BG = opcode$
pdrl5_CG   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_CG
        gcode$ = 0
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CG < 0, invers_CG = 1
														else, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CG < 0, invers_CG = 0
														else, invers_CG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_CG = 0, pmxinvd_CG
        if invers_CG = 1, pmxinvg_CG
        pdebut_CG
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        axeCpos_CG = axeC_CG
        axeApos_CG = axeA_CG

        if mi1_C_base_CG <> 1 & mi1_C_base_CG <> 2, pessaicompteur_CG
        axeCpos1_CG = axeCpos_CG
        axeApos1_CG = axeApos_CG
        axeCpos_CG = axeCpos_CG + 90
       !axeApos1_CG,!axeCpos_CG
       if mr2print_CG = 0, mr2print_CG =zsecuprint
       prvmr2_CG = mr2print_CG

       if mr2print_CG <> -1,	[
	   							if flag_changement_outil_CG = 1, sr, *mr2print_CG, sbzero, sczero, paf, *mr2$, sm, sxmag_CG, symag_CG ,e$
								else, sr, *mr2print_CG, paf, *mr2$,e$
								]

       gcode$ = 0

       tox4print_CG = (((Vx_CG/longvec) * (depth$ * -1)) + x$)
       toy4print_CG = (((Vy_CG/longvec) * (depth$ * -1)) + y$)
       toz4print_CG = (((Vz_CG/longvec) * (depth$ * -1)) + z$)


       if tete_rev_CG = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_CG
		   if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
           if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
		   srtcpon, e$
           if mr2print_CG =  -1,sr, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, *axeCpos1_CG, *axeApos1_CG, paf,pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, *axeCpos1_CG, *axeApos1_CG, e$     #orientationtete 
           else, sr, *xrprintrap_CG, *yrprintrap_CG, *axeCpos1_CG, *axeApos1_CG paf, pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, *axeCpos1_CG, *axeApos1_CG,e$, sr, *zrprintrap_CG, paf, *zrprintrap_CG, e$     #orientationtete 
           #if mr2print_CG =  -1,sm, paf,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, axeCpos1_CG, axeApos1_CG, e$     #orientationtete 
           #else, sm, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, axeCpos1_CG, axeApos1_CG,e$, sm, paf, *zrprint_CG, e$     #orientationtete
           #sm, paf,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$     #orientationtete 

           sr, *xgarde_CG, *ygarde_CG, *zgarde_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
           gcode$ = 1
           sl, *xprint_CG, *yprint_CG, *zprint_CG,*frplunge$, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,*frplunge$, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, sr, *xrprint_CG, *yrprint_CG, *zrprint_CG, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$            # retour plan de secu
            else, sr, *xgarde_CG, *ygarde_CG, *zgarde_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

        oldstation_CG = mi4_CG
        frbase_CG = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_CG
       xprint_CG = 0
       yprint_CG = 0
       #zinitht_CG = dest_ret_5x_CG
       #*sav_x_pmx, *tox4print_CG, e$
       #*sav_y_pmx,  *toy4print_CG, e$
       #*sav_z_pmx, *toz4print_CG, e$
       zinitht_CG = sqrt((sav_x_pmx - tox4print_CG)^2 + (sav_y_pmx - toy4print_CG)^2 + (sav_z_pmx - toz4print_CG)^2)
       old_zinitht_CG = zinitht_CG

       @initht$
       @zinitht_CG
       zprint_CG = refht$
       panul_plan_inc_CG
            if (x$ = u$) & (y$ = v$), [axeCpos1_CG = 0, axeApos1_CG = 0, axeCpos_CG = 0, axeApos_CG = 0]
            if axeApos1_CG > maxi_a_CG | axeApos1_CG < mini_a_CG, psortie10_CG
			if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        	if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
			srtcpon, e$
			if garage_CG <> 0 & change_outil_CG = 0, sr,*axeCpos1_CG, paf, pgcode_force_CG, *axeCpos1_CG, e$
		   change_outil_CG = 0
            if mr2print_CG =  -1,sr, *xrprint_CG, *yrprint_CG, *zrprint_CG, *axeCpos1_CG, *axeApos1_CG, paf,pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, *axeCpos1_CG, *axeApos1_CG, e$     #orientationtete
            else, sr, *xrprint_CG, *yrprint_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *axeCpos1_CG, *axeApos1_CG, e$     #orientationtete
            sm,paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm, paf, "AROT", axeCpos_CG, axeApos_CG, e$
           sm, paf, "M32 ; BLOCAGE AXE B", e$,sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1

                        xprint_CG = xr$
                        yprint_CG = yr$
                        zprint_CG = zr$
                        sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,e$ #
                        pcaldrilxyzsimu_CG
                        xprint_CG = v_abs_plus_x_sec_CG
                        yprint_CG = v_abs_plus_y_sec_CG
                        zprint_CG = v_abs_plus_z_sec_CG
                        sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,e$ # dep au plan garde  
                        old_v_abs_plus_x_sec_CG = v_abs_plus_x_sec_CG
                        old_v_abs_plus_y_sec_CG = v_abs_plus_y_sec_CG
                        old_v_abs_plus_z_sec_CG = v_abs_plus_z_sec_CG
            #sm, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zinitht_CG,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CG = toy4print_CG
           old_toz4_CG = toz4print_CG
           old_axeCpos_CG = axeCpos_CG
           old_axeApos_CG = axeApos_CG
           oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG
         xprint_CG = 0
         yprint_CG = 0

        oldstation_CG = mi4_CG
        frbase_CG = fr$
       ]
        old_opcode_CG = opcode$
pdrl5_AM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_AM
        gcode$ = 0
		Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AM < 0, invers_AM = 1
														else, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AM < 0, invers_AM = 0
														else, invers_AM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_AM = 0, pmxinvd_AM
        if invers_AM = 1, pmxinvg_AM
        pdebut_AM
        Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        axeCpos_AM = axeC_AM
        axeApos_AM = axeA_AM

        if mi1_C_base_AM <> 1 & mi1_C_base_AM <> 2, pessaicompteur_AM
        axeCpos1_AM = axeCpos_AM
        axeApos1_AM = axeApos_AM
       !axeApos1_AM,!axeCpos_AM
       if mr2print_AM = 0, mr2print_AM =zsecuprint
       prvmr2_AM = mr2print_AM

       if mr2print_AM <> -1,pnumligne,*mr2print_AM,e$

       gcode$ = 0

       tox4print_AM = (((Vx_AM/longvec) * (depth$ * -1)) + x$)
       toy4print_AM = (((Vy_AM/longvec) * (depth$ * -1)) + y$)
       toz4print_AM = (((Vz_AM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_AM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$

           if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, *zrprintrap_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
           else, pnumligne, pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprintrap_AM, e$     #orientationtete
           #if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprint_AM, e$     #orientationtete
           #pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$     #orientationtete 

           pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,frplunge_AM, e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

        oldstation_AM = mi4_AM
        frbase_AM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_AM
       xprint_AM = 0
       yprint_AM = 0
       #zinitht_AM = dest_ret_5x_AM
       #*sav_x_pmx, *tox4print_AM, e$
       #*sav_y_pmx,  *toy4print_AM, e$
       #*sav_z_pmx, *toz4print_AM, e$
       zinitht_AM = sqrt((sav_x_pmx - tox4print_AM)^2 + (sav_y_pmx - toy4print_AM)^2 + (sav_z_pmx - toz4print_AM)^2)
       old_zinitht_AM = zinitht_AM

       @initht$
       @zinitht_AM
       zprint_AM = refht$
       pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
       if (x$ = u$) & (y$ = v$), [axeCpos1_AM = 0, axeApos1_AM = 0, axeCpos_AM = 0, axeApos_AM = 0]
       if axeApos1_AM > maxi_a_AM | axeApos1_AM < mini_a_AM, psortie10_AM
           if mr2print_AM =  -1,pnumligne,pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
           else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
           pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$


            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zinitht_AM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_AM = toy4print_AM
           old_toz4_AM = toz4print_AM
           old_axeCpos_AM = axeCpos_AM
           old_axeApos_AM = axeApos_AM
           oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM
         xprint_AM = 0
         yprint_AM = 0

        oldstation_AM = mi4_AM
        frbase_AM = fr$
       ]

pdrl5_BM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_BM
        gcode$ = 0
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BM < 0, invers_BM = 1
														else, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BM < 0, invers_BM = 0
														else, invers_BM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_BM = 0, pmxinvd_BM
        if invers_BM = 1, pmxinvg_BM
        pdebut_BM
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        axeCpos_BM = axeC_BM
        axeApos_BM = axeA_BM

        if mi1_C_base_BM <> 1 & mi1_C_base_BM <> 2, pessaicompteur_BM
        axeCpos1_BM = axeCpos_BM
        axeApos1_BM = axeApos_BM
       !axeApos1_BM,!axeCpos_BM
       if mr2print_BM = 0, mr2print_BM =zsecuprint
       prvmr2_BM = mr2print_BM

       if mr2print_BM <> -1,pnumligne,*mr2print_BM,e$

       gcode$ = 0

       tox4print_BM = (((Vx_BM/longvec) * (depth$ * -1)) + x$)
       toy4print_BM = (((Vy_BM/longvec) * (depth$ * -1)) + y$)
       toz4print_BM = (((Vz_BM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_BM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_BM

           if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, *zrprintrap_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
           else, pnumligne, pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprintrap_BM, e$     #orientationtete
           #if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprint_BM, e$     #orientationtete
           #pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$     #orientationtete 

           pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,frplunge_BM e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

        oldstation_BM = mi4_BM
        frbase_BM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_BM
       xprint_BM = 0
       yprint_BM = 0
       #zinitht_BM = dest_ret_5x_BM
       #*sav_x_pmx, *tox4print_BM, e$
       #*sav_y_pmx,  *toy4print_BM, e$
       #*sav_z_pmx, *toz4print_BM, e$
       zinitht_BM = sqrt((sav_x_pmx - tox4print_BM)^2 + (sav_y_pmx - toy4print_BM)^2 + (sav_z_pmx - toz4print_BM)^2)
       old_zinitht_BM = zinitht_BM

       @initht$
       @zinitht_BM
       zprint_BM = refht$
       panul_plan_inc_BM
            if (x$ = u$) & (y$ = v$), [axeCpos1_BM = 0, axeApos1_BM = 0, axeCpos_BM = 0, axeApos_BM = 0]
            if axeApos1_BM > maxi_a_BM | axeApos1_BM < mini_a_BM, psortie10_BM
           if mr2print_BM =  -1,pnumligne,pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
           else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
           pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$


            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zinitht_BM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_BM = toy4print_BM
           old_toz4_BM = toz4print_BM
           old_axeCpos_BM = axeCpos_BM
           old_axeApos_BM = axeApos_BM
           oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM
         xprint_BM = 0
         yprint_BM = 0

        oldstation_BM = mi4_BM
        frbase_BM = fr$
       ]

pdrl5_CM   # ecriture 1 er percage en 5 axes
                xr$ = sav_x_pmx
                yr$ = sav_y_pmx
                zr$ = sav_z_pmx
                tourne = 0
                !tourne
                pprint_CM
        gcode$ = 0
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CM < 0, invers_CM = 1
														else, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CM < 0, invers_CM = 0
														else, invers_CM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_CM = 0, pmxinvd_CM
        if invers_CM = 1, pmxinvg_CM
        pdebut_CM
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        axeCpos_CM = axeC_CM
        axeApos_CM = axeA_CM

        if mi1_C_base_CM <> 1 & mi1_C_base_CM <> 2, pessaicompteur_CM
        axeCpos1_CM = axeCpos_CM
        axeApos1_CM = axeApos_CM
        axeCpos_CM = axeCpos_CM + 90
       !axeApos1_CM,!axeCpos_CM
       if mr2print_CM = 0, mr2print_CM =zsecuprint
       prvmr2_CM = mr2print_CM

       if mr2print_CM <> -1,pnumligne,*mr2print_CM,e$

       gcode$ = 0

       tox4print_CM = (((Vx_CM/longvec) * (depth$ * -1)) + x$)
       toy4print_CM = (((Vy_CM/longvec) * (depth$ * -1)) + y$)
       toz4print_CM = (((Vz_CM/longvec) * (depth$ * -1)) + z$)


       if tete_rev_CM = 1,
       [
        #" on est en mode percage 5 axes avec renvoi d'angle ",e$

           panul_plan_inc_CM

           if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, *zrprintrap_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
           else, pnumligne, pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprintrap_CM, e$     #orientationtete
           #if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
           #else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprint_CM, e$     #orientationtete
           #pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$     #orientationtete 

           pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
           gcode$ = 1
           frplunge_CM = frplunge$
           pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,frplunge_CM e$                # percage

           if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000, pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$            # retour plan de secu
            else, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
            if typepercage = 1, gcode$ = 0

           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

        oldstation_CM = mi4_CM
        frbase_CM = fr$

       ] # on sort du mode percage 5 axes avec renvoi d'angle 
       else,
       [
            #" on est en mode percage 5 axes sans renvoi d'angle ", e$
       pvoir_CM
       xprint_CM = 0
       yprint_CM = 0
       #zinitht_CM = dest_ret_5x_CM
       #*sav_x_pmx, *tox4print_CM, e$
       #*sav_y_pmx,  *toy4print_CM, e$
       #*sav_z_pmx, *toz4print_CM, e$
       zinitht_CM = sqrt((sav_x_pmx - tox4print_CM)^2 + (sav_y_pmx - toy4print_CM)^2 + (sav_z_pmx - toz4print_CM)^2)
       old_zinitht_CM = zinitht_CM

       @initht$
       @zinitht_CM
       zprint_CM = refht$
       panul_plan_inc_CM
            if (x$ = u$) & (y$ = v$), [axeCpos1_CM = 0, axeApos1_CM = 0, axeCpos_CM = 0, axeApos_CM = 0]
            if axeApos1_CM > maxi_a_CM | axeApos1_CM < mini_a_CM, psortie10_CM
           if mr2print_CM =  -1,pnumligne,pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete
           else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete
           pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
           pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1

            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zinitht_CM,e$                         # dep au plan garde          
          # n, *z, e


           old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
           old_toy4_CM = toy4print_CM
           old_toz4_CM = toz4print_CM
           old_axeCpos_CM = axeCpos_CM
           old_axeApos_CM = axeApos_CM
           oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM
         xprint_CM = 0
         yprint_CM = 0

        oldstation_CM = mi4_CM
        frbase_CM = fr$
       ]

#endregion
#region pdrl5_2

pdrl5_2_AG   # ecriture percage suivant en 5 axes
		old_axeC_simu_AG = axeC_AG
		old_axeA_simu_AG = axeA_AG
		gcode$ = 0
		Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AG < 0, invers_AG = 1
														else, invers_AG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AG < 0, invers_AG = 0
														else, invers_AG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_AG = 0, pmxinvd_AG
        if invers_AG = 1, pmxinvg_AG
        pdebut_AG
        Vx_AG = u$ - x$
        Vy_AG = v$ - y$
        Vz_AG = w$ - z$
        axeCpos_AG = axeC_AG
        axeApos_AG = axeA_AG
        if mi1_C_base_AG <> 1 & mi1_C_base_AG <> 2, pessaicompteur_AG
        axeCpos1_AG = axeCpos_AG
        axeApos1_AG = axeApos_AG
        !axeApos1_AG,!axeCpos_AG
        if mr2print_AG = 0, mr2print_AG = zsecuprint
        prvmr2_AG = mr2print_AG

        if tete_rev_AG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 
            #sm, paf,"G151 EC0. EA0. EU0. EV0. EW0.", e$
            !xrprint_AG, !xgarde_AG, !yrprint_AG, !ygarde_AG, !zrprint_AG, !zgarde_AG

             if xrprint_AG = xgarde_AG & yrprint_AG = ygarde_AG & zrprint_AG = zgarde_AG,""
             else,
             [
             old_x_print_AG = old_x_AG
             old_y_print_AG = old_y_AG
             old_z_print_AG = old_z_AG
             if retplangarde = 0, sr, *old_x_print_AG, *old_y_print_AG, *old_z_print_AG, paf, pgcode_force_AG, *old_x_print_AG, *old_y_print_AG, *old_z_print_AG, e$
             ]

            #if mi3$ = 0 & mr2print_AG <> -1,
            #    [
            #    gcode$ = 0
            #    sm, paf, pgcode_AG, *mr2print_AG ,e$
            #    sm, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, axeCpos1_AG, axeApos1_AG,e$, sm, paf, *zrprint_AG, e$
            #    ]
           #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_AG = old_z_AG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, sr, *xgarde_AG, *ygarde_AG, *zgarde_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG, *axeCpos1_AG, *axeApos1_AG, e$
                else,
                if nextop$ = 100, sr, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, e$     #orientationtete 
                else, sr, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, *axeCpos1_AG, *axeApos1_AG, e$     #orientationtete
              #   ]



            if xrprint_AG <> xgarde_AG | yrprint_AG <> ygarde_AG | zrprint_AG <> zgarde_AG,
            [
            if retplangarde <> 2, sr,*xgarde_AG, *ygarde_AG, *zgarde_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            sl, *xprint_AG, *yprint_AG, *zprint_AG,*frplunge$, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG,*frplunge$, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_AG <> zrprint_AG, sr, *xgarde_AG, *ygarde_AG, *zgarde_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$
                gcode$ = 0
                sr, *xrprint_AG, *yrprint_AG, *zrprint_AG, paf, pgcode_force_AG, *xrprint_AG, *yrprint_AG, *zrprint_AG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_AG = xdegvec + nextx$
                yrprintrap_AG = ydegvec + nexty$
                zrprintrap_AG = zdegvec + nextz$
                sr, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, paf, pgcode_force_AG, *xrprintrap_AG, *yrprintrap_AG, *zrprintrap_AG, e$
                ]

            ]
            else,   sr, *xgarde_AG, *ygarde_AG, *zgarde_AG, paf, pgcode_force_AG, *xgarde_AG, *ygarde_AG, *zgarde_AG,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG

            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG

            oldstation_AG = mi4_AG
            frbase_AG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
            tox4print_AG = ((Vx_AG/longvec) * (depth$ * -1)) + xprint_AG
            toy4print_AG = ((Vy_AG/longvec) * (depth$ * -1)) + yprint_AG
            toz4print_AG = ((Vz_AG/longvec) * (depth$ * -1)) + zprint_AG
            pvoir_AG


            if cycle_heli_spiral_AG = 0,
            [
                            if planperc = 0,    [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                ]
                                        else,   [
                                                xprint_AG = v_abs_plus_x_AG
                                                yprint_AG = v_abs_plus_y_AG
                                                zprint_AG = v_abs_plus_z_AG
                                                ]
                            if nextop$ <> 100, sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                            else, sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$ # retour a plan suite dernier usinage          
            #if nextop$ <> 100, sr, *old_dest_ret_5x_AG, paf, "G80", *old_dest_ret_5x_AG, e$
            #else, sr, *dest_ret_5x_AG, paf, "G80", *dest_ret_5x_AG,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
                            if planperc = 0,    [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                ]
                                        else,   [
                                                xprint_AG = v_abs_plus_x_AG
                                                yprint_AG = v_abs_plus_y_AG
                                                zprint_AG = v_abs_plus_z_AG
                                                ]
                            gcode$ = 0
                            if nextop$ <> 100, sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$
                            else, sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$ # retour a plan suite dernier usinage             
            #gcode$ = 0
            #if nextop$ <> 100, sr, *old_dest_ret_5x_AG, paf, pgcode_AG, *old_dest_ret_5x_AG, e$
            #else, sr, *dest_ret_5x_AG, paf, pgcode_AG , *dest_ret_5x_AG,e$ # retour a plan suite dernier usinage
            ]

			old_xprint_simu_AG = xprint_AG
			old_yprint_simu_AG = yprint_AG
			old_zprint_simu_AG = zprint_AG

            #if mi3$ = 0 & mr2print_AG <>   -1,
            #    [
            #    #pcalxyz3d_AG

            #    sm, paf, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            #    sm, paf, *mr2print_AG ,e$
            #    xaproche = (((Vx_AG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_AG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_AG = (((Vz_AG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_AG longvec et xaproche", *Vx_AG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    sm, paf,pgcode_force_AG, *xaproche, *yaproche, axeCpos1_AG, axeApos1_AG, e$
            #    ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_AG = 0, axeApos1_AG = 0, axeCpos_AG = 0, axeApos_AG = 0]
            gcode$ = 0
            sm, paf, "G151", axeCpos_AG, axeApos_AG, tox4print_AG, toy4print_AG, toz4print_AG, e$
            xprint_AG = 0
            yprint_AG = 0
            if nextop$ <> 100, zinitht_AG = old_dest_ret_5x_AG
            else, zinitht_AG = dest_ret_5x_AG
            zprint_AG = refht$
            # n, pgcode_force_AG, axeCpos1_AG, axeApos1_AG, e                    #orientation tete
            # n, pgcode_force_AG, *x, *y, *zinitht_AG,e          # dep au plan garde            
            if axeApos1_AG > maxi_a_AG | axeApos1_AG < mini_a_AG, psortie10_AG


            pcaldrilxyzsimu_AG
            xprint_AG = v_abs_plus_x_sec_AG
            yprint_AG = v_abs_plus_y_sec_AG
            zprint_AG = v_abs_plus_z_sec_AG
			prtcp_simu_AG
            sr, *xprint_AG, *yprint_AG, *zprint_AG, axeCpos1_AG, axeApos1_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, axeCpos1_AG, axeApos1_AG, e$                    #orientation tete+ garde
            old_v_abs_plus_x_sec_AG = v_abs_plus_x_sec_AG
            old_v_abs_plus_y_sec_AG = v_abs_plus_y_sec_AG
            old_v_abs_plus_z_sec_AG = v_abs_plus_z_sec_AG
            #sr, *xprint_AG, *yprint_AG, *zinitht_AG, *axeCpos1_AG, *axeApos1_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zinitht_AG, *axeCpos1_AG, *axeApos1_AG, e$                    #orientation tete+ garde
            #n, pgcode_force_AG, *x, *y, *z, e
            old_tox4_AG = tox4print_AG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AG = toy4print_AG
            old_toz4_AG = toz4print_AG
            old_axeCpos_AG = axeCpos_AG
            old_axeApos_AG = axeApos_AG
            oldreel_axeCpos_AG = reel_axeCpos_AG
            old_x_AG=xrprint_AG
            old_y_AG=yrprint_AG
            old_z_AG=zrprint_AG
            oldstation_AG = mi4_AG
            frbase_AG = fr$
            ]

pdrl5_2_BG   # ecriture percage suivant en 5 axes
		old_axeC_simu_BG = axeC_BG
		old_axeA_simu_BG = axeA_BG
        gcode$ = 0
        Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BG < 0, invers_BG = 1
														else, invers_BG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BG < 0, invers_BG = 0
														else, invers_BG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_BG = 0, pmxinvd_BG
        if invers_BG = 1, pmxinvg_BG
        pdebut_BG
        Vx_BG = u$ - x$
        Vy_BG = v$ - y$
        Vz_BG = w$ - z$
        axeCpos_BG = axeC_BG
        axeApos_BG = axeA_BG
        if mi1_C_base_BG <> 1 & mi1_C_base_BG <> 2, pessaicompteur_BG
        axeCpos1_BG = axeCpos_BG
        axeApos1_BG = axeApos_BG
        !axeApos1_BG,!axeCpos_BG
        if mr2print_BG = 0, mr2print_BG = zsecuprint
        prvmr2_BG = mr2print_BG

        if tete_rev_BG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_BG, !xgarde_BG, !yrprint_BG, !ygarde_BG, !zrprint_BG, !zgarde_BG

             if xrprint_BG = xgarde_BG & yrprint_BG = ygarde_BG & zrprint_BG = zgarde_BG,""
             else,
             [
             old_x_print_BG = old_x_BG
             old_y_print_BG = old_y_BG
             old_z_print_BG = old_z_BG
             if retplangarde = 0, sr, *old_x_print_BG, *old_y_print_BG, *old_z_print_BG, paf, pgcode_force_BG, *old_x_print_BG, *old_y_print_BG, *old_z_print_BG, e$
             ]

            #if mi3$ = 0 & mr2print_BG <> -1,
            #    [
            #    gcode$ = 0
            #    sm, paf, pgcode_BG, *mr2print_BG ,e$
            #    sm, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, axeCpos1_BG, axeApos1_BG,e$, sm, paf, *zrprint_BG, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_BG = old_z_BG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, sr, *xgarde_BG, *ygarde_BG, *zgarde_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG, *axeCpos1_BG, *axeApos1_BG, e$
                else,
                if nextop$ = 100, sr, *xrprint_BG, *yrprint_BG, *zrprint_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, *axeCpos1_BG, *axeApos1_BG, e$     #orientationtete 
                else, sr, *xrprint_BG, *yrprint_BG, *old_z_print_BG, *axeCpos1_BG, *axeApos1_BG, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *old_z_print_BG, *axeCpos1_BG, *axeApos1_BG, e$     #orientationtete

            #     ]



            if xrprint_BG <> xgarde_BG | yrprint_BG <> ygarde_BG | zrprint_BG <> zgarde_BG,
            [
            if retplangarde <> 2, sr,*xgarde_BG, *ygarde_BG, *zgarde_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            sl, *xprint_BG, *yprint_BG, *zprint_BG,*frplunge$, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG,*frplunge$, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_BG <> zrprint_BG, sr, *xgarde_BG, *ygarde_BG, *zgarde_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$
                gcode$ = 0
                sr, *xrprint_BG, *yrprint_BG, *zrprint_BG, paf, pgcode_force_BG, *xrprint_BG, *yrprint_BG, *zrprint_BG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_BG = xdegvec + nextx$
                yrprintrap_BG = ydegvec + nexty$
                zrprintrap_BG = zdegvec + nextz$
                sr, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, paf, pgcode_force_BG, *xrprintrap_BG, *yrprintrap_BG, *zrprintrap_BG, e$
                ]

            ]
            else,   sr, *xgarde_BG, *ygarde_BG, *zgarde_BG, paf, pgcode_force_BG, *xgarde_BG, *ygarde_BG, *zgarde_BG,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG

            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG

            oldstation_BG = mi4_BG
            frbase_BG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_BG,yprint_BG    ,zprint_BG, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_BG = ((Vx_BG/longvec) * (depth$ * -1)) + xprint_BG
            toy4print_BG = ((Vy_BG/longvec) * (depth$ * -1)) + yprint_BG
            toz4print_BG = ((Vz_BG/longvec) * (depth$ * -1)) + zprint_BG
            pvoir_BG

            if cycle_heli_spiral_BG = 0,
            [
                            if planperc = 0,    [
                                                xprint_BG = old_v_abs_plus_x_sec_BG
                                                yprint_BG = old_v_abs_plus_y_sec_BG
                                                zprint_BG = old_v_abs_plus_z_sec_BG
                                                ]
                                        else,   [
                                                xprint_BG = v_abs_plus_x_BG
                                                yprint_BG = v_abs_plus_y_BG
                                                zprint_BG = v_abs_plus_z_BG
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
            else, sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$ # retour a plan suite dernier usinage           
            ]
            else,
            [
            if planperc = 0,    [
                                                xprint_BG = old_v_abs_plus_x_sec_BG
                                                yprint_BG = old_v_abs_plus_y_sec_BG
                                                zprint_BG = old_v_abs_plus_z_sec_BG
                                                ]
                                        else,   [
                                                xprint_BG = v_abs_plus_x_BG
                                                yprint_BG = v_abs_plus_y_BG
                                                zprint_BG = v_abs_plus_z_BG
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
            else, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$ # retour a plan suite dernier usinage 
            ]
			
			old_xprint_simu_BG = xprint_BG
			old_yprint_simu_BG = yprint_BG
			old_zprint_simu_BG = zprint_BG
			
            #if mi3$ = 0 & mr2print_BG <>   -1,
            #    [
            #    #pcalxyz3d_BG
            #
            #    panul_plan_inc_BG
            #    sm, paf, *mr2print_BG ,e$
            #    xaproche = (((Vx_BG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_BG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_BG = (((Vz_BG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_BG longvec et xaproche", *Vx_BG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    sm, paf,pgcode_force_BG, *xaproche, *yaproche, axeCpos1_BG, axeApos1_BG, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_BG = 0, axeApos1_BG = 0, axeCpos_BG = 0, axeApos_BG = 0]
            gcode$ = 0
            sm, paf, "TRANS", e$, sm, paf, "ROT", e$
            sm, paf, "TRANS", tox4print_BG, toy4print_BG, toz4print_BG, e$, sm, paf, "AROT", axeCpos_BG, axeApos_BG, e$
            xprint_BG = 0
            yprint_BG = 0
            if nextop$ <> 100, zinitht_BG = old_dest_ret_5x_BG
            else, zinitht_BG = dest_ret_5x_BG
            zprint_BG = refht$
            # n, pgcode_force_BG, axeCpos1_BG, axeApos1_BG, e                    #orientation tete
            # n, pgcode_force_BG, *x, *y, *zinitht_BG,e          # dep au plan garde            
            if axeApos1_BG > maxi_a_BG | axeApos1_BG < mini_a_BG, psortie10_BG
            pcaldrilxyzsimu_BG
            xprint_BG = v_abs_plus_x_sec_BG
            yprint_BG = v_abs_plus_y_sec_BG
            zprint_BG = v_abs_plus_z_sec_BG
			prtcp_simu_BG
            sr, *xprint_BG, *yprint_BG, *zprint_BG, axeCpos1_BG, axeApos1_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, axeCpos1_BG, axeApos1_BG, e$                    #orientation tete+ garde
            old_v_abs_plus_x_sec_BG = v_abs_plus_x_sec_BG
            old_v_abs_plus_y_sec_BG = v_abs_plus_y_sec_BG
            old_v_abs_plus_z_sec_BG = v_abs_plus_z_sec_BG

            #n, pgcode_force_BG, *x, *y, *z, e

            old_tox4_BG = tox4print_BG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BG = toy4print_BG
            old_toz4_BG = toz4print_BG
            old_axeCpos_BG = axeCpos_BG
            old_axeApos_BG = axeApos_BG
            oldreel_axeCpos_BG = reel_axeCpos_BG
            old_x_BG=xrprint_BG
            old_y_BG=yrprint_BG
            old_z_BG=zrprint_BG
            oldstation_BG = mi4_BG
            frbase_BG = fr$
            ]

pdrl5_2_CG   # ecriture percage suivant en 5 axes
		old_axeC_simu_CG = axeC_CG
		old_axeA_simu_CG = axeA_CG
        gcode$ = 0
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CG < 0, invers_CG = 1
														else, invers_CG = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CG < 0, invers_CG = 0
														else, invers_CG = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_CG = 0, pmxinvd_CG
        if invers_CG = 1, pmxinvg_CG
        pdebut_CG
        Vx_CG = u$ - x$
        Vy_CG = v$ - y$
        Vz_CG = w$ - z$
        axeCpos_CG = axeC_CG
        axeApos_CG = axeA_CG
        if mi1_C_base_CG <> 1 & mi1_C_base_CG <> 2, pessaicompteur_CG
        axeCpos1_CG = axeCpos_CG
        axeApos1_CG = axeApos_CG
        axeCpos_CG = axeCpos_CG + 90
        !axeApos1_CG,!axeCpos_CG
        if mr2print_CG = 0, mr2print_CG = zsecuprint
        prvmr2_CG = mr2print_CG

        if tete_rev_CG = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_CG, !xgarde_CG, !yrprint_CG, !ygarde_CG, !zrprint_CG, !zgarde_CG

             if xrprint_CG = xgarde_CG & yrprint_CG = ygarde_CG & zrprint_CG = zgarde_CG,""
             else,
             [
             old_x_print_CG = old_x_CG
             old_y_print_CG = old_y_CG
             old_z_print_CG = old_z_CG
             if retplangarde = 0, sr, *old_x_print_CG, *old_y_print_CG, *old_z_print_CG, paf, pgcode_force_CG, *old_x_print_CG, *old_y_print_CG, *old_z_print_CG, e$
             ]

            #if mi3$ = 0 & mr2print_CG <> -1,
            #    [
            #    gcode$ = 0
            #    sm, paf, pgcode_CG, *mr2print_CG ,e$
            #    sm, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, axeCpos1_CG, axeApos1_CG,e$, sm, paf, *zrprint_CG, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                old_z_print_CG = old_z_CG
				if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        		if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, sr, *xgarde_CG, *ygarde_CG, *zgarde_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG, *axeCpos1_CG, *axeApos1_CG, e$
                else,
                if nextop$ = 100, sr, *xrprint_CG, *yrprint_CG, *zrprint_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, *axeCpos1_CG, *axeApos1_CG, e$     #orientationtete 
                else, sr, *xrprint_CG, *yrprint_CG, *old_z_print_CG, *axeCpos1_CG, *axeApos1_CG, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *old_z_print_CG, *axeCpos1_CG, *axeApos1_CG, e$     #orientationtete

            #     ]



            if xrprint_CG <> xgarde_CG | yrprint_CG <> ygarde_CG | zrprint_CG <> zgarde_CG,
            [
            if retplangarde <> 2, sr,*xgarde_CG, *ygarde_CG, *zgarde_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            sl, *xprint_CG, *yprint_CG, *zprint_CG,*frplunge$, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG,*frplunge$, e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_CG <> zrprint_CG, sr, *xgarde_CG, *ygarde_CG, *zgarde_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$
                gcode$ = 0
                sr, *xrprint_CG, *yrprint_CG, *zrprint_CG, paf, pgcode_force_CG, *xrprint_CG, *yrprint_CG, *zrprint_CG, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_CG = xdegvec + nextx$
                yrprintrap_CG = ydegvec + nexty$
                zrprintrap_CG = zdegvec + nextz$
                sr, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, paf, pgcode_force_CG, *xrprintrap_CG, *yrprintrap_CG, *zrprintrap_CG, e$
                ]

            ]
            else,   sr, *xgarde_CG, *ygarde_CG, *zgarde_CG, paf, pgcode_force_CG, *xgarde_CG, *ygarde_CG, *zgarde_CG,e$                        # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG

            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG

            oldstation_CG = mi4_CG
            frbase_CG = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_CG,yprint_CG    ,zprint_CG, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_CG = ((Vx_CG/longvec) * (depth$ * -1)) + xprint_CG
            toy4print_CG = ((Vy_CG/longvec) * (depth$ * -1)) + yprint_CG
            toz4print_CG = ((Vz_CG/longvec) * (depth$ * -1)) + zprint_CG
            pvoir_CG

            if cycle_heli_spiral_CG = 0,
            [
                            if planperc = 0,    [
                                                xprint_CG = old_v_abs_plus_x_sec_CG
                                                yprint_CG = old_v_abs_plus_y_sec_CG
                                                zprint_CG = old_v_abs_plus_z_sec_CG
                                                ]
                                        else,   [
                                                xprint_CG = v_abs_plus_x_CG
                                                yprint_CG = v_abs_plus_y_CG
                                                zprint_CG = v_abs_plus_z_CG
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
            else, sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$ # retour a plan suite dernier usinage           
            ]
            else,
            [
            if planperc = 0,    [
                                                xprint_CG = old_v_abs_plus_x_sec_CG
                                                yprint_CG = old_v_abs_plus_y_sec_CG
                                                zprint_CG = old_v_abs_plus_z_sec_CG
                                                ]
                                        else,   [
                                                xprint_CG = v_abs_plus_x_CG
                                                yprint_CG = v_abs_plus_y_CG
                                                zprint_CG = v_abs_plus_z_CG
                                                ]
            gcode$ = 0
            if nextop$ <> 100, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
            else, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$ # retour a plan suite dernier usinage 
            ]
			
			old_xprint_simu_CG = xprint_CG
			old_yprint_simu_CG = yprint_CG
			old_zprint_simu_CG = zprint_CG
            #if mi3$ = 0 & mr2print_CG <>   -1,
            #    [
            #    #pcalxyz3d_CG
            #
            #    panul_plan_inc_CG
            #    sm, paf, *mr2print_CG ,e$
            #    xaproche = (((Vx_CG/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_CG/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_CG = (((Vz_CG/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_CG longvec et xaproche", *Vx_CG, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    sm, paf,pgcode_force_CG, *xaproche, *yaproche, axeCpos1_CG, axeApos1_CG, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_CG = 0, axeApos1_CG = 0, axeCpos_CG = 0, axeApos_CG = 0]
            gcode$ = 0
            if blocaxe_CG = 1, sm, paf, "M31 ; DEBLOCAGE AXE B", e$, sm, paf, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CG = 0
            sm, paf, "TRANS", e$, sm, paf, "ROT", e$
            sm, paf, "TRANS", tox4print_CG, toy4print_CG, toz4print_CG, e$, sm, paf, "AROT", axeCpos_CG, axeApos_CG, e$
            xprint_CG = 0
            yprint_CG = 0
            if nextop$ <> 100, zinitht_CG = old_dest_ret_5x_CG
            else, zinitht_CG = dest_ret_5x_CG
            zprint_CG = refht$
            # n, pgcode_force_CG, axeCpos1_CG, axeApos1_CG, e                    #orientation tete
            # n, pgcode_force_CG, *x, *y, *zinitht_CG,e          # dep au plan garde            
            if axeApos1_CG > maxi_a_CG | axeApos1_CG < mini_a_CG, psortie10_CG

            pcaldrilxyzsimu_CG
            xprint_CG = v_abs_plus_x_sec_CG
            yprint_CG = v_abs_plus_y_sec_CG
            zprint_CG = v_abs_plus_z_sec_CG
			prtcp_simu_CG
			if axeCpos1_CG > maxi_c_CG, psortie_ratrap_planinc_deroul_CG
        	if axeCpos1_CG < mini_c_CG, psortie_ratrap_planinc_enroul_CG
            sr, *xprint_CG, *yprint_CG, *zprint_CG, axeCpos1_CG, axeApos1_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, axeCpos1_CG, axeApos1_CG, e$                    #orientation tete+ garde
            old_v_abs_plus_x_sec_CG = v_abs_plus_x_sec_CG
            old_v_abs_plus_y_sec_CG = v_abs_plus_y_sec_CG
            old_v_abs_plus_z_sec_CG = v_abs_plus_z_sec_CG

            #n, pgcode_force_CG, *x, *y, *z, e
            sm, paf, "M32 ; BLOCAGE AXE B", e$, sm, paf, "M34 ; BLOCAGE AXE C", e$, blocaxe_CG = 1
            old_tox4_CG = tox4print_CG    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CG = toy4print_CG
            old_toz4_CG = toz4print_CG
            old_axeCpos_CG = axeCpos_CG
            old_axeApos_CG = axeApos_CG
            oldreel_axeCpos_CG = reel_axeCpos_CG
            old_x_CG=xrprint_CG
            old_y_CG=yrprint_CG
            old_z_CG=zrprint_CG
            oldstation_CG = mi4_CG
            frbase_CG = fr$
            ]

pdrl5_2_AM   # ecriture percage suivant en 5 axes
        gcode$ = 0
		Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        if t$ = tete_rev_ang_11 | t$ = tete_rev_ang_21,	[
														if Vz_AM < 0, invers_AM = 1
														else, invers_AM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if t$ = tete_rev_ang_12 | t$ = tete_rev_ang_22, [
														if Vz_AM < 0, invers_AM = 0
														else, invers_AM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_AM = 0, pmxinvd_AM
        if invers_AM = 1, pmxinvg_AM
        pdebut_AM
        Vx_AM = u$ - x$
        Vy_AM = v$ - y$
        Vz_AM = w$ - z$
        axeCpos_AM = axeC_AM
        axeApos_AM = axeA_AM
        if mi1_C_base_AM <> 1 & mi1_C_base_AM <> 2, pessaicompteur_AM
        axeCpos1_AM = axeCpos_AM
        axeApos1_AM = axeApos_AM
        !axeApos1_AM,!axeCpos_AM
        if mr2print_AM = 0, mr2print_AM = zsecuprint
        prvmr2_AM = mr2print_AM

        if tete_rev_AM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 
            #pnumligne,"G151 EC0. EA0. EU0. EV0. EW0.", e$
            !xrprint_AM, !xgarde_AM, !yrprint_AM, !ygarde_AM, !zrprint_AM, !zgarde_AM

             if xrprint_AM = xgarde_AM & yrprint_AM = ygarde_AM & zrprint_AM = zgarde_AM,""
             else,
             [
             old_x_print_AM = old_x_AM
             old_y_print_AM = old_y_AM
             old_z_print_AM = old_z_AM
             if retplangarde = 0, pnumligne, pgcode_force_AM, *old_x_print_AM, *old_y_print_AM, *old_z_print_AM, e$
             ]

            #if mi3$ = 0 & mr2print_AM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_AM, *mr2print_AM ,e$
            #    pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, axeCpos1_AM, axeApos1_AM,e$, pnumligne, *zrprint_AM, e$
            #    ]
           #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_AM = old_z_AM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM, axeCpos1_AM, axeApos1_AM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete 
                else, pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, axeCpos1_AM, axeApos1_AM, e$     #orientationtete
              #   ]



            if xrprint_AM <> xgarde_AM | yrprint_AM <> ygarde_AM | zrprint_AM <> zgarde_AM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            frplunge_AM = frplunge$
            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zprint_AM,frplunge_AM e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_AM <> zrprint_AM, pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$
                gcode$ = 0
                pnumligne, pgcode_force_AM, *xrprint_AM, *yrprint_AM, *zrprint_AM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_AM = xdegvec + nextx$
                yrprintrap_AM = ydegvec + nexty$
                zrprintrap_AM = zdegvec + nextz$
                pnumligne,pgcode_force_AM, *xrprintrap_AM, *yrprintrap_AM, *zrprintrap_AM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_AM, *xgarde_AM, *ygarde_AM, *zgarde_AM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM

            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM

            oldstation_AM = mi4_AM
            frbase_AM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
            tox4print_AM = ((Vx_AM/longvec) * (depth$ * -1)) + xprint_AM
            toy4print_AM = ((Vy_AM/longvec) * (depth$ * -1)) + yprint_AM
            toz4print_AM = ((Vz_AM/longvec) * (depth$ * -1)) + zprint_AM
            pvoir_AM


            if cycle_heli_spiral_AM = 0,
            [
            if nextop$ <> 100, pnumligne, "G80", *old_dest_ret_5x_AM, e$
            else, pnumligne, "G80", *dest_ret_5x_AM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_AM, *old_dest_ret_5x_AM, e$
            else, pnumligne, pgcode_AM , *dest_ret_5x_AM,e$ # retour a plan suite dernier usinage
            ]


            #if mi3$ = 0 & mr2print_AM <>   -1,
            #    [
            #    #pcalxyz3d_AM

            #    pnumligne, "G151 EC0. EA0. EU0. EV0. EW0.", e$
            #    pnumligne, *mr2print_AM ,e$
            #    xaproche = (((Vx_AM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_AM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_AM = (((Vz_AM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_AM longvec et xaproche", *Vx_AM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_AM, *xaproche, *yaproche, axeCpos1_AM, axeApos1_AM, e$
            #    ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_AM = 0, axeApos1_AM = 0, axeCpos_AM = 0, axeApos_AM = 0]
            gcode$ = 0
            pnumligne, "G151", axeCpos_AM, axeApos_AM, tox4print_AM, toy4print_AM, toz4print_AM, e$
            xprint_AM = 0
            yprint_AM = 0
            if nextop$ <> 100, zinitht_AM = old_dest_ret_5x_AM
            else, zinitht_AM = dest_ret_5x_AM
            zprint_AM = refht$
            # n, pgcode_force_AM, axeCpos1_AM, axeApos1_AM, e                    #orientation tete
            # n, pgcode_force_AM, *x, *y, *zinitht_AM,e          # dep au plan garde            
            if axeApos1_AM > maxi_a_AM | axeApos1_AM < mini_a_AM, psortie10_AM
            pnumligne, pgcode_force_AM, *xprint_AM, *yprint_AM, *zinitht_AM, axeCpos1_AM, axeApos1_AM, e$                    #orientation tete+ garde
            #n, pgcode_force_AM, *x, *y, *z, e
            old_tox4_AM = tox4print_AM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_AM = toy4print_AM
            old_toz4_AM = toz4print_AM
            old_axeCpos_AM = axeCpos_AM
            old_axeApos_AM = axeApos_AM
            oldreel_axeCpos_AM = reel_axeCpos_AM
            old_x_AM=xrprint_AM
            old_y_AM=yrprint_AM
            old_z_AM=zrprint_AM
            oldstation_AM = mi4_AM
            frbase_AM = fr$
            ]

pdrl5_2_BM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_BM < 0, invers_BM = 1
														else, invers_BM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_BM < 0, invers_BM = 0
														else, invers_BM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_BM = 0, pmxinvd_BM
        if invers_BM = 1, pmxinvg_BM
        pdebut_BM
        Vx_BM = u$ - x$
        Vy_BM = v$ - y$
        Vz_BM = w$ - z$
        axeCpos_BM = axeC_BM
        axeApos_BM = axeA_BM
        if mi1_C_base_BM <> 1 & mi1_C_base_BM <> 2, pessaicompteur_BM
        axeCpos1_BM = axeCpos_BM
        axeApos1_BM = axeApos_BM
        !axeApos1_BM,!axeCpos_BM
        if mr2print_BM = 0, mr2print_BM = zsecuprint
        prvmr2_BM = mr2print_BM

        if tete_rev_BM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_BM, !xgarde_BM, !yrprint_BM, !ygarde_BM, !zrprint_BM, !zgarde_BM

             if xrprint_BM = xgarde_BM & yrprint_BM = ygarde_BM & zrprint_BM = zgarde_BM,""
             else,
             [
             old_x_print_BM = old_x_BM
             old_y_print_BM = old_y_BM
             old_z_print_BM = old_z_BM
             if retplangarde = 0, pnumligne, pgcode_force_BM, *old_x_print_BM, *old_y_print_BM, *old_z_print_BM, e$
             ]

            #if mi3$ = 0 & mr2print_BM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_BM, *mr2print_BM ,e$
            #    pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, axeCpos1_BM, axeApos1_BM,e$, pnumligne, *zrprint_BM, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_BM = old_z_BM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM, axeCpos1_BM, axeApos1_BM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete 
                else, pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *old_z_print_BM, axeCpos1_BM, axeApos1_BM, e$     #orientationtete
            #     ]



            if xrprint_BM <> xgarde_BM | yrprint_BM <> ygarde_BM | zrprint_BM <> zgarde_BM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            frplunge_BM = frplunge$
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zprint_BM,frplunge_BM e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_BM <> zrprint_BM, pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$
                gcode$ = 0
                pnumligne, pgcode_force_BM, *xrprint_BM, *yrprint_BM, *zrprint_BM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_BM = xdegvec + nextx$
                yrprintrap_BM = ydegvec + nexty$
                zrprintrap_BM = zdegvec + nextz$
                pnumligne,pgcode_force_BM, *xrprintrap_BM, *yrprintrap_BM, *zrprintrap_BM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_BM, *xgarde_BM, *ygarde_BM, *zgarde_BM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM

            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM

            oldstation_BM = mi4_BM
            frbase_BM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_BM,yprint_BM    ,zprint_BM, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_BM = ((Vx_BM/longvec) * (depth$ * -1)) + xprint_BM
            toy4print_BM = ((Vy_BM/longvec) * (depth$ * -1)) + yprint_BM
            toz4print_BM = ((Vz_BM/longvec) * (depth$ * -1)) + zprint_BM
            pvoir_BM

            if cycle_heli_spiral_BM = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_BM, *old_dest_ret_5x_BM,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_BM, *dest_ret_5x_BM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_BM, *old_dest_ret_5x_BM, e$
            else, pnumligne, pgcode_BM , *dest_ret_5x_BM,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_BM <>   -1,
            #    [
            #    #pcalxyz3d_BM
            #
            #    panul_plan_inc_BM
            #    pnumligne, *mr2print_BM ,e$
            #    xaproche = (((Vx_BM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_BM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_BM = (((Vz_BM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_BM longvec et xaproche", *Vx_BM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_BM, *xaproche, *yaproche, axeCpos1_BM, axeApos1_BM, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_BM = 0, axeApos1_BM = 0, axeCpos_BM = 0, axeApos_BM = 0]
            gcode$ = 0
            pnumligne, "TRANS", e$, pnumligne, "ROT", e$
            pnumligne, "TRANS", tox4print_BM, toy4print_BM, toz4print_BM, e$, pnumligne, "AROT", axeCpos_BM, axeApos_BM, e$
            xprint_BM = 0
            yprint_BM = 0
            if nextop$ <> 100, zinitht_BM = old_dest_ret_5x_BM
            else, zinitht_BM = dest_ret_5x_BM
            zprint_BM = refht$
            # n, pgcode_force_BM, axeCpos1_BM, axeApos1_BM, e                    #orientation tete
            # n, pgcode_force_BM, *x, *y, *zinitht_BM,e          # dep au plan garde            
            if axeApos1_BM > maxi_a_BM | axeApos1_BM < mini_a_BM, psortie10_BM
            pnumligne, pgcode_force_BM, *xprint_BM, *yprint_BM, *zinitht_BM, axeCpos1_BM, axeApos1_BM, e$                    #orientation tete+ garde
            #n, pgcode_force_BM, *x, *y, *z, e
            old_tox4_BM = tox4print_BM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_BM = toy4print_BM
            old_toz4_BM = toz4print_BM
            old_axeCpos_BM = axeCpos_BM
            old_axeApos_BM = axeApos_BM
            oldreel_axeCpos_BM = reel_axeCpos_BM
            old_x_BM=xrprint_BM
            old_y_BM=yrprint_BM
            old_z_BM=zrprint_BM
            oldstation_BM = mi4_BM
            frbase_BM = fr$
            ]

pdrl5_2_CM   # ecriture percage suivant en 5 axes
        gcode$ = 0
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        if tete_rev_ang_droite = 1,	[
														if Vz_CM < 0, invers_CM = 1
														else, invers_CM = 0  # pas de choix sens A si tete a renvoi d'angle
														]
        if tete_rev_ang_gauche = 1, [
														if Vz_CM < 0, invers_CM = 0
														else, invers_CM = 1  # pas de choix sens A si tete a renvoi d'angle
														]
        if invers_CM = 0, pmxinvd_CM
        if invers_CM = 1, pmxinvg_CM
        pdebut_CM
        Vx_CM = u$ - x$
        Vy_CM = v$ - y$
        Vz_CM = w$ - z$
        axeCpos_CM = axeC_CM
        axeApos_CM = axeA_CM
        if mi1_C_base_CM <> 1 & mi1_C_base_CM <> 2, pessaicompteur_CM
        axeCpos1_CM = axeCpos_CM
        axeApos1_CM = axeApos_CM
        axeCpos_CM = axeCpos_CM + 90
        !axeApos1_CM,!axeCpos_CM
        if mr2print_CM = 0, mr2print_CM = zsecuprint
        prvmr2_CM = mr2print_CM

        if tete_rev_CM = 1,
            [ # on est en mode percage 5 axes avec renvoi d'angle 

            !xrprint_CM, !xgarde_CM, !yrprint_CM, !ygarde_CM, !zrprint_CM, !zgarde_CM

             if xrprint_CM = xgarde_CM & yrprint_CM = ygarde_CM & zrprint_CM = zgarde_CM,""
             else,
             [
             old_x_print_CM = old_x_CM
             old_y_print_CM = old_y_CM
             old_z_print_CM = old_z_CM
             if retplangarde = 0, pnumligne, pgcode_force_CM, *old_x_print_CM, *old_y_print_CM, *old_z_print_CM, e$
             ]

            #if mi3$ = 0 & mr2print_CM <> -1,
            #    [
            #    gcode$ = 0
            #    pnumligne, pgcode_CM, *mr2print_CM ,e$
            #    pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, axeCpos1_CM, axeApos1_CM,e$, pnumligne, *zrprint_CM, e$
            #    ]
            #else,[
                #" voir nextop=", *nextop$, e$
                 old_z_print_CM = old_z_CM
                if retplangarde = 1 & nextop$ = 80, retplangarde = 2, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM, axeCpos1_CM, axeApos1_CM, e$
                else,
                if nextop$ = 100, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete 
                else, pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *old_z_print_CM, axeCpos1_CM, axeApos1_CM, e$     #orientationtete
            #     ]



            if xrprint_CM <> xgarde_CM | yrprint_CM <> ygarde_CM | zrprint_CM <> zgarde_CM,
            [
            if retplangarde <> 2, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
            ]
            else, retplangarde = 1
            gcode$ = 1
            frplunge_CM = frplunge$
            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zprint_CM,frplunge_CM e$                # percage
             if typepercage = 0, gcode$ = 0

            if nextop$ <> 100 | nextop$ > 1000,

            [
                if zgarde_CM <> zrprint_CM, pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$
                gcode$ = 0
                pnumligne, pgcode_force_CM, *xrprint_CM, *yrprint_CM, *zrprint_CM, e$            # retour plan de secu le sup a 1000 est du a un bug de master
                if nextx$ <> 9999 & nexty$ <> 9999 & nextz$ <> 9999,
                [
                xrprintrap_CM = xdegvec + nextx$
                yrprintrap_CM = ydegvec + nexty$
                zrprintrap_CM = zdegvec + nextz$
                pnumligne,pgcode_force_CM, *xrprintrap_CM, *yrprintrap_CM, *zrprintrap_CM, e$
                ]

            ]
            else,   pnumligne, pgcode_force_CM, *xgarde_CM, *ygarde_CM, *zgarde_CM,e$                         # dep au plan garde 
             if typepercage = 1, gcode$ = 0
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM

            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM

            oldstation_CM = mi4_CM
            frbase_CM = fr$

            ] # on sort du mode percage 5 axes avec renvoi d'angle 
         else,
            [
           # " voir ici ", xprint_CM,yprint_CM    ,zprint_CM, e$
            #" voir xyz", *x$, *y$, *z$, e$
            tox4print_CM = ((Vx_CM/longvec) * (depth$ * -1)) + xprint_CM
            toy4print_CM = ((Vy_CM/longvec) * (depth$ * -1)) + yprint_CM
            toz4print_CM = ((Vz_CM/longvec) * (depth$ * -1)) + zprint_CM
            pvoir_CM

            if cycle_heli_spiral_CM = 0,
            [
                gcode$ = 0
            if nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, pgcode_CM, *old_dest_ret_5x_CM,e$
            else, pnumligne, "MCALL", e$, pnumligne, pgcode_CM, *dest_ret_5x_CM,e$ # retour a plan suite dernier usinage
            ]
            else,
            [
            gcode$ = 0
            if nextop$ <> 100, pnumligne, pgcode_CM, *old_dest_ret_5x_CM, e$
            else, pnumligne, pgcode_CM , *dest_ret_5x_CM,e$ # retour a plan suite dernier usinage
            ]
            #if mi3$ = 0 & mr2print_CM <>   -1,
            #    [
            #    #pcalxyz3d_CM
            #
            #    panul_plan_inc_CM
            #    pnumligne, *mr2print_CM ,e$
            #    xaproche = (((Vx_CM/longvec) * (initht$ - refht$) ) + ucal)
            #    yaproche = (((Vy_CM/longvec) * (initht$ - refht$) ) + vcal)
            #    zaproche_CM = (((Vz_CM/longvec) * (initht$ - refht$) ) + wcal)
            #    #"voir Vx_CM longvec et xaproche", *Vx_CM, *longvec, xaproche, e$
            #    #"----",uprint, vprint,*refht$, * e$
            #    pnumligne,pgcode_force_CM, *xaproche, *yaproche, axeCpos1_CM, axeApos1_CM, e$
            #   ]
            if (x$ = u$) & (y$ = v$), [axeCpos1_CM = 0, axeApos1_CM = 0, axeCpos_CM = 0, axeApos_CM = 0]
            gcode$ = 0
            if blocaxe_CM = 1, pnumligne, "M31 ; DEBLOCAGE AXE B", e$, pnumligne, "M33 ; DEBLOCAGE AXE C", e$, blocaxe_CM = 0
            pnumligne, "TRANS", e$, pnumligne, "ROT", e$
            pnumligne, "TRANS", tox4print_CM, toy4print_CM, toz4print_CM, e$, pnumligne, "AROT", axeCpos_CM, axeApos_CM, e$
            xprint_CM = 0
            yprint_CM = 0
            if nextop$ <> 100, zinitht_CM = old_dest_ret_5x_CM
            else, zinitht_CM = dest_ret_5x_CM
            zprint_CM = refht$
            # n, pgcode_force_CM, axeCpos1_CM, axeApos1_CM, e                    #orientation tete
            # n, pgcode_force_CM, *x, *y, *zinitht_CM,e          # dep au plan garde            
            if axeApos1_CM > maxi_a_CM | axeApos1_CM < mini_a_CM, psortie10_CM
            pnumligne, pgcode_force_CM, *xprint_CM, *yprint_CM, *zinitht_CM, axeCpos1_CM, axeApos1_CM, e$                    #orientation tete+ garde
            #n, pgcode_force_CM, *x, *y, *z, e
            pnumligne, "M32 ; BLOCAGE AXE B", e$, pnumligne, "M34 ; BLOCAGE AXE C", e$, blocaxe_CM = 1
            old_tox4_CM = tox4print_CM    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
            old_toy4_CM = toy4print_CM
            old_toz4_CM = toz4print_CM
            old_axeCpos_CM = axeCpos_CM
            old_axeApos_CM = axeApos_CM
            oldreel_axeCpos_CM = reel_axeCpos_CM
            old_x_CM=xrprint_CM
            old_y_CM=yrprint_CM
            old_z_CM=zrprint_CM
            oldstation_CM = mi4_CM
            frbase_CM = fr$
            ]
#endregion
#region pdrill
pdrill$
            pchange_AG
            pdrill_AG

            pchange_AM
            pdrill_AM

            pchange_BG
            pdrill_BG

            pchange_BM
            pdrill_BM

            pchange_CG
            pdrill_CG

            pchange_CM
            pdrill_CM

pdrill_AG      # Cycle de percage G81
            #pvoir_AG
            if strcom_AG = svide, strcom_AG = "PERCAGE SIMPLE", "MW_OP_COMMENT", strcom_AG, e$
            pprint_AG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_AG = 1, pdrl5_AG

            if tete_rev_AG = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AG , @inithtprint_AG
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$ , paf, pgcode_AG, *depthprint_AG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
           ]
           if tete_rev_AG = 0,
           [
            if drill5axes_AG = 1,
                    [
                    pcaldrilxyzsimu_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf,"G81", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *frplunge$, e$
                    #if  nextop$ <> 100, sm, paf, "G80", *old_zinitht_AG, e$

                    if  nextop$ <> 100, [
                                        xprint_AG = old_v_abs_plus_x_sec_AG
                                        yprint_AG = old_v_abs_plus_y_sec_AG
                                        zprint_AG = old_v_abs_plus_z_sec_AG
                                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                        ]
                    ]

            else,   [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G81", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$, e$
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]

            typcycle_AG = 1
           ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pdrill_BG      # Cycle de percage G81
            if strcom_BG = svide, strcom_BG = "PERCAGE SIMPLE", "MW_OP_COMMENT", strcom_BG, e$
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes_BG = 1, tosz$ = 0
            #pvoir_BG
            sdis_BG = refht$ - tosz$
            pprint_BG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_BG = 1, pdrl5_BG

           if tete_rev_BG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_BG , @inithtprint_BG
                sr, *xprint_BG, *yprint_BG, *inithtprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
                if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
                gcode$ = 1
                sl, *depthprint_BG, *frplunge$ , paf, pgcode_BG, *depthprint_BG, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint_BG, paf, pgcode_BG, *inithtprint_BG, e$
                ]
           if tete_rev_BG = 0,
                [
                if drill5axes_BG = 1,
                    [
                    pcaldrilxyzsimu_BG
                    initht5x_BG = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                    spaces$ = 1
                    #sm, paf, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    #sm, paf, "G81", xprint_BG, yprint_BG, *depth$, *refht$, *initht5x_BG, frplunge$, e$        
                    if  nextop$ <> 100, [
                                        xprint_BG = old_v_abs_plus_x_sec_BG
                                        yprint_BG = old_v_abs_plus_y_sec_BG
                                        zprint_BG = old_v_abs_plus_z_sec_BG
                                        sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                    spaces$ = 1
                    pcaldrilxyzsimu_BG
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    gcode$ = 0
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    #sm, paf, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    typcycle_BG = 1
                    ]
                ]
           old_dest_ret_5x_BG = dest_ret_5x_BG

pdrill_CG      # Cycle de percage G81
            if strcom_CG = svide, strcom_CG = "PERCAGE SIMPLE", "MW_OP_COMMENT", strcom_CG, e$
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes_CG = 1, tosz$ = 0
            #pvoir_CG
            sdis_CG = refht$ - tosz$
            pprint_CG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_CG = 1, pdrl5_CG

           if tete_rev_CG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_CG , @inithtprint_CG
                sr, *xprint_CG, *yprint_CG, *inithtprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
                if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
                gcode$ = 1
                sl, *depthprint_CG, *frplunge$ , paf, pgcode_CG, *depthprint_CG, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint_CG, paf, pgcode_CG, *inithtprint_CG, e$
                ]
           if tete_rev_CG = 0,
                [
                if drill5axes_CG = 1,
                    [
                    pcaldrilxyzsimu_CG
                    initht5x_CG = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                    spaces$ = 1
                    #sm, paf, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    #sm, paf, "G81", xprint_CG, yprint_CG, *depth$, *refht$, *initht5x_CG, frplunge$, e$        
                    if  nextop$ <> 100, [
                                        xprint_CG = old_v_abs_plus_x_sec_CG
                                        yprint_CG = old_v_abs_plus_y_sec_CG
                                        zprint_CG = old_v_abs_plus_z_sec_CG
                                        sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                    spaces$ = 1
                    pcaldrilxyzsimu_CG
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    gcode$ = 0
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    #sm, paf, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    typcycle_CG = 1
                    ]
                ]
           old_dest_ret_5x_CG = dest_ret_5x_CG

pdrill_AM      # Cycle de percage G81
            #pvoir_AM

            pprint_AM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_AM = 1, pdrl5_AM

            if tete_rev_AM = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AM , @inithtprint_AM
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           gcode$ = 0
           pnumligne, pgcode_AM, inithtprint_AM, e$
           ]
           if tete_rev_AM = 0,
           [
            if drill5axes_AM = 1,
                    [
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    frplunge_AM = frplunge$
                    pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM, e$
                    if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                    ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM, e$
                    ]
            typcycle_AM = 1
           ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pdrill_BM      # Cycle de percage G81
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes_BM = 1, tosz$ = 0
            #pvoir_BM
            sdis_BM = refht$ - tosz$
            pprint_BM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_BM = 1, pdrl5_BM

           if tete_rev_BM = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_BM , @inithtprint_BM
                pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
                gcode$ = 1
                frplunge_BM = frplunge$
                pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
                gcode$ = 0
                pnumligne, pgcode_BM, inithtprint_BM, e$
                ]
           if tete_rev_BM = 0,
                [
                if drill5axes_BM = 1,
                    [
                    initht5x_BM = refht$
                    frplunge_BM = frplunge$
                    pnumligne, frplunge_BM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BM, *yprint_BM, e$
                    psouf_imp_BM
                    #pnumligne, "G81", xprint_BM, yprint_BM, *depth$, *refht$, *initht5x_BM, frplunge_BM, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                    ]
                else,
                    [
                    frplunge_BM = frplunge$
                    pnumligne, frplunge_BM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_BM, *yprint_BM, e$
                    psouf_imp_BM
                    typcycle_BM = 1
                    ]
                ]
           old_dest_ret_5x_BM = dest_ret_5x_BM

pdrill_CM      # Cycle de percage G81
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
			if drill5axes_CM = 1, tosz$ = 0
            #pvoir_CM
            sdis_CM = refht$ - tosz$
            pprint_CM
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_CM = 1, pdrl5_CM

           if tete_rev_CM = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_CM , @inithtprint_CM
                pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
                gcode$ = 1
                frplunge_CM = frplunge$
                pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
                gcode$ = 0
                pnumligne, pgcode_CM, inithtprint_CM, e$
                ]
           if tete_rev_CM = 0,
                [
                if drill5axes_CM = 1,
                    [
                    initht5x_CM = refht$
                    frplunge_CM = frplunge$
                    pnumligne, frplunge_CM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CM, *yprint_CM, e$
                    psouf_imp_CM
                    #pnumligne, "G81", xprint_CM, yprint_CM, *depth$, *refht$, *initht5x_CM, frplunge_CM, e$
                    if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                    ]
                else,
                    [
                    frplunge_CM = frplunge$
                    pnumligne, frplunge_CM, e$
                    spaces$ = 0
                    pnumligne, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                    spaces$ = 1
                    pnumligne, *xprint_CM, *yprint_CM, e$
                    psouf_imp_CM
                    typcycle_CM = 1
                    ]
                ]
           old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region ppeck
ppeck$
            pchange_AG
            ppeck_AG

            pchange_AM
            ppeck_AM

            pchange_BG
            ppeck_BG

            pchange_BM
            ppeck_BM

            pchange_CG
            ppeck_CG

            pchange_CM
            ppeck_CM

ppeck_AG     # Cycle de debourrage G83
            if strcom_AG = svide, strcom_AG = "PERCAGE DEBOURRAGE", "MW_OP_COMMENT", strcom_AG, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            pcaldrilxyzsimu_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            peck1_AG = peck1$
                            peck2_AG = peck2$
                            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G83", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *peck1_AG, *peck2_AG, *frplunge$,e$
                            if  nextop$ <> 100, [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                                ]
                            ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G83", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *peck1_AG, *peck2_AG, *frplunge$,e$
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]
            old_dest_ret_5x_AG = dest_ret_5x_AG

ppeck_BG     # Cycle de debourrage G83
            if strcom_BG = svide, strcom_BG = "PERCAGE DEBOURRAGE", "MW_OP_COMMENT", strcom_BG, e$
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
			sdis_BG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BG = 1
            if drill5axes_BG = 1,
                            [
                            pdrl5_BG
                            pcaldrilxyzsimu_BG
                            initht5x_BG = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0," MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG

                            if  nextop$ <> 100, [
                                                xprint_BG = old_v_abs_plus_x_sec_BG
                                                yprint_BG = old_v_abs_plus_y_sec_BG
                                                zprint_BG = old_v_abs_plus_z_sec_BG
                                                sm, paf, "MCALL", e$
                                                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                ]
                             ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_BG, *yprint_BG, e$
                            pcaldrilxyzsimu_BG
                            xprint_BG = v_abs_plus_x_BG
                            yprint_BG = v_abs_plus_y_BG
                            zprint_BG = v_abs_plus_z_BG
                            gcode$ = 0
                            sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                            psouf_imp_BG
                            ]
            old_dest_ret_5x_BG = dest_ret_5x_BG

ppeck_CG     # Cycle de debourrage G83
            if strcom_CG = svide, strcom_CG = "PERCAGE DEBOURRAGE", "MW_OP_COMMENT", strcom_CG, e$
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
			sdis_CG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CG = 1
            if drill5axes_CG = 1,
                            [
                            pdrl5_CG
                            pcaldrilxyzsimu_CG
                            initht5x_CG = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0," MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, [
                                                xprint_CG = old_v_abs_plus_x_sec_CG
                                                yprint_CG = old_v_abs_plus_y_sec_CG
                                                zprint_CG = old_v_abs_plus_z_sec_CG
                                                sm, paf, "MCALL", e$
                                                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                                ]
                            ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_CG, *yprint_CG, e$
                            pcaldrilxyzsimu_CG
                            xprint_CG = v_abs_plus_x_CG
                            yprint_CG = v_abs_plus_y_CG
                            zprint_CG = v_abs_plus_z_CG
                            gcode$ = 0
                            sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                            psouf_imp_CG
                            ]
            old_dest_ret_5x_CG = dest_ret_5x_CG

ppeck_AM     # Cycle de debourrage G83
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            peck1_AM = peck1$
                            peck2_AM = peck2$
                            frplunge_AM = frplunge$
                            pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                    ]
            old_dest_ret_5x_AM = dest_ret_5x_AM

ppeck_BM     # Cycle de debourrage G83
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
			sdis_BM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BM = 1
            if drill5axes_BM = 1,
                            [
                            pdrl5_BM
                            initht5x_BM = refht$
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                             ]
            else,
                            [
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            ]
            old_dest_ret_5x_BM = dest_ret_5x_BM

ppeck_CM     # Cycle de debourrage G83
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
			sdis_CM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CM = 1
            if drill5axes_CM = 1,
                            [
                            pdrl5_CM
                            initht5x_CM = refht$
                            frplunge_CM = frplunge$
                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                             ]
            else,
                            [
                            frplunge_CM = frplunge$
                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            ]
            old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region pchpbrk
pchpbrk$
            pchange_AG
            pchpbrk_AG

            pchange_AM
            pchpbrk_AM

            pchange_BG
            pchpbrk_BG

            pchange_BM
            pchpbrk_BM

            pchange_CG
            pchpbrk_CG

            pchange_CM
            pchpbrk_CM

pchpbrk_AG   # Cycle de brise copeaux G87
            if strcom_AG = svide, strcom_AG = "PERCAGE BRISE COPEAU", "MW_OP_COMMENT", strcom_AG, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            pcaldrilxyzsimu_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            peckclr_AG = peckclr$
                            peck1_AG = peck1$
                            peck2_AG = peck2$
                            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G87", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *peck1_AG, *peck2_AG, *peckclr_AG, *frplunge$,e$
                            if  nextop$ <> 100, [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                                ]
                             ]

           else,        [
                        depth_AG = depth$
                        refht_AG = refht$
                        dwell_AG = dwell$
                        initht_AG = initht$
                        peck1_AG = peck1$
                        peck2_AG = peck2$
                        sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G87", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *peck1_AG, *peck2_AG, *dwell_AG, *frplunge$,e$
                        pcaldrilxyzsimu_AG
                        xprint_AG = v_abs_plus_x_AG
                        yprint_AG = v_abs_plus_y_AG
                        zprint_AG = v_abs_plus_z_AG
                        gcode$ = 0
                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                        ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pchpbrk_BG   # Cycle de Cycle 83 en brise copeau
            if strcom_BG = svide, strcom_BG = "PERCAGE BRISE COPEAU", "MW_OP_COMMENT", strcom_BG, e$
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
			sdis_BG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BG = 1
            if drill5axes_BG = 1,
                            [
                            pdrl5_BG
                            pcaldrilxyzsimu_BG
                            initht5x_BG = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, [
                                                xprint_BG = old_v_abs_plus_x_sec_BG
                                                yprint_BG = old_v_abs_plus_y_sec_BG
                                                zprint_BG = old_v_abs_plus_z_sec_BG
                                                sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                ]
                             ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pcaldrilxyzsimu_BG
                            xprint_BG = v_abs_plus_x_BG
                            yprint_BG = v_abs_plus_y_BG
                            zprint_BG = v_abs_plus_z_BG
                            gcode$ = 0
                            sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                            #sm, paf, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            ]
            old_dest_ret_5x_BG = dest_ret_5x_BG

pchpbrk_CG   # Cycle de Cycle 83 en brise copeau
            if strcom_CG = svide, strcom_CG = "PERCAGE BRISE COPEAU", "MW_OP_COMMENT", strcom_CG, e$
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
			sdis_CG = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CG = 1
            if drill5axes_CG = 1,
                            [
                            pdrl5_CG
                            pcaldrilxyzsimu_CG
                            initht5x_CG = refht$
                            sm, paf, frplunge$, e$

                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, [
                                                xprint_CG = old_v_abs_plus_x_sec_CG
                                                yprint_CG = old_v_abs_plus_y_sec_CG
                                                zprint_CG = old_v_abs_plus_z_sec_CG
                                                sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                                ]
                             ]
            else,
                            [
                            sm, paf, frplunge$, e$

                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pcaldrilxyzsimu_CG
                            xprint_CG = v_abs_plus_x_CG
                            yprint_CG = v_abs_plus_y_CG
                            zprint_CG = v_abs_plus_z_CG
                            gcode$ = 0
                            sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                            #sm, paf, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            ]
            old_dest_ret_5x_CG = dest_ret_5x_CG

pchpbrk_AM   # Cycle de brise copeaux G87
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            peckclr_AM = peckclr$
                            peck1_AM = peck1$
                            peck2_AM = peck2$
                            frplunge_AM = frplunge$
                            pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, peckclr_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    dwell_AM = dwell$
                    initht_AM = initht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, peck1_AM, peck2_AM, dwell_AM, frplunge_AM,e$
                    ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pchpbrk_BM   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
			sdis_BM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_BM = 1
            if drill5axes_BM = 1,
                            [
                            pdrl5_BM
                            initht5x_BM = refht$
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                             ]
            else,
                            [
                            frplunge_BM = frplunge$
                            pnumligne, frplunge_BM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            ]
            old_dest_ret_5x_BM = dest_ret_5x_BM

pchpbrk_CM   # Cycle de Cycle 83 en brise copeau
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
			sdis_CM = refht$ - tosz$
            if peckclr$ > 100 | peckclr$ <=0, peckclr$ = 100
            peckclr$ = peckclr$ / 100 # passage de % en ratio


            typcycle_CM = 1
            if drill5axes_CM = 1,
                            [
                            pdrl5_CM
                            initht5x_CM = refht$
                            frplunge_CM = frplunge$
                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                             ]
            else,
                            [
                            frplunge_CM = frplunge$
                            pnumligne, frplunge_CM, e$
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            ]
            old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region ptap
ptap$
            pchange_AG
            ptap_AG

            pchange_AM
            ptap_AM

            pchange_BG
            ptap_BG

            pchange_BM
            ptap_BM

            pchange_CG
            ptap_CG

            pchange_CM
            ptap_CM

ptap_AG        # Cycle de taraudage G84
            if strcom_AG = svide, strcom_AG = "TARAUDAGE (9101)", "MW_OP_COMMENT", strcom_AG, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1

            if tldia$ = 3, pas_AG = 0.5
            if tldia$ = 4, pas_AG = 0.7
            if tldia$ = 5, pas_AG = 0.8
            if tldia$ = 6, pas_AG = 1
            if tldia$ = 8, pas_AG = 1.25
            if tldia$ = 10, pas_AG = 1.5
            if tldia$ = 12, pas_AG = 1.75
            if tldia$ = 14, pas_AG = 2
            if tldia$ = 16, pas_AG = 2
            if retr$ <> 0, pas_AG = retr$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G84", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *pas_AG,e$
            pcaldrilxyzsimu_AG
            xprint_AG = v_abs_plus_x_AG
            yprint_AG = v_abs_plus_y_AG
            zprint_AG = v_abs_plus_z_AG
            gcode$ = 0
            sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
            old_dest_ret_5x_AG = dest_ret_5x_AG

ptap_BG        # Cycle de taraudage G84
            psortie2_BG

ptap_CG        # Cycle de taraudage G84
            psortie2_CG

ptap_AM        # Cycle de taraudage G84
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1

            if tldia$ = 3, pas_AM = 0.5
            if tldia$ = 4, pas_AM = 0.7
            if tldia$ = 5, pas_AM = 0.8
            if tldia$ = 6, pas_AM = 1
            if tldia$ = 8, pas_AM = 1.25
            if tldia$ = 10, pas_AM = 1.5
            if tldia$ = 12, pas_AM = 1.75
            if tldia$ = 14, pas_AM = 2
            if tldia$ = 16, pas_AM = 2
            if retr$ <> 0, pas_AM = retr$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            pnumligne, "G84", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, pas_AM,e$
            old_dest_ret_5x_AM = dest_ret_5x_AM

ptap_BM        # Cycle de taraudage G84
            psortie2_BM

ptap_CM        # Cycle de taraudage G84
            psortie2_CM
#endregion
#region pmisc1
pmisc1$
            pchange_AG
            pmisc1_AG

            pchange_AM
            pmisc1_AM

            pchange_BG
            pmisc1_BG

            pchange_BM
            pmisc1_BM

            pchange_CG
            pmisc1_CG

            pchange_CM
            pmisc1_CM

pmisc1_AG      # Cycle d'alesage par points
            if strcom_AG = svide, strcom_AG = "PERCAGE/ALESAGE (RETOUR ARRETE)", "MW_OP_COMMENT", strcom_AG, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            pdrl5_AG
                            pcaldrilxyzsimu_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G82", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *frplunge$,e$
                            if  nextop$ <> 100, [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                                ]
                             ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G82", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$,e$
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]
           old_dest_ret_5x_AG = dest_ret_5x_AG

pmisc1_BG      # Cycle d'alesage G85
            if strcom_BG = svide, strcom_BG = "PERCAGE/ALESAGE (RETOUR ARRETE)", "MW_OP_COMMENT", strcom_BG, e$
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_BG
            if drill5axes_BG = 1, tosz$ = 0
			sdis_BG = refht$ - tosz$
            avance_plonge = frplunge$
            typepercage = 1
            if drill5axes_BG = 1, pdrl5_BG

            if tete_rev_BG = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_BG , @inithtprint_BG
                                sr, xprint_BG, yprint_BG, inithtprint_BG, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
                                if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
                                gcode$ = 1
                                sl, *depthprint_BG, *frplunge$, paf, pgcode_force_BG, *depthprint_BG, *frplunge$ , e$
                                sl, *refhtprint_BG, *frplunge$, paf, pgcode_BG, *refhtprint_BG, e$
                                gcode$ = 0
                                if refhtprint_BG <> inithtprint_BG, sr, *inithtprint_BG, paf, pgcode_BG, *inithtprint_BG, e$
                                ]
           if tete_rev_BG = 0,
                                [
                                if drill5axes_BG = 1,
                                                [
                                                pcaldrilxyzsimu_BG
                                                initht5x_BG = refht$
                                                sm, paf, frplunge$, e$

                                                sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0," MCALL CYCLE85(", *initht5x_BG,",", *tosz$, ",",sdis_BG,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                #sm, paf, *xprint_BG, *yprint_BG, e$
                                                psouf_imp_BG
                                                if  nextop$ <> 100, [
                                                                    xprint_BG = old_v_abs_plus_x_sec_BG
                                                                    yprint_BG = old_v_abs_plus_y_sec_BG
                                                                    zprint_BG = old_v_abs_plus_z_sec_BG
                                                                    sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                                    ]
                                                ]
                                else,
                                                [
                                                sm, paf, frplunge$, e$

                                                sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_BG,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pcaldrilxyzsimu_BG
                                                xprint_BG = v_abs_plus_x_BG
                                                yprint_BG = v_abs_plus_y_BG
                                                zprint_BG = v_abs_plus_z_BG
                                                gcode$ = 0
                                                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                                #sm, paf, *xprint_BG, *yprint_BG, e$
                                                psouf_imp_BG
                                                ]
                                typcycle_BG = 1
                                ]
           old_dest_ret_5x_BG = dest_ret_5x_BG

pmisc1_CG      # Cycle d'alesage G85
            if strcom_CG = svide, strcom_CG = "PERCAGE/ALESAGE (RETOUR ARRETE)", "MW_OP_COMMENT", strcom_CG, e$
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_CG
            if drill5axes_CG = 1, tosz$ = 0
			sdis_CG = refht$ - tosz$
            avance_plonge = frplunge$
            typepercage = 1
            if drill5axes_CG = 1, pdrl5_CG

            if tete_rev_CG = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_CG , @inithtprint_CG
                                sr, xprint_CG, yprint_CG, inithtprint_CG, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
                                if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
                                gcode$ = 1
                                sl, *depthprint_CG, *frplunge$, paf, pgcode_force_CG, *depthprint_CG, *frplunge$ , e$
                                sl, *refhtprint_CG, *frplunge$, paf, pgcode_CG, *refhtprint_CG, e$
                                gcode$ = 0
                                if refhtprint_CG <> inithtprint_CG, sr, *inithtprint_CG, paf, pgcode_CG, *inithtprint_CG, e$
                                ]
           if tete_rev_CG = 0,
                                [
                                if drill5axes_CG = 1,
                                                [
                                                pcaldrilxyzsimu_CG
                                                initht5x_CG = refht$
                                                sm, paf, frplunge$, e$

                                                sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0," MCALL CYCLE85(", *initht5x_CG,",", *tosz$, ",",sdis_CG,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                #sm, paf, *xprint_CG, *yprint_CG, e$
                                                psouf_imp_CG
                                                if  nextop$ <> 100, [
                                                                    xprint_CG = old_v_abs_plus_x_sec_CG
                                                                    yprint_CG = old_v_abs_plus_y_sec_CG
                                                                    zprint_CG = old_v_abs_plus_z_sec_CG
                                                                    sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                                                    ]
                                                ]
                                else,
                                                [
                                                sm, paf, frplunge$, e$

                                                sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_CG,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pcaldrilxyzsimu_CG
                                                xprint_CG = v_abs_plus_x_CG
                                                yprint_CG = v_abs_plus_y_CG
                                                zprint_CG = v_abs_plus_z_CG
                                                gcode$ = 0
                                                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                                #sm, paf, *xprint_CG, *yprint_CG, e$
                                                psouf_imp_CG
                                                ]
                                typcycle_CG = 1
                                ]
           old_dest_ret_5x_CG = dest_ret_5x_CG

pmisc1_AM      # Cycle d'alesage par points
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            frplunge_AM = frplunge$
                            pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM,e$
                    ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pmisc1_BM      # Cycle d'alesage G85
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_BM
            if drill5axes_BM = 1, tosz$ = 0
			sdis_BM = refht$ - tosz$
            frplunge_BM = frplunge$
            avance_plonge = frplunge_BM
            typepercage = 1
            if drill5axes_BM = 1, pdrl5_BM

            if tete_rev_BM = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_BM , @inithtprint_BM
                                pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
                                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
                                gcode$ = 1
                                frplunge_BM = frplunge$
                                pnumligne, pgcode_force_BM, depthprint_BM, frplunge_BM , e$
                                pnumligne, pgcode_BM, refhtprint_BM, e$
                                gcode$ = 0
                                if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, inithtprint_BM, e$
                                ]
           if tete_rev_BM = 0,
                                [
                                if drill5axes_BM = 1,
                                                [

                                                initht5x_BM = refht$
                                                frplunge_BM = frplunge$
                                                pnumligne, frplunge_BM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_BM,",", *tosz$, ",",sdis_BM,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BM, *yprint_BM, e$
                                                psouf_imp_BM
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                                ]
                                else,
                                                [
                                                frplunge_BM = frplunge$
                                                pnumligne, frplunge_BM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_BM,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_BM, *yprint_BM, e$
                                                psouf_imp_BM
                                                ]
                                typcycle_BM = 1
                                ]
           old_dest_ret_5x_BM = dest_ret_5x_BM

pmisc1_CM      # Cycle d'alesage G85
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            pprint_CM
            if drill5axes_CM = 1, tosz$ = 0
			sdis_CM = refht$ - tosz$
            frplunge_CM = frplunge$
            avance_plonge = frplunge_CM
            typepercage = 1
            if drill5axes_CM = 1, pdrl5_CM

            if tete_rev_CM = 1 & mod5xcont = 0,
                                [
                                gcode$ = 0
                                @refhtprint_CM , @inithtprint_CM
                                pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
                                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
                                gcode$ = 1
                                frplunge_CM = frplunge$
                                pnumligne, pgcode_force_CM, depthprint_CM, frplunge_CM , e$
                                pnumligne, pgcode_CM, refhtprint_CM, e$
                                gcode$ = 0
                                if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, inithtprint_CM, e$
                                ]
           if tete_rev_CM = 0,
                                [
                                if drill5axes_CM = 1,
                                                [

                                                initht5x_CM = refht$
                                                frplunge_CM = frplunge$
                                                pnumligne, frplunge_CM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht5x_CM,",", *tosz$, ",",sdis_CM,",", *depth$,",, ",dwell$,",",*avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CM, *yprint_CM, e$
                                                psouf_imp_CM
                                                if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                                ]
                                else,
                                                [
                                                frplunge_CM = frplunge$
                                                pnumligne, frplunge_CM, e$
                                                spaces$ = 0
                                                pnumligne, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_CM,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                                                spaces$ = 1
                                                pnumligne, *xprint_CM, *yprint_CM, e$
                                                psouf_imp_CM
                                                ]
                                typcycle_CM = 1
                                ]
           old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region pbore2
pbore2$
            pchange_AG
            pbore2_AG

            pchange_AM
            pbore2_AM

            pchange_BG
            pbore2_BG

            pchange_BM
            pbore2_BM

            pchange_CG
            pbore2_CG

            pchange_CM
            pbore2_CM

pbore2_AG      # alesage indexe G86
            if strcom_AG = svide, strcom_AG = "ALESAGE INDEXE (9101)", "MW_OP_COMMENT", strcom_AG, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1, pdrl5_AG
            if drill5axes_AG = 1, initht$ = refht$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G86", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, "EP.2 EC0. EA180.", *frplunge$, e$
            pcaldrilxyzsimu_AG
            xprint_AG = v_abs_plus_x_AG
            yprint_AG = v_abs_plus_y_AG
            zprint_AG = v_abs_plus_z_AG
            gcode$ = 0
            sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
            if drill5axes_AG = 1, sr, *zinitht_AG, paf, "G80", *zinitht_AG, e$
            old_dest_ret_5x_AG = dest_ret_5x_AG

pbore2_BG      # alesage indexe G86
            psortie2_BG

pbore2_CG      # alesage indexe G86
            psortie2_CG

pbore2_AM      # alesage indexe G86
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1, pdrl5_AM
            if drill5axes_AM = 1, initht$ = refht$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            frplunge_AM = frplunge$
            pnumligne, "G86", *xprint_AM, *yprint_AM, *depth_AM, *refht_AM, *initht_AM, "EP.2 EC0. EA180.", frplunge_AM, e$
            if drill5axes_AM = 1, pnumligne, "G80", *zinitht_AM, e$
            old_dest_ret_5x_AM = dest_ret_5x_AM

pbore2_BM      # alesage indexe G86
            psortie2_BM

pbore2_CM      # alesage indexe G86
            psortie2_CM
#endregion
#region pbore1

pbore1$
            pchange_AG
            pbore1_AG

            pchange_AM
            pbore1_AM

            pchange_BG
            pbore1_BG

            pchange_BM
            pbore1_BM

            pchange_CG
            pbore1_CG

            pchange_CM
            pbore1_CM

pbore1_AG      # Cycle d'alesage G85
            if strcom_AG = svide, strcom_AG = "ALESAGE (9101)", "MW_OP_COMMENT", strcom_AG, e$
            pprint_AG
            typepercage = 1
            if drill5axes_AG = 1, pdrl5_AG

            if tete_rev_AG = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AG , @inithtprint_AG
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$, paf, pgcode_force_AG, *depthprint_AG, *frplunge$ , e$
           sl, *refhtprint_AG,  *frplunge$, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 0
           if refhtprint_AG <> inithtprint_AG, sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
           ]
           if tete_rev_AG = 0,
           [
            if drill5axes_AG = 1,[
                            pcaldrilxyzsimu_AG
                            initht5x_AG = refht$
                            depth_AG = depth$
                            refht_AG = refht$
                            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G85", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *frplunge$, e$
                            if  nextop$ <> 100, [
                                                xprint_AG = old_v_abs_plus_x_sec_AG
                                                yprint_AG = old_v_abs_plus_y_sec_AG
                                                zprint_AG = old_v_abs_plus_z_sec_AG
                                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                                ]
                             ]

           else,    [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G85", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$, e$
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]
           typcycle_AG = 1
           ]
           old_dest_ret_5x_AG = dest_ret_5x_AG


pbore1_BG      # Cycle d'alesage par points
            psortie2_BG

pbore1_CG      # Cycle d'alesage par points
            psortie2_CG

pbore1_AM      # Cycle d'alesage G85

            pprint_AM
            typepercage = 1
            if drill5axes_AM = 1, pdrl5_AM

            if tete_rev_AM = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AM , @inithtprint_AM
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_force_AM, depthprint_AM, frplunge_AM , e$
           pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 0
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, inithtprint_AM, e$
           ]
           if tete_rev_AM = 0,
           [
            if drill5axes_AM = 1,[
                            pdrl5_AM
                            initht5x_AM = refht$
                            depth_AM = depth$
                            refht_AM = refht$
                            frplunge_AM = frplunge$
                            pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM, e$
                            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                             ]

           else,    [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    frplunge_AM = frplunge$
                    pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM, e$
                    ]
           typcycle_AM = 1
           ]
           old_dest_ret_5x_AM = dest_ret_5x_AM

pbore1_BM      # Cycle d'alesage par points
            psortie2_BM

pbore1_CM      # Cycle d'alesage par points
            psortie2_CM
#endregion
#region pmisc2_OLD 

pmisc2_OLD_BG     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_BG
                        !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_OLD_CG     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_CG
                        !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_OLD_BM     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_BM
                        !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_OLD_CM     # Cycle  special helicoido-spiral
                         pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
                        percage_helicoido_spiral_CM
                        !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pmisc2
pmisc2$
            pchange_AG
            pmisc2_AG

            pchange_AM
            pmisc2_AM

            pchange_BG
            pmisc2_BG

            pchange_BM
            pmisc2_BM

            pchange_CG
            pmisc2_CG

            pchange_CM
            pmisc2_CM

pmisc2_AG      # Cycle  special helicoido-spiral
            if rotaxtyp$ = 3, [
            if strcom_AG = svide, strcom_AG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_AG, e$
            sm,paf, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_AG = 1, psortie_AG
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_AG
                            initht5x_AG = refht$
                            percage_helicoido_spiral_AG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_AG, paf, pgcode_force_AG, *old_zinitht_AG, e$
                             ]
           else, percage_helicoido_spiral_AG
           old_dest_ret_5x_AG = dest_ret_5x_AG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                            ]
            else,   [
            if strcom_AG = svide, strcom_AG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_AG, e$
            pcalcule_variable_AG
            pprint_AG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_AG = 1, pdrl5_AG

            if tete_rev_AG = 1 & mod5xcont = 0,
           [

           gcode$ = 0
           @refhtprint_AG , @inithtprint_AG
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$ , paf, pgcode_AG, *depthprint_AG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
           ]
           if tete_rev_AG = 0,
           [
            if drill5axes_AG = 1,
                    [
                    pcaldrilxyzsimu_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    #if  nextop$ <> 100, sm, paf, "G80", *old_zinitht_AG, e$

                    if  nextop$ <> 100, [
                                        xprint_AG = old_v_abs_plus_x_sec_AG
                                        yprint_AG = old_v_abs_plus_y_sec_AG
                                        zprint_AG = old_v_abs_plus_z_sec_AG
                                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                        ]
                    ]

            else,   [
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]

            typcycle_AG = 1
           ]
           old_dest_ret_5x_AG = dest_ret_5x_AG
                    ]

pmisc2_BG      # Cycle  special helicoido-spiral
            if rotaxtyp$ = 3, [
            if strcom_BG = svide, strcom_BG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_BG, e$
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
            sm,paf, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_BG = 1, psortie_BG
            pprint_BG
            typcycle_BG = 1
            if drill5axes_BG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_BG
                            initht5x_BG = refht$
                            percage_helicoido_spiral_BG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_BG, paf, pgcode_force_BG, *old_zinitht_BG, e$
                             ]
           else, percage_helicoido_spiral_BG
           old_dest_ret_5x_BG = dest_ret_5x_BG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            if strcom_BG = svide, strcom_BG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_BG, e$
            pcalcule_variable_BG
            if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!

            #pvoir_BG
			if drill5axes_BG = 1, tosz$ = 0
            sdis_BG = refht$ - tosz$
            pprint_BG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_BG = 1, pdrl5_BG

           if tete_rev_BG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_BG , @inithtprint_BG
                sr, *xprint_BG, *yprint_BG, *inithtprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
                if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
                gcode$ = 1
                sl, *depthprint_BG, *frplunge$ , paf, pgcode_BG, *depthprint_BG, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint_BG, paf, pgcode_BG, *inithtprint_BG, e$
                ]
           if tete_rev_BG = 0,
                [
                if drill5axes_BG = 1,
                    [
                    pcaldrilxyzsimu_BG
                    initht5x_BG = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    #sm, paf, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    #sm, paf, "G81", xprint_BG, yprint_BG, *depth$, *refht$, *initht5x_BG, frplunge$, e$        
                    if  nextop$ <> 100, [
                                        xprint_BG = old_v_abs_plus_x_sec_BG
                                        yprint_BG = old_v_abs_plus_y_sec_BG
                                        zprint_BG = old_v_abs_plus_z_sec_BG
                                        sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    pcaldrilxyzsimu_BG
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    gcode$ = 0
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    #sm, paf, *xprint_BG, *yprint_BG, e$
                    psouf_imp_BG
                    typcycle_BG = 1
                    ]
                ]
           old_dest_ret_5x_BG = dest_ret_5x_BG
                    ]

pmisc2_CG      # Cycle  special helicoido-spiral
            if rotaxtyp$ = 3, [
            if strcom_CG = svide, strcom_CG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_CG, e$
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
            sm,paf, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_CG = 1, psortie_CG
            pprint_CG
            typcycle_CG = 1
            if drill5axes_CG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_CG
                            initht5x_CG = refht$
                            percage_helicoido_spiral_CG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_CG, paf, pgcode_force_CG, *old_zinitht_CG, e$
                             ]
           else, percage_helicoido_spiral_CG
           old_dest_ret_5x_CG = dest_ret_5x_CG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            if strcom_CG = svide, strcom_CG = "PERCAGE CAQ", "MW_OP_COMMENT", strcom_CG, e$
            pcalcule_variable_CG
            if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!

            #pvoir_CG
			if drill5axes_CG = 1, tosz$ = 0
            sdis_CG = refht$ - tosz$
            pprint_CG
            typepercage = 0
            #"voir les xyzvuvw", xcal, ycal, zcal, ucal, vcal, wcal, e$
            if drill5axes_CG = 1, pdrl5_CG

           if tete_rev_CG = 1 & mod5xcont = 0,
                [
                gcode$ = 0
                @refhtprint_CG , @inithtprint_CG
                sr, *xprint_CG, *yprint_CG, *inithtprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
                if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
                gcode$ = 1
                sl, *depthprint_CG, *frplunge$ , paf, pgcode_CG, *depthprint_CG, *frplunge$ , e$
                gcode$ = 0
                sr, *inithtprint_CG, paf, pgcode_CG, *inithtprint_CG, e$
                ]
           if tete_rev_CG = 0,
                [
                if drill5axes_CG = 1,
                    [
                    pcaldrilxyzsimu_CG
                    initht5x_CG = refht$
                    sm,paf, frplunge$, e$

                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    #sm, paf, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    #sm, paf, "G81", xprint_CG, yprint_CG, *depth$, *refht$, *initht5x_CG, frplunge$, e$        
                    if  nextop$ <> 100, [
                                        xprint_CG = old_v_abs_plus_x_sec_CG
                                        yprint_CG = old_v_abs_plus_y_sec_CG
                                        zprint_CG = old_v_abs_plus_z_sec_CG
                                        sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                        ]
                    ]
                else,
                    [
                    sm, paf, *frplunge$, e$
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, pafcom,"CYCLE CAQ", e$
                    spaces$ = 1
                    pcaldrilxyzsimu_CG
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    gcode$ = 0
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    #sm, paf, *xprint_CG, *yprint_CG, e$
                    psouf_imp_CG
                    typcycle_CG = 1
                    ]
                ]
           old_dest_ret_5x_CG = dest_ret_5x_CG
                    ]

pmisc2_AM      # Cycle  special helicoido-spiral
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_AM = 1, psortie_AM
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_AM
                            initht5x_AM = refht$
                            percage_helicoido_spiral_AM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                             ]
           else, percage_helicoido_spiral_AM
           old_dest_ret_5x_AM = dest_ret_5x_AM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_BM      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_BM = 1, psortie_BM
            pprint_BM
            typcycle_BM = 1
            if drill5axes_BM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_BM
                            initht5x_BM = refht$
                            percage_helicoido_spiral_BM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                             ]
           else, percage_helicoido_spiral_BM
           old_dest_ret_5x_BM = dest_ret_5x_BM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_CM      # Cycle  special helicoido-spiral
            if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
            pnumligne, sdcom, " DEBUT CYCLE CAQ", sfcom, e$
            if tete_rev_CM = 1, psortie_CM
            pprint_CM
            typcycle_CM = 1
            if drill5axes_CM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_CM
                            initht5x_CM = refht$
                            percage_helicoido_spiral_CM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                             ]
           else, percage_helicoido_spiral_CM
           old_dest_ret_5x_CM = dest_ret_5x_CM
            !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pdrill_2
pdrill_2$
            pchange_AG
            pdrill_2_AG

            pchange_AM
            pdrill_2_AM

            pchange_BG
            pdrill_2_BG

            pchange_BM
            pdrill_2_BM

            pchange_CG
            pdrill_2_CG

            pchange_CM
            pdrill_2_CM

pdrill_2_AG    # Canned Drill Cycle
            #Pvoir_AG   sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G81", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$, e$
            pprint_AG
            if drill5axes_AG = 1, pdrl5_2_AG
             if tete_rev_AG = 1 & mod5xcont = 0,
              [
            @refhtprint_AG , @inithtprint_AG
           gcode$ = 0
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$, paf, pgcode_AG, *depthprint_AG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
             ]
           if tete_rev_AG = 0,
             [
        if drill5axes_AG = 1, [
                pcaldrilxyzsimu_AG
                initht5x_AG = refht$
                depth_AG = depth$
                refht_AG = refht$
                sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G81", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *frplunge$,e$
                #if  nextop$ <> 100, sr, *old_zinitht_AG, paf, "G80", *old_zinitht_AG, e$

                if  nextop$ <> 100, [
                                    xprint_AG = v_abs_plus_x_sec_fin_AG
                                    yprint_AG = v_abs_plus_y_sec_fin_AG
                                    zprint_AG = v_abs_plus_z_sec_fin_AG
                                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                    ]
                            ]

        else,   [
                pcaldrilxyzsimu_AG
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                gcode$ = 0
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                depth_AG = depth$
                refht_AG = refht$
                initht_AG = initht$
                xprint_AG = x$
                yprint_AG = y$
                zprint_AG = z$
                sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G81", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$, e$
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                ]
        old_dest_ret_5x_AG = dest_ret_5x_AG
           ]

pdrill_2_BG    # Canned Drill Cycle
            #Pvoir_BG
            pprint_BG
            if drill5axes_BG = 1, pdrl5_2_BG
             if tete_rev_BG = 1 & mod5xcont = 0,
              [
            @refhtprint_BG , @inithtprint_BG
           gcode$ = 0
           sr, *xprint_BG, *yprint_BG, *inithtprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
           if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
           gcode$ = 1
           sl, *depthprint_BG, *frplunge$, paf, pgcode_BG, *depthprint_BG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_BG, paf, pgcode_BG, *inithtprint_BG, e$
             ]
           if tete_rev_BG = 0,
                        [
                        if drill5axes_BG = 1, [
                        pcaldrilxyzsimu_BG
						tosz$ = 0
                        initht5x_BG = refht$

                        sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE81(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                        spaces$ = 1
                        #sm, paf, *xprint_BG, *yprint_BG, e$
                        psouf_imp_BG
                        if  nextop$ <> 100, [
                                    xprint_BG = v_abs_plus_x_sec_fin_BG
                                    yprint_BG = v_abs_plus_y_sec_fin_BG
                                    zprint_BG = v_abs_plus_z_sec_fin_BG
                                    sm, paf, "MCALL", e$, sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                    ]
                        ]
        #else, sm, paf, xprint_BG, yprint_BG, e$, # depth$, refht$, initht$,e$
        else,   [
                pcaldrilxyzsimu_BG
                xprint_BG = v_abs_plus_x_BG
                yprint_BG = v_abs_plus_y_BG
                zprint_BG = v_abs_plus_z_BG
                gcode$ = 0
                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                xprint_BG = x$
                yprint_BG = y$
                zprint_BG = z$
                sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_BG,",", *depth$, ")",e$
                spaces$ = 1
                xprint_BG = v_abs_plus_x_BG
                yprint_BG = v_abs_plus_y_BG
                zprint_BG = v_abs_plus_z_BG
                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                ]
        psouf_imp_BG
        old_dest_ret_5x_BG = dest_ret_5x_BG
           ]

pdrill_2_CG    # Canned Drill Cycle
           #Pvoir_CG
            pprint_CG
            if drill5axes_CG = 1, pdrl5_2_CG
             if tete_rev_CG = 1 & mod5xcont = 0,
              [
            @refhtprint_CG , @inithtprint_CG
           gcode$ = 0
           sr, *xprint_CG, *yprint_CG, *inithtprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
           if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
           gcode$ = 1
           sl, *depthprint_CG, *frplunge$, paf, pgcode_CG, *depthprint_CG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_CG, paf, pgcode_CG, *inithtprint_CG, e$
             ]
           if tete_rev_CG = 0,
                        [
                        if drill5axes_CG = 1, [
                        pcaldrilxyzsimu_CG
						tosz$ = 0
                        initht5x_CG = refht$

                        sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE81(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                        spaces$ = 1
                        #sm, paf, *xprint_CG, *yprint_CG, e$
                        psouf_imp_CG
                        if  nextop$ <> 100, [
                                    xprint_CG = v_abs_plus_x_sec_fin_CG
                                    yprint_CG = v_abs_plus_y_sec_fin_CG
                                    zprint_CG = v_abs_plus_z_sec_fin_CG
                                    sm, paf, "MCALL", e$, sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                    ]
                        ]
        #else, sm, paf, xprint_CG, yprint_CG, e$, # depth$, refht$, initht$,e$
        else,   [
                pcaldrilxyzsimu_CG
                xprint_CG = v_abs_plus_x_CG
                yprint_CG = v_abs_plus_y_CG
                zprint_CG = v_abs_plus_z_CG
                gcode$ = 0
                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                xprint_CG = x$
                yprint_CG = y$
                zprint_CG = z$
                sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf,spaces$ = 0, " MCALL CYCLE81(", *initht$,",", *tosz$, ",",*sdis_CG,",", *depth$, ")",e$
                spaces$ = 1
                xprint_CG = v_abs_plus_x_CG
                yprint_CG = v_abs_plus_y_CG
                zprint_CG = v_abs_plus_z_CG
                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                ]
        psouf_imp_CG
        old_dest_ret_5x_CG = dest_ret_5x_CG
           ]

pdrill_2_AM    # Canned Drill Cycle
            #Pvoir_AM
            pprint_AM
            if drill5axes_AM = 1, pdrl5_2_AM
             if tete_rev_AM = 1 & mod5xcont = 0,
              [
            @refhtprint_AM , @inithtprint_AM
           gcode$ = 0
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           gcode$ = 0
           pnumligne, pgcode_AM, inithtprint_AM, e$
             ]
           if tete_rev_AM = 0,
             [
        if drill5axes_AM = 1, [
                initht5x_AM = refht$
                depth_AM = depth$
                refht_AM = refht$
                frplunge_AM = frplunge$
                pnumligne, "G81", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                            ]

        else,   [
                depth_AM = depth$
                refht_AM = refht$
                initht_AM = initht$
                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                ]
        old_dest_ret_5x_AM = dest_ret_5x_AM
           ]

pdrill_2_BM    # Canned Drill Cycle
            #Pvoir_BM
            pprint_BM
            if drill5axes_BM = 1, pdrl5_2_BM
             if tete_rev_BM = 1 & mod5xcont = 0,
              [
            @refhtprint_BM , @inithtprint_BM
           gcode$ = 0
           pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
           gcode$ = 0
           pnumligne, pgcode_BM, inithtprint_BM, e$
             ]
           if tete_rev_BM = 0,
                        [
                        if drill5axes_BM = 1, [
                        initht5x_BM = refht$
						tosz$ = 0
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_BM, *yprint_BM, e$
                        psouf_imp_BM
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                        ]
        else, pnumligne, xprint_BM, yprint_BM, e$, # depth$, refht$, initht$,e$
        psouf_imp_BM
        old_dest_ret_5x_BM = dest_ret_5x_BM
           ]

pdrill_2_CM    # Canned Drill Cycle
            #Pvoir_CM
            pprint_CM
            if drill5axes_CM = 1, pdrl5_2_CM
             if tete_rev_CM = 1 & mod5xcont = 0,
              [
            @refhtprint_CM , @inithtprint_CM
           gcode$ = 0
           pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 1
           frplunge_CM = frplunge$
           pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
           gcode$ = 0
           pnumligne, pgcode_CM, inithtprint_CM, e$
             ]
           if tete_rev_CM = 0,
                        [
                        if drill5axes_CM = 1, [
                        initht5x_CM = refht$
						tosz$ = 0
                        spaces$ = 0
                        pnumligne, " MCALL CYCLE81(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$, ")",e$
                        spaces$ = 1
                        pnumligne, *xprint_CM, *yprint_CM, e$
                        psouf_imp_CM
                        if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                        ]
        else, pnumligne, xprint_CM, yprint_CM, e$, # depth$, refht$, initht$,e$
        psouf_imp_CM
        old_dest_ret_5x_CM = dest_ret_5x_CM
           ]
#endregion
#region ppeck_2
ppeck_2$
            pchange_AG
            ppeck_2_AG

            pchange_AM
            ppeck_2_AM

            pchange_BG
            ppeck_2_BG

            pchange_BM
            ppeck_2_BM

            pchange_CG
            ppeck_2_CG

            pchange_CM
            ppeck_2_CM

ppeck_2_AG     # Canned Peck Drill Cycle
            pprint_AG
            if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    pcaldrilxyzsimu_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G83", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *peck1_AG, *peck2_AG, *frplunge$,e$
                    if  nextop$ <> 100, [
                                        xprint_AG = v_abs_plus_x_sec_fin_AG
                                        yprint_AG = v_abs_plus_y_sec_fin_AG
                                        zprint_AG = v_abs_plus_z_sec_fin_AG
                                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                        ]
                                ]

            else,   [
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    xprint_AG = x$
                    yprint_AG = y$
                    zprint_AG = z$
                    sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G83", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *peck1_AG, *peck2_AG, *frplunge$,e$
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]
             old_dest_ret_5x_AG = dest_ret_5x_AG

ppeck_2_BG     # Canned Peck Drill Cycle
            pprint_BG
            if drill5axes_BG = 1,[
                    pdrl5_2_BG
                    pcaldrilxyzsimu_BG
                    initht5x_BG = refht$
					tosz$ = 0

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint_BG, yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, [
                                        xprint_BG = v_abs_plus_x_sec_fin_BG
                                        yprint_BG = v_abs_plus_y_sec_fin_BG
                                        zprint_BG = v_abs_plus_z_sec_fin_BG
                                        sm, paf, "MCALL", e$
                                        sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                        ]
                                ]
            #else, sm, paf, xprint_BG, yprint_BG, e$ #depth$, refht$, initht$,e$
            else,   [
                    pcaldrilxyzsimu_BG
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    gcode$ = 0
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    xprint_BG = x$
                    yprint_BG = y$
                    zprint_BG = z$
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                    spaces$ = 1
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    ]
            psouf_imp_BG
             old_dest_ret_5x_BG = dest_ret_5x_BG

ppeck_2_CG     # Canned Peck Drill Cycle
           pprint_CG
            if drill5axes_CG = 1,[
                    pdrl5_2_CG
                    pcaldrilxyzsimu_CG
                    initht5x_CG = refht$
					tosz$ = 0
					
                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint_CG, yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, [
                                        xprint_CG = v_abs_plus_x_sec_fin_CG
                                        yprint_CG = v_abs_plus_y_sec_fin_CG
                                        zprint_CG = v_abs_plus_z_sec_fin_CG
                                        sm, paf, "MCALL", e$
                                        sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                        ]
                                ]
            #else, sm, paf, xprint_CG, yprint_CG, e$ #depth$, refht$, initht$,e$
            else,   [
                    pcaldrilxyzsimu_CG
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    gcode$ = 0
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    xprint_CG = x$
                    yprint_CG = y$
                    zprint_CG = z$
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                    spaces$ = 1
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    ]
            psouf_imp_CG
             old_dest_ret_5x_CG = dest_ret_5x_CG

ppeck_2_AM     # Canned Peck Drill Cycle
            pprint_AM
            if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                     pnumligne, "G83", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, frplunge_AM,e$
                      if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                                ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                    ]
             old_dest_ret_5x_AM = dest_ret_5x_AM

ppeck_2_BM     # Canned Peck Drill Cycle
            pprint_BM
            if drill5axes_BM = 1,[
                    pdrl5_2_BM
					tosz$ = 0
                    initht5x_BM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BM, yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                ]
            else, pnumligne, xprint_BM, yprint_BM, e$ #depth$, refht$, initht$,e$
            psouf_imp_BM
             old_dest_ret_5x_BM = dest_ret_5x_BM

ppeck_2_CM     # Canned Peck Drill Cycle
            pprint_CM
            if drill5axes_CM = 1,[
                    pdrl5_2_CM
					tosz$ = 0
                    initht5x_CM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",1,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CM, yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                ]
            else, pnumligne, xprint_CM, yprint_CM, e$ #depth$, refht$, initht$,e$
            psouf_imp_CM
             old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region pchpbrk_2
pchpbrk_2$
            pchange_AG
            pchpbrk_2_AG

            pchange_AM
            pchpbrk_2_AM

            pchange_BG
            pchpbrk_2_BG

            pchange_BM
            pchpbrk_2_BM

            pchange_CG
            pchpbrk_2_CG

            pchange_CM
            pchpbrk_2_CM

pchpbrk_2_AG   # Canned Chip Break Cycle
            pprint_AG
        if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    pcaldrilxyzsimu_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    peckclr_AG = peckclr$
                    peck1_AG = peck1$
                    peck2_AG = peck2$
                    sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G87", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *peck1_AG, *peck2_AG, *peckclr_AG, *frplunge$,e$
                    if  nextop$ <> 100, [
                                        xprint_AG = v_abs_plus_x_sec_fin_AG
                                        yprint_AG = v_abs_plus_y_sec_fin_AG
                                        zprint_AG = v_abs_plus_z_sec_fin_AG
                                        sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                        ]
                        ]

                         else,  [
                                pcaldrilxyzsimu_AG
                                xprint_AG = v_abs_plus_x_AG
                                yprint_AG = v_abs_plus_y_AG
                                zprint_AG = v_abs_plus_z_AG
                                gcode$ = 0
                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                depth_AG = depth$
                                refht_AG = refht$
                                initht_AG = initht$
                                xprint_AG = x$
                                yprint_AG = y$
                                zprint_AG = z$
                                sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G87", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *peck1_AG, *peck2_AG, *dwell_AG, *frplunge$,e$
                                xprint_AG = v_abs_plus_x_AG
                                yprint_AG = v_abs_plus_y_AG
                                zprint_AG = v_abs_plus_z_AG
                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                ]
                     old_dest_ret_5x_AG = dest_ret_5x_AG

pchpbrk_2_BG   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_BG
            if drill5axes_BG = 1,[
                    pdrl5_2_BG
                    pcaldrilxyzsimu_BG
					tosz$ = 0
                    initht5x_BG = refht$

                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf,spaces$ = 0," MCALL CYCLE83(", *initht5x_BG,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint_BG, yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, [
                                        xprint_BG = v_abs_plus_x_sec_fin_BG
                                        yprint_BG = v_abs_plus_y_sec_fin_BG
                                        zprint_BG = v_abs_plus_z_sec_fin_BG
                                        sm, paf, "MCALL", e$
                                        sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                        ]
                                ]
            else,   [
                                pcaldrilxyzsimu_BG
                                xprint_BG = v_abs_plus_x_BG
                                yprint_BG = v_abs_plus_y_BG
                                zprint_BG = v_abs_plus_z_BG
                                gcode$ = 0
                                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                xprint_BG = x$
                                yprint_BG = y$
                                zprint_BG = z$
                                sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_BG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                                spaces$ = 1
                                xprint_BG = v_abs_plus_x_BG
                                yprint_BG = v_abs_plus_y_BG
                                zprint_BG = v_abs_plus_z_BG
                                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                ]
            psouf_imp_BG
             old_dest_ret_5x_BG = dest_ret_5x_BG

pchpbrk_2_CG   # Canned Chip Break Cycle 83 en brise copeau
               pprint_CG
            if drill5axes_CG = 1,[
                    pdrl5_2_CG
                    pcaldrilxyzsimu_CG
					tosz$ = 0
                    initht5x_CG = refht$

                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf,spaces$ = 0," MCALL CYCLE83(", *initht5x_CG,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            #sm, paf, xprint_CG, yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, [
                                        xprint_CG = v_abs_plus_x_sec_fin_CG
                                        yprint_CG = v_abs_plus_y_sec_fin_CG
                                        zprint_CG = v_abs_plus_z_sec_fin_CG
                                        sm, paf, "MCALL", e$
                                        sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                        ]
                                ]
            else,   [
                                pcaldrilxyzsimu_CG
                                xprint_CG = v_abs_plus_x_CG
                                yprint_CG = v_abs_plus_y_CG
                                zprint_CG = v_abs_plus_z_CG
                                gcode$ = 0
                                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                xprint_CG = x$
                                yprint_CG = y$
                                zprint_CG = z$
                                sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE83(", *initht$,",", *tosz$, ",", *sdis_CG,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                                spaces$ = 1
                                xprint_CG = v_abs_plus_x_CG
                                yprint_CG = v_abs_plus_y_CG
                                zprint_CG = v_abs_plus_z_CG
                                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                ]
            psouf_imp_CG
             old_dest_ret_5x_CG = dest_ret_5x_CG

pchpbrk_2_AM   # Canned Chip Break Cycle
            pprint_AM
        if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    peckclr_AM = peckclr$
                    peck1_AM = peck1$
                    peck2_AM = peck2$
                    frplunge_AM = frplunge$
                    pnumligne, "G87", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, peck1_AM, peck2_AM, peckclr_AM, frplunge_AM,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                        ]

                         else,  [
                                depth_AM = depth$
                                refht_AM = refht$
                                initht_AM = initht$
                                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                                ]
                     old_dest_ret_5x_AM = dest_ret_5x_AM

pchpbrk_2_BM   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_BM
            if drill5axes_BM = 1,[
                    pdrl5_2_BM
					tosz$ = 0
                    initht5x_BM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_BM,",", *tosz$, ",", *sdis_BM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_BM, yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                                ]
            else, pnumligne, xprint_BM, yprint_BM, e$ #depth$, refht$, initht$,e$
            psouf_imp_BM
             old_dest_ret_5x_BM = dest_ret_5x_BM

pchpbrk_2_CM   # Canned Chip Break Cycle 83 en brise copeau
                 pprint_CM
            if drill5axes_CM = 1,[
                    pdrl5_2_CM
					tosz$ = 0
                    initht5x_CM = refht$
                     spaces$ = 0
                            pnumligne, " MCALL CYCLE83(", *initht5x_CM,",", *tosz$, ",", *sdis_CM,",", *depth$,",,,", *peck1$,",", peck2$,",",dwell$,",",retr$,",", peckclr$, ",0,3,,,,)",e$
                            spaces$ = 1
                            pnumligne, xprint_CM, yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                                ]
            else, pnumligne, xprint_CM, yprint_CM, e$ #depth$, refht$, initht$,e$
            psouf_imp_CM
             old_dest_ret_5x_CM = dest_ret_5x_CM
#endregion
#region ptap_2
ptap_2$
            pchange_AG
            ptap_2_AG

            pchange_AM
            ptap_2_AM

            pchange_BG
            ptap_2_BG

            pchange_BM
            ptap_2_BM

            pchange_CG
            ptap_2_CG

            pchange_CM
            ptap_2_CM

ptap_2_AG      # Canned Tap Cycle
            pprint_AG
            pcaldrilxyzsimu_AG
            xprint_AG = v_abs_plus_x_AG
            yprint_AG = v_abs_plus_y_AG
            zprint_AG = v_abs_plus_z_AG
            gcode$ = 0
            sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G84", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *pas_AG,e$
            xprint_AG = v_abs_plus_x_AG
            yprint_AG = v_abs_plus_y_AG
            zprint_AG = v_abs_plus_z_AG
            sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$

ptap_2_BG      # Canned Tap Cycle
            pprint_BG
            sr, *xprint_BG, *yprint_BG, paf, *xprint_BG, *yprint_BG, *depth$, *refht$, *initht$,e$

ptap_2_CG      # Canned Tap Cycle
            pprint_CG
            sr, *xprint_CG, *yprint_CG, paf, *xprint_CG, *yprint_CG, *depth$, *refht$, *initht$,e$

ptap_2_AM      # Canned Tap Cycle
            pprint_AM
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$

ptap_2_BM      # Canned Tap Cycle
            pprint_BM
            pnumligne, xprint_BM, yprint_BM, depth$, refht$, initht$,e$

ptap_2_CM      # Canned Tap Cycle
            pprint_CM
            pnumligne, xprint_CM, yprint_CM, depth$, refht$, initht$,e$
#endregion
#region pmisc1_2
pmisc1_2$
            pchange_AG
            pmisc1_2_AG

            pchange_AM
            pmisc1_2_AM

            pchange_BG
            pmisc1_2_BG

            pchange_BM
            pmisc1_2_BM

            pchange_CG
            pmisc1_2_CG

            pchange_CM
            pmisc1_2_CM

pmisc1_2_AG    # Canned Misc #1 Cycle
            pprint_AG
            if drill5axes_AG = 1,[
            pdrl5_2_AG
            pcaldrilxyzsimu_AG
            initht$ = refht$
            depth_AG = depth$
            refht_AG = refht$
            initht_AG = initht$
            sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G82", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$,e$
            if  nextop$ <> 100, [
                                xprint_AG = v_abs_plus_x_sec_fin_AG
                                yprint_AG = v_abs_plus_y_sec_fin_AG
                                zprint_AG = v_abs_plus_z_sec_fin_AG
                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                ]
             ]

            else,   [
                    pcaldrilxyzsimu_AG
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    gcode$ = 0
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    depth_AG = depth$
                    refht_AG = refht$
                    initht_AG = initht$
                    xprint_AG = x$
                    yprint_AG = y$
                    zprint_AG = z$
                    sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G82", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$,e$
                    xprint_AG = v_abs_plus_x_AG
                    yprint_AG = v_abs_plus_y_AG
                    zprint_AG = v_abs_plus_z_AG
                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                    ]
            old_dest_ret_5x_AG = dest_ret_5x_AG

pmisc1_2_BG    # Canned Bore #1 Cycle
            pprint_BG
            if drill5axes_BG = 1, pdrl5_2_BG
             if tete_rev_BG = 1 & mod5xcont = 0,
              [
            @refhtprint_BG , @inithtprint_BG
           gcode$ = 0
           sr, *xprint_BG, *yprint_BG, *inithtprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
           if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
           gcode$ = 1
           sl, *depthprint_BG, *frplunge$, paf, pgcode_BG, *depthprint_BG, *frplunge$ , e$
           sl, *refhtprint_BG, *frplunge$, paf, pgcode_BG, *refhtprint_BG, e$
           gcode$ = 0
           if refhtprint_BG <> inithtprint_BG, sr, *inithtprint_BG, paf pgcode_BG, *inithtprint_BG, e$
             ]
           if tete_rev_BG = 0,
             [
        if drill5axes_BG = 1,
                            [
                            pcaldrilxyzsimu_BG
                            initht5x_BG = refht$
							tosz$ = 0
                            sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht5x_BG,",", *tosz$, ",",*sdis_BG,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            #sm, paf, *xprint_BG, *yprint_BG, e$
                            psouf_imp_BG
                            if  nextop$ <> 100, [
                                xprint_BG = v_abs_plus_x_sec_fin_BG
                                yprint_BG = v_abs_plus_y_sec_fin_BG
                                zprint_BG = v_abs_plus_z_sec_fin_BG
                                sm, paf, "MCALL", e$
                                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                ]
                            ]

        else,   [
                    pcaldrilxyzsimu_BG
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    gcode$ = 0
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    xprint_BG = x$
                    yprint_BG = y$
                    zprint_BG = z$
                    sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_BG,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                    spaces$ = 1
                    xprint_BG = v_abs_plus_x_BG
                    yprint_BG = v_abs_plus_y_BG
                    zprint_BG = v_abs_plus_z_BG
                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                    ]
        psouf_imp_BG
        old_dest_ret_5x_BG = dest_ret_5x_BG
           ]

pmisc1_2_CG    # Canned Bore #1 Cycle
            pprint_CG
            if drill5axes_CG = 1, pdrl5_2_CG
             if tete_rev_CG = 1 & mod5xcont = 0,
              [
            @refhtprint_CG , @inithtprint_CG
           gcode$ = 0
           sr, *xprint_CG, *yprint_CG, *inithtprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
           if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
           gcode$ = 1
           sl, *depthprint_CG, *frplunge$, paf, pgcode_CG, *depthprint_CG, *frplunge$ , e$
           sl, *refhtprint_CG, *frplunge$, paf, pgcode_CG, *refhtprint_CG, e$
           gcode$ = 0
           if refhtprint_CG <> inithtprint_CG, sr, *inithtprint_CG, paf pgcode_CG, *inithtprint_CG, e$
             ]
           if tete_rev_CG = 0,
             [
        if drill5axes_CG = 1,
                            [
                            pcaldrilxyzsimu_CG
                            initht5x_CG = refht$
							tosz$ = 0
                            sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht5x_CG,",", *tosz$, ",",*sdis_CG,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            #sm, paf, *xprint_CG, *yprint_CG, e$
                            psouf_imp_CG
                            if  nextop$ <> 100, [
                                xprint_CG = v_abs_plus_x_sec_fin_CG
                                yprint_CG = v_abs_plus_y_sec_fin_CG
                                zprint_CG = v_abs_plus_z_sec_fin_CG
                                sm, paf, "MCALL", e$
                                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                ]
                            ]

        else,   [
                    pcaldrilxyzsimu_CG
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    gcode$ = 0
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    xprint_CG = x$
                    yprint_CG = y$
                    zprint_CG = z$
                    sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, paf, spaces$ = 0, " MCALL CYCLE85(", *initht$,",", *tosz$, ",",sdis_CG,",", *depth$,",,",dwell$,",",avance_plonge,",",peckclr$,")",e$
                    spaces$ = 1
                    xprint_CG = v_abs_plus_x_CG
                    yprint_CG = v_abs_plus_y_CG
                    zprint_CG = v_abs_plus_z_CG
                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                    ]
        psouf_imp_CG
        old_dest_ret_5x_CG = dest_ret_5x_CG
           ]

pmisc1_2_AM    # Canned Misc #1 Cycle
            pprint_AM
            if drill5axes_AM = 1,[
            pdrl5_2_AM
            initht$ = refht$
            depth_AM = depth$
            refht_AM = refht$
            initht_AM = initht$
            frplunge_AM = frplunge$
            pnumligne, "G82", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht_AM, frplunge_AM,e$
            if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
             ]

            else,   [
                    depth_AM = depth$
                    refht_AM = refht$
                    initht_AM = initht$
                    pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                    ]
            old_dest_ret_5x_AM = dest_ret_5x_AM

pmisc1_2_BM    # Canned Bore #1 Cycle
            pprint_BM
            if drill5axes_BM = 1, pdrl5_2_BM
             if tete_rev_BM = 1 & mod5xcont = 0,
              [
            @refhtprint_BM , @inithtprint_BM
           gcode$ = 0
           pnumligne, pgcode_BM, xprint_BM, yprint_BM, inithtprint_BM, e$
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 1
           frplunge_BM = frplunge$
           pnumligne, pgcode_BM, depthprint_BM, frplunge_BM , e$
           pnumligne, pgcode_BM, refhtprint_BM, e$
           gcode$ = 0
           if refhtprint_BM <> inithtprint_BM, pnumligne, pgcode_BM, inithtprint_BM, e$
             ]
           if tete_rev_BM = 0,
             [
        if drill5axes_BM = 1,
                            [
                            initht5x_BM = refht$
							tosz$ = 0
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_BM,",", *tosz$, ",",*sdis_BM,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_BM, *yprint_BM, e$
                            psouf_imp_BM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_BM, e$
                            ]

        else, pnumligne, xprint_BM, yprint_BM, e$ # depth$, refht$, initht$,e$
        psouf_imp_BM
        old_dest_ret_5x_BM = dest_ret_5x_BM
           ]

pmisc1_2_CM    # Canned Bore #1 Cycle
            pprint_CM
            if drill5axes_CM = 1, pdrl5_2_CM
             if tete_rev_CM = 1 & mod5xcont = 0,
              [
            @refhtprint_CM , @inithtprint_CM
           gcode$ = 0
           pnumligne, pgcode_CM, xprint_CM, yprint_CM, inithtprint_CM, e$
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 1
           frplunge_CM = frplunge$
           pnumligne, pgcode_CM, depthprint_CM, frplunge_CM , e$
           pnumligne, pgcode_CM, refhtprint_CM, e$
           gcode$ = 0
           if refhtprint_CM <> inithtprint_CM, pnumligne, pgcode_CM, inithtprint_CM, e$
             ]
           if tete_rev_CM = 0,
             [
        if drill5axes_CM = 1,
                            [
                            initht5x_CM = refht$
							tosz$ = 0
                            spaces$ = 0
                            pnumligne, " MCALL CYCLE85(", *initht5x_CM,",", *tosz$, ",",*sdis_CM,",", *depth$,",, ",*dwell$,",",*avance_plonge,",",*peckclr$,")",e$
                            spaces$ = 1
                            pnumligne, *xprint_CM, *yprint_CM, e$
                            psouf_imp_CM
                            if  nextop$ <> 100, pnumligne, "MCALL", e$, pnumligne, *old_zinitht_CM, e$
                            ]

        else, pnumligne, xprint_CM, yprint_CM, e$ # depth$, refht$, initht$,e$
        psouf_imp_CM
        old_dest_ret_5x_CM = dest_ret_5x_CM
           ]
#endregion
#region pbore2_2
pbore2_2$
            pchange_AG
            pbore2_2_AG

            pchange_AM
            pbore2_2_AM

            pchange_BG
            pbore2_2_BG

            pchange_BM
            pbore2_2_BM

            pchange_CG
            pbore2_2_CG

            pchange_CM
            pbore2_2_CM

pbore2_2_AG    # Canned Bore #2 Cycle
            pprint_AG
        if drill5axes_AG = 1,[
                    pdrl5_2_AG
                    initht5x_AG = refht$
                    depth_AG = depth$
                    refht_AG = refht$
                    sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G86", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, "EP.2 EC0. EA180.", *frplunge$,e$
                     if  nextop$ <> 100, sm, *old_zinitht_AG, paf, "G80", *old_zinitht_AG, e$
                          ]

                         else,  [
                                pcaldrilxyzsimu_AG
                                xprint_AG = v_abs_plus_x_AG
                                yprint_AG = v_abs_plus_y_AG
                                zprint_AG = v_abs_plus_z_AG
                                gcode$ = 0
                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                depth_AG = depth$
                                refht_AG = refht$
                                initht_AG = initht$
                                xprint_AG = x$
                                yprint_AG = y$
                                zprint_AG = z$
                                sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G86", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, "EP.2 EC0. EA180.", *frplunge$, e$
                                xprint_AG = v_abs_plus_x_AG
                                yprint_AG = v_abs_plus_y_AG
                                zprint_AG = v_abs_plus_z_AG
                                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                ]
                         old_dest_ret_5x_AG = dest_ret_5x_AG

pbore2_2_BG    # Canned Bore #2 Cycle

pbore2_2_CG    # Canned Bore #2 Cycle

pbore2_2_AM    # Canned Bore #2 Cycle
            pprint_AM
        if drill5axes_AM = 1,[
                    pdrl5_2_AM
                    initht5x_AM = refht$
                    depth_AM = depth$
                    refht_AM = refht$
                    frplunge_AM = frplunge$
                    pnumligne, "G86", *xprint_AM, *yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, "EP.2 EC0. EA180.", frplunge_AM,e$
                     if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                          ]

                         else,  [
                                depth_AM = depth$
                                refht_AM = refht$
                                initht_AM = initht$
                                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                                ]
                         old_dest_ret_5x_AM = dest_ret_5x_AM

pbore2_2_BM    # Canned Bore #2 Cycle

pbore2_2_CM    # Canned Bore #2 Cycle
#endregion
#region pbore1_2
pbore1_2$
            pchange_AG
            pbore1_2_AG

            pchange_AM
            pbore1_2_AM

            pchange_BG
            pbore1_2_BG

            pchange_BM
            pbore1_2_BM

            pchange_CG
            pbore1_2_CG

            pchange_CM
            pbore1_2_CM

pbore1_2_AG    # Canned Bore #1 Cycle
            pprint_AG
            if drill5axes_AG = 1, pdrl5_2_AG
             if tete_rev_AG = 1 & mod5xcont = 0,
              [
            @refhtprint_AG , @inithtprint_AG
           gcode$ = 0
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$, paf, pgcode_AG, *depthprint_AG, *frplunge$ , e$
           sl, *refhtprint_AG, *frplunge$, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 0
           if refhtprint_AG <> inithtprint_AG, sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
             ]
           if tete_rev_AG = 0,
             [
        if drill5axes_AG = 1, [
                pcaldrilxyzsimu_AG
                initht5x_AG = refht$
                depth_AG = depth$
                refht_AG = refht$
                sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, paf, "G85", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht5x_AG, *frplunge$,e$
                if  nextop$ <> 100, [
                                    xprint_AG = v_abs_plus_x_sec_fin_AG
                                    yprint_AG = v_abs_plus_y_sec_fin_AG
                                    zprint_AG = v_abs_plus_z_sec_fin_AG
                                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, "G80", *xprint_AG, *yprint_AG, *zprint_AG, e$
                                    ]
                            ]

        else,   [
                pcaldrilxyzsimu_AG
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                gcode$ = 0
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                depth_AG = depth$
                refht_AG = refht$
                initht_AG = initht$
                xprint_AG = x$
                yprint_AG = y$
                zprint_AG = z$
                sl, *xprint_AG, *yprint_AG, *depth_AG, *frplunge$, paf, "G85", *xprint_AG, *yprint_AG, *depth_AG, *refht_AG, *initht_AG, *frplunge$, e$
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                ]
        old_dest_ret_5x_AG = dest_ret_5x_AG
           ]

pbore1_2_BG    # Canned Misc #1 Cycle

pbore1_2_CG    # Canned Misc #1 Cycle

pbore1_2_AM    # Canned Bore #1 Cycle
            pprint_AM
            if drill5axes_AM = 1, pdrl5_2_AM
             if tete_rev_AM = 1 & mod5xcont = 0,
              [
            @refhtprint_AM , @inithtprint_AM
           gcode$ = 0
           pnumligne, pgcode_AM, xprint_AM, yprint_AM, inithtprint_AM, e$
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 1
           frplunge_AM = frplunge$
           pnumligne, pgcode_AM, depthprint_AM, frplunge_AM , e$
           pnumligne, pgcode_AM, refhtprint_AM, e$
           gcode$ = 0
           if refhtprint_AM <> inithtprint_AM, pnumligne, pgcode_AM, inithtprint_AM, e$
             ]
           if tete_rev_AM = 0,
             [
        if drill5axes_AM = 1, [
                initht5x_AM = refht$
                depth_AM = depth$
                refht_AM = refht$
                frplunge_AM = frplunge$
                pnumligne, "G85", xprint_AM, yprint_AM, *depth_AM, *refht_AM, *initht5x_AM, frplunge_AM,e$
                if  nextop$ <> 100, pnumligne, "G80", *old_zinitht_AM, e$
                            ]

        else,   [
                depth_AM = depth$
                refht_AM = refht$
                initht_AM = initht$
                pnumligne, xprint_AM, yprint_AM, depth_AM, refht_AM, initht_AM,e$
                ]
        old_dest_ret_5x_AM = dest_ret_5x_AM
           ]

pbore1_2_BM    # Canned Misc #1 Cycle

pbore1_2_CM    # Canned Misc #1 Cycle
#endregion
#region pmisc2_2_old

pmisc2_2_old_BG    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_BG
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_CG    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_CG
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_BM    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_BM
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_old_CM    # Canned Misc #2 Cycle
                percage_helicoido_spiral_2_CM
                !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pmisc2_2
pmisc2_2$
            pchange_AG
            pmisc2_2_AG

            pchange_AM
            pmisc2_2_AM

            pchange_BG
            pmisc2_2_BG

            pchange_BM
            pmisc2_2_BM

            pchange_CG
            pmisc2_2_CG

            pchange_CM
            pmisc2_2_CM

pmisc2_2_AG    # Canned Misc #2 Cycle
            if rotaxtyp$ = 3, [
            pprint_AG
            typcycle_AG = 1
            if drill5axes_AG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AG
                            initht5x_AG = refht$
                           #xprint_AG = 0
                            #yprint_AG = 0
                            percage_helicoido_spiral_2_AG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_AG, paf, pgcode_force_AG, *old_zinitht_AG, e$
                             ]
           else, percage_helicoido_spiral_2_AG
           old_dest_ret_5x_AG = dest_ret_5x_AG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            pprint_AG
            if drill5axes_AG = 1, pdrl5_2_AG
             if tete_rev_AG = 1 & mod5xcont = 0,
              [
            @refhtprint_AG , @inithtprint_AG
           gcode$ = 0
           sr, *xprint_AG, *yprint_AG, *inithtprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *inithtprint_AG, e$
           if refhtprint_AG <> inithtprint_AG, sr, *refhtprint_AG, paf, pgcode_AG, *refhtprint_AG, e$
           gcode$ = 1
           sl, *depthprint_AG, *frplunge$, paf, pgcode_AG, *depthprint_AG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_AG, paf, pgcode_AG, *inithtprint_AG, e$
             ]
           if tete_rev_AG = 0,
             [
        if drill5axes_AG = 1, [
                pcaldrilxyzsimu_AG
                initht5x_AG = refht$
                depth_AG = depth$
                refht_AG = refht$
                sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, pafcom,"CYCLE CAQ", e$
                #if  nextop$ <> 100, sr, *old_zinitht_AG, paf, "G80", *old_zinitht_AG, e$

                if  nextop$ <> 100, [
                                    xprint_AG = v_abs_plus_x_sec_fin_AG
                                    yprint_AG = v_abs_plus_y_sec_fin_AG
                                    zprint_AG = v_abs_plus_z_sec_fin_AG
                                    sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, *xprint_AG, *yprint_AG, *zprint_AG, e$
                                    ]
                            ]

        else,   [
                pcaldrilxyzsimu_AG
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                gcode$ = 0
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                depth_AG = depth$
                refht_AG = refht$
                initht_AG = initht$
                xprint_AG = x$
                yprint_AG = y$
                zprint_AG = z$
                sl, *xprint_AG, *yprint_AG, *zprint_AG, *frplunge$, pafcom,"CYCLE CAQ", e$
                xprint_AG = v_abs_plus_x_AG
                yprint_AG = v_abs_plus_y_AG
                zprint_AG = v_abs_plus_z_AG
                sr, *xprint_AG, *yprint_AG, *zprint_AG, paf, pgcode_force_AG, *xprint_AG, *yprint_AG, *zprint_AG, e$
                ]
        old_dest_ret_5x_AG = dest_ret_5x_AG
           ]
                    ]

pmisc2_2_BG    # Canned Misc #2 Cycle
            if rotaxtyp$ = 3, [
            pprint_BG
            typcycle_BG = 1
            if drill5axes_BG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BG
                            initht5x_BG = refht$
                           #xprint_BG = 0
                            #yprint_BG = 0
                            percage_helicoido_spiral_2_BG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_BG, paf, pgcode_force_BG, *old_zinitht_BG, e$
                             ]
           else, percage_helicoido_spiral_2_BG
           old_dest_ret_5x_BG = dest_ret_5x_BG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            pprint_BG
            if drill5axes_BG = 1, pdrl5_2_BG
             if tete_rev_BG = 1 & mod5xcont = 0,
              [
            @refhtprint_BG , @inithtprint_BG
           gcode$ = 0
           sr, *xprint_BG, *yprint_BG, *inithtprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *inithtprint_BG, e$
           if refhtprint_BG <> inithtprint_BG, sr, *refhtprint_BG, paf, pgcode_BG, *refhtprint_BG, e$
           gcode$ = 1
           sl, *depthprint_BG, *frplunge$, paf, pgcode_BG, *depthprint_BG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_BG, paf, pgcode_BG, *inithtprint_BG, e$
             ]
           if tete_rev_BG = 0,
                        [
                        if drill5axes_BG = 1, [
                        pcaldrilxyzsimu_BG
                        initht5x_BG = refht$

                        sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, pafcom,"CYCLE CAQ", e$
                        spaces$ = 1
                        #sm, paf, *xprint_BG, *yprint_BG, e$
                        psouf_imp_BG
                        if  nextop$ <> 100, [
                                    xprint_BG = v_abs_plus_x_sec_fin_BG
                                    yprint_BG = v_abs_plus_y_sec_fin_BG
                                    zprint_BG = v_abs_plus_z_sec_fin_BG
                                    sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, *xprint_BG, *yprint_BG, *zprint_BG, e$
                                    ]
                        ]
        #else, sm, paf, xprint_BG, yprint_BG, e$, # depth$, refht$, initht$,e$
        else,   [
                pcaldrilxyzsimu_BG
                xprint_BG = v_abs_plus_x_BG
                yprint_BG = v_abs_plus_y_BG
                zprint_BG = v_abs_plus_z_BG
                gcode$ = 0
                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                xprint_BG = x$
                yprint_BG = y$
                zprint_BG = z$
                sl, *xprint_BG, *yprint_BG, *zprint_BG, *frplunge$, pafcom,"CYCLE CAQ", e$
                spaces$ = 1
                xprint_BG = v_abs_plus_x_BG
                yprint_BG = v_abs_plus_y_BG
                zprint_BG = v_abs_plus_z_BG
                sr, *xprint_BG, *yprint_BG, *zprint_BG, paf, pgcode_force_BG, *xprint_BG, *yprint_BG, *zprint_BG, e$
                ]
        psouf_imp_BG
        old_dest_ret_5x_BG = dest_ret_5x_BG
           ]
                    ]

pmisc2_2_CG    # Canned Misc #2 Cycle
            if rotaxtyp$ = 3, [
            pprint_CG
            typcycle_CG = 1
            if drill5axes_CG = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CG
                            initht5x_CG = refht$
                           #xprint_CG = 0
                            #yprint_CG = 0
                            percage_helicoido_spiral_2_CG

                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_CG, paf, pgcode_force_CG, *old_zinitht_CG, e$
                             ]
           else, percage_helicoido_spiral_2_CG
           old_dest_ret_5x_CG = dest_ret_5x_CG
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            ]
            else,   [
            pprint_CG
            if drill5axes_CG = 1, pdrl5_2_CG
             if tete_rev_CG = 1 & mod5xcont = 0,
              [
            @refhtprint_CG , @inithtprint_CG
           gcode$ = 0
           sr, *xprint_CG, *yprint_CG, *inithtprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *inithtprint_CG, e$
           if refhtprint_CG <> inithtprint_CG, sr, *refhtprint_CG, paf, pgcode_CG, *refhtprint_CG, e$
           gcode$ = 1
           sl, *depthprint_CG, *frplunge$, paf, pgcode_CG, *depthprint_CG, *frplunge$ , e$
           gcode$ = 0
           sr, *inithtprint_CG, paf, pgcode_CG, *inithtprint_CG, e$
             ]
           if tete_rev_CG = 0,
                        [
                        if drill5axes_CG = 1, [
                        pcaldrilxyzsimu_CG
                        initht5x_CG = refht$

                        sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, pafcom,"CYCLE CAQ", e$
                        spaces$ = 1
                        #sm, paf, *xprint_CG, *yprint_CG, e$
                        psouf_imp_CG
                        if  nextop$ <> 100, [
                                    xprint_CG = v_abs_plus_x_sec_fin_CG
                                    yprint_CG = v_abs_plus_y_sec_fin_CG
                                    zprint_CG = v_abs_plus_z_sec_fin_CG
                                    sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, *xprint_CG, *yprint_CG, *zprint_CG, e$
                                    ]
                        ]
        #else, sm, paf, xprint_CG, yprint_CG, e$, # depth$, refht$, initht$,e$
        else,   [
                pcaldrilxyzsimu_CG
                xprint_CG = v_abs_plus_x_CG
                yprint_CG = v_abs_plus_y_CG
                zprint_CG = v_abs_plus_z_CG
                gcode$ = 0
                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                xprint_CG = x$
                yprint_CG = y$
                zprint_CG = z$
                sl, *xprint_CG, *yprint_CG, *zprint_CG, *frplunge$, pafcom,"CYCLE CAQ", e$
                spaces$ = 1
                xprint_CG = v_abs_plus_x_CG
                yprint_CG = v_abs_plus_y_CG
                zprint_CG = v_abs_plus_z_CG
                sr, *xprint_CG, *yprint_CG, *zprint_CG, paf, pgcode_force_CG, *xprint_CG, *yprint_CG, *zprint_CG, e$
                ]
        psouf_imp_CG
        old_dest_ret_5x_CG = dest_ret_5x_CG
           ]
                    ]

pmisc2_2_AM    # Canned Misc #2 Cycle
            pprint_AM
            typcycle_AM = 1
            if drill5axes_AM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AM
                            initht5x_AM = refht$
                           #xprint_AM = 0
                            #yprint_AM = 0
                            percage_helicoido_spiral_2_AM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                             ]
           else, percage_helicoido_spiral_2_AM
           old_dest_ret_5x_AM = dest_ret_5x_AM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_BM    # Canned Misc #2 Cycle
            pprint_BM
            typcycle_BM = 1
            if drill5axes_BM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BM
                            initht5x_BM = refht$
                           #xprint_BM = 0
                            #yprint_BM = 0
                            percage_helicoido_spiral_2_BM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                             ]
           else, percage_helicoido_spiral_2_BM
           old_dest_ret_5x_BM = dest_ret_5x_BM
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pmisc2_2_CM    # Canned Misc #2 Cycle
            pprint_CM
            typcycle_CM = 1
            if drill5axes_CM = 1,[
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CM
                            initht5x_CM = refht$
                           #xprint_CM = 0
                            #yprint_CM = 0
                            percage_helicoido_spiral_2_CM

                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                             ]
           else, percage_helicoido_spiral_2_CM
           old_dest_ret_5x_CM = dest_ret_5x_CM
            !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pcanceldc
pcanceldc$
            pchange_AG
            pcanceldc_AG

            pchange_AM
            pcanceldc_AM

            pchange_BG
            pcanceldc_BG

            pchange_BM
            pcanceldc_BM

            pchange_CG
            pcanceldc_CG

            pchange_CM
            pcanceldc_CM

pcanceldc_AG   # Cancel canned drill cycle
            #pprint_AG
            zinitht_AG = initht$
            if cycle_heli_spiral_AG = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AG = 0
                 if drill5axes_AG = 0, sr, *zinitht_AG, paf, pgcode_AG, *zinitht_AG,e$
                  sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$
                ]
            if drill5axes_AG = 0 & typcycle_AG = 1, sr, *zinitht_AG, paf, "G80", *zinitht_AG,e$
            typcycle_AG = 0

            pdmodalxyz_AG

pcanceldc_BG   # Cancel canned drill cycle
            #pprint_BG
           # "voir les Z=", *refht$, *initht$, *initht5x_BG, e$ 
            zinitht_BG = initht$
            if cycle_heli_spiral_BG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BG = 0
                 gcode$ = 0
                 if drill5axes_BG = 0, sr, *zinitht_BG, paf, pgcode_force_BG, *zinitht_BG,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BG = 0 & typcycle_BG = 1, sm, paf, "MCALL",e$, sr, *zinitht_BG, paf, *zinitht_BG,e$
                  ]
            typcycle_BG = 0
            pdmodalxyz_BG

pcanceldc_CG   # Cancel canned drill cycle
            #pprint_CG
           # "voir les Z=", *refht$, *initht$, *initht5x_CG, e$ 
            zinitht_CG = initht$
            if cycle_heli_spiral_CG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CG = 0
                 gcode$ = 0
                 if drill5axes_CG = 0, sr, *zinitht_CG, paf, pgcode_force_CG, *zinitht_CG,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CG = 0 & typcycle_CG = 1 & drillcyc$ <> 11, sm, paf, "MCALL",e$, sr, *zinitht_CG, paf, *zinitht_CG,e$
                    if drill5axes_CG = 0 & typcycle_CG = 1, sr, *zinitht_CG, paf, *zinitht_CG,e$
                  ]
            typcycle_CG = 0
            pdmodalxyz_CG

pcanceldc_AM   # Cancel canned drill cycle
            #pprint_AM
            zinitht_AM = initht$
            if cycle_heli_spiral_AM = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AM = 0
                 if drill5axes_AM = 0, pnumligne, pgcode_AM, *zinitht_AM,e$
                  pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$
                ]
            if drill5axes_AM = 0 & typcycle_AM = 1, pnumligne, "G80", *zinitht_AM,e$
            typcycle_AM = 0

            pdmodalxyz_AM

pcanceldc_BM   # Cancel canned drill cycle
            #pprint_BM
           # "voir les Z=", *refht$, *initht$, *initht5x_BM, e$ 
            zinitht_BM = initht$
            if cycle_heli_spiral_BM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BM = 0
                 gcode$ = 0
                 if drill5axes_BM = 0, pnumligne, pgcode_force_BM, *zinitht_BM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BM = 0 & typcycle_BM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BM,e$
                  ]
            typcycle_BM = 0
            pdmodalxyz_BM

pcanceldc_CM   # Cancel canned drill cycle
            #pprint_CM
           # "voir les Z=", *refht$, *initht$, *initht5x_CM, e$ 
            zinitht_CM = initht$
            if cycle_heli_spiral_CM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CM = 0
                 gcode$ = 0
                 if drill5axes_CM = 0, pnumligne, pgcode_force_CM, *zinitht_CM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CM = 0 & typcycle_CM = 1 & drillcyc$ <> 11, pnumligne, "MCALL",e$, pnumligne, *zinitht_CM,e$
                    if drill5axes_CM = 0 & typcycle_CM = 1, pnumligne, *zinitht_CM,e$
                  ]
            typcycle_CM = 0
            pdmodalxyz_CM
#endregion
#region pcancelcc
pcancelcc$
            pchange_AG
            pcancelcc_AG

            pchange_AM
            pcancelcc_AM

            pchange_BG
            pcancelcc_BG

            pchange_BM
            pcancelcc_BM

            pchange_CG
            pcancelcc_CG

            pchange_CM
            pcancelcc_CM

pcancelcc_AG   # Cancel canned drill cycle
            pprint_AG
           if cycle_heli_spiral_AG = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AG = 0
                 if drill5axes_AG = 0, sr, *zinitht_AG, paf, pgcode_AG, *zinitht_AG,e$
                  sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$
                ]
            if drill5axes_AG = 0 & typcycle_AG = 1, sr, *zinitht_AG, paf "G80", *zinitht_AG,e$
            typcycle_AG = 0
              # Define string variables to hold 'sparameter' string data

pcancelcc_BG   # Cancel canned drill cycle
            pprint_BG
             if cycle_heli_spiral_BG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BG = 0
                  gcode$ = 0
                 if drill5axes_BG = 0, sr, *zinitht_BG, paf, pgcode_force_BG, *zinitht_BG,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BG = 0 & typcycle_BG = 1, sm, paf, "MCALL",e$, sr, *zinitht_BG, paf, *zinitht_BG, e$
                  ]
            typcycle_BG = 0

pcancelcc_CG   # Cancel canned drill cycle
            pprint_CG
             if cycle_heli_spiral_CG = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CG = 0
                  gcode$ = 0
                 if drill5axes_CG = 0, sr, *zinitht_CG, paf, pgcode_force_CG, *zinitht_CG,e$
                 sm, paf, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CG = 0 & typcycle_CG = 1, sm, paf, "MCALL",e$, sr, *zinitht_CG, paf, *zinitht_CG, e$
                  ]
            typcycle_CG = 0

pcancelcc_AM   # Cancel canned drill cycle
            pprint_AM
           if cycle_heli_spiral_AM = 1,# choix du gcode pour ecrire G0
                [
                 gcode$ = 0
                 cycle_heli_spiral_AM = 0
                 if drill5axes_AM = 0, pnumligne, pgcode_AM, *zinitht_AM,e$
                  pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$
                ]
            if drill5axes_AM = 0 & typcycle_AM = 1, pnumligne, "G80", *zinitht_AM,e$
            typcycle_AM = 0
              # Define string variables to hold 'sparameter' string data

pcancelcc_BM   # Cancel canned drill cycle
            pprint_BM
             if cycle_heli_spiral_BM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_BM = 0
                  gcode$ = 0
                 if drill5axes_BM = 0, pnumligne, pgcode_force_BM, *zinitht_BM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_BM = 0 & typcycle_BM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_BM,e$
                  ]
            typcycle_BM = 0

pcancelcc_CM   # Cancel canned drill cycle
            pprint_CM
             if cycle_heli_spiral_CM = 1, gcode$ = 0,
                [
                 cycle_heli_spiral_CM = 0
                  gcode$ = 0
                 if drill5axes_CM = 0, pnumligne, pgcode_force_CM, *zinitht_CM,e$
                 pnumligne, sdcom, " FIN CYCLE CAQ ", sfcom, e$    # choix du gcode pour ecrire G0
                ]
            else, [
                    if drill5axes_CM = 0 & typcycle_CM = 1, pnumligne, "MCALL",e$, pnumligne, *zinitht_CM,e$
                  ]
            typcycle_CM = 0
#endregion
#region pnumop

pnumop_AG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_AG, numop_AG = numop_AG + 1
pnumop_BG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_BG, numop_BG = numop_BG + 1
pnumop_CG      # numerotation des operations post-processées

             if op_id$ <> prvop_id_CG, numop_CG = numop_CG + 1

pnumop_AM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_AM, numop_AM = numop_AM + 1
pnumop_BM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_BM, numop_BM = numop_BM + 1
pnumop_CM      # numerotation des operations post-processées

             if op_id$ <> prvop_id_CM, numop_CM = numop_CM + 1
#endregion
#endregion

#region   CYCLE SPECIAL HELICOIDO-SPIRAL #OK
#region variables CYCLE SPECIAL HELICOIDO-SPIRAL
# ----------------------- DEBUT CYCLE SPECIAL HELICOIDO-SPIRAL ------------------------
#------------- DECLARATION DES VARIABLES via le cycle  ------------
fmt "Aval ou OPP=" 4 ava_opp                        # Détermine si la fraise travail en avalant ou opposition
fmt "Diametre final=" 2 dia_final                   # diametre du trou programmé 
fmt "Diametre ebauche=" 2 dia_ebauche               # diametre d'ebauche
fmt "Pas maximum en Z=" 2 pas_max_z                 # Pas maximum en Z
fmt "Pas maximum en XY=" 2 pas_max_xy               # Pas maximum en XY pour la spiral en fond de trou
fmt "Nb Tr de finition=" 4 nbe_tr_fin               # Nombre de tour pour passe de finition
fmt "F" 5 f_ent_cir   #OK                              # avance en entree ciculaire au debut de l'helicoide
fmt "F" 5 f_int_hel   #OK                               # avance de l'helicoide 
fmt "F" 5 f_spiral    #OK                               # avance de la spiral
fmt "F" 5 f_int_fin   #OK                               # avance sur la finition du trou
fmt "F" 5 f_sor_cir   #OK                               # avance sur la sortie de la finition du trou
fmt "F" 5 f_base      #OK                               # avance de base du cycle
fmt "Dis. entre perp=" 2 ent_perp                   # distance d'entree perpendiculaire au debut du cycle pour le G41
fmt "Gestion usure=" 4 cor_ray                      # ativation d'un G41 ou G42 suivant besoins
fmt "Nb Tr de finition de retour=" 4 nbe_tr_retour  # Nombre de tour pour la deuxieme passe de finition a l'opposer du sens de la premiere
fmt  "OPERATION "  5 numop                          # NUMERO D'OPERATION
fmt "Drl_prm1=" 2 drl_prm1$
fmt "Drl_prm2=" 2 drl_prm2$
fmt "Drl_prm3=" 2 drl_prm3$
fmt "Drl_prm4=" 2 drl_prm4$
fmt "Drl_prm5=" 2 drl_prm5$
fmt "Drl_prm6=" 2 drl_prm6$
fmt "Drl_prm7=" 2 drl_prm7$
fmt "Drl_prm8=" 2 drl_prm8$
fmt "Drl_prm9=" 2 drl_prm9$
fmt "Drl_prm10=" 2 drl_prm10$
#------------- DECLARATION DES VARIABLES pour calcul interne  ------------
fmt "X" 2 x_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Y" 2 y_chs                                 # coordonee X du centre du trou du cycle helicoido-spiral
fmt "Z" 2 z_plan_securite                       # coordonee Z du plan de securite
fmt "Z" 2 z_profondeur                          # coordonee Z du fond du trou
fmt "X" 2 x_ent_cir                             # coordonee X du point du centre du cercle pour l'entre circulaire
fmt "R" 2 ray_ent_cir                           # rayon du cercle de l'entree circulaire
fmt "Nb pas Z =" 4 nbe_pas_z                    # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Nb de pas actuel" 4 nbe_pas_actu           # nombre de pas actuel
fmt "Pas Z=" 2 pas_z                            # valeur reel du pas de l'helice
fmt "Nb pas XY =" 2 nbe_pas_xy                  # nombre de pas ( ou de tour ) sur l'interpo helicoidale
fmt "Pas XY=" 2 pas_xy                          # valeur reel du pas de la spiral
fmt "Nb de cercle" 2 nbe_demi_cercle            # nombre de demi cercle que constitue la spiral
fmt "R" 2 ray_sor_cir                           # rayon pour la sortie de la spiral
fmt "X" 2 x_sor_cir                             # coordonee X du point du centre du cercle pour la sortie circulaire
fmt "R" 2 ray_ebauche                           # rayon d'ebauche 
fmt "Sens" 4 sens_usi                           # sens de l'usinage, -1 = avalant, 1 = opposition et depend de la reponce: Avalant=0 Oppositon = 1
fmt "X" 2 old_xp_chs                            # ecriture d'un X dans le cycle Helicoédo-Spiral
fmt "I" 2 i_eb_cir                              # coordonee I centre du cercle de l'helicoide en relatif point de depart
fmt "J" 2 j_eb_cir                              # coordonee J centre du cercle en relatif point de depart
fmt "Diam" 2 diam_cercle                        # diametre du cercle d'un demi tours de spiral
fmt "X max dans le trou" 2 xp_chs_max           # coordoonee maxi dans le centre du trou
fmt "Ray_sortie" 2 ray_cercle_sortie            # Rayon de sortie sur la finition 
fmt "rap_ray_sortie=" 1 rapport_ray_sortie      # rapport muliplicateur du rayon de sortie
fmt "angle_ray_sortie" 1 angle_ray_sortie       # angle de balayage de la portion de cercle de la sortie
fmt "Nb spiral debut " 4 nb_tr_debut " tr"      # Nombre de spiral en debut
fmt "Nb spiral fin " 4 nb_tr_fin    " tr"       # Nombre de spiral en fin
fmt "Pas spiral debut-fin " 2 pas_Z_deb_fin " mm"       # Pas de la spiral d'entree et de fin  
fmt "haut spi debut" 2 prof_z_deb_spi           # calcul de la hauteur de la spiral de debut en ebauche
fmt "haut spi fin" 2 prof_z_fin_spi             # calcul de la hauteur de la spiral de fin en ebauche
fmt "helice total = " 2 hauteur_hel " mm"               # hauteur total de l'helicoide
fmt "Le cumul helice debut et fin = " 2 hauteur_hel_debfin " mm"
fmt "Ray_cercle ebauche" 2 ray_cercle_ebauche   # Rayon de sortie sur la finition 

#------------------ DECLARATIONS DE MESSAGE SI VALEURS NON CONFORMES-----------

sdcom : ";"
sfcom : ""
#endregion
#region percage_helicoido_spiral_2

percage_helicoido_spiral_2_AG  # ecriture générale du cycle spécial helicoédo-spiral trou suivant
                                gcode$ = 0

                                xabs_AG = xprint_AG
                                yabs_AG = yprint_AG
                                zabs_AG = initht$

                                sr, *zabs_AG, paf, pgcode_force_AG, *zabs_AG, e$
                                sm, paf, sdcom, " POSITIONEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_AG, *yabs_AG, paf, *xabs_AG, *yabs_AG, e$
                                percage_helicoido_spiral_AG

percage_helicoido_spiral_2_BG      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_BG = xprint_BG
                                yabs_BG = yprint_BG
                                zabs_BG = initht$
                                sr, *zabs_BG, paf, pgcode_force_BG, *zabs_BG, e$
                                sm, paf, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_BG, *yabs_BG, paf, *xabs_BG, *yabs_BG, e$
                                percage_helicoido_spiral_BG

percage_helicoido_spiral_2_CG      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_CG = xprint_CG
                                yabs_CG = yprint_CG
                                zabs_CG = initht$
                                sr, *zabs_CG, paf, pgcode_force_CG, *zabs_CG, e$
                                sm, paf, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_CG, *yabs_CG, paf, *xabs_CG, *yabs_CG, e$
                                percage_helicoido_spiral_CG

percage_helicoido_spiral_2_AM  # ecriture générale du cycle spécial helicoédo-spiral trou suivant
                                gcode$ = 0

                                xabs_AM = xprint_AM
                                yabs_AM = yprint_AM
                                zabs_AM = initht$

                                pnumligne, pgcode_force_AM, *zabs_AM, e$
                                pnumligne, sdcom, " POSITIONEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_AM, *yabs_AM, e$
                                percage_helicoido_spiral_AM

percage_helicoido_spiral_2_BM      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_BM = xprint_BM
                                yabs_BM = yprint_BM
                                zabs_BM = initht$
                                pnumligne, pgcode_force_BM, *zabs_BM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BM, *yabs_BM, e$
                                percage_helicoido_spiral_BM

percage_helicoido_spiral_2_CM      # ecriture générale du cycle spécial CAQ trou suivant
                                gcode$ = 0
                                xabs_CM = xprint_CM
                                yabs_CM = yprint_CM
                                zabs_CM = initht$
                                pnumligne, pgcode_force_CM, *zabs_CM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CM, *yabs_CM, e$
                                percage_helicoido_spiral_CM
#endregion
#region percage_helicoido_spiral

percage_helicoido_spiral_AG   # ecriture générale du cycle spécial helicoédo-spiral

                            pcalcule_variable_AG
                            #pvoir_variable_AG
                            #ptest_variable_AG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_AG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_AG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_AG - prof_z_deb_spi
                                phase_2_AG                                         # debut ebauche helicoide

                                z_dessus_brut_AG = z_dessus_brut_AG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_AG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_AG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_AG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_AG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_AG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_AG         # premiere serie de passes de finition 
                                    ]
                                phase_5_AG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_AG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_AG         # premiere serie de passes de deuxieme finition 
                                    phase_8_AG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_AG           # premiere serie de passes de finition 
                                phase_5_2_AG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_AG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_AG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_AG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_BG   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_BG
                            #pvoir_variable_BG
                            #ptest_variable_BG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_BG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_BG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_BG - prof_z_deb_spi
                                phase_2_BG                                         # debut ebauche helicoide

                                z_dessus_brut_BG = z_dessus_brut_BG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_BG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_BG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_BG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_BG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_BG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_BG         # premiere serie de passes de finition 
                                    ]
                                phase_5_BG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_BG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_BG         # premiere serie de passes de deuxieme finition 
                                    phase_8_BG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_BG           # premiere serie de passes de finition 
                                phase_5_2_BG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_BG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_BG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_BG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_CG   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_CG
                            #pvoir_variable_CG
                            #ptest_variable_CG
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_CG                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_CG
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_CG - prof_z_deb_spi
                                phase_2_CG                                         # debut ebauche helicoide

                                z_dessus_brut_CG = z_dessus_brut_CG - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_CG - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_CG                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_CG = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                sm, paf, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_CG                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_CG             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_CG         # premiere serie de passes de finition 
                                    ]
                                phase_5_CG             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_CG         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_CG         # premiere serie de passes de deuxieme finition 
                                    phase_8_CG         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_CG           # premiere serie de passes de finition 
                                phase_5_2_CG           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_CG       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_CG       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_CG       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_AM   # ecriture générale du cycle spécial helicoédo-spiral

                            pcalcule_variable_AM
                            #pvoir_variable_AM
                            #ptest_variable_AM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_AM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_AM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_AM - prof_z_deb_spi
                                phase_2_AM                                         # debut ebauche helicoide

                                z_dessus_brut_AM = z_dessus_brut_AM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_AM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_AM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_AM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_AM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_AM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_AM         # premiere serie de passes de finition 
                                    ]
                                phase_5_AM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_AM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_AM         # premiere serie de passes de deuxieme finition 
                                    phase_8_AM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_AM           # premiere serie de passes de finition 
                                phase_5_2_AM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_AM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_AM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_AM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_BM   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_BM
                            #pvoir_variable_BM
                            #ptest_variable_BM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_BM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_BM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_BM - prof_z_deb_spi
                                phase_2_BM                                         # debut ebauche helicoide

                                z_dessus_brut_BM = z_dessus_brut_BM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_BM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_BM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_BM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_BM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_BM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_BM         # premiere serie de passes de finition 
                                    ]
                                phase_5_BM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_BM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_BM         # premiere serie de passes de deuxieme finition 
                                    phase_8_BM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_BM           # premiere serie de passes de finition 
                                phase_5_2_BM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_BM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_BM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_BM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]

percage_helicoido_spiral_CM   # ecriture générale du cycle spécial CAQ                         
                            pcalcule_variable_CM
                            #pvoir_variable_CM
                            #ptest_variable_CM
                            spaces$ = 1
                            if ent_perp <> -1,
                                [
                                phase_1_CM                 # approche ligne + demi cercle
                                ]
                            else,
                                [
                                phase_1_2_CM
                                ]

                            if pas_Z_deb_fin > 0 & nb_tr_debut <> 0,  # debut ebauche helicoide
                                [
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "DEBUT EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_debut
                                pas_z = pas_Z_deb_fin
                                prof_z_deb_spi = nb_tr_debut * pas_Z_deb_fin    # calcul de la hauteur de la spiral de debut en ebauche
                                z_profondeur = z_dessus_brut_CM - prof_z_deb_spi
                                phase_2_CM                                         # debut ebauche helicoide

                                z_dessus_brut_CM = z_dessus_brut_CM - prof_z_deb_spi
                                ]
                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,
                                [
                                prof_z_fin_spi =  pas_Z_deb_fin * nb_tr_fin
                                z_profondeur = depth$ + prof_z_fin_spi
                                ]
                            else,
                                [
                                 prof_z_fin_spi = 0
                                 z_profondeur = depth$
                                ]

                            # Calcul du nb de passe et du pas exacte
                            hauteur_hel = z_dessus_brut_CM - z_profondeur
                            nbe_pas_z = hauteur_hel/pas_max_z
                            if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            pas_z = hauteur_hel/nbe_pas_z

                            phase_2_CM                 # entre matiere helicoide

                            if pas_Z_deb_fin > 0 & nb_tr_fin <> 0,  # fin ebauche helicoide
                                [
                                z_profondeur = depth$
                                z_dessus_brut_CM = z_profondeur + prof_z_fin_spi
                                # Calcul du nb de passe et du pas exacte    
                                pnumligne, sdcom, "FIN EBAUCHE HELICOIDALE", sfcom, e$
                                nbe_pas_z = nb_tr_fin
                                pas_z = pas_Z_deb_fin
                                phase_2_CM                 # fin ebauche helicoide
                                ]
                        if dia_ebauche < dia_final, #  d'ebauche en spiral jusqu'au au diam final
                                [
                                phase_3_CM             # ebauche fond du trou en spiral                            
                            if nbe_tr_fin > 0,      # pas de premiere serie de passes de finition si on veux pas 
                                    [
                                    phase_4_CM         # premiere serie de passes de finition 
                                    ]
                                phase_5_CM             # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_CM         # entre ligne + cercle pour deuxiemme finition
                                    phase_7_CM         # premiere serie de passes de deuxieme finition 
                                    phase_8_CM         # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
                        else,                       # on est deja au diametre final, donc on finis directement
                                [
                                phase_4_2_CM           # premiere serie de passes de finition 
                                phase_5_2_CM           # sortie circlaire + ligne suite finition contour
                            if nbe_tr_retour > 0,   # pas de deuxiemme passe de finition si on veux pas
                                    [
                                    phase_6_2_CM       # entre ligne + cercle pour deuxiemme finition
                                    phase_7_2_CM       # premiere serie de passes de deuxieme finition 
                                    phase_8_2_CM       # sortie circlaire + ligne suite deuxieme finition contour
                                    ]
                                ]
#endregion
#region pvoir_variable

pvoir_variable_AG         # juste pour voir si tout OK
                            "voir variable drl:",e$

                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_AG = ",z_retraction_AG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir rayon ebauche = ", ray_ebauche, e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_AG =", z_dessus_brut_AG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir rapport_ray_sortie=", rapport_ray_sortie, e$
                            " angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_BG        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_BG = ",z_retraction_BG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_BG =", z_dessus_brut_BG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_CG        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir , e$
                            f_int_hel, e$
                            f_spiral, e$
                            f_int_fin, e$
                            f_sor_cir, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_CG = ",z_retraction_CG , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base = ",f_base , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_CG =", z_dessus_brut_CG, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_AM         # juste pour voir si tout OK
                            "voir variable drl:",e$

                            f_ent_cir_AM , e$
                            f_int_hel_AM, e$
                            f_spiral_AM, e$
                            f_int_fin_AM, e$
                            f_sor_cir_AM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_AM = ",z_retraction_AM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir rayon ebauche = ", ray_ebauche, e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_AM = ",f_base_AM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_AM =", z_dessus_brut_AM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir rapport_ray_sortie=", rapport_ray_sortie, e$
                            " angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_BM        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir_BM , e$
                            f_int_hel_BM, e$
                            f_spiral_BM, e$
                            f_int_fin_BM, e$
                            f_sor_cir_BM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_BM = ",z_retraction_BM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_BM = ",f_base_BM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_BM =", z_dessus_brut_BM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$

pvoir_variable_CM        # juste pour voir si tout OK
                            "voir variable drl:",e$
                            f_ent_cir_CM , e$
                            f_int_hel_CM, e$
                            f_spiral_CM, e$
                            f_int_fin_CM, e$
                            f_sor_cir_CM, e$
                            ent_perp,e$
                            cor_ray, e$
                            nbe_tr_retour, e$
                            " voir z_retraction_CM = ",z_retraction_CM , e$
                            " voir z_plan_securite = ", z_plan_securite, e$
                            " voir z_profondeur = ",z_profondeur , e$
                            " voir dia_ebauche = ",dia_ebauche , e$
                            " voir ava_opp = ", *ava_opp , e$
                            " voir dia_final = ",dia_final , e$
                            " voir nbe_tr_fin = ",nbe_tr_fin , e$
                            " voir pas_max_z = ", pas_max_z, e$
                            " voir f_base_CM = ",f_base_CM , e$
                            " voir pas_max_xy = ",pas_max_xy , e$
                            " voir z_dessus_brut_CM =", z_dessus_brut_CM, e$
                            " voir ray_ent_cir=", ray_ent_cir, e$
                            " voir nbe_pas_z=", nbe_pas_z, e$
                            " voir pas_z=", pas_z, e$
                            " Voir nbe_pas_xy=", nbe_pas_xy, e$
                            " voir pas_xy=", pas_xy, e$
                            " voir nbe_demi_cercle=", nbe_demi_cercle, e$
                            " voir ray_sor_cir=", ray_sor_cir, e$
                            " voir ray_cercle_sortie=", ray_cercle_sortie, e$
                            " voir ray_cercle_ebauche=",ray_cercle_ebauche, e$
                            " voir rapport_ray_sortie= ", rapport_ray_sortie, e$
                            " voir angle_ray_sortie=", angle_ray_sortie, e$
                            " Voir pas spiral debut et fin=", *pas_Z_deb_fin, e$
                            " Voir le nombre de tour en debut spiral d'entree=", nb_tr_debut, e$
                            " Voir le nombre de tour en fin spiral d'entree=", nb_tr_fin, e$
                            "------------- fin de verification ---------", e$
#endregion
#region pcalcule_variable

pcalcule_variable_AG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_AG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_AG = 1, z_dessus_brut_AG = drl_sel_tos$
                            else, z_dessus_brut_AG = tosz$
                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin


                            abs_inc = 1 # defini si les cercle sont incremental ou absolue



                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_AG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin
                            #"voir hauteur_hel=", hauteur_hel, e$
                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_AG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_AG = 1
                            xabs_AG = xprint_AG         # reprendre les positions xyz avant le dégagement
                            yabs_AG = yprint_AG
                            zabs_AG = zprint_AG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                           # pas_z = hauteur_hel/nbe_pas_z
                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_AG

pcalcule_variable_BG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_BG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_BG = 1, z_dessus_brut_BG = drl_sel_tos$
                            else, z_dessus_brut_BG = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_BG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_BG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_BG = 1
                            xabs_BG = xprint_BG
                            yabs_BG = yprint_BG
                            zabs_BG = zprint_BG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_BG = xabs_BG + ent_perp
                                #x_ent_cir = x_perp_BG - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_BG = ray_ent_cir * -1 # + x_perp_BG  # si I en ABS
                                x_sor_cir = xabs_BG + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_BG = xabs_BG - ent_perp
                                #x_ent_cir = x_perp_BG +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_BG = ray_ent_cir # + x_perp_BG  # si I en ABS
                                x_sor_cir = xabs_BG - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_BG

pcalcule_variable_CG       # mise a jour des variables 
                            f_ent_cir = drl_prm1$
                            f_int_hel = drl_prm2$
                            f_spiral  = drl_prm3$
                            f_int_fin = drl_prm4$
                            f_sor_cir = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_CG = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_CG = 1, z_dessus_brut_CG = drl_sel_tos$
                            else, z_dessus_brut_CG = tosz$

                            if f_ent_cir = 0, f_ent_cir = f_base
                            if f_int_hel = 0, f_int_hel = f_ent_cir
                            if f_spiral  = 0, f_spiral = f_int_hel
                            if f_int_fin = 0, f_int_fin = f_spiral
                            if f_sor_cir = 0, f_sor_cir = f_int_fin





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_CG - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_CG   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_CG = 1
                            xabs_CG = xprint_CG
                            yabs_CG = yprint_CG
                            zabs_CG = zprint_CG



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_CG = xabs_CG + ent_perp
                                #x_ent_cir = x_perp_CG - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_CG = ray_ent_cir * -1 # + x_perp_CG  # si I en ABS
                                x_sor_cir = xabs_CG + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_CG = xabs_CG - ent_perp
                                #x_ent_cir = x_perp_CG +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_CG = ray_ent_cir # + x_perp_CG  # si I en ABS
                                x_sor_cir = xabs_CG - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_CG                          

pcalcule_variable_AM       # mise a jour des variables 
                            f_ent_cir_AM = drl_prm1$
                            f_int_hel_AM = drl_prm2$
                            f_spiral_AM  = drl_prm3$
                            f_int_fin_AM = drl_prm4$
                            f_sor_cir_AM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_AM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_AM = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_AM = 1, z_dessus_brut_AM = drl_sel_tos$
                            else, z_dessus_brut_AM = tosz$
                            if f_ent_cir_AM = 0, f_ent_cir_AM = f_base_AM
                            if f_int_hel_AM = 0, f_int_hel_AM = f_ent_cir_AM
                            if f_spiral_AM  = 0, f_spiral_AM = f_int_hel_AM
                            if f_int_fin_AM = 0, f_int_fin_AM = f_spiral_AM
                            if f_sor_cir_AM = 0, f_sor_cir_AM = f_int_fin_AM


                            abs_inc = 1 # defini si les cercle sont incremental ou absolue



                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_AM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin
                            #"voir hauteur_hel=", hauteur_hel, e$
                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_AM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_AM = 1
                            xabs_AM = xprint_AM         # reprendre les positions xyz avant le dégagement
                            yabs_AM = yprint_AM
                            zabs_AM = zprint_AM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                           # pas_z = hauteur_hel/nbe_pas_z
                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_AM

pcalcule_variable_BM       # mise a jour des variables 
                            f_ent_cir_BM = drl_prm1$
                            f_int_hel_BM = drl_prm2$
                            f_spiral_BM  = drl_prm3$
                            f_int_fin_BM = drl_prm4$
                            f_sor_cir_BM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_BM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_BM = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_BM = 1, z_dessus_brut_BM = drl_sel_tos$
                            else, z_dessus_brut_BM = tosz$

                            if f_ent_cir_BM = 0, f_ent_cir_BM = f_base_BM
                            if f_int_hel_BM = 0, f_int_hel_BM = f_ent_cir_BM
                            if f_spiral_BM  = 0, f_spiral_BM = f_int_hel_BM
                            if f_int_fin_BM = 0, f_int_fin_BM = f_spiral_BM
                            if f_sor_cir_BM = 0, f_sor_cir_BM = f_int_fin_BM





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_BM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_BM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_BM = 1
                            xabs_BM = xprint_BM
                            yabs_BM = yprint_BM
                            zabs_BM = zprint_BM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_BM = xabs_BM + ent_perp
                                #x_ent_cir = x_perp_BM - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_BM = ray_ent_cir * -1 # + x_perp_BM  # si I en ABS
                                x_sor_cir = xabs_BM + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_BM = xabs_BM - ent_perp
                                #x_ent_cir = x_perp_BM +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_BM = ray_ent_cir # + x_perp_BM  # si I en ABS
                                x_sor_cir = xabs_BM - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_BM

pcalcule_variable_CM       # mise a jour des variables 
                            f_ent_cir_CM = drl_prm1$
                            f_int_hel_CM = drl_prm2$
                            f_spiral_CM  = drl_prm3$
                            f_int_fin_CM = drl_prm4$
                            f_sor_cir_CM = drl_prm5$
                            ent_perp  = drl_prm6$
                            cor_ray   = drl_prm7$
                            nbe_tr_retour = drl_prm8$
                            pas_Z_deb_fin = drl_prm9$
                            nb_tr_debut = int(drl_prm10$)
                            nb_tr_fin = (frac(drl_prm10$))*100
                            z_retraction_CM = refht$
                            z_plan_securite = initht$
                            z_profondeur = depth$
                            dia_ebauche = peckclr$
                            ava_opp = peck1$
                            dia_final = peck2$
                            nbe_tr_fin = shftdrl$
                            pas_max_z = retr$
                            f_base_CM = frplunge$
                            #pas_max_xy = dwell$
                            if drill5axes_CM = 1, z_dessus_brut_CM = drl_sel_tos$
                            else, z_dessus_brut_CM = tosz$

                            if f_ent_cir_CM = 0, f_ent_cir_CM = f_base_CM
                            if f_int_hel_CM = 0, f_int_hel_CM = f_ent_cir_CM
                            if f_spiral_CM  = 0, f_spiral_CM = f_int_hel_CM
                            if f_int_fin_CM = 0, f_int_fin_CM = f_spiral_CM
                            if f_sor_cir_CM = 0, f_sor_cir_CM = f_int_fin_CM





                            if (dia_final <> dia_ebauche) &  (nbe_tr_fin = 0) & (nbe_tr_retour =0) , nbe_tr_fin = 1

                            hauteur_hel = z_dessus_brut_CM - z_profondeur
                            hauteur_hel_debfin = (nb_tr_debut + nb_tr_fin)* pas_Z_deb_fin

                            ray_ebauche = (dia_ebauche - tldia$) / 2
                            if ava_opp = 0, sens_usi = -1
                            else, sens_usi = 1

                            #ptest_variable_CM   # on test si toutes les variable sont OK 

                            cycle_heli_spiral_CM = 1
                            xabs_CM = xprint_CM
                            yabs_CM = yprint_CM
                            zabs_CM = zprint_CM



                            ray_ent_cir = ( ent_perp + ((dia_ebauche - tldia$)/2))/2
                            ray_sor_cir = ((dia_final - tldia$) /2 )/2
                            if sens_usi = 1, # on est en opposition
                                [
                                x_perp_CM = xabs_CM + ent_perp
                                #x_ent_cir = x_perp_CM - ((dia_ebauche - tldia$) / 2) 
                                i_ent_cir_CM = ray_ent_cir * -1 # + x_perp_CM  # si I en ABS
                                x_sor_cir = xabs_CM + ((dia_final - tldia$ + ent_perp) / 2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2) * -1
                                ]
                            else,   # on est en avalant
                                [
                                x_perp_CM = xabs_CM - ent_perp
                                #x_ent_cir = x_perp_CM +((dia_ebauche - tldia$)/2) 
                                i_ent_cir_CM = ray_ent_cir # + x_perp_CM  # si I en ABS
                                x_sor_cir = xabs_CM - ((dia_final - tldia$ + ent_perp)/2)
                                #i_sor_cir = ((dia_final - tldia$ + ent_perp) / 2)
                                ]

                            i_eb_cir = ray_ebauche
                            #nbe_pas_z = hauteur_hel/pas_max_z
                            #if frac(nbe_pas_z), nbe_pas_z = int(nbe_pas_z) + 1
                            #pas_z = hauteur_hel/nbe_pas_z

                            if dia_final <> dia_ebauche,
                                    [
                                    nbe_pas_xy = (dia_final-dia_ebauche)/(2*pas_max_xy)
                                    if frac(nbe_pas_xy), nbe_pas_xy = int(nbe_pas_xy) + 1
                                    pas_xy = (dia_final-dia_ebauche)/(2*nbe_pas_xy)
                                    nbe_demi_cercle = ( 2 * nbe_pas_xy ) - 1
                                    ]
                            rapport_ray_sortie = (2/3)
                            angle_ray_sortie = 120
                            ray_cercle_sortie = ((dia_final - tldia$)/4) * rapport_ray_sortie
                            ray_cercle_ebauche = ((dia_ebauche - tldia$)/4) * rapport_ray_sortie
                            #pvoir_variable_CM
#endregion
#region ptest_variable
#region ptest_variable_AG OK
ptest_variable_AG     # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur1_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur2_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur20_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur3_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur4_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur5_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur24_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [ 
                            #   ###subout$### = 4
                            #   serreur_visu_AG = serreur6_AG + no2str(numop_AG) 
                            #   *serreur_visu_AG, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_AG)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_AG = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur7_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur8_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur9_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if f_ent_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur10_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if f_int_hel < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur11_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if f_spiral < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur12_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if f_int_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur13_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if f_sor_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur14_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur15_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur16_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur17_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur18_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur19_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if z_dessus_brut_AG > z_retraction_AG,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur21_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if z_retraction_AG > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur21_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur25_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur26_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur27_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur à l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]


                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_AG = 0 ,
                                [
                                serreur_visu_AG = serreur23_AG + no2str(numop_AG)
                                if subout$ <> 3, result = mprint(serreur_visu_AG,2)
                                if result = 1,  "MW_OP_COMMENT", sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, *serreur_visu_AG, ###subout$### = 3, erreur_AG = 1#, exitpost$ # abandonner   
                                ]
#endregion
#region ptest_variable_BG OK
ptest_variable_BG        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur1_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur2_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur20_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur3_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur4_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur5_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur24_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   ###subout$### = 4
                            #   serreur_visu_BG = serreur6_BG + no2str(numop_BG) 
                            #   *serreur_visu_BG, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_BG)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_BG = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur7_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur8_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur9_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if f_ent_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur10_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if f_int_hel < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur11_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if f_spiral < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur12_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if f_int_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur13_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if f_sor_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur14_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur15_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur16_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur17_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur18_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur19_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if z_dessus_brut_BG > z_retraction_BG,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur21_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if z_retraction_BG > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur21_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]
                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur25_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur26_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur27_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_BG = 0 ,
                                [
                                serreur_visu_BG = serreur23_BG + no2str(numop_BG)
                                if subout$ <> 3, result = mprint(serreur_visu_BG,2)
                                if result = 1,  "MW_OP_COMMENT",  sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, *serreur_visu_BG, ###subout$### = 3, erreur_BG = 1#, exitpost$ # abandonner   
                                ]
#endregion
#region ptest_variable_CG OK
ptest_variable_CG        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur1_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur2_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur20_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur3_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur4_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur5_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur24_CG + no2str(numop_CG)
                                "MW_OP_COMMENT",  *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   ###subout$### = 4
                            #   serreur_visu_CG = serreur6_CG + no2str(numop_CG) 
                            #   *serreur_visu_CG, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_CG)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_CG = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur7_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur8_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur9_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if f_ent_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur10_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if f_int_hel < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur11_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if f_spiral < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur12_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if f_int_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur13_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if f_sor_cir < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur14_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur15_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur16_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur17_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur18_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur19_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if z_dessus_brut_CG > z_retraction_CG,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur21_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if z_retraction_CG > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur21_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]
                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur25_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur26_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur27_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_CG = 0 ,
                                [
                                serreur_visu_CG = serreur23_CG + no2str(numop_CG)
                                if subout$ <> 3, result = mprint(serreur_visu_CG,2)
                                if result = 1, "MW_OP_COMMENT",  sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, *serreur_visu_CG, ###subout$### = 3, erreur_CG = 1#, exitpost$ # abandonner   
                                ]
#endregion
#region ptest_variable_AM OK
ptest_variable_AM       # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur1_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur2_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur20_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur3_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur4_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur5_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur24_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [ 
                            #   ###subout$### = 4
                            #   serreur_visu_AM = serreur6_AM + no2str(numop_AM) 
                            #   "MW_OP_COMMENT", *serreur_visu_AM, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_AM)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_AM = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur7_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur8_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur9_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if f_ent_cir_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur10_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if f_int_hel_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur11_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if f_spiral_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur12_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if f_int_fin_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur13_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if f_sor_cir_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur14_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur15_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur16_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur17_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur18_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur19_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if z_dessus_brut_AM > z_retraction_AM,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur21_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if z_retraction_AM > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur21_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur25_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur26_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur27_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur à l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]


                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_AM = 0 ,
                                [
                                serreur_visu_AM = serreur23_AM + no2str(numop_AM)
                                if subout$ <> 3, result = mprint(serreur_visu_AM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, "MW_OP_COMMENT", *serreur_visu_AM, ###subout$### = 3, erreur_AM = 1#, exitpost$ # abandonner   
                                ]
#endregion
#region ptest_variable_BM OK
ptest_variable_BM        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur1_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur2_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur20_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur3_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur4_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur5_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur24_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   ###subout$### = 4
                            #   serreur_visu_BM = serreur6_BM + no2str(numop_BM) 
                            #   "MW_OP_COMMENT", *serreur_visu_BM, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_BM)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_BM = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur7_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur8_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur9_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if f_ent_cir_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur10_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if f_int_hel_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur11_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if f_spiral_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur12_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if f_int_fin_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur13_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if f_sor_cir_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur14_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur15_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur16_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur17_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur18_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur19_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if z_dessus_brut_BM > z_retraction_BM,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur21_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if z_retraction_BM > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur21_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]
                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur25_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur26_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur27_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_BM = 0 ,
                                [
                                serreur_visu_BM = serreur23_BM + no2str(numop_BM)
                                if subout$ <> 3, result = mprint(serreur_visu_BM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, "MW_OP_COMMENT", *serreur_visu_BM, ###subout$### = 3, erreur_BM = 1#, exitpost$ # abandonner   
                                ]
#endregion
#region ptest_variable_CM OK
ptest_variable_CM        # test sur les valeures rentrées et sortie du pp si pas ok                
                         if ava_opp <> 0 & ava_opp <> 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur1_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                         if dia_final <=0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur2_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                         if hauteur_hel <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur20_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                         if dia_ebauche <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur3_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]
                        if dia_ebauche > dia_final,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur4_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if dia_final < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur5_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur24_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        #if pas_max_z > hauteur_hel,
                            #   [
                            #   ###subout$### = 4
                            #   serreur_visu_CM = serreur6_CM + no2str(numop_CM) 
                            #   "MW_OP_COMMENT", *serreur_visu_CM, e$
                            #   if subout$ <> 3, result = mprint(serreur_visu_CM)
                            #    exitpost$ # abandonner 
                            #   ###subout$### = 3
                            #   erreur_CM = 1
                            #   ]          

                        if pas_max_z <= 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur7_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if pas_max_xy < 0 | ( pas_max_xy = 0  &  dia_ebauche <> dia_final ) ,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur8_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if nbe_tr_fin < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur9_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if f_ent_cir_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur10_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if f_int_hel_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur11_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if f_spiral_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur12_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if f_int_fin_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur13_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if f_sor_cir_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur14_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if ent_perp > ray_ebauche,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur15_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if ent_perp = 0 & cor_ray = 1,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur16_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                         if cor_ray <> 1 & cor_ray <> 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur17_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if nbe_tr_retour < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur18_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if dia_ebauche < tldia$,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur19_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if z_dessus_brut_CM > z_retraction_CM,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur21_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if z_retraction_CM > z_plan_securite,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur21_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]
                        if drl_prm9$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur25_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]
                        if drl_prm10$ < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur26_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]
                        if hauteur_hel_debfin >= hauteur_hel ,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur27_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                *nb_tr_debut, e$
                                *nb_tr_fin, e$
                                *pas_Z_deb_fin, e$
                                *hauteur_hel_debfin, " donc superieur a l'", hauteur_hel, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                        if dia_ebauche > ( 2 * tldia$ ) & cycle_heli_spiral_CM = 0 ,
                                [
                                serreur_visu_CM = serreur23_CM + no2str(numop_CM)
                                if subout$ <> 3, result = mprint(serreur_visu_CM,2)
                                if result = 1,  pnumligne, sdcom, "ATTENTION : RISQUE DE CAROTTE", sfcom, e$
                                if result = 2,  ###subout$### = 4, "MW_OP_COMMENT", *serreur_visu_CM, ###subout$### = 3, erreur_CM = 1#, exitpost$ # abandonner   
                                ]
#endregion                              
#endregion
#region PF

pf_base_AG             # ecriture que si sup a 0
                        if f_base > 0, avance_AG = f_base, avance_AG

pf_base_BG             # ecriture que si sup a 0
                        if f_base > 0, avance_BG = f_base, avance_BG

pf_base_CG             # ecriture que si sup a 0
                        if f_base > 0, avance_CG = f_base, avance_CG

pf_base_AM             # ecriture que si sup a 0
                        if f_base_AM > 0, avance_AM = f_base_AM, avance_AM

pf_base_BM             # ecriture que si sup a 0
                        if f_base_BM > 0, avance_BM = f_base_BM, avance_BM

pf_base_CM             # ecriture que si sup a 0
                        if f_base_CM > 0, avance_CM = f_base_CM, avance_CM
######################################################                      

pf_ent_cir_AG          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance_AG = f_ent_cir, avance_AG

pf_ent_cir_BG          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance_BG = f_ent_cir, avance_BG

pf_ent_cir_CG          # ecriture que si sup a 0
                        if f_ent_cir > 0, avance_CG = f_ent_cir, avance_CG

pf_ent_cir_AM          # ecriture que si sup a 0
                        if f_ent_cir_AM > 0, avance_AM = f_ent_cir_AM, avance_AM

pf_ent_cir_BM          # ecriture que si sup a 0
                        if f_ent_cir_BM > 0, avance_BM = f_ent_cir_BM, avance_BM

pf_ent_cir_CM          # ecriture que si sup a 0
                        if f_ent_cir_CM > 0, avance_CM = f_ent_cir_CM, avance_CM
######################################################

pf_int_hel_AG          # ecriture que si sup a 0
                        if f_int_hel > 0, avance_AG = f_int_hel, avance_AG

pf_int_hel_BG          # ecriture que si sup a 0
                        if f_int_hel > 0, avance_BG = f_int_hel, avance_BG

pf_int_hel_CG          # ecriture que si sup a 0
                        if f_int_hel > 0, avance_CG = f_int_hel, avance_CG

pf_int_hel_AM          # ecriture que si sup a 0
                        if f_int_hel_AM > 0, avance_AM = f_int_hel_AM, avance_AM

pf_int_hel_BM          # ecriture que si sup a 0
                        if f_int_hel_BM > 0, avance_BM = f_int_hel_BM, avance_BM

pf_int_hel_CM          # ecriture que si sup a 0
                        if f_int_hel_CM > 0, avance_CM = f_int_hel_CM, avance_CM
######################################################

pf_spiral_AG           # ecriture que si sup a 0
                        if f_spiral > 0, avance_AG = f_spiral, avance_AG

pf_spiral_BG           # ecriture que si sup a 0
                        if f_spiral > 0, avance_BG = f_spiral, avance_BG

pf_spiral_CG           # ecriture que si sup a 0
                        if f_spiral > 0, avance_CG = f_spiral, avance_CG

pf_spiral_AM           # ecriture que si sup a 0
                        if f_spiral_AM > 0, avance_AM = f_spiral_AM, avance_AM

pf_spiral_BM           # ecriture que si sup a 0
                        if f_spiral_BM > 0, avance_BM = f_spiral_BM, avance_BM

pf_spiral_CM           # ecriture que si sup a 0
                        if f_spiral_CM > 0, avance_CM = f_spiral_CM, avance_CM
######################################################

pf_int_fin_AG          # ecriture que si sup a 0
                        if f_int_fin > 0, avance_AG = f_int_fin, avance_AG

pf_int_fin_BG          # ecriture que si sup a 0
                        if f_int_fin > 0, avance_BG = f_int_fin, avance_BG

pf_int_fin_CG          # ecriture que si sup a 0
                        if f_int_fin > 0, avance_CG = f_int_fin, avance_CG

pf_int_fin_AM          # ecriture que si sup a 0
                        if f_int_fin_AM > 0, avance_AM = f_int_fin_AM, avance_AM

pf_int_fin_BM          # ecriture que si sup a 0
                        if f_int_fin_BM > 0, avance_BM = f_int_fin_BM, avance_BM

pf_int_fin_CM          # ecriture que si sup a 0
                        if f_int_fin_CM > 0, avance_CM = f_int_fin_CM, avance_CM
######################################################

pf_sor_cir_AG         # ecriture que si sup a 0
                        if f_sor_cir > 0, avance_AG = f_sor_cir, avance_AG

pf_sor_cir_BG          # ecriture que si sup a 0
                        if f_sor_cir > 0, avance_BG = f_sor_cir, avance_BG

pf_sor_cir_CG          # ecriture que si sup a 0
                        if f_sor_cir > 0, avance_CG = f_sor_cir, avance_CG

pf_sor_cir_AM         # ecriture que si sup a 0
                        if f_sor_cir_AM > 0, avance_AM = f_sor_cir_AM, avance_AM

pf_sor_cir_BM          # ecriture que si sup a 0
                        if f_sor_cir_BM > 0, avance_BM = f_sor_cir_BM, avance_BM

pf_sor_cir_CM          # ecriture que si sup a 0
                        if f_sor_cir_CM > 0, avance_CM = f_sor_cir_CM, avance_CM
#endregion
#region pcor_ray

pcor_ray_on_AG         # ecriture d'un G41 ou G42 si besoin
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, pafcom, "G42"
                        else, sm, pafcom,"G41"
                        ]

pcor_ray_on_BG         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, paf,"G42",e$
                        else, sm, paf,"G41",e$
                        ]

pcor_ray_on_CG         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, paf,"G42",e$
                        else, sm, paf,"G41",e$
                        ]

pcor_ray_on_AM         # ecriture d'un G41 ou G42 si besoin
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G42"
                        else, "G41"
                        ]

pcor_ray_on_BM         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]

pcor_ray_on_CM         # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G42",e$
                        else, pnumligne,"G41",e$
                        ]
######################################################

pcor_ray_on_inv_AG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, pafcom,"G41"
                        else, sm, pafcom,"G42"
                        ]

pcor_ray_on_inv_BG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, paf,"G41",e$
                        else, sm, paf,"G42",e$
                        ]

pcor_ray_on_inv_CG         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, sm, paf,"G41",e$
                        else, sm, paf,"G42",e$
                        ]

pcor_ray_on_inv_AM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        #"voir cor_ray", *cor_ray, e$
                        #"voir sens_usi", *sens_usi, e$
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, "G41"
                        else, "G42"
                        ]

pcor_ray_on_inv_BM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]

pcor_ray_on_inv_CM         # ecriture d'un G41 ou G42 si besoin sur la finition contraire
                        if cor_ray = 1,
                        [
                        if sens_usi = 1, pnumligne,"G41",e$
                        else, pnumligne,"G42",e$
                        ]
######################################################

pcor_ray_off_AG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, sm, pafcom,"G40"

pcor_ray_off_BG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, sm, paf,"G40",e$

pcor_ray_off_CG            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, sm, paf,"G40",e$

pcor_ray_off_AM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, "G40"

pcor_ray_off_BM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$

pcor_ray_off_CM            # ecriture d'un G41 ou G42 si besoin
                        if cor_ray = 1, pnumligne,"G40",e$
#endregion
#region phase_1

phase_1_AG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        yp_chs_AG = yabs_AG
                        yinc_abs = yp_chs_AG * abs_inc
                        jp_chs_AG = yinc_abs

                        gcode$ = 0
                        sm, paf, sdcom, "MOUVEMENT APPROCHE", sfcom, e$
                        sr, *z_retraction_AG, paf, pgcode_AG, *z_retraction_AG, e$
                        gcode$ = 1
                        sl, *z_dessus_brut_AG, *pf_base_AG, pgcode_AG, *z_dessus_brut_AG, *pf_base_AG,  e$

                        if sens_usi = 1,
                                [
                                xp_chs_AG = xabs_AG + ent_perp
                                pnumligne, pgcode_AG, *xp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,  e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - (ray_ent_cir * 2)
                                ip_chs_AG = (ray_ent_cir * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposiion
                                pnumligne, pgcode_AG,xp_chs_AG,yp_chs_AG, ip_chs_AG, jp_chs_AG, e$
                                ]
                        else,
                                [
                                xp_chs_AG = xabs_AG - ent_perp
                                pnumligne, pgcode_AG, *xp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,  e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + (ray_ent_cir*2)
                                ip_chs_AG = (ray_ent_cir) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposiion
                                pnumligne, pgcode_AG,xp_chs_AG,yp_chs_AG, ip_chs_AG, jp_chs_AG, e$
                                ]

phase_1_BG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_BG, *z_retraction_BG, e$
                        gcode$ = 1
                        pnumligne, pgcode_BG, *z_dessus_brut_BG, pf_base_BG,  e$
                        pcor_ray_on_BG
                        pnumligne, pgcode_BG, *x_perp_BG, pf_ent_cir_BG, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BG = x_perp_BG - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_BG = x_perp_BG + (ray_ent_cir*2)
                                ]
                        yp_chs_BG = yabs_BG
                        j_ent_cir_BG = 0 # si J en INC
                        #j_ent_cir_BG = y$ # si J en ABS                   
                        pnumligne, pgcode_BG,xp_chs_BG,yp_chs_BG, i_ent_cir_BG, j_ent_cir_BG, e$

phase_1_CG                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_CG, *z_retraction_CG, e$
                        gcode$ = 1
                        pnumligne, pgcode_CG, *z_dessus_brut_CG, pf_base_CG,  e$
                        pcor_ray_on_CG
                        pnumligne, pgcode_CG, *x_perp_CG, pf_ent_cir_CG, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CG = x_perp_CG - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_CG = x_perp_CG + (ray_ent_cir*2)
                                ]
                        yp_chs_CG = yabs_CG
                        j_ent_cir_CG = 0 # si J en INC
                        #j_ent_cir_CG = y$ # si J en ABS                   
                        pnumligne, pgcode_CG,xp_chs_CG,yp_chs_CG, i_ent_cir_CG, j_ent_cir_CG, e$

phase_1_AM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        yp_chs_AM = yabs_AM
                        yinc_abs = yp_chs_AM * abs_inc
                        jp_chs_AM = yinc_abs

                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$
                        pnumligne, pgcode_AM, *z_retraction_AM, e$
                        gcode$ = 1
                        pnumligne, pgcode_AM, *z_dessus_brut_AM, pf_base_AM,  e$

                        if sens_usi = 1,
                                [
                                xp_chs_AM = xabs_AM + ent_perp
                                pnumligne, pgcode_AM, *xp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,  e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - (ray_ent_cir * 2)
                                ip_chs_AM = (ray_ent_cir * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposiion
                                pnumligne, pgcode_AM,xp_chs_AM,yp_chs_AM, ip_chs_AM, jp_chs_AM, e$
                                ]
                        else,
                                [
                                xp_chs_AM = xabs_AM - ent_perp
                                pnumligne, pgcode_AM, *xp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,  e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + (ray_ent_cir*2)
                                ip_chs_AM = (ray_ent_cir) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposiion
                                pnumligne, pgcode_AM,xp_chs_AM,yp_chs_AM, ip_chs_AM, jp_chs_AM, e$
                                ]

phase_1_BM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_BM, *z_retraction_BM, e$
                        gcode$ = 1
                        pnumligne, pgcode_BM, *z_dessus_brut_BM, pf_base_BM,  e$
                        pcor_ray_on_BM
                        pnumligne, pgcode_BM, *x_perp_BM, pf_ent_cir_BM, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BM = x_perp_BM - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_BM = x_perp_BM + (ray_ent_cir*2)
                                ]
                        yp_chs_BM = yabs_BM
                        j_ent_cir_BM = 0 # si J en INC
                        #j_ent_cir_BM = y$ # si J en ABS                   
                        pnumligne, pgcode_BM,xp_chs_BM,yp_chs_BM, i_ent_cir_BM, j_ent_cir_BM, e$

phase_1_CM                # ecriture mouvement d'entre du cycle soit l'approche en Z, ligne d'entre pour correcteur + rayon d'entre
                        gcode$ = 0
                        pnumligne, sdcom, "MOUVEMENT APPROCHE", sfcom, e$

                        pnumligne, pgcode_CM, *z_retraction_CM, e$
                        gcode$ = 1
                        pnumligne, pgcode_CM, *z_dessus_brut_CM, pf_base_CM,  e$
                        pcor_ray_on_CM
                        pnumligne, pgcode_CM, *x_perp_CM, pf_ent_cir_CM, e$
                        if sens_usi = 1,
                                [
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CM = x_perp_CM - (ray_ent_cir*2)
                                ]
                        else,
                                [
                                gcode$ = 3     # G03 car on est en avalant
                                xp_chs_CM = x_perp_CM + (ray_ent_cir*2)
                                ]
                        yp_chs_CM = yabs_CM
                        j_ent_cir_CM = 0 # si J en INC
                        #j_ent_cir_CM = y$ # si J en ABS                   
                        pnumligne, pgcode_CM,xp_chs_CM,yp_chs_CM, i_ent_cir_CM, j_ent_cir_CM, e$
#endregion
#region phase_1_2

phase_1_2_AG               #   ecriture mouvement d'entre du cycle soit l'approche en Z, ligne en goute d'eau
                            gcode$ = 0
                            sr, *z_retraction_AG, paf, pgcode_AG, *z_retraction_AG, e$
                            gcode$ = 1
                            sl, *z_dessus_brut_AG, pf_base_AG, paf, pgcode_AG, *z_dessus_brut_AG, pf_base_AG,  e$
                            #pcor_ray_on_AG
                            sm,paf, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_AG = 0
                            zp_chs_AG = z_dessus_brut_AG
                            if sens_usi = 1,
                                [

                                xp_chs_AG = xabs_AG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG,e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_AG = (ray_cercle_ebauche * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AG = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_ent_cir_AG , e$
                                ]
                            else,
                                [

                                xp_chs_AG = xabs_AG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pf_ent_cir_AG, pcor_ray_on_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + (( dia_ebauche - tldia$) /2)
                                ip_chs_AG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )+ xinc_abs
                                jp_chs_AG = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_ent_cir_AG , e$
                                ]

phase_1_2_BG              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_BG, *z_retraction_BG, e$
                            gcode$ = 1
                            pnumligne, pgcode_BG, *z_dessus_brut_BG, pf_base_BG,  e$
                            #pcor_ray_on_BG
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_dessus_brut_BG
                            if sens_usi = 1,
                                [

                                xp_chs_BG = xabs_BG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_ent_cir_BG,pcor_ray_on_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_BG = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_ent_cir_BG , e$
                                ]
                            else,
                                [

                                xp_chs_BG = xabs_BG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_ent_cir_BG, pcor_ray_on_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + (( dia_ebauche - tldia$) /2)
                                ip_chs_BG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_BG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_ent_cir_BG , e$
                                ]

phase_1_2_CG              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_CG, *z_retraction_CG, e$
                            gcode$ = 1
                            pnumligne, pgcode_CG, *z_dessus_brut_CG, pf_base_CG,  e$
                            #pcor_ray_on_CG
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_dessus_brut_CG
                            if sens_usi = 1,
                                [

                                xp_chs_CG = xabs_CG - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_ent_cir_CG,pcor_ray_on_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_ebauche - tldia$) /2)
                                ip_chs_CG = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_ent_cir_CG , e$
                                ]
                            else,
                                [

                                xp_chs_CG = xabs_CG + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_ent_cir_CG, pcor_ray_on_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + (( dia_ebauche - tldia$) /2)
                                ip_chs_CG = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_CG = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_ent_cir_CG , e$
                                ]

phase_1_2_AM               #   ecriture mouvement d'entre du cycle soit l'approche en Z, ligne en goute d'eau
                            gcode$ = 0
                            pnumligne, pgcode_AM, *z_retraction_AM, e$
                            gcode$ = 1
                            pnumligne, pgcode_AM, *z_dessus_brut_AM, pf_base_AM,  e$
                            #pcor_ray_on_AM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_AM = 0
                            zp_chs_AM = z_dessus_brut_AM
                            if sens_usi = 1,
                                [

                                xp_chs_AM = xabs_AM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM,e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_AM = (ray_cercle_ebauche * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AM = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_ent_cir_AM , e$
                                ]
                            else,
                                [

                                xp_chs_AM = xabs_AM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pf_ent_cir_AM, pcor_ray_on_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + (( dia_ebauche - tldia$) /2)
                                ip_chs_AM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )+ xinc_abs
                                jp_chs_AM = (ray_cercle_ebauche * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_ent_cir_AM , e$
                                ]

phase_1_2_BM              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_BM, *z_retraction_BM, e$
                            gcode$ = 1
                            pnumligne, pgcode_BM, *z_dessus_brut_BM, pf_base_BM,  e$
                            #pcor_ray_on_BM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_dessus_brut_BM
                            if sens_usi = 1,
                                [

                                xp_chs_BM = xabs_BM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_ent_cir_BM,pcor_ray_on_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_BM = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_ent_cir_BM , e$
                                ]
                            else,
                                [

                                xp_chs_BM = xabs_BM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_ent_cir_BM, pcor_ray_on_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + (( dia_ebauche - tldia$) /2)
                                ip_chs_BM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_BM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_ent_cir_BM , e$
                                ]

phase_1_2_CM              #   ecriture de l'entree en debut de deuxieme finition
                            gcode$ = 0
                            pnumligne, pgcode_CM, *z_retraction_CM, e$
                            gcode$ = 1
                            pnumligne, pgcode_CM, *z_dessus_brut_CM, pf_base_CM,  e$
                            #pcor_ray_on_CM
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU EN APPROCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_dessus_brut_CM
                            if sens_usi = 1,
                                [

                                xp_chs_CM = xabs_CM - ( (dia_ebauche - tldia$) /2) + ray_cercle_ebauche -  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_ent_cir_CM,pcor_ray_on_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_ebauche - tldia$) /2)
                                ip_chs_CM = (ray_cercle_ebauche * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_ent_cir_CM , e$
                                ]
                            else,
                                [

                                xp_chs_CM = xabs_CM + ( (dia_ebauche - tldia$) /2) - ray_cercle_ebauche +  (ray_cercle_ebauche * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_ebauche * sin(angle_ray_sortie))
                                gcode$ = 1

                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_ent_cir_CM, pcor_ray_on_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + (( dia_ebauche - tldia$) /2)
                                ip_chs_CM = (ray_cercle_ebauche * cos(angle_ray_sortie) * -1 )
                                jp_chs_CM = (ray_cercle_ebauche * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_ent_cir_CM , e$
                                ]
#endregion
#region phase_2

phase_2_AG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_dessus_brut_AG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ( ray_ebauche * 2 )
                                ip_chs_AG = i_eb_cir + xinc_abs
                                zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue   
                                xp_chs_AG = xp_chs_AG - ( ray_ebauche * 2 )
                                ip_chs_AG = (i_eb_cir * -1) + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AG = z_profondeur
                                else, zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                xp_chs_AG = xp_chs_AG - ( ray_ebauche * 2 )
                                ip_chs_AG = (i_eb_cir * -1) + xinc_abs
                                zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ( ray_ebauche * 2 )
                                ip_chs_AG = i_eb_cir + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AG = z_profondeur
                                else, zp_chs_AG = zp_chs_AG - ( pas_z / 2)
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_hel_AG, e$
                                ]
                            ]

phase_2_BG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_dessus_brut_BG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BG = xp_chs_BG + ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir
                                zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                xp_chs_BG = xp_chs_BG - ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BG = z_profondeur
                                else, zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_BG = xp_chs_BG - ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir * -1
                                zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                xp_chs_BG = xp_chs_BG + ( ray_ebauche * 2 )
                                ip_chs_BG = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BG = z_profondeur
                                else, zp_chs_BG = zp_chs_BG - ( pas_z / 2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_hel_BG, e$
                                ]
                            ]

phase_2_CG                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_dessus_brut_CG
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CG = xp_chs_CG + ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir
                                zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                xp_chs_CG = xp_chs_CG - ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CG = z_profondeur
                                else, zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_CG = xp_chs_CG - ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir * -1
                                zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                xp_chs_CG = xp_chs_CG + ( ray_ebauche * 2 )
                                ip_chs_CG = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CG = z_profondeur
                                else, zp_chs_CG = zp_chs_CG - ( pas_z / 2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_hel_CG, e$
                                ]
                            ]
phase_2_AM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_dessus_brut_AM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ( ray_ebauche * 2 )
                                ip_chs_AM = i_eb_cir + xinc_abs
                                zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue   
                                xp_chs_AM = xp_chs_AM - ( ray_ebauche * 2 )
                                ip_chs_AM = (i_eb_cir * -1) + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AM = z_profondeur
                                else, zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                xp_chs_AM = xp_chs_AM - ( ray_ebauche * 2 )
                                ip_chs_AM = (i_eb_cir * -1) + xinc_abs
                                zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ( ray_ebauche * 2 )
                                ip_chs_AM = i_eb_cir + xinc_abs
                                if nbe_pas_actu = nbe_pas_z, zp_chs_AM = z_profondeur
                                else, zp_chs_AM = zp_chs_AM - ( pas_z / 2)
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_hel_AM, e$
                                ]
                            ]

phase_2_BM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_dessus_brut_BM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_BM = xp_chs_BM + ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir
                                zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                xp_chs_BM = xp_chs_BM - ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BM = z_profondeur
                                else, zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_BM = xp_chs_BM - ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir * -1
                                zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                xp_chs_BM = xp_chs_BM + ( ray_ebauche * 2 )
                                ip_chs_BM = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_BM = z_profondeur
                                else, zp_chs_BM = zp_chs_BM - ( pas_z / 2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_hel_BM, e$
                                ]
                            ]

phase_2_CM                 #   ecriture de l'helice pour ebauche
                            pnumligne, sdcom, "EBAUCHE HELICOIDALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_dessus_brut_CM
                            nbe_pas_actu = 0

                        while nbe_pas_actu < nbe_pas_z,   # on cree des helices tant que l'on est pas a la profondeur finale via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 2   # G02 car on est en opposiion
                                xp_chs_CM = xp_chs_CM + ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir
                                zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                xp_chs_CM = xp_chs_CM - ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir * -1
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CM = z_profondeur
                                else, zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$

                                ]
                            else,
                                [
                                nbe_pas_actu = nbe_pas_actu + 1
                                gcode$ = 3   # G03 car on est en avalant
                                xp_chs_CM = xp_chs_CM - ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir * -1
                                zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                xp_chs_CM = xp_chs_CM + ( ray_ebauche * 2 )
                                ip_chs_CM = i_eb_cir
                                if nbe_pas_actu = nbe_pas_z, zp_chs_CM = z_profondeur
                                else, zp_chs_CM = zp_chs_CM - ( pas_z / 2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_hel_CM, e$
                                ]
                            ]
#endregion
#region phase_3

phase_3_AG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue     
                                xp_chs_max = xabs_AG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_AG-xp_chs_AG)*2) + (pas_xy)
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_max = xabs_AG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) + (pas_xy)
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour 
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) #+ (pas_xy/2)
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                        # deuxieme demi-tour
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_AG-xp_chs_AG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AG
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                if xp_chs_AG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_AG = xp_chs_max
                                    ]
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            else,
                                [
                                # premier demi-tour 
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_AG- xp_chs_AG)*2) #+ (pas_xy/2)
                                xp_chs_AG = xp_chs_AG + diam_cercle
                                ip_chs_AG = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                # deuxieme demi-tour
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_AG-xabs_AG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AG
                                xp_chs_AG = xp_chs_AG - diam_cercle
                                if xp_chs_AG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_AG = xp_chs_max
                                    ]
                                ip_chs_AG = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_spiral_AG, e$
                                ]
                            ]

phase_3_BG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_BG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_BG-xp_chs_BG)*2) + (pas_xy)
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_BG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) + (pas_xy)
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) #+ (pas_xy/2)
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_BG-xp_chs_BG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BG
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                if xp_chs_BG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_BG = xp_chs_max
                                    ]
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_BG- xp_chs_BG)*2) #+ (pas_xy/2)
                                xp_chs_BG = xp_chs_BG + diam_cercle
                                ip_chs_BG = (diam_cercle/2)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_BG-xabs_BG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BG
                                xp_chs_BG = xp_chs_BG - diam_cercle
                                if xp_chs_BG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_BG = xp_chs_max
                                    ]
                                ip_chs_BG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_spiral_BG, e$
                                ]
                            ]

phase_3_CG                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_CG + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_CG-xp_chs_CG)*2) + (pas_xy)
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_CG - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) + (pas_xy)
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) #+ (pas_xy/2)
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_CG-xp_chs_CG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CG
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                if xp_chs_CG > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_CG = xp_chs_max
                                    ]
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_CG- xp_chs_CG)*2) #+ (pas_xy/2)
                                xp_chs_CG = xp_chs_CG + diam_cercle
                                ip_chs_CG = (diam_cercle/2)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_CG-xabs_CG)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CG
                                xp_chs_CG = xp_chs_CG - diam_cercle
                                if xp_chs_CG < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_CG = xp_chs_max
                                    ]
                                ip_chs_CG = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_spiral_CG, e$
                                ]
                            ]

phase_3_AM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue     
                                xp_chs_max = xabs_AM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_AM-xp_chs_AM)*2) + (pas_xy)
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_max = xabs_AM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) + (pas_xy)
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour 
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) #+ (pas_xy/2)
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                        # deuxieme demi-tour
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_AM-xp_chs_AM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AM
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                if xp_chs_AM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_AM = xp_chs_max
                                    ]
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            else,
                                [
                                # premier demi-tour 
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_AM- xp_chs_AM)*2) #+ (pas_xy/2)
                                xp_chs_AM = xp_chs_AM + diam_cercle
                                ip_chs_AM = (diam_cercle/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                # deuxieme demi-tour
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue         
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_AM-xabs_AM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_AM
                                xp_chs_AM = xp_chs_AM - diam_cercle
                                if xp_chs_AM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_AM = xp_chs_max
                                    ]
                                ip_chs_AM = ((diam_cercle/2) * -1) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_spiral_AM, e$
                                ]
                            ]

phase_3_BM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_BM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_BM-xp_chs_BM)*2) + (pas_xy)
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_BM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) + (pas_xy)
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) #+ (pas_xy/2)
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_BM-xp_chs_BM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BM
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                if xp_chs_BM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_BM = xp_chs_max
                                    ]
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_BM- xp_chs_BM)*2) #+ (pas_xy/2)
                                xp_chs_BM = xp_chs_BM + diam_cercle
                                ip_chs_BM = (diam_cercle/2)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_BM-xabs_BM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_BM
                                xp_chs_BM = xp_chs_BM - diam_cercle
                                if xp_chs_BM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_BM = xp_chs_max
                                    ]
                                ip_chs_BM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_spiral_BM, e$
                                ]
                            ]

phase_3_CM                #   ecriture de la spirale d'ebauche au fond du trou 
                            pnumligne, sdcom, "EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            nbe_pas_actu = 1

                            if sens_usi = 1,  # premier cercle de la spirale 
                                [
                                xp_chs_max = xabs_CM + ( (dia_final - tldia$) /2)
                                gcode$ = 2   # G02 car on est en opposiion
                                diam_cercle = ((xabs_CM-xp_chs_CM)*2) + (pas_xy)
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            else,
                            [
                                xp_chs_max = xabs_CM - ( (dia_final - tldia$) /2)
                                gcode$ = 3   # G02 car on est en opposiion
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) + (pas_xy)
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]

                        while nbe_pas_actu < nbe_pas_xy,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                            if sens_usi = 1,
                                [
                        # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) #+ (pas_xy/2)
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                        # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xabs_CM-xp_chs_CM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CM
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                if xp_chs_CM > xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = xp_chs_max - old_xp_chs
                                    xp_chs_CM = xp_chs_max
                                    ]
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            else,
                                [
                                # premier demi-tour         
                                nbe_pas_actu = nbe_pas_actu + 1
                                diam_cercle = ((xabs_CM- xp_chs_CM)*2) #+ (pas_xy/2)
                                xp_chs_CM = xp_chs_CM + diam_cercle
                                ip_chs_CM = (diam_cercle/2)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                # deuxieme demi-tour        
                                #nbe_pas_actu = nbe_pas_actu + 1    
                                diam_cercle = ((xp_chs_CM-xabs_CM)*2) + (pas_xy)
                                old_xp_chs = xp_chs_CM
                                xp_chs_CM = xp_chs_CM - diam_cercle
                                if xp_chs_CM < xp_chs_max,  # on depasse le point max a cause des cumuls des arrondis donc on rajuste
                                    [
                                    diam_cercle = old_xp_chs - xp_chs_max
                                    xp_chs_CM = xp_chs_max
                                    ]
                                ip_chs_CM = (diam_cercle/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_spiral_CM, e$
                                ]
                            ]
#endregion
#region phase_4

phase_4_AG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_4_BG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_4_CG             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]

phase_4_AM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_4_BM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_4_CM             #   ecriture des 1 er passes de finition au fond du trou
                            pnumligne, sdcom, "1ERE SERIE DE FINITION", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tours
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]
#endregion
#region phase_4_2

phase_4_2_AG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2)  + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_4_2_BG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_4_2_CG               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]

phase_4_2_AM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2)  + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_4_2_BM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_4_2_CM               #   ecriture des 1 er passes de finition au fond du trou quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SERIE DE FINITION SANS EBAUCHE SPIRALE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_fin,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]
#endregion
#region phase_5

phase_5_AG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$


                            zp_chs_AG = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie  + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]

phase_5_BG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]

phase_5_CG             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]

phase_5_AM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$


                            zp_chs_AM = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie  + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]

phase_5_BM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]

phase_5_CM             #   ecriture de la sortie en fin de finition
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU", sfcom, e$

                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi = 1,
                                [
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
#endregion
#region phase_5_2

phase_5_2_AG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$


                            zp_chs_AG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$
                                ]

phase_5_2_BG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                ]

phase_5_2_CG               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                ]

phase_5_2_AM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$


                            zp_chs_AM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$
                                ]

phase_5_2_BM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                ]

phase_5_2_CM               #   ecriture de la sortie en fin de finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "1ERE SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                ]
#endregion
#region phase_6

phase_6_AG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$

                            zp_chs_AG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2)
                                ip_chs_AG = ((ray_cercle_sortie * cos(angle_ray_sortie))) + xinc_abs
                                jp_chs_AG = ((ray_cercle_sortie * sin(angle_ray_sortie)) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]
                            else,
                                [
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]

phase_6_BG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]

phase_6_CG                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]

phase_6_AM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$

                            zp_chs_AM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2)
                                ip_chs_AM = ((ray_cercle_sortie * cos(angle_ray_sortie))) + xinc_abs
                                jp_chs_AM = ((ray_cercle_sortie * sin(angle_ray_sortie)) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]
                            else,
                                [
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]

phase_6_BM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]

phase_6_CM                 #   ecriture de l'entree en debut de deuxieme finition
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie)) * -1
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1)
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
#endregion
#region phase_6_2

phase_6_2_AG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            zp_chs_AG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG - ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AG = (ray_cercle_sortie * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, *zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]
                            else,
                                [
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xp_chs_AG,*yp_chs_AG, zp_chs_AG, pcor_ray_on_inv_AG, pf_sor_cir_AG, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                yp_chs_AG = yabs_AG
                                xp_chs_AG = xabs_AG + ( (dia_final - tldia$) /2)
                                ip_chs_AG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AG = ((ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1) + yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                ]

phase_6_2_BG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 2
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG - ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, *zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BG
                                pnumligne, pgcode_force_BG, *xp_chs_BG,*yp_chs_BG, zp_chs_BG, pf_sor_cir_BG, e$
                                gcode$ = 3
                                yp_chs_BG = yabs_BG
                                xp_chs_BG = xabs_BG + ( (dia_final - tldia$) /2)
                                ip_chs_BG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                ]

phase_6_2_CG               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 2
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG - ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, *zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CG
                                pnumligne, pgcode_force_CG, *xp_chs_CG,*yp_chs_CG, zp_chs_CG, pf_sor_cir_CG, e$
                                gcode$ = 3
                                yp_chs_CG = yabs_CG
                                xp_chs_CG = xabs_CG + ( (dia_final - tldia$) /2)
                                ip_chs_CG = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CG = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                ]

phase_6_2_AM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            zp_chs_AM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 2
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM - ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie)) + xinc_abs
                                jp_chs_AM = (ray_cercle_sortie * sin(angle_ray_sortie)) + yinc_abs
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, *zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]
                            else,
                                [
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xp_chs_AM,*yp_chs_AM, zp_chs_AM, pcor_ray_on_inv_AM, pf_sor_cir_AM, e$
                                gcode$ = 3
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                yp_chs_AM = yabs_AM
                                xp_chs_AM = xabs_AM + ( (dia_final - tldia$) /2)
                                ip_chs_AM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1) + xinc_abs
                                jp_chs_AM = ((ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1) + yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                ]

phase_6_2_BM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 2
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM - ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, *zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_BM
                                pnumligne, pgcode_force_BM, *xp_chs_BM,*yp_chs_BM, zp_chs_BM, pf_sor_cir_BM, e$
                                gcode$ = 3
                                yp_chs_BM = yabs_BM
                                xp_chs_BM = xabs_BM + ( (dia_final - tldia$) /2)
                                ip_chs_BM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_BM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                ]

phase_6_2_CM               #   ecriture de l'entree en debut de deuxieme finition quand il n'y a pas d'ebauche
                            pnumligne, sdcom, "ENTREE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            if sens_usi <> 1,
                                [
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2) + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 2
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM - ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie))
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie))
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, *zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2) - ray_cercle_sortie +  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é )  
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                gcode$ = 1
                                pcor_ray_on_inv_CM
                                pnumligne, pgcode_force_CM, *xp_chs_CM,*yp_chs_CM, zp_chs_CM, pf_sor_cir_CM, e$
                                gcode$ = 3
                                yp_chs_CM = yabs_CM
                                xp_chs_CM = xabs_CM + ( (dia_final - tldia$) /2)
                                ip_chs_CM = (ray_cercle_sortie * cos(angle_ray_sortie) * -1)
                                jp_chs_CM = (ray_cercle_sortie * sin(angle_ray_sortie) * -1) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                ]
#endregion
#region phase_7

phase_7_AG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs

                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_7_BG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_7_CG                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]

phase_7_AM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs

                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_7_BM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_7_CM                 #           #   ecriture des deuxiemes passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]
#endregion
#region phase_7_2

phase_7_2_AG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_AG = yabs_AG
                            yinc_abs = yp_chs_AG * abs_inc
                            jp_chs_AG = yinc_abs
                            zp_chs_AG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2)* -1) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs

                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG + ((dia_final - tldia$)/2)
                                ip_chs_AG = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue 
                                xp_chs_AG = xabs_AG - ((dia_final - tldia$)/2)
                                ip_chs_AG = (((dia_final - tldia$)/2) * -1 ) + xinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_int_fin_AG, e$
                                ]
                        ]

phase_7_2_BG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_BG = yabs_BG
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                            else,
                                [
                                xp_chs_BG = xabs_BG + ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                xp_chs_BG = xabs_BG - ((dia_final - tldia$)/2)
                                ip_chs_BG = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_int_fin_BG, e$
                                ]
                        ]

phase_7_2_CG                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_CG = yabs_CG
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                            else,
                                [
                                xp_chs_CG = xabs_CG + ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                xp_chs_CG = xabs_CG - ((dia_final - tldia$)/2)
                                ip_chs_CG = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_int_fin_CG, e$
                                ]
                        ]

phase_7_2_AM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_AM = yabs_AM
                            yinc_abs = yp_chs_AM * abs_inc
                            jp_chs_AM = yinc_abs
                            zp_chs_AM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2)* -1) + xinc_abs
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs

                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM + ((dia_final - tldia$)/2)
                                ip_chs_AM = ((dia_final - tldia$)/2) + xinc_abs
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue 
                                xp_chs_AM = xabs_AM - ((dia_final - tldia$)/2)
                                ip_chs_AM = (((dia_final - tldia$)/2) * -1 ) + xinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_int_fin_AM, e$
                                ]
                        ]

phase_7_2_BM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_BM = yabs_BM
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                            else,
                                [
                                xp_chs_BM = xabs_BM + ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                xp_chs_BM = xabs_BM - ((dia_final - tldia$)/2)
                                ip_chs_BM = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_int_fin_BM, e$
                                ]
                        ]

phase_7_2_CM                   #           #   ecriture des deuxieme passes de finition au fond du trou
                            pnumligne, sdcom, "2EME SERIE DE FINITION SANS EBAUCHE", sfcom, e$
                            yp_chs_CM = yabs_CM
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur
                            nbe_pas_actu = 1

                    while nbe_pas_actu <= nbe_tr_retour,   # on cree la spirale tant que l'on est pas au diam de finition via le nombre de tour
                        [
                        nbe_pas_actu = nbe_pas_actu + 1
                            if sens_usi = 1,
                                [
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)* -1
                                gcode$ = 3   # G03 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)

                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                            else,
                                [
                                xp_chs_CM = xabs_CM + ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2)
                                gcode$ = 2   # G02 car on est en opposition
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                xp_chs_CM = xabs_CM - ((dia_final - tldia$)/2)
                                ip_chs_CM = ((dia_final - tldia$)/2) * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_int_fin_CM, e$
                                ]
                        ]
#endregion
#region phase_8

phase_8_AG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$

                            zp_chs_AG = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue     
                                gcode$ = 3   # G03 car on est en opposition
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie  + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue     
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]

phase_8_BG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]

phase_8_CG             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]

phase_8_AM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$

                            zp_chs_AM = z_profondeur

                            if sens_usi = 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue     
                                gcode$ = 3   # G03 car on est en opposition
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie  + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue     
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]

phase_8_BM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]

phase_8_CM             #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi = 1,
                                [
                                    gcode$ = 3   # G03 car on est en opposition
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
                            else,
                                [
                                gcode$ = 2   # G02 car on est en opposition
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM - (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
#endregion
#region phase_8_2

phase_8_2_AG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            zp_chs_AG = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_AG = xp_chs_AG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = ray_cercle_sortie + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AG * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AG * abs_inc  # en cas de ij absolue 
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_AG = xp_chs_AG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AG = yabs_AG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AG = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AG = yinc_abs
                                pnumligne, pgcode_force_AG,xp_chs_AG,yp_chs_AG, zp_chs_AG, *ip_chs_AG, *jp_chs_AG, pf_sor_cir_AG , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AG, *xabs_AG,*yabs_AG, zp_chs_AG, pcor_ray_off_AG, pf_sor_cir_AG, e$

                                ]

phase_8_2_BG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BG = 0
                            zp_chs_BG = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_BG = xp_chs_BG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_BG = xp_chs_BG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BG = yabs_BG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BG,xp_chs_BG,yp_chs_BG, zp_chs_BG, *ip_chs_BG, *jp_chs_BG, pf_sor_cir_BG , e$
                                gcode$ = 1
                                pcor_ray_off_BG
                                pnumligne, pgcode_force_BG, *xabs_BG,*yabs_BG, zp_chs_BG, pf_sor_cir_BG, e$

                                ]

phase_8_2_CG               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CG = 0
                            zp_chs_CG = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_CG = xp_chs_CG + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_CG = xp_chs_CG - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CG = yabs_CG + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CG = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CG,xp_chs_CG,yp_chs_CG, zp_chs_CG, *ip_chs_CG, *jp_chs_CG, pf_sor_cir_CG , e$
                                gcode$ = 1
                                pcor_ray_off_CG
                                pnumligne, pgcode_force_CG, *xabs_CG,*yabs_CG, zp_chs_CG, pf_sor_cir_CG, e$

                                ]

phase_8_2_AM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$

                            zp_chs_AM = z_profondeur

                            if sens_usi <> 1,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_AM = xp_chs_AM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = ray_cercle_sortie + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]
                            else,
                                [
                                xinc_abs = xp_chs_AM * abs_inc  # en cas de ij absolue
                                yinc_abs = yp_chs_AM * abs_inc  # en cas de ij absolue 
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_AM = xp_chs_AM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_AM = yabs_AM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_AM = (ray_cercle_sortie * -1) + xinc_abs
                                jp_chs_AM = yinc_abs
                                pnumligne, pgcode_force_AM,xp_chs_AM,yp_chs_AM, zp_chs_AM, *ip_chs_AM, *jp_chs_AM, pf_sor_cir_AM , e$
                                gcode$ = 1
                                pnumligne, pgcode_force_AM, *xabs_AM,*yabs_AM, zp_chs_AM, pcor_ray_off_AM, pf_sor_cir_AM, e$

                                ]

phase_8_2_BM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_BM = 0
                            zp_chs_BM = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_BM = xp_chs_BM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_BM = xp_chs_BM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_BM = yabs_BM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_BM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_BM,xp_chs_BM,yp_chs_BM, zp_chs_BM, *ip_chs_BM, *jp_chs_BM, pf_sor_cir_BM , e$
                                gcode$ = 1
                                pcor_ray_off_BM
                                pnumligne, pgcode_force_BM, *xabs_BM,*yabs_BM, zp_chs_BM, pf_sor_cir_BM, e$

                                ]

phase_8_2_CM               #   ecriture de la sortie en fin de deuxieme finition
                            pnumligne, sdcom, "2EME SORTIE GOUTTE D EAU SANS EBAUCHE", sfcom, e$
                            jp_chs_CM = 0
                            zp_chs_CM = z_profondeur

                            if sens_usi <> 1,
                                [
                                gcode$ = 2   # G03 car on est en opposition
                                xp_chs_CM = xp_chs_CM + ray_cercle_sortie -  (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
                            else,
                                [
                                gcode$ = 3   # G02 car on est en opposition
                                xp_chs_CM = xp_chs_CM - ray_cercle_sortie  + (ray_cercle_sortie * cos(angle_ray_sortie)) # position X sur une ouverture de 120é ) 
                                yp_chs_CM = yabs_CM + (ray_cercle_sortie * sin(angle_ray_sortie))
                                ip_chs_CM = ray_cercle_sortie * -1
                                pnumligne, pgcode_force_CM,xp_chs_CM,yp_chs_CM, zp_chs_CM, *ip_chs_CM, *jp_chs_CM, pf_sor_cir_CM , e$
                                gcode$ = 1
                                pcor_ray_off_CM
                                pnumligne, pgcode_force_CM, *xabs_CM,*yabs_CM, zp_chs_CM, pf_sor_cir_CM, e$

                                ]
#endregion
# ------------------------ FIN CYCLE SPECIAL HELICOIDO-SPIRAL -------------------------
#endregion

#region   CYCLE SPECIAL percage decompose #OK
#region variables CYCLE SPECIAL percage decompose
# ------------------------ debut  CYCLE SPECIAL percage decompose -------------------------

#-------- ecriture des format -------------

fmt "F" 4 avance_1 #OK
fmt "F" 4 avance_2 #OK
fmt "F" 4 avance_3 #OK
fmt "F" 4 avance_4 #OK
fmt "F" 4 avance_5 #OK
fmt "ABS_REL" 4 abso_rel
fmt "sortie" 4 sortie_cycle_prof
#endregion
#region pvoirvariable_2

pvoirvariable_2_AG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_AG = ",prof_1_AG, e$
                            "voir prof_2_AG = ",prof_2_AG, e$
                            "voir prof_3_AG = ",prof_3_AG, e$
                            "voir prof_4_AG = ",prof_4_AG, e$
                            "voir prof_5_AG = ",prof_5_AG, e$
                            "voir tempo_1_AG = ",*tempo_1_AG, e$
                            "voir tempo_2_AG = ",*tempo_2_AG, e$
                            "voir tempo_3_AG = ",*tempo_3_AG, e$
                            "voir tempo_4_AG = ",*tempo_4_AG, e$
                            "voir tempo_5_AG = ",*tempo_5_AG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_AG = ",z_retraction_AG, e$

pvoirvariable_2_BG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_BG = ",prof_1_BG, e$
                            "voir prof_2_BG = ",prof_2_BG, e$
                            "voir prof_3_BG = ",prof_3_BG, e$
                            "voir prof_4_BG = ",prof_4_BG, e$
                            "voir prof_5_BG = ",prof_5_BG, e$
                            "voir tempo_1_BG = ",*tempo_1_BG, e$
                            "voir tempo_2_BG = ",*tempo_2_BG, e$
                            "voir tempo_3_BG = ",*tempo_3_BG, e$
                            "voir tempo_4_BG = ",*tempo_4_BG, e$
                            "voir tempo_5_BG = ",*tempo_5_BG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_BG = ",z_retraction_BG, e$

pvoirvariable_2_CG   # voir les varialble apres mise a jour
                            "voir avance_1 = ",avance_1, e$
                            "voir avance_2 = ",avance_2, e$
                            "voir avance_3  = ",avance_3, e$
                            "voir avance_4 = ",avance_4, e$
                            "voir avance_5 = ",avance_5, e$
                            "voir prof_1_CG = ",prof_1_CG, e$
                            "voir prof_2_CG = ",prof_2_CG, e$
                            "voir prof_3_CG = ",prof_3_CG, e$
                            "voir prof_4_CG = ",prof_4_CG, e$
                            "voir prof_5_CG = ",prof_5_CG, e$
                            "voir tempo_1_CG = ",*tempo_1_CG, e$
                            "voir tempo_2_CG = ",*tempo_2_CG, e$
                            "voir tempo_3_CG = ",*tempo_3_CG, e$
                            "voir tempo_4_CG = ",*tempo_4_CG, e$
                            "voir tempo_5_CG = ",*tempo_5_CG, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_CG = ",z_retraction_CG, e$

pvoirvariable_2_AM   # voir les varialble apres mise a jour
                            "voir avance_1_AM = ",avance_1_AM, e$
                            "voir avance_2_AM = ",avance_2_AM, e$
                            "voir avance_3_AM  = ",avance_3_AM, e$
                            "voir avance_4_AM = ",avance_4_AM, e$
                            "voir avance_5_AM = ",avance_5_AM, e$
                            "voir prof_1_AM = ",prof_1_AM, e$
                            "voir prof_2_AM = ",prof_2_AM, e$
                            "voir prof_3_AM = ",prof_3_AM, e$
                            "voir prof_4_AM = ",prof_4_AM, e$
                            "voir prof_5_AM = ",prof_5_AM, e$
                            "voir tempo_1_AM = ",*tempo_1_AM, e$
                            "voir tempo_2_AM = ",*tempo_2_AM, e$
                            "voir tempo_3_AM = ",*tempo_3_AM, e$
                            "voir tempo_4_AM = ",*tempo_4_AM, e$
                            "voir tempo_5_AM = ",*tempo_5_AM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_AM = ",z_retraction_AM, e$

pvoirvariable_2_BM   # voir les varialble apres mise a jour
                            "voir avance_1_BM = ",avance_1_BM, e$
                            "voir avance_2_BM = ",avance_2_BM, e$
                            "voir avance_3_BM  = ",avance_3_BM, e$
                            "voir avance_4_BM = ",avance_4_BM, e$
                            "voir avance_5_BM = ",avance_5_BM, e$
                            "voir prof_1_BM = ",prof_1_BM, e$
                            "voir prof_2_BM = ",prof_2_BM, e$
                            "voir prof_3_BM = ",prof_3_BM, e$
                            "voir prof_4_BM = ",prof_4_BM, e$
                            "voir prof_5_BM = ",prof_5_BM, e$
                            "voir tempo_1_BM = ",*tempo_1_BM, e$
                            "voir tempo_2_BM = ",*tempo_2_BM, e$
                            "voir tempo_3_BM = ",*tempo_3_BM, e$
                            "voir tempo_4_BM = ",*tempo_4_BM, e$
                            "voir tempo_5_BM = ",*tempo_5_BM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_BM = ",z_retraction_BM, e$

pvoirvariable_2_CM   # voir les varialble apres mise a jour
                            "voir avance_1_CM = ",avance_1_CM, e$
                            "voir avance_2_CM = ",avance_2_CM, e$
                            "voir avance_3_CM  = ",avance_3_CM, e$
                            "voir avance_4_CM = ",avance_4_CM, e$
                            "voir avance_5_CM = ",avance_5_CM, e$
                            "voir prof_1_CM = ",prof_1_CM, e$
                            "voir prof_2_CM = ",prof_2_CM, e$
                            "voir prof_3_CM = ",prof_3_CM, e$
                            "voir prof_4_CM = ",prof_4_CM, e$
                            "voir prof_5_CM = ",prof_5_CM, e$
                            "voir tempo_1_CM = ",*tempo_1_CM, e$
                            "voir tempo_2_CM = ",*tempo_2_CM, e$
                            "voir tempo_3_CM = ",*tempo_3_CM, e$
                            "voir tempo_4_CM = ",*tempo_4_CM, e$
                            "voir tempo_5_CM = ",*tempo_5_CM, e$
                            "voir abso_rel = ",abso_rel, e$
                            "voir z_retraction_CM = ",z_retraction_CM, e$
#endregion
#region pcalcule_variable_2

pcalcule_variable_2_AG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_AG = drl_prm1$
                            prof_2_AG = drl_prm2$
                            prof_3_AG = drl_prm3$
                            prof_4_AG = drl_prm4$
                            prof_5_AG = drl_prm5$
                            tempo_1_AG = (frac(drl_prm6$)) * 10
                            tempo_2_AG = (frac(drl_prm7$)) * 10
                            tempo_3_AG = (frac(drl_prm8$)) * 10
                            tempo_4_AG = (frac(drl_prm9$)) * 10
                            tempo_5_AG = (frac(drl_prm10$)) * 10
                            abso_rel = peck1$
                            zabs_AG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_AG =  prof_1_AG + tosz$
                            prof_2_rel_AG = prof_2_AG + prof_1_rel_AG
                            prof_3_rel_AG = prof_3_AG + prof_2_rel_AG
                            prof_4_rel_AG = prof_4_AG + prof_3_rel_AG
                            prof_5_rel_AG = prof_5_AG + prof_4_rel_AG

                            #pvoirvariable_2_AG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur100_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_AG = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_AG = serreur101_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                               ]

                            if prof_1_AG = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_AG = serreur102_AG + no2str(numop_AG)
                                "MW_OP_COMMENT", *serreur_visu_AG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AG = 1
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5

pcalcule_variable_2_BG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_BG = drl_prm1$
                            prof_2_BG = drl_prm2$
                            prof_3_BG = drl_prm3$
                            prof_4_BG = drl_prm4$
                            prof_5_BG = drl_prm5$
                            tempo_1_BG = (frac(drl_prm6$)) * 10
                            tempo_2_BG = (frac(drl_prm7$)) * 10
                            tempo_3_BG = (frac(drl_prm8$)) * 10
                            tempo_4_BG = (frac(drl_prm9$)) * 10
                            tempo_5_BG = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_BG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_BG =  prof_1_BG + tosz$
                            prof_2_rel_BG = prof_2_BG + prof_1_rel_BG
                            prof_3_rel_BG = prof_3_BG + prof_2_rel_BG
                            prof_4_rel_BG = prof_4_BG + prof_3_rel_BG
                            prof_5_rel_BG = prof_5_BG + prof_4_rel_BG

                            #pvoirvariable_2_BG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur100_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_BG = serreur101_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BG = 1
                               ]

                            if prof_1_BG = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_BG = serreur102_BG + no2str(numop_BG)
                                "MW_OP_COMMENT", *serreur_visu_BG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_BG = 1
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5

pcalcule_variable_2_CG       # mise a jour des variables 
                            avance_1 = int(drl_prm6$)
                            avance_2 = int(drl_prm7$)
                            avance_3  = int(drl_prm8$)
                            avance_4 = int(drl_prm9$)
                            avance_5 = int(drl_prm10$)
                            prof_1_CG = drl_prm1$
                            prof_2_CG = drl_prm2$
                            prof_3_CG = drl_prm3$
                            prof_4_CG = drl_prm4$
                            prof_5_CG = drl_prm5$
                            tempo_1_CG = (frac(drl_prm6$)) * 10
                            tempo_2_CG = (frac(drl_prm7$)) * 10
                            tempo_3_CG = (frac(drl_prm8$)) * 10
                            tempo_4_CG = (frac(drl_prm9$)) * 10
                            tempo_5_CG = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_CG = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_CG =  prof_1_CG + tosz$
                            prof_2_rel_CG = prof_2_CG + prof_1_rel_CG
                            prof_3_rel_CG = prof_3_CG + prof_2_rel_CG
                            prof_4_rel_CG = prof_4_CG + prof_3_rel_CG
                            prof_5_rel_CG = prof_5_CG + prof_4_rel_CG

                            #pvoirvariable_2_CG


                            @avance_1, @avance_2, @avance_3, @avance_4, @avance_5

                            if avance_1 < 0 | avance_2 < 0 | avance_3 < 0 | avance_4 < 0 | avance_5 < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur100_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_CG = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_CG = serreur101_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_CG = 1
                               ]

                            if prof_1_CG = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_CG = serreur102_CG + no2str(numop_CG)
                                "MW_OP_COMMENT", *serreur_visu_CG, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CG)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CG = 1
                                ]

                                if avance_1 = 0, avance_1 = frplunge$
                                @avance_1
                                if avance_2 = 0, avance_2 = avance_1
                                @avance_2
                                if avance_3 = 0, avance_3 = avance_2
                                @avance_3
                                if avance_4 = 0, avance_4 = avance_3
                                @avance_4
                                if avance_5 = 0, avance_5 = avance_4
                                @avance_5

pcalcule_variable_2_AM       # mise a jour des variables 
                            avance_1_AM = int(drl_prm6$)
                            avance_2_AM = int(drl_prm7$)
                            avance_3_AM  = int(drl_prm8$)
                            avance_4_AM = int(drl_prm9$)
                            avance_5_AM = int(drl_prm10$)
                            prof_1_AM = drl_prm1$
                            prof_2_AM = drl_prm2$
                            prof_3_AM = drl_prm3$
                            prof_4_AM = drl_prm4$
                            prof_5_AM = drl_prm5$
                            tempo_1_AM = (frac(drl_prm6$)) * 10
                            tempo_2_AM = (frac(drl_prm7$)) * 10
                            tempo_3_AM = (frac(drl_prm8$)) * 10
                            tempo_4_AM = (frac(drl_prm9$)) * 10
                            tempo_5_AM = (frac(drl_prm10$)) * 10
                            abso_rel = peck1$
                            zabs_AM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_AM =  prof_1_AM + tosz$
                            prof_2_rel_AM = prof_2_AM + prof_1_rel_AM
                            prof_3_rel_AM = prof_3_AM + prof_2_rel_AM
                            prof_4_rel_AM = prof_4_AM + prof_3_rel_AM
                            prof_5_rel_AM = prof_5_AM + prof_4_rel_AM

                            #pvoirvariable_2_AM


                            @avance_1_AM, @avance_2_AM, @avance_3_AM, @avance_4_AM, @avance_5_AM

                            if avance_1_AM < 0 | avance_2_AM < 0 | avance_3_AM < 0 | avance_4_AM < 0 | avance_5_AM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur100_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_AM = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_AM = serreur101_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_AM = 1
                               ]

                            if prof_1_AM = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_AM = serreur102_AM + no2str(numop_AM)
                                "MW_OP_COMMENT", *serreur_visu_AM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_AM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_AM = 1
                                ]

                                if avance_1_AM = 0, avance_1_AM = frplunge$
                                @avance_1_AM
                                if avance_2_AM = 0, avance_2_AM = avance_1_AM
                                @avance_2_AM
                                if avance_3_AM = 0, avance_3_AM = avance_2_AM
                                @avance_3_AM
                                if avance_4_AM = 0, avance_4_AM = avance_3_AM
                                @avance_4_AM
                                if avance_5_AM = 0, avance_5_AM = avance_4_AM
                                @avance_5_AM

pcalcule_variable_2_BM       # mise a jour des variables 
                            avance_1_BM = int(drl_prm6$)
                            avance_2_BM = int(drl_prm7$)
                            avance_3_BM  = int(drl_prm8$)
                            avance_4_BM = int(drl_prm9$)
                            avance_5_BM = int(drl_prm10$)
                            prof_1_BM = drl_prm1$
                            prof_2_BM = drl_prm2$
                            prof_3_BM = drl_prm3$
                            prof_4_BM = drl_prm4$
                            prof_5_BM = drl_prm5$
                            tempo_1_BM = (frac(drl_prm6$)) * 10
                            tempo_2_BM = (frac(drl_prm7$)) * 10
                            tempo_3_BM = (frac(drl_prm8$)) * 10
                            tempo_4_BM = (frac(drl_prm9$)) * 10
                            tempo_5_BM = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_BM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_BM =  prof_1_BM + tosz$
                            prof_2_rel_BM = prof_2_BM + prof_1_rel_BM
                            prof_3_rel_BM = prof_3_BM + prof_2_rel_BM
                            prof_4_rel_BM = prof_4_BM + prof_3_rel_BM
                            prof_5_rel_BM = prof_5_BM + prof_4_rel_BM

                            #pvoirvariable_2_BM


                            @avance_1_BM, @avance_2_BM, @avance_3_BM, @avance_4_BM, @avance_5_BM

                            if avance_1_BM < 0 | avance_2_BM < 0 | avance_3_BM < 0 | avance_4_BM < 0 | avance_5_BM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur100_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_BM = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_BM = serreur101_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                               ]

                            if prof_1_BM = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_BM = serreur102_BM + no2str(numop_BM)
                                "MW_OP_COMMENT", *serreur_visu_BM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_BM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_BM = 1
                                ]

                                if avance_1_BM = 0, avance_1_BM = frplunge$
                                @avance_1_BM
                                if avance_2_BM = 0, avance_2_BM = avance_1_BM
                                @avance_2_BM
                                if avance_3_BM = 0, avance_3_BM = avance_2_BM
                                @avance_3_BM
                                if avance_4_BM = 0, avance_4_BM = avance_3_BM
                                @avance_4_BM
                                if avance_5_BM = 0, avance_5_BM = avance_4_BM
                                @avance_5_BM

pcalcule_variable_2_CM       # mise a jour des variables 
                            avance_1_CM = int(drl_prm6$)
                            avance_2_CM = int(drl_prm7$)
                            avance_3_CM  = int(drl_prm8$)
                            avance_4_CM = int(drl_prm9$)
                            avance_5_CM = int(drl_prm10$)
                            prof_1_CM = drl_prm1$
                            prof_2_CM = drl_prm2$
                            prof_3_CM = drl_prm3$
                            prof_4_CM = drl_prm4$
                            prof_5_CM = drl_prm5$
                            tempo_1_CM = (frac(drl_prm6$)) * 10
                            tempo_2_CM = (frac(drl_prm7$)) * 10
                            tempo_3_CM = (frac(drl_prm8$)) * 10
                            tempo_4_CM = (frac(drl_prm9$)) * 10
                            tempo_5_CM = (frac(drl_prm10$))* 10
                            abso_rel = peck1$
                            zabs_CM = refht$
                            sortie_cycle_prof = 0
                            prof_1_rel_CM =  prof_1_CM + tosz$
                            prof_2_rel_CM = prof_2_CM + prof_1_rel_CM
                            prof_3_rel_CM = prof_3_CM + prof_2_rel_CM
                            prof_4_rel_CM = prof_4_CM + prof_3_rel_CM
                            prof_5_rel_CM = prof_5_CM + prof_4_rel_CM

                            #pvoirvariable_2_CM


                            @avance_1_CM, @avance_2_CM, @avance_3_CM, @avance_4_CM, @avance_5_CM

                            if avance_1_CM < 0 | avance_2_CM < 0 | avance_3_CM < 0 | avance_4_CM < 0 | avance_5_CM < 0,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur100_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]
                            if abso_rel <> 0 & abso_rel <> 1,
                               [
                                ###subout$### = 4
                                serreur_visu_CM = serreur101_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner
                                ###subout$### = 3
                                erreur_CM = 1
                               ]

                            if prof_1_CM = 9999,
                                [
                                ###subout$### = 4
                                serreur_visu_CM = serreur102_CM + no2str(numop_CM)
                                "MW_OP_COMMENT", *serreur_visu_CM, e$
                                if subout$ <> 3, result = mprint(serreur_visu_CM)
                                #exitpost$ # abandonner 
                                ###subout$### = 3
                                erreur_CM = 1
                                ]

                                if avance_1_CM = 0, avance_1_CM = frplunge$
                                @avance_1_CM
                                if avance_2_CM = 0, avance_2_CM = avance_1_CM
                                @avance_2_CM
                                if avance_3_CM = 0, avance_3_CM = avance_2_CM
                                @avance_3_CM
                                if avance_4_CM = 0, avance_4_CM = avance_3_CM
                                @avance_4_CM
                                if avance_5_CM = 0, avance_5_CM = avance_4_CM
                                @avance_5_CM
#endregion
#region percage_avance_controle_2

percage_avance_controle_2_AG

                                gcode$ = 0

                                xabs_AG = xprint_AG
                                yabs_AG = yprint_AG
                                zabs_AG = initht$
                                if drill5axes_AG <> 1,
                                [
                                sr, *zabs_AG, paf, pgcode_force_AG, *zabs_AG, e$
                                sm, paf, sdcom, " POSITIONEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_AG, *yabs_AG, paf, *xabs_AG, *yabs_AG, e$
                                ]
                                percage_avance_controle_AG

percage_avance_controle_2_BG

                                gcode$ = 0

                                xabs_BG = xprint_BG
                                yabs_BG = yprint_BG
                                zabs_BG = initht$
                                if drill5axes_BG <> 1,
                                [
                                sr, *zabs_BG, paf, pgcode_force_BG, *zabs_BG, e$
                                sm, paf, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_BG, *yabs_BG, paf, *xabs_BG, *yabs_BG, e$
                                ]
                                percage_avance_controle_BG

percage_avance_controle_2_CG

                                gcode$ = 0

                                xabs_CG = xprint_CG
                                yabs_CG = yprint_CG
                                zabs_CG = initht$
                                if drill5axes_CG <> 1,
                                [
                                sr, *zabs_CG, paf, pgcode_force_CG, *zabs_CG, e$
                                sm, paf, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                sr, *xabs_CG, *yabs_CG, paf, *xabs_CG, *yabs_CG, e$
                                ]
                                percage_avance_controle_CG

percage_avance_controle_2_AM

                                gcode$ = 0

                                xabs_AM = xprint_AM
                                yabs_AM = yprint_AM
                                zabs_AM = initht$
                                if drill5axes_AM <> 1,
                                [
                                pnumligne, pgcode_force_AM, *zabs_AM, e$
                                pnumligne, sdcom, " POSITIONEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_AM, *yabs_AM, e$
                                ]
                                percage_avance_controle_AM

percage_avance_controle_2_BM

                                gcode$ = 0

                                xabs_BM = xprint_BM
                                yabs_BM = yprint_BM
                                zabs_BM = initht$
                                if drill5axes_BM <> 1,
                                [
                                pnumligne, pgcode_force_BM, *zabs_BM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_BM, *yabs_BM, e$
                                ]
                                percage_avance_controle_BM

percage_avance_controle_2_CM

                                gcode$ = 0

                                xabs_CM = xprint_CM
                                yabs_CM = yprint_CM
                                zabs_CM = initht$
                                if drill5axes_CM <> 1,
                                [
                                pnumligne, pgcode_force_CM, *zabs_CM, e$
                                pnumligne, sdcom, " POSITIONNEMENT TROU SUIVANT", sfcom, e$
                                pnumligne, *xabs_CM, *yabs_CM, e$
                                ]
                                percage_avance_controle_CM
#endregion
#region percage_avance_controle

percage_avance_controle_AG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_AG = 1

                            sm, paf, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_AG
                            gcode$ = 0
                            sr, *zabs_AG, paf, pgcode_AG, *zabs_AG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                sl, *prof_1_AG, *pfr_AG, paf, pgcode_AG, *prof_1_AG, *pfr_AG,  e$
                                if tempo_1_AG > 0, sm, paf, *tempo_1_AG, e$

                                if prof_2_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_AG, *pfr_AG, paf, pgcode_AG, *prof_2_AG, *pfr_AG,  e$
                                        if tempo_2_AG > 0, sm, paf, *tempo_2_AG, e$
                                        ]
                                if prof_3_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_AG, *pfr_AG, paf, pgcode_AG, *prof_3_AG, *pfr_AG,  e$
                                        if tempo_3_AG > 0, sm, paf, *tempo_3_AG, e$
                                        ]
                                if prof_4_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_AG, *pfr_AG, paf, pgcode_AG, *prof_4_AG, *pfr_AG,  e$
                                        if tempo_4_AG > 0, sm, paf, *tempo_4_AG, e$
                                        ]
                                if prof_5_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_AG, *pfr_AG, paf, pgcode_AG, *prof_5_AG, *pfr_AG,  e$
                                        if tempo_5_AG > 0, sm, paf, *tempo_5_AG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                sl, *prof_1_rel_AG, *pfr_AG, paf, pgcode_AG, *prof_1_rel_AG, *pfr_AG,  e$
                                if tempo_1_AG > 0, sm, paf, *tempo_1_AG, e$

                                if prof_2_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_rel_AG, *pfr_AG, paf, pgcode_AG, *prof_2_rel_AG, *pfr_AG,  e$
                                        if tempo_2_AG > 0, sm, paf, *tempo_2_AG, e$
                                        ]
                                if prof_3_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_rel_AG, *pfr_AG, paf, pgcode_AG, *prof_3_rel_AG, *pfr_AG,  e$
                                        if tempo_3_AG > 0, sm, paf, *tempo_3_AG, e$
                                        ]
                                if prof_4_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_rel_AG, *pfr_AG, paf, pgcode_AG, *prof_4_rel_AG, *pfr_AG,  e$
                                        if tempo_4_AG > 0, sm, paf, *tempo_4_AG, e$
                                        ]
                                if prof_5_AG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_rel_AG, *pfr_AG, paf, pgcode_AG, *prof_5_rel_AG, *pfr_AG,  e$
                                        if tempo_5_AG > 0, sm, paf, *tempo_5_AG, e$
                                        ]

                                 ]

percage_avance_controle_BG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_BG = 1

                            sm, paf, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_BG
                            gcode$ = 0
                            sr, *zabs_BG, paf, pgcode_BG, *zabs_BG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                sl, *prof_1_BG, *pfr_BG, paf, pgcode_BG, *prof_1_BG, *pfr_BG,  e$
                                if tempo_1_BG > 0, sm, paf, *tempo_1_BG, e$

                                if prof_2_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_BG, *pfr_BG, paf, pgcode_BG, *prof_2_BG, *pfr_BG,  e$
                                        if tempo_2_BG > 0, sm, paf, *tempo_2_BG, e$
                                        ]
                                if prof_3_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_BG, *pfr_BG, paf, pgcode_BG, *prof_3_BG, *pfr_BG,  e$
                                        if tempo_3_BG > 0, sm, paf, *tempo_3_BG, e$
                                        ]
                                if prof_4_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_BG, *pfr_BG, paf, pgcode_BG, *prof_4_BG, *pfr_BG,  e$
                                        if tempo_4_BG > 0, sm, paf, *tempo_4_BG, e$
                                        ]
                                if prof_5_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_BG, *pfr_BG, paf, pgcode_BG, *prof_5_BG, *pfr_BG,  e$
                                        if tempo_5_BG > 0, sm, paf, *tempo_5_BG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                sl, *prof_1_rel_BG, *pfr_BG, paf, pgcode_BG, *prof_1_rel_BG, *pfr_BG,  e$
                                if tempo_1_BG > 0, sm, paf, *tempo_1_BG, e$

                                if prof_2_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_rel_BG, *pfr_BG, paf, pgcode_BG, *prof_2_rel_BG, *pfr_BG,  e$
                                        if tempo_2_BG > 0, sm, paf, *tempo_2_BG, e$
                                        ]
                                if prof_3_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_rel_BG, *pfr_BG, paf, pgcode_BG, *prof_3_rel_BG, *pfr_BG,  e$
                                        if tempo_3_BG > 0, sm, paf, *tempo_3_BG, e$
                                        ]
                                if prof_4_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_rel_BG, *pfr_BG, paf, pgcode_BG, *prof_4_rel_BG, *pfr_BG,  e$
                                        if tempo_4_BG > 0, sm, paf, *tempo_4_BG, e$
                                        ]
                                if prof_5_BG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_rel_BG, *pfr_BG, paf, pgcode_BG, *prof_5_rel_BG, *pfr_BG,  e$
                                        if tempo_5_BG > 0, sm, paf, *tempo_5_BG, e$
                                        ]

                                 ]
percage_avance_controle_CG    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_CG = 1

                            sm, paf, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_CG
                            gcode$ = 0
                            sr, *zabs_CG, paf, pgcode_CG, *zabs_CG, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1
                                sl, *prof_1_CG, *pfr_CG, paf, pgcode_CG, *prof_1_CG, *pfr_CG,  e$
                                if tempo_1_CG > 0, sm, paf, *tempo_1_CG, e$

                                if prof_2_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_CG, *pfr_CG, paf, pgcode_CG, *prof_2_CG, *pfr_CG,  e$
                                        if tempo_2_CG > 0, sm, paf, *tempo_2_CG, e$
                                        ]
                                if prof_3_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_CG, *pfr_CG, paf, pgcode_CG, *prof_3_CG, *pfr_CG,  e$
                                        if tempo_3_CG > 0, sm, paf, *tempo_3_CG, e$
                                        ]
                                if prof_4_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_CG, *pfr_CG, paf, pgcode_CG, *prof_4_CG, *pfr_CG,  e$
                                        if tempo_4_CG > 0, sm, paf, *tempo_4_CG, e$
                                        ]
                                if prof_5_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_CG, *pfr_CG, paf, pgcode_CG, *prof_5_CG, *pfr_CG,  e$
                                        if tempo_5_CG > 0, sm, paf, *tempo_5_CG, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                sm, paf, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1

                                sl, *prof_1_rel_CG, *pfr_CG, paf, pgcode_CG, *prof_1_rel_CG, *pfr_CG,  e$
                                if tempo_1_CG > 0, sm, paf, *tempo_1_CG, e$

                                if prof_2_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2
                                        sl, *prof_2_rel_CG, *pfr_CG, paf, pgcode_CG, *prof_2_rel_CG, *pfr_CG,  e$
                                        if tempo_2_CG > 0, sm, paf, *tempo_2_CG, e$
                                        ]
                                if prof_3_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3
                                        sl, *prof_3_rel_CG, *pfr_CG, paf, pgcode_CG, *prof_3_rel_CG, *pfr_CG,  e$
                                        if tempo_3_CG > 0, sm, paf, *tempo_3_CG, e$
                                        ]
                                if prof_4_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4
                                        sl, *prof_4_rel_CG, *pfr_CG, paf, pgcode_CG, *prof_4_rel_CG, *pfr_CG,  e$
                                        if tempo_4_CG > 0, sm, paf, *tempo_4_CG, e$
                                        ]
                                if prof_5_CG = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        sm, paf, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5
                                        sl, *prof_5_rel_CG, *pfr_CG, paf, pgcode_CG, *prof_5_rel_CG, *pfr_CG,  e$
                                        if tempo_5_CG > 0, sm, paf, *tempo_5_CG, e$
                                        ]

                                 ]

percage_avance_controle_AM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_AM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_AM
                            gcode$ = 0
                            pnumligne, pgcode_AM, zabs_AM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_AM
                                pnumligne, pgcode_AM, prof_1_AM, pfr_AM,  e$
                                if tempo_1_AM > 0, pnumligne, *tempo_1_AM, e$

                                if prof_2_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_AM
                                        pnumligne, pgcode_AM, prof_2_AM, pfr_AM,  e$
                                        if tempo_2_AM > 0, pnumligne, *tempo_2_AM, e$
                                        ]
                                if prof_3_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_AM
                                        pnumligne, pgcode_AM, prof_3_AM, pfr_AM,  e$
                                        if tempo_3_AM > 0, pnumligne, *tempo_3_AM, e$
                                        ]
                                if prof_4_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_AM
                                        pnumligne, pgcode_AM, prof_4_AM, pfr_AM,  e$
                                        if tempo_4_AM > 0, pnumligne, *tempo_4_AM, e$
                                        ]
                                if prof_5_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_AM
                                        pnumligne, pgcode_AM, prof_5_AM, pfr_AM,  e$
                                        if tempo_5_AM > 0, pnumligne, *tempo_5_AM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_AM

                                pnumligne, pgcode_AM, prof_1_rel_AM, pfr_AM,  e$
                                if tempo_1_AM > 0, pnumligne, *tempo_1_AM, e$

                                if prof_2_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_AM
                                        pnumligne, pgcode_AM, prof_2_rel_AM, pfr_AM,  e$
                                        if tempo_2_AM > 0, pnumligne, *tempo_2_AM, e$
                                        ]
                                if prof_3_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_AM
                                        pnumligne, pgcode_AM, prof_3_rel_AM, pfr_AM,  e$
                                        if tempo_3_AM > 0, pnumligne, *tempo_3_AM, e$
                                        ]
                                if prof_4_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_AM
                                        pnumligne, pgcode_AM, prof_4_rel_AM, pfr_AM,  e$
                                        if tempo_4_AM > 0, pnumligne, *tempo_4_AM, e$
                                        ]
                                if prof_5_AM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_AM
                                        pnumligne, pgcode_AM, prof_5_rel_AM, pfr_AM,  e$
                                        if tempo_5_AM > 0, pnumligne, *tempo_5_AM, e$
                                        ]

                                 ]

percage_avance_controle_BM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_BM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_BM
                            gcode$ = 0
                            pnumligne, pgcode_BM, zabs_BM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_BM
                                pnumligne, pgcode_BM, prof_1_BM, pfr_BM,  e$
                                if tempo_1_BM > 0, pnumligne, *tempo_1_BM, e$

                                if prof_2_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_BM
                                        pnumligne, pgcode_BM, prof_2_BM, pfr_BM,  e$
                                        if tempo_2_BM > 0, pnumligne, *tempo_2_BM, e$
                                        ]
                                if prof_3_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_BM
                                        pnumligne, pgcode_BM, prof_3_BM, pfr_BM,  e$
                                        if tempo_3_BM > 0, pnumligne, *tempo_3_BM, e$
                                        ]
                                if prof_4_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_BM
                                        pnumligne, pgcode_BM, prof_4_BM, pfr_BM,  e$
                                        if tempo_4_BM > 0, pnumligne, *tempo_4_BM, e$
                                        ]
                                if prof_5_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_BM
                                        pnumligne, pgcode_BM, prof_5_BM, pfr_BM,  e$
                                        if tempo_5_BM > 0, pnumligne, *tempo_5_BM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_BM

                                pnumligne, pgcode_BM, prof_1_rel_BM, pfr_BM,  e$
                                if tempo_1_BM > 0, pnumligne, *tempo_1_BM, e$

                                if prof_2_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_BM
                                        pnumligne, pgcode_BM, prof_2_rel_BM, pfr_BM,  e$
                                        if tempo_2_BM > 0, pnumligne, *tempo_2_BM, e$
                                        ]
                                if prof_3_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_BM
                                        pnumligne, pgcode_BM, prof_3_rel_BM, pfr_BM,  e$
                                        if tempo_3_BM > 0, pnumligne, *tempo_3_BM, e$
                                        ]
                                if prof_4_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_BM
                                        pnumligne, pgcode_BM, prof_4_rel_BM, pfr_BM,  e$
                                        if tempo_4_BM > 0, pnumligne, *tempo_4_BM, e$
                                        ]
                                if prof_5_BM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_BM
                                        pnumligne, pgcode_BM, prof_5_rel_BM, pfr_BM,  e$
                                        if tempo_5_BM > 0, pnumligne, *tempo_5_BM, e$
                                        ]

                                 ]
percage_avance_controle_CM    # premiere passage pour ecriture du cycle 
                                cycle_heli_spiral_CM = 1

                            pnumligne, sdcom, "APPROCHE DESSUS DU TROU", sfcom, e$
                            pcalcule_variable_2_CM
                            gcode$ = 0
                            pnumligne, pgcode_CM, zabs_CM, e$
                            gcode$ = 1

                            if abso_rel = 0,  # mode absolue
                                    [
                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_CM
                                pnumligne, pgcode_CM, prof_1_CM, pfr_CM,  e$
                                if tempo_1_CM > 0, pnumligne, *tempo_1_CM, e$

                                if prof_2_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_CM
                                        pnumligne, pgcode_CM, prof_2_CM, pfr_CM,  e$
                                        if tempo_2_CM > 0, pnumligne, *tempo_2_CM, e$
                                        ]
                                if prof_3_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_CM
                                        pnumligne, pgcode_CM, prof_3_CM, pfr_CM,  e$
                                        if tempo_3_CM > 0, pnumligne, *tempo_3_CM, e$
                                        ]
                                if prof_4_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_CM
                                        pnumligne, pgcode_CM, prof_4_CM, pfr_CM,  e$
                                        if tempo_4_CM > 0, pnumligne, *tempo_4_CM, e$
                                        ]
                                if prof_5_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_CM
                                        pnumligne, pgcode_CM, prof_5_CM, pfr_CM,  e$
                                        if tempo_5_CM > 0, pnumligne, *tempo_5_CM, e$
                                        ]

                                 ]
                         if abso_rel = 1,  # mode relatif
                                 [


                                pnumligne, sdcom, "PREMIERE PROFONDEUR", sfcom, e$
                                fr$ = avance_1_CM

                                pnumligne, pgcode_CM, prof_1_rel_CM, pfr_CM,  e$
                                if tempo_1_CM > 0, pnumligne, *tempo_1_CM, e$

                                if prof_2_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "DEUXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_2_CM
                                        pnumligne, pgcode_CM, prof_2_rel_CM, pfr_CM,  e$
                                        if tempo_2_CM > 0, pnumligne, *tempo_2_CM, e$
                                        ]
                                if prof_3_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "TROIXIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_3_CM
                                        pnumligne, pgcode_CM, prof_3_rel_CM, pfr_CM,  e$
                                        if tempo_3_CM > 0, pnumligne, *tempo_3_CM, e$
                                        ]
                                if prof_4_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "QUATRIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_4_CM
                                        pnumligne, pgcode_CM, prof_4_rel_CM, pfr_CM,  e$
                                        if tempo_4_CM > 0, pnumligne, *tempo_4_CM, e$
                                        ]
                                if prof_5_CM = 9999, sortie_cycle_prof = 1
                                if sortie_cycle_prof <> 1,
                                        [
                                        pnumligne, sdcom, "CINQUIEME PROFONDEUR", sfcom, e$
                                        fr$ = avance_5_CM
                                        pnumligne, pgcode_CM, prof_5_rel_CM, pfr_CM,  e$
                                        if tempo_5_CM > 0, pnumligne, *tempo_5_CM, e$
                                        ]

                                 ]
#endregion
#endregion

#region   CYCLE de palpage de bague #OK
#region palpage de bague
# ------------------------ debut  CYCLE de palpage de bague -------------------------

#-------- ecriture des format -------------

fmt "R10=" 2 R10
fmt "R11=" 2 R11
fmt "R12=" 2 R12
fmt "R15=" 2 R15
fmt "R16=" 2 R16
fmt "R17=" 2 R17
fmt "R18=" 2 R18
fmt "Z=R12+" 2 zdecpalp

palpagebague_BG  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_BG, psortie8_BG
                gcode$ = 0
                R10 = xprint_BG
                R11 = yprint_BG
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_BG = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                sm, paf, "; Mise à zéro des valeurs de décalage fin du G54", e$
                sm, paf, "R15=-1", e$
                sm, paf, "PALPBAGUE", e$
                sm, paf, "G54", e$
                sm, paf, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                sm, "A0 C0", paf, "G0 SUPA A0 C0", e$
                sm, paf, "TRAORI(1)", e$
                sm, paf, "G54", e$
                sm, paf, "D1", e$
                #sm, paf,"M210 ; Dévalidation sécurité Z-", e$
                sm, paf, R10, "; (mm) : Position théorique en X de la bague", e$
                sm, paf, R11, "; (mm) : Position théorique en Y de la bague", e$
                sm, paf, R12, "; (mm) : Position théorique en Z de la bague", e$
                sm, paf, R15, "; (mm) : Diamètre intérieur de la bague",e$
                sm, paf, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                sm, paf, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                sm, paf, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                sr, *zaproche_BG, paf, pgcode_force_BG, *zaproche_BG, e$
                sm, paf, "PALPBAGUE", e$
                sm, paf, "; Mise à jour des offsets", e$
                sm, paf, "TRAORI(1)", e$
                sm, paf, "DECALAGE", e$
                sm, paf, "G54", e$
                #sm, paf, "M211 ; Validation sécurité Z-", e$
                #sm, paf, "CRENO_END", e$

palpagebague_CG  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_CG, psortie8_CG
                gcode$ = 0
                R10 = xprint_CG
                R11 = yprint_CG
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_CG = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                sm, paf, "; Mise à zéro des valeurs de décalage fin du G54", e$
                sm, paf, "R15=-1", e$
                sm, paf, "PALPBAGUE", e$
                sm, paf, "G54", e$
                sm, paf, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                sm, "B0 C0", paf, "G0 SUPA B0 C0", e$
                sm, paf, "TRAORI(1)", e$
                sm, paf, "G54", e$
                sm, paf, "D1", e$
                #sm, paf,"M210 ; Dévalidation sécurité Z-", e$
                sm, paf, R10, "; (mm) : Position théorique en X de la bague", e$
                sm, paf, R11, "; (mm) : Position théorique en Y de la bague", e$
                sm, paf, R12, "; (mm) : Position théorique en Z de la bague", e$
                sm, paf, R15, "; (mm) : Diamètre intérieur de la bague",e$
                sm, paf, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                sm, paf, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                sm, paf, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                sr, *zaproche_CG, paf, pgcode_force_CG, *zaproche_CG, e$
                sm, paf, "PALPBAGUE", e$
                sm, paf, "; Mise à jour des offsets", e$
                sm, paf, "TRAORI(1)", e$
                sm, paf, "DECALAGE", e$
                sm, paf, "G54", e$
                #sm, paf, "M211 ; Validation sécurité Z-", e$
                #sm, paf, "CRENO_END", e$               

palpagebague_BM  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_BM, psortie8_BM
                gcode$ = 0
                R10 = xprint_BM
                R11 = yprint_BM
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_BM = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA A0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_BM, *zaproche_BM, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$

palpagebague_CM  # ecriture du cycle de palpage de bague

                if strtool$ <> spalpeur_CM, psortie8_CM
                gcode$ = 0
                R10 = xprint_CM
                R11 = yprint_CM
                R12 = zdrl$
                R15 = peck1$
                R16 = peck2$
                R17 = peckclr$
                R18 = retr$
                zaproche_CM = refht$

# Modification EdC le 22 nov. 2013 - Début - 
                pnumligne, "; Mise à zéro des valeurs de décalage fin du G54", e$
                pnumligne, "R15=-1", e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "G54", e$
                pnumligne, "; Fin de mise à zéro des valeurs de décalage fin du G54", e$
# Modification EdC le 22 nov. 2013 - Fin -

                pnumligne, "G0 SUPA B0 C0", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "G54", e$
                pnumligne, "D1", e$
                #pnumligne,"M210 ; Dévalidation sécurité Z-", e$
                pnumligne, R10, "; (mm) : Position théorique en X de la bague", e$
                pnumligne, R11, "; (mm) : Position théorique en Y de la bague", e$
                pnumligne, R12, "; (mm) : Position théorique en Z de la bague", e$
                pnumligne, R15, "; (mm) : Diamètre intérieur de la bague",e$
                pnumligne, R16, "; (mm) : Décalage sur diamètre pour palpage en Z", e$
                pnumligne, R17, "; (°) : Décalage angulaire pour palpage en Z", e$
                pnumligne, R18, "; ( mm ) :  Décalage de profondeur à l'intérieur du trou", e$
                pnumligne, pgcode_force_CM, *zaproche_CM, e$
                pnumligne, "PALPBAGUE", e$
                pnumligne, "; Mise à jour des offsets", e$
                pnumligne, "TRAORI(1)", e$
                pnumligne, "DECALAGE", e$
                pnumligne, "G54", e$
                #pnumligne, "M211 ; Validation sécurité Z-", e$
                #pnumligne, "CRENO_END", e$
#endregion              
#region pdrlcst
pdrlcst$
            pchange_AG
            pdrlcst_AG

            pchange_AM
            pdrlcst_AM

            pchange_BG
            pdrlcst_BG

            pchange_BM
            pdrlcst_BM

            pchange_CG
            pdrlcst_CG

            pchange_CM
            pdrlcst_CM

pdrlcst_AG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                if strcom_AG = svide, strcom_AG = "PERCAGE DECOMPOSE", "MW_OP_COMMENT", strcom_AG, e$
                        sm, paf, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_AG = 1, psortie_AG
                        pprint_AG
                        typcycle_AG = 1
                        if drill5axes_AG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_AG
                         initht5x_AG = refht$
                         percage_avance_controle_AG
                         if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_AG, paf, pgcode_force_AG, *old_zinitht_AG, e$
                         ]
                        else, percage_avance_controle_AG
                        old_dest_ret_5x_AG = dest_ret_5x_AG
                ]
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_BG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                if strcom_BG = svide, strcom_BG = "PERCAGE DECOMPOSE", "MW_OP_COMMENT", strcom_BG, e$
                       if strtool$ = spalpeur_BG, psortie7_BG  # on verifie que l'on ne perce pas avec le palpeur!
                        sm, paf, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_BG = 1, psortie_BG
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_BG
                         initht5x_BG = refht$
                         percage_avance_controle_BG
                         if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_BG, paf, pgcode_force_BG, *old_zinitht_BG, e$
                  ]
                    else, percage_avance_controle_BG
                    old_dest_ret_5x_BG = dest_ret_5x_BG
                ]


                if drl_cycle$ = 11,
                [
                if strcom_BG = svide, strcom_BG = "PALPAGE BAGUE (9103 + 9110)", "MW_OP_COMMENT", strcom_BG, e$
                        sm, paf, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_BG = 1, psortie_BG
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1, psortie6_BG
                        palpagebague_BG
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_CG     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                if strcom_CG = svide, strcom_CG = "PERCAGE DECOMPOSE", "MW_OP_COMMENT", strcom_CG, e$
                       if strtool$ = spalpeur_CG, psortie7_CG  # on verifie que l'on ne perce pas avec le palpeur!
                        sm, paf, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_CG = 1, psortie_CG
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_CG
                         initht5x_CG = refht$
                         percage_avance_controle_CG
                         if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_CG, paf, pgcode_force_CG, *old_zinitht_CG, e$
                  ]
                    else, percage_avance_controle_CG
                    old_dest_ret_5x_CG = dest_ret_5x_CG
                ]


                if drl_cycle$ = 11,
                [
                if strcom_BG = svide, strcom_BG = "PALPAGE BAGUE (9103 + 9110)", "MW_OP_COMMENT", strcom_BG, e$
                        sm, paf, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_CG = 1, psortie_CG
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1, psortie6_CG
                        palpagebague_CG
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_AM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_AM = 1, psortie_AM
                        pprint_AM
                        typcycle_AM = 1
                        if drill5axes_AM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_AM
                         initht5x_AM = refht$
                         percage_avance_controle_AM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                         ]
                        else, percage_avance_controle_AM
                        old_dest_ret_5x_AM = dest_ret_5x_AM
                ]
                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_BM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_BM, psortie7_BM  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_BM = 1, psortie_BM
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_BM
                         initht5x_BM = refht$
                         percage_avance_controle_BM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                  ]
                    else, percage_avance_controle_BM
                    old_dest_ret_5x_BM = dest_ret_5x_BM
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_BM = 1, psortie_BM
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1, psortie6_BM
                        palpagebague_BM
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_CM     # cycle speciaux premier passage

                if drl_cycle$ = 9,
                [
                       if strtool$ = spalpeur_CM, psortie7_CM  # on verifie que l'on ne perce pas avec le palpeur!
                        pnumligne, sdcom, " DEBUT CYCLE DECOMPOSE A AVANCE CONTROLEE", sfcom, e$
                        if tete_rev_CM = 1, psortie_CM
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1,
                        [
                        #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                         pdrl5_CM
                         initht5x_CM = refht$
                         percage_avance_controle_CM
                         if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                  ]
                    else, percage_avance_controle_CM
                    old_dest_ret_5x_CM = dest_ret_5x_CM
                ]


                if drl_cycle$ = 11,
                [
                        pnumligne, sdcom, " DEBUT CYCLE PALPAGE BLUM", sfcom, e$
                        if tete_rev_CM = 1, psortie_CM
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1, psortie6_CM
                        palpagebague_CM
                ]

                !x$, !y$, !z$, !xr$, !yr$, !zr$
#endregion
#region pdrlcst_2
pdrlcst_2$
            pchange_AG
            pdrlcst_2_AG

            pchange_AM
            pdrlcst_2_AM

            pchange_BG
            pdrlcst_2_BG

            pchange_BM
            pdrlcst_2_BM

            pchange_CG
            pdrlcst_2_CG

            pchange_CM
            pdrlcst_2_CM

pdrlcst_2_AG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_AG
                        typcycle_AG = 1
                        if drill5axes_AG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AG
                            initht5x_AG = refht$
                            percage_avance_controle_2_AG
                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_AG, paf, pgcode_force_AG, *old_zinitht_AG, e$
                         ]
                else, percage_avance_controle_2_AG
                old_dest_ret_5x_AG = dest_ret_5x_AG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_2_BG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_BG
                        typcycle_BG = 1
                        if drill5axes_BG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BG
                            initht5x_BG = refht$
                            percage_avance_controle_2_BG
                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_BG, paf, pgcode_force_BG, *old_zinitht_BG, e$
                         ]
                else, percage_avance_controle_2_BG
                old_dest_ret_5x_BG = dest_ret_5x_BG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_BG

pdrlcst_2_CG     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_CG
                        typcycle_CG = 1
                        if drill5axes_CG = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CG
                            initht5x_CG = refht$
                            percage_avance_controle_2_CG
                            if  nextop$ <> 100, gcode$ = 0, sr, *old_zinitht_CG, paf, pgcode_force_CG, *old_zinitht_CG, e$
                         ]
                else, percage_avance_controle_2_CG
                old_dest_ret_5x_CG = dest_ret_5x_CG
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_CG

pdrlcst_2_AM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_AM
                        typcycle_AM = 1
                        if drill5axes_AM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_AM
                            initht5x_AM = refht$
                            percage_avance_controle_2_AM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_AM, *old_zinitht_AM, e$
                         ]
                else, percage_avance_controle_2_AM
                old_dest_ret_5x_AM = dest_ret_5x_AM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$

pdrlcst_2_BM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_BM
                        typcycle_BM = 1
                        if drill5axes_BM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_BM
                            initht5x_BM = refht$
                            percage_avance_controle_2_BM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_BM, *old_zinitht_BM, e$
                         ]
                else, percage_avance_controle_2_BM
                old_dest_ret_5x_BM = dest_ret_5x_BM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_BM

pdrlcst_2_CM     # cycle speciaux deuxieme passage
                if drl_cycle$ = 9,
                [
                        pprint_CM
                        typcycle_CM = 1
                        if drill5axes_CM = 1,
                        [
                            #" voir =",  *refht$, *initht$, *depth$, *zdrl$, *tosz$, *drl_sel_tos$, e$
                            pdrl5_2_CM
                            initht5x_CM = refht$
                            percage_avance_controle_2_CM
                            if  nextop$ <> 100, gcode$ = 0, pnumligne, pgcode_force_CM, *old_zinitht_CM, e$
                         ]
                else, percage_avance_controle_2_CM
                old_dest_ret_5x_CM = dest_ret_5x_CM
                ]
            !x$, !y$, !z$, !xr$, !yr$, !zr$
                if drl_cycle$ = 11, psortie9_CM
#endregion
#endregion

#region   psouf_imp #OK
#region psouf
#----------------------------cycle fixes----------------------------------------------


fmt "" 4 retard_enclenchement
fmt "" 4 duree_enclenchement

psouf_imp_BG       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    ###subout$### = 4
                                    serreur_visu_BG = serreur201_BG + no2str(numop_BG)
                                    "MW_OP_COMMENT", *serreur_visu_BG, e$
                                    if subout$ <> 3, result = mprint(serreur_visu_BG)
                                    #exitpost$ # abandonner                 
                                    ###subout$### = 3
                                    erreur_BG = 1
                                    ]
                                    spaces$ = 1
                                    sm, paf, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_CG       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    ###subout$### = 4
                                    serreur_visu_CG = serreur201_CG + no2str(numop_CG)
                                    "MW_OP_COMMENT", *serreur_visu_CG, e$
                                    if subout$ <> 3, result = mprint(serreur_visu_CG)
                                    #exitpost$ # abandonner                 
                                    ###subout$### = 3
                                    erreur_CG = 1
                                    ]
                                    spaces$ = 1
                                    sm, paf, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_BM       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    ###subout$### = 4
                                    serreur_visu_BM = serreur201_BM + no2str(numop_BM)
                                    "MW_OP_COMMENT", *serreur_visu_BM, e$
                                    if subout$ <> 3, result = mprint(serreur_visu_BM)
                                    #exitpost$ # abandonner
                                    ###subout$### = 3
                                    erreur_BM = 1
                                    ]
                                    spaces$ = 1
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]

psouf_imp_CM       # gestion soufllage impulsion apres percage
                  if drl_prm9$ <> 0,
                                    [
                                    retard_enclenchement = drl_prm9$ * 1000
                                    duree_enclenchement = drl_prm10$ * 1000
                                    if lubrif_m7 = 1 | lubrif_m207 = 1,
                                    [
                                    ###subout$### = 4
                                    serreur_visu_CM = serreur201_CM + no2str(numop_CM)
                                    "MW_OP_COMMENT", *serreur_visu_CM, e$
                                    if subout$ <> 3, result = mprint(serreur_visu_CM)
                                    #exitpost$ # abandonner                 
                                    ###subout$### = 3
                                    erreur_CM = 1
                                    ]
                                    spaces$ = 1
                                    pnumligne, " SOUF_IMP(",*retard_enclenchement,",",*duree_enclenchement,")", e$
                                    spaces$ = 1
                                    ]
#endregion                                  
#region pvoir
stl_mfg_com : ""       # 'tool mfg comment' from tool
stl_chuck_com : ""     # 'tool chuck comment' from tool
snomoutil : ""          # nom outil suite bug que strtool prend pas les points

pvoir_AG     # voir les position de percage


            vec_reel_x = tox4print_AG - drl_init_x$
            vec_reel_y = toy4print_AG - drl_init_y$
            vec_reel_z = toz4print_AG - drl_init_z$

            dest_ret_5x_AG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_AG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
            #"-------------->",voir dest_ret_5x_AG", *dest_ret_5x_AG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_AG, *toy4print_AG, *toz4print_AG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$

pvoir_BG     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_BG", *tox4print_BG, *toy4print_BG,*toz4print_BG, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_BG - drl_init_x$
            vec_reel_y = toy4print_BG - drl_init_y$
            vec_reel_z = toz4print_BG - drl_init_z$

            dest_ret_5x_BG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_BG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_BG", *dest_ret_5x_BG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_BG, *toy4print_BG, *toz4print_BG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_CG     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_CG", *tox4print_CG, *toy4print_CG,*toz4print_CG, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_CG - drl_init_x$
            vec_reel_y = toy4print_CG - drl_init_y$
            vec_reel_z = toz4print_CG - drl_init_z$

            dest_ret_5x_CG = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_CG = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_CG", *dest_ret_5x_CG, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_CG, *toy4print_CG, *toz4print_CG e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data              

pvoir_AM     # voir les position de percage


            vec_reel_x = tox4print_AM - drl_init_x$
            vec_reel_y = toy4print_AM - drl_init_y$
            vec_reel_z = toz4print_AM - drl_init_z$

            dest_ret_5x_AM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_AM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
            #"-------------->",voir dest_ret_5x_AM", *dest_ret_5x_AM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_AM, *toy4print_AM, *toz4print_AM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$

pvoir_BM     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_BM", *tox4print_BM, *toy4print_BM,*toz4print_BM, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_BM - drl_init_x$
            vec_reel_y = toy4print_BM - drl_init_y$
            vec_reel_z = toz4print_BM - drl_init_z$

            dest_ret_5x_BM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_BM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_BM", *dest_ret_5x_BM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_BM, *toy4print_BM, *toz4print_BM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data

pvoir_CM     # voir les position de percage
            #" voir tourne", *tourne, e$
            #"voir les tox4", *tox4$, *toy4$,*toz4$, e$
            #"voir tox4print_CM", *tox4print_CM, *toy4print_CM,*toz4print_CM, e$
            #"voir drl_init_x$", *drl_init_x$, *drl_init_y$, *drl_init_y$, e$

            vec_reel_x = tox4print_CM - drl_init_x$
            vec_reel_y = toy4print_CM - drl_init_y$
            vec_reel_z = toz4print_CM - drl_init_z$

            dest_ret_5x_CM = (sqrt(vec_reel_x * vec_reel_x + vec_reel_y * vec_reel_y + vec_reel_z * vec_reel_z)) # - drl_sel_ref$

            #dest_ret_5x_CM = initht$
            #"voir drl_sel_ref", *drl_sel_ref$, e$
            #"voir les vec_reel_XYZ", *vec_reel_x,*vec_reel_y, *vec_reel_z, e$
           #"--------------> voir dest_ret_5x_CM", *dest_ret_5x_CM, e$
            #"voir next op", *nextop$,  e$
            #"x=",*x$,"y=",*y$,"z=",*z$, "u=",*u$, "v=", *v$, "w=", *w$, "xr=", *xr$, "yr=", *yr$, "zr=", *zr$, e$
            #"voir les tox4", *tox4print_CM, *toy4print_CM, *toz4print_CM e$
            #"drl_init_x$", *drl_init_x$, "drl_init_y$", *drl_init_y$, "drl_init_z$", *drl_init_z$, e$ # les drl_init sont les points xyz dans le plan 3d
            #"voir refht et initht", *refht$ , *initht$, *drl_sel_ref$, e$
              # Define string variables to hold 'sparameter' string data
#endregion
#endregion

#region   PPARAMETER #OK
#region pwrttparam
pwrttparam$
            pchange_AG
            pwrttparam_AG

            pchange_AM
            pwrttparam_AM

            pchange_BG
            pwrttparam_BG

            pchange_BM
            pwrttparam_BM

            pchange_CG
            pwrttparam_CG

            pchange_CM
            pwrttparam_CM

pwrttparam_AG     #Pre-read parameter data
               #"pwrttparam", ~prmcode$, ~sparameter$, e$ 
pwrttparam_BG   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$

pwrttparam_CG   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$


pwrttparam_AM     #Pre-read parameter data
               #"pwrttparam", ~prmcode$, ~sparameter$, e$ 
pwrttparam_BM   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$

pwrttparam_CM   #Pre-read parameter data
             if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]

            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
            #"pwrttparam", ~prmcode$, ~sparameter$, e$
#endregion
#region pparameter
pparameter$
            pchange_AG
            pparameter_AG

            pchange_AM
            pparameter_AM

            pchange_BG
            pparameter_BG

            pchange_BM
            pparameter_BM

            pchange_CG
            pparameter_CG

            pchange_CM
            pparameter_CM

pparameter_AG   # Read in the 20000 series 'additional parameters' from OPS file
                #if prmcode$ = 15557, " la on y est ", e$
			if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
             #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres
             # 20002 = tool definition - 'manufacturer' data
          if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 12727 = tool definition - 'chuck name' data
          if (prmcode$ = 12727),stl_chuck_com = sparameter$ #Save string for output later
            if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)
            if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
pparameter_BG   # Read in the 20000 series 'additional parameters' from OPS file
               if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
			    if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
			
            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
             if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
pparameter_CG   # Read in the 20000 series 'additional parameters' from OPS file
            if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
			    if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
			
            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation              
            if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
pparameter_AM   # Read in the 20000 series 'additional parameters' from OPS file
                #if prmcode$ = 15557, " la on y est ", e$
			if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
                if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
             #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres
             # 20002 = tool definition - 'manufacturer' data
          if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 12727 = tool definition - 'chuck name' data
          if (prmcode$ = 12727),stl_chuck_com = sparameter$ #Save string for output later
            if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)
            if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
pparameter_BM   # Read in the 20000 series 'additional parameters' from OPS file
             if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
			    if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
			
            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation 
             if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
pparameter_CM   # Read in the 20000 series 'additional parameters' from OPS file
              if prmcode$ = 10112, pas_max_xy = rpar(sparameter$, 1)
			    if prmcode$ = 20007,[
                     paramT1 = rpar(sparameter$, 11)        # lecture des parametres d'outil
               #" voir sortie", paramT1,paramT2,paramT3,paramT4,paramT5,paramT6,paramT7 e$
                ]
			
            #~prmcode$, " var =", sparameter$, e$        # pour afficher tous les parametres


             # 2000 = strtool mais en mieux
             if (prmcode$ = 20001), snomoutil = sparameter$ #Save string for output later

             # 20002 = tool definition - 'manufacturer' data
             if (prmcode$ = 20002), stl_mfg_com = sparameter$ #Save string for output later

             # 20003 = tool definition - 'chuck name' data
            if (prmcode$ = 12727), stl_chuck_com = sparameter$ #Save string for output later

             # 10006 = tool definition - rayon coin outil 
            if (prmcode$ = 10006), rayon_coin_outil = rpar(sparameter$, 1) #Save string for output later
             if prmcode$ = 41132, oscilliation = rpar(sparameter$, 1)        # lecture des parametres si on a enclancher l'oscilliation
             if prmcode$ = 15339, planperc = rpar(sparameter$, 1)
#endregion
#region pecriture_bl_master

pecriture_bl_master_BG   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              
            if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                   " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
           else,
                                    [
                                    spaces$ = 0
                                   " ; BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
             spaces$ = 1

pecriture_bl_master_CG   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              

pecriture_bl_master_BM   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              
            if var_1 <> 0,
                                    [
                                    spaces$ = 0
                                   " BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
           else,
                                    [
                                    spaces$ = 0
                                   " ; BL_MASTER(",var_2,",",var_3,",",var_4,",",var_5,",",var_6,",",var_7,")"
                                    spaces$ = 1
                                    ]
             spaces$ = 1

pecriture_bl_master_CM   # ecriture de la routine bl master en liste outil 

            vartool_1 = rpar(strtool$, 2)  # extraction du nom outil en variable numerique qui sont dans le champ nom outil     
            svartool_1 = no2str(vartool_1) # passage de la valeur numerique en string
            spaces$ = 0
            if stl_chuck_com <> svide, soutil = svartool_1 + stl_chuck_com
            else, soutil = svartool_1
            rayon_outil = tldia$/2
            longeur_outil = paramT3 + paramT7
            var_1 = rpar(stl_mfg_com, 7)   # extraction des variable numerique qui sont dans le champ mandrain                              

#endregion
#region pwrtt
pwrtt$
            ###subout$### = 0
            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, " - ",t$,snomoutil, stl_chuck_com, e$
            if t$ > 0, lastopid = op_id$

            pchange_AG
            pwrtt_AG

            pchange_AM
            pwrtt_AM

            pchange_BG
            pwrtt_BG

            pchange_BM
            pwrtt_BM

            pchange_CG
            pwrtt_CG

            pchange_CM
            pwrtt_CM

pwrtt_AG       #  
            strtool$ = ucase(strtool$)
            if t$ > 0, sm,pafcom,spaces$ = 0, "(", t$, strtool$,stl_chuck_com,")", spaces$ = 1,e$

            if t$ > 0, lastopid = op_id$

pwrtt_BG       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, sm,paf,"MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_BG, 34,")", spaces$ = 1,e$

            if t$ > 0, lastopid = op_id$

pwrtt_CG       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            if t$ > 0, sm,paf,"MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_CG, 34,")", spaces$ = 1,e$

            if t$ > 0, lastopid = op_id$

pwrtt_AM       #  
            strtool$ = ucase(strtool$)
            #enlevé pour concat#if t$ > 0, "(", t$, strtool$,stl_chuck_com,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_BM       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
            #enlevé pour concat#if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_BM, 34,")", e$

            if t$ > 0, lastopid = op_id$

pwrtt_CM       #  

            spaces$ = 1
            snomoutil = ucase(snomoutil)
			pecriture_bl_master_CM
            #enlevé pour concat#if t$ > 0, pnumligne,  "MSG(",34, t$, snomoutil, stl_chuck_com, pecriture_bl_master_CM, 34,")", e$

            if t$ > 0, lastopid = op_id$
#endregion  
#region ptransreal
fmt 2 trans_num_prg
trans_num_prg : 0
fmt 2 prem_passage_ptrans
prem_passage_ptrans : 0
fmt 2 compteur_passage_trans
compteur_passage_trans : 0
ptransreal$

		if prem_passage_ptrans = 0, trans_num_prg = trans_mr1$, prem_passage_ptrans = 1
		compteur_passage_trans = compteur_passage_trans + 1
#endregion		
#endregion

#region   VALEURS OPTIONNELLES
# --------------------------------------------------------------------------
# Numbered questions for Mastercam --  Used by Mill 7
# --------------------------------------------------------------------------
38. Rapid feedrate? 20000.0
1538. Rapid feedrate (metric)? 10000.0

80. Communications port number for receive and transmit (1 or 2) ? 2
81. Data rate (110,150,300,600,1200,2400,4800,9600,14400,19200,38400)? 9600
82. Parity (E/O/N)? E
83. Data bits (7 or 8)? 7
84. Stop bits (1 or 2)? 2
85. Strip line feeds? N
86. Delay after end of line (seconds)? 0
87. Ascii, Eia, or Binary (A/E/B)? A
88. Echo keyboard to screen in terminal emulation? n
89. Strip carriage returns? N
90. Drive and subdirectory for NC files?
91. Name of executable post processor? MP
92. Name of reverse post processor? RP
93. Reverse post PST file name?
100. Number of places BEFORE the decimal point for sequence numbers? 3
101. Number of places AFTER the decimal point for sequence numbers? 0
103. Maximum spindle speed? 5000
107. Average time for tool change (seconds)? 2.0

159. Show first and last position as fully compensated in simulation? n

160. Display first and last entity in toolpath when simulating cutter compensation in control? y
161. Enable Home Position button? y
162. Enable Reference Point button? N
163. Enable Misc. Values button? Y
164. Enable Rotary Axis button? N
165. Enable Tool Plane button? N
166. Enable Construction Plane button? Y
167. Enable Tool Display button? N

# --------------------------------------------------------------------------
# Default Miscellaneous Real Values
# --------------------------------------------------------------------------
201. valeur de recul en 5 axes cont (mr1)? 199.0
202. plan de retournement en 5 axes cont (mr2)? 1500.0
203. Default miscellaneous real variable 3 (mr3)? 1500.0
204. Default miscellaneous real variable 4 (mr4)? 0.0
205. Default miscellaneous real variable 5 (mr5)? 0.0
206. Default miscellaneous real variable 6 (mr6)? 0.0
207. Default miscellaneous real variable 7 (mr7)? 180.0
208. DECALAGE X                            (mr8)? 0.0
209. DECALAGE Y                            (mr9)? 0.0
210. DECALAGE Z                            (mr10)? 0.0

# --------------------------------------------------------------------------
# Valeurs réelles par défaut (METRIQUE)
# --------------------------------------------------------------------------
1601. Default miscellaneous real variable 1 (mr1) (metric)? 199.0
1602. Default miscellaneous real variable 2 (mr2) (metric)? 1500.0
1603. Default miscellaneous real variable 3 (mr3) (metric)? 1500.0
1604. Default miscellaneous real variable 4 (mr4) (metric)? 0.0
1605. Default miscellaneous real variable 5 (mr5) (metric)? 0.0
1606. Default miscellaneous real variable 6 (mr6) (metric)? 0.0
1607. Default miscellaneous real variable 7 (mr7) (metric)? 180.0
1608. Default miscellaneous real variable 8 (mr8) (metric)? 0.0
1609. Default miscellaneous real variable 9 (mr9) (metric)? 0.0
1610. Default miscellaneous real variable 10 (mr10) (metric)? 0.0

# --------------------------------------------------------------------------
# Activer/désactiver les commutateurs de variables réelles
# --------------------------------------------------------------------------
1611. Enable miscellaneous real variable 1? y
1612. Enable miscellaneous real variable 2? y
1613. Enable miscellaneous real variable 3? y
1614. Enable miscellaneous real variable 4? y
1615. Enable miscellaneous real variable 5? y
1616. Enable miscellaneous real variable 6? y
1617. Enable miscellaneous real variable 7? y
1618. Enable miscellaneous real variable 8? y
1619. Enable miscellaneous real variable 9? y
1620. Enable miscellaneous real variable 10? y


# --------------------------------------------------------------------------
# Default Miscellaneous Integer Values
# --------------------------------------------------------------------------
301. tour de plus en 5 axes continue 1 ou -1 (mi1)? 0
302. commance en A- en 5 axes continue (mi2)? 0
303. Miscellaneous integer variable 4 (mi3)? 1
304. Miscellaneous integer variable 4 (mi4)? 0
305. Miscellaneous integer variable 5 (mi5)? 0
306. Miscellaneous integer variable 6 (mi6)? 0
307. Miscellaneous integer variable 7 (mi7)? 0
308. decalage en x (mi8)? 0
309. decalage en y (mi9)? 0
310. decalage en z (mi10)? 0

# --------------------------------------------------------------------------
# Activer/désactiver les commutateurs de variables entiéres
# --------------------------------------------------------------------------
1621. Enable miscellaneous integer variable 1? y
1622. Enable miscellaneous integer variable 2? y
1623. Enable miscellaneous integer variable 3? y
1624. Enable miscellaneous integer variable 4? y
1625. Enable miscellaneous integer variable 5? y
1626. Enable miscellaneous integer variable 6? y
1627. Enable miscellaneous integer variable 7? y
1628. Enable miscellaneous integer variable 8? y
1629. Enable miscellaneous integer variable 9? y
1630. Enable miscellaneous integer variable 10? y


# --------------------------------------------------------------------------
# Configuration File association parameters (default is "y")
# --------------------------------------------------------------------------
#400. Name of associated cfg file? 
401. Read SYSTEM COLORS section? y
402. Read ALLOCATIONS section? y
403. Read TOLERANCES section? y
404. Read DATA PATHS section? y
405. Read COMMUNICATIONS section? y
406. Read DRAFT SETTINGS section? y
407. Read MISCELLANEOUS section? y
408. Read NC SETTINGS section? y
409. Read DIALOG SCRIPTS section? y
410. Read DESIGN SETTINGS section? y
411. Read PLOTTER SETTINGS section? y
412. Read ALT-KEY ASSIGNMENTS section? y
413. Read CAD section? Y
414. Read START/EXIT section? Y
415. Read SCREEN section? Y
416. Read FILE NAMES section? Y

1500. Chook to execute from 'Misc. values' button?
1501. Insert parameter information in the ascii NCI? n
1502. Write operation information to binary file (.ops)? n
1503. Write transform operations (0=transform ops, 1=source ops, 2=both)? 1

1520. Display a warning when cutter compensation in control simulation finds an error? n

1521. Number of controller look-ahead blocks for CDC in control? 2

1530. Ignore work offset numbers when processing subprograms? y
1531. Ignore contour flags when processing subprograms? y

# Do NOT manually change the answer for Q.1999 !
1999. Product major version number that post supports? 9

3001. Machine acceleration? 2
3002. timing size? .1
[CTRL_MILL|DEFAULT]
[misc integers]
1. "Tour sur C positif ou négatif"
2. "A ou B positif ou négatif"
3. "Filtrage Angle 5X sur PP"//1
4. "n° de cloche"
5. "Type de mode de transfert du Prg."
6. "Variation de Hauteur"
7. "Variation de Hauteur"
8. "Dynamique de la machine"
9. "Shunt sécurité Axe Z (STC9103 et STC9110)"
10. "Arrêt avant opération"
[misc reals]
1. " "
2. "Altitude de retournement"//1300.//1300.
3. "Altitude de changement outil (STC9101)"//1500.//1500.
4. "Correcteur dynamique longueur outil"
5. "Filtrage 5X"
6. "Variation de Hauteur"
7. "Points d'arrêt G9"//-1.//-1.
8. "Décalage X"
9. "Décalage Y"
10. "Décalage Z"
[simple drill]
1. "PERCAGE SIMPLE"
2. "Avance"
3. ""
4. "Plan de sécurité"
7. ""
8. ""
9. ""
10. ""
11. ""
[peck drill]
1. "PERCAGE DEBOURRAGE"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[chip break]
1. "PERCAGE BRISE COPEAU"
2. "Avance"
3. "Tempo fin trou DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. "1ere passe FDPR"
8. "Valeur dégression DAM"
9. "Av 1er prof en % FRF"
10. "Tempo debut trou DTS"
11. ""
[tap]
1. "TARAUDAGE (9101)"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Pas spécial"
11. ""
[bore1]
1. "ALESAGE (9101)"
2. "Avance"
3. ""
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. ""
11. ""
[bore2]
1. "ALESAGE INDEXE (9101)"
2. "Avance"
3. "Tempo"
4. "Plan de sécurité"
5. "Garde"
7. ""
8. ""
9. ""
10. "Nombre de passes"
11. ""
[misc1]
1. "PERCAGE/ALESAGE (RETOUR ARRETE)"
2. "Avance"
3. "Tempo DTB"
4. "Plan de sécurité"
5. "Garde SDIS"
7. ""
8. ""
9. "Avance retour RFF "
10. ""
11. ""
[misc2]
1. "PERCAGE CAQ"
2. "Avance initiale"
3. "Pas maxi XY spirale"
4. "Plan de sécurité"
5. "Garde"
7. "Avalant=0 Oppo=1"
8. "Diamétre final"
9. "Diamétre ebauche"
10. "Pas maxi hélice en Z"
11. "Nbe tours de finition"
[drill cycle 9]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 10]
1. "PERCAGE DECOMPOSE"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Absolu(0) - Relatif(1)"
8. ""
9. ""
10. ""
11. ""
[drill cycle 11]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 12]
1. "PALPAGE BAGUE (9103 + 9110)"
2. "Avance initiale"
3. ""
4. "Plan de sécurité"
5. "Garde"
6. ""
7. "Diam Inter Bague"
8. "Décalage Palp. Ray."
9. "Décalage angulaire"
10. "Profondeur de palpage "
11. ""
[drill cycle 13]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 14]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 15]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 16]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 17]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 18]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 19]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[drill cycle 20]
1. "Non autorisé"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. ""
11. ""
[simple drill custom parameters]
1. "Paramètres percage G81"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[peck drill custom parameters]
1. "Paramètres debourage G83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[chip break drill custom parameters]
1. "Paramètres de brise copeau 83"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[tap custom parameters]
1. "Non Utilisé"
[bore1 custom parameters]
1. "Paramètres Percage/alesage G85"
2. ""
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
9. ""
10. "Souf: retard en S"
11. "Souf: durée imp en S"
[bore2 custom parameters]
1. "Paramètres de cycle spécial 6"
[misc1 custom parameters]
1. "Paramètres de cycle spécial 7"
[misc2 custom parameters]
1. "Paramètres de cycle Hélicoido-spiral"
2. "f entrée circulaire"
3. "f interpo. hélicoidale"
4. "f spirale"
5. "f interpo. finale"
6. "f sortie circulaire"
7. "Dist. en Perp. -1=cercle"
8. "Cor. ray. usure=1"
9. "Nbe tours de retour"
10. "Pas en Z debut/fin"
11. "Nb tours debut/fin"
[drill cycle 9 custom parameters]
1. "Paramètres de cycle spécial 9"
[drill cycle 10 custom parameters]
1. "Perçage décomposé"
2. "Profondeur n°1"
3. "Profondeur n°2"
4. "Profondeur n°3"
5. "Profondeur n°4"
6. "Profondeur n°5"
7. "F:n°1.Tempo(1/10)"
8. "F:n°2.Tempo(1/10)"
9. "F:n°3.Tempo(1/10)"
10. "F:n°4.Tempo(1/10)"
11. "F:n°5.Tempo(1/10)"
[drill cycle 11 custom parameters]
1. "Paramètres de cycle spécial 11"
[drill cycle 12 custom parameters]
1. "Paramètres de cycle spécial 12"
[drill cycle 13 custom parameters]
1. "Paramètres de cycle spécial 13"
[drill cycle 14 custom parameters]
1. "Paramètres de cycle spécial 14"
[drill cycle 15 custom parameters]
1. "Paramètres de cycle spécial 15"
[drill cycle 16 custom parameters]
1. "Paramètres de cycle spécial 16"
[drill cycle 17 custom parameters]
1. "Paramètres de cycle spécial 17"
[drill cycle 18 custom parameters]
1. "Paramètres de cycle spécial 18"
[drill cycle 19 custom parameters]
1. "Paramètres de cycle spécial 19"
[drill cycle 20 custom parameters]
1. "Paramètres de cycle spécial 20"
[drill cycle descriptions]
7. "Divers 1"
8. "Divers 2"
9. "Cycle #9"
10. "Percage decomposé"
11. "Cycle #11"
12. "Palpage bague"
13. "Cycle #13"
14. "Cycle #14"
15. "Cycle #15"
16. "Cycle #16"
17. "Cycle #17"
18. "Cycle #18"
19. "Cycle #19"
20. "Cycle #20"
[canned text]
1. "BRIDER LA PIECE AVEC VIS"
2. "OTER LES VIS"
3. "BRIDER LA PIECE AVEC SERRE-JOINTS"
4. "OTER SERRE-JOINTS"
5. "OTER LES CHUTES"
6. "BRIDER LES CHUTES AU RUBAN ADHESIF PAPIER"
7. "-"
8. "-"
9. "-"
10. "-"
11. "-"
12. "-"
13. "-"
14. "-"
15. "-"
16. "-"
17. "-"
18. "-"
19. "-"
20. "-"
21. "-"
22. "-"
23. "-"
24. "-"
25. "-"
26. "-"
27. "-"
28. "-"
29. "-"
30. "-"
31. "-"
32. "-"
33. "-"
34. "-"
35. "-"
36. "-"
37. "-"
[tool parameters]
9. "Eau - Air - Aspi"
[transform operation]
1. "C = Tr-: -1, Tr+: 1, init: -2"
2. "A = neg: -1, pos: 0, init: -2"
3. ""
4. ""
5. ""
6. ""
7. ""
8. ""
[CTRL_TEXT_END]
#endregion
