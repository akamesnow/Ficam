[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V24.00 P1 E1 W24.00 T1639753131 M24.00 I0 O0
# ---------------------------------------------------------------------------------------------------------
# -   POST PRO FRAISAGE 5 AXES avec plusieurs cinematique ET creation du fichier pour machinsim natif                                                       -
# -   SOUS PROG EN Z en ABSOLUE et INCREMENTAL                                                            -
# ---------------------------------------------------------------------------------------------------------
# -   Version X9.0                                                                                         -
# ---------------------------------------------------------------------------------------------------------
# -   Affichage des Surep R et L et 3D                                                                    -
# -   Affichage des type de corections                                                                    -
# -   Gestion du palpeur de bris outil                                                                    -
# -   Utiliser la comande DR-(rayon outil) pour correction usure usure inverse                            -
# ---------------------------------------------------------------------------------------------------------
# -       MASTERCAM X9         F.I.CAM                                                                    -
# ---------------------------------------------------------------------------------------------------------
# - Realise le      : 14/01/15  Par : JV ( simul ) et ED ( matrice )
# - Pour la societe :
# - Armoire CN      : HEID 426/530
# - Nom MACHINE     :  TOUTE CONFIG
#
# ---------------------------------------------------------------------------------------------------------
# -                                           -
# ---------------------------------------------------------------------------------------------------------
# -   DESCRIPTION DES MODIFICATIONS           -
# affichage du descripteur de fichier meme si pas question entete
# ajout de l'info groupe ou non
# mi10 utilise pour ajuster les avances sur les arc 0=NON 1=Ralentir 2=Accelerer 3=les Deux
# modification de la gestions des degagement machine en fonction des flag de reglage PST
# mi1 utilise pour ne pas degager en Z avant rotation plateau
# mi2 utilise pour ne pas bloquer le diviseur
# Workof (nede Decalage) de 54 a 59  (0 pour 54 1 pour 55 etc...) et 59.1P1 P2 apres
# ecriture des parametres dans NCI et du fichier OPS (pour lire les infos de surep)
# creation des bloc pour afficher les surep
# creation de l'affichage des types de correction
# gestion du pmx en 4 axes
# lecture de la def armoire pour :
#                   l'extension de l'iso
#                   les arcs
#                   les commentaires
#                   la preparation de l'outil suivant
# Lecture de la def machine pour :
#                   Le nom de la machine
#                   Le nombre d'axes rotatif (1 seul supporte)
#                   Le sens de rotation de l'axe rotatif
#                   Le nom de l'axe rotatif (ABC)
#                   L'avance Maxi et Mini de la machine
# Ajour des cycle 5 axes percage par ed le 25-01-2015
# modification pour supporter machine a 45e par eric le 10/7/2015
# integration des butee sur B
#------------------- cette partie calcul est proteger , Appeler FICAM 02.37.26.28.10 si besoin------

#startbin$
#------for CNC Software------------- Post processor at FICAM France Call +33.2.37.26.28.10 or m1$ Dauvilliers Eric at e.dauvilliers@ficam.com ------

###ATTENTION SI MODIF PP SIMU EN PP ISO REMETTRE +1%3l POUR FS2 ET FS3###
fs  2  +1.3l        # pp simu
#fs  2  +1%3l        # pp iso
fs  3  +1.3ln       # pp simu
#fs  3  +1%3ln       # pp iso
type_pp = 1# type de post processeur 1=iso 2=machsim
#coolant$ = 1

#---------------------------------------------------------------------------------------------------------
#            REGLAGES DU PST
#
sext : "CL"         # extention pour le programme de simulation
inc_degage  : 1     # degagement machine  1 en INCREMENTAL (G91) ou 0 en ABSOLUE (G90)




smodedeg    : "M91" # Mode de degagement des axes M91 ou M92 ou G28 ou G53
sfmax5x     : "FMAX"# vitesse rapide pour deplacement en 5 axes positionner premiere TNC530 = F9999 ou FMAX pour nouvelle generation

fmt  "B" 3 axeAB5xsimu  # nom de l'axe A ou B
fmt  "B" 3 axeAB5x       # nom de l'axe A ou B

deg_debut   : 0     # Degager aux debut de prog             0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY
deg_outil   : 1     # Degager aux changement outil          0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY
deg_4axe    : 2     # Degager aux changement position 4 ou 5 eme axe  0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY
deg_fin     : 5     # Degager en fin de programme           0=nom  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY

numcoment   : 1     # Numeroter les lignes de commentaire 0 = nom 1 = oui
numsprog    : 1     # Numeroter les lignes de sous programme 0 = nom 1 = oui
info_corr   : 1     # afficher le type de correction
info_surep  : 1     # afficher les surepaisseurs xy et z
info_outil  : 1     # afficher les info sur l'outil
info_groupe : 1     # afficher les noms des groupe d'usinage
outil_apres : 0     # preparation outil suivant juste apres appel outil : 0  - preparation outil suivant avec premier placement : 1
use_progno  : 0     # Ecrire le NC sous forme O0123.nc  = 1 ou TOTO.NC = 0
entete      : 0     # Poser les question pour l'entete
tooltable$  : 1     # creation liste outil en entete
use_bloque  : 0     # 1 pour ecrire M10 M11 (blocage diviseur) -  0 pour ne pas ecrire M10 M11
nom_tool    : 0     # 0 pour TOOL CALL 1  -  1 pour TOOL CALL "fraise_2_tailles_dia_10"
avance_arc  : 0     # ajuster les avances sur les arcs en correction usure ou ordinateur 0 = nom 1 = oui (utilise avance mxi et mini de la def machine)
fmini       : 1     # avance mini machine en travail
fmaxi       : 16000 # avance maxi machine en travail
nbroutil    : 0    # nombre d'outil de la machine pour ajout au D (0 pour T1 D1 - 30 pour T1 D31)
test_bris   : 0     # test de bris outil 0=non, 1= ecriture en cycle "TCH PROBE 481", 2=appel sous programme qui est dans "sbris_outil" a configurer plus bas, 3= "TCH PROB 586"
sbris_outil : ";CALL PGM TNC:\USINAGE\L_BREAK_TEST.H"    # macro appel de sous programme pour test bris_outil
use_DR      : 0     # Utiliser la comande DR-(rayon outil) pour correction usure usure inverse
cycle32on   : 1     # Ecriture du compresseur CYCL DEF 32
stop_opt    : 1     # Ecrire un stop Optionnel avant changement outil
dernieroutil : 0   # numero du dernier outil imposer en pres chargement, si 0 alors rechargement du nom du 1er outil
sdernieroutil : "" # nom du dernier outil imposer en pres chargement, si 0 alors rechargement du nom du 1er outil
gestion_nom_outil : 0 # Gestion du nom de l'outil heid, les blancs en heidhenain ne sont pas lu dans la preparation outil, donc on enleve ce qu'il y a apres le blanc ex: strname= hitachis_D8 ravageuse => TOOL CALL "HITACHIS_D8"
question_deg_X : 0  # pose la question de la valeur de degagement sur X pour le M91/M92 0=non, 1=oui
question_deg_Y : 0  # pose la question de la valeur de degagement sur X pour le M91/M92 0=non, 1=oui
question_deg_Z : 0  # pose la question de la valeur de degagement sur X pour le M91/M92 0=non, 1=oui
question_axeC : 0   # pose la question si il y a un axe C de monte sur la table
force_ss : 1        # 1= on force l'affichage de la vitesse de rotation a chaque operation


#--------------- variable pour le 5 axes ------------------------------------------
mode_5axe   : 1     # type machine: 0 3 et 4 axes, 1 = 5 axes positionne et continue
type_plane  : 1     # type de mode spacial, 1 = plan, 2 = point, 3 = Cycle 19 ( TNC426 )




ecrit_plane_dessus : 1 # ecrire un cycle plan meme en dessus , 0 = pas ecriture si dessus, 1 ecriture
frap5x : 5000       # Vitesse RAPIDE EN DEPLACEMENT 5 AXES
macro : 0           # ecrit une macro en fin de prog en LBL 99 ou on donne les mouvements a faire entre chaque changement outil et plan ( voir pmacro )
seqplus : "SEQ+"    # sens, ou de quel cote positionner 5 axes pour une 530
seqmoins : "SEQ-"   # sens, ou de quel cote positionner 5 axes pour une 530


GESTc247 : 1        # Gestion du cycle 247 en 5 axes , 0 = sans, 1 = juste au debut, 2 = gestion total ( workoff)
ecrivec : 0         # ecriture du 5X en format vectoriel = 0, format A, B, C = 1

bruit = 0.002       # sinus du cone a partir moment on on considere d'etre en vertical, evite que l'axe C danse
changpolar_AB : 1    # polarite de l'angle A (ou B) par defaut en 5 axes continue ( non fonctionnel en vectoriel )  ! Ne pas changer
changpolar_C  : 1    # polarite de l'angle C  par defaut en 5 axes continue ( non fonctionnel en vectoriel )
mode_turn : 1       # mode turn au changement d'outil
sens_de_B : -1      # polarite de A ou B mais que quand type_axe = 5
sens_de_C : -1      # polarite de C mais que quand type_axe = 5



smachineA : "DM0"
smachineB : "DM1"
smachineC : "DM2"
smachineD : "DM3"
smachineE : "DM4"
sdefmachine : ""
snum_prog_fichier : ""
numentete = 4
fmt "num entete=" 4 numentete
fmt "num machine=" 4 machine
machine : 4

pchoix_machine     # Reglage du choix machine
                    sdefmachine = snamenc$
                    snum_prog_fichier = brksps(numentete,sdefmachine) # on coupe a partir du blanc


                    if sdefmachine = smachineA, machine = 0
                    if sdefmachine = smachineB, machine = 1
                    if sdefmachine = smachineC, machine = 2
                    if sdefmachine = smachineD, machine = 3
                    if sdefmachine = smachineE, machine = 4



                    #while ( machine < 0 | machine > 3),  Q15

                        #n$, "machine ", *machine, e$

                    if machine = 0,   # POUR DMU 50 eVolution
                        [
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN POUR ", smachineA, sfcom, e$ #         nom  MACHINE du traitement post-pro
                        Vect_porteur_x =   0 # vecteur porteur sur X si mode type_axe = 5                              POUR DMU 50 eVolution
                        Vect_porteur_y =  0.70710678  # vecteur porteur sur Y si mode type_axe = 5                   POUR DMU 50 eVolution
                        Vect_porteur_z =  -0.70710678 # vecteur porteur sur Z si mode type_axe = 5                   POUR DMU 50 eVolution
                        sensbase = 1  # sens de base par defaut 1 = positif SEQ+ ou -1 pour SEQ- en cycle plane      POUR DMU 50 eVolution
                        maxi_B = 180.5        # angle maxi le l'angle A ou B    POUR DMU 50 eVo linear                   POUR DMU 50 eVolution
                        mini_B = -0.5    # angle mini de l'angle A ou B    POUR DMU 50 eVo linear                       POUR DMU 50 eVolution
                        type_axe = 4        # type de cynematique de la machine a toujours renseigner quand on sort axe reel en 5 axes continue ( ecrivec = 1 )
                                            # 1 = axe sur la table A et C ( DMU 65, hermle U30 )
                                            # 2 = axe sur la table B et C ( DMU 50 nouvelle generation, mikron HSM )
                                            # 3 = axe C sur la table porte par Z, Axe B porte la Broche sur Y ( DMF 360 ) prend en compte une approche diferrente en positionner 5 axes
                                            # 4 = axe a 45 degre en vue de cote porte par Y ( DMU50 CLASSIC, huron, )
                                            # 5 = axe suivant axe machine porte dans l'angle machine ( DMU 50,40,60, etc evo ) renseignez le vecteur porteur
                        degagez = -1        # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey = -420      # Degagement en Y pour appel outil
                        degagex = -1          # Degagement en X pour appel outil et changement de position 4eme axe
                        degagez_fin = -1    # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey_fin = -1      # Degagement en Y pour appel outil
                        degagex_fin = -1      # Degagement en X pour appel outil et changement de position 4eme axe
                        sfmax = sf999maxi        # STRING de la vitesse rapide
                        ]
                    if machine = 1,   # POUR DMU 50 eVo linear
                        [
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN POUR ", smachineB, sfcom, e$ #         nom  MACHINE du traitement post-pro
                        Vect_porteur_x =   0.584821 # vecteur porteur sur X si mode type_axe = 5                      POUR DMU 50 eVo linear
                        Vect_porteur_y =  0.57358   # vecteur porteur sur Y si mode type_axe = 5                       POUR DMU 50 eVo linear
                        Vect_porteur_z =  -0.573576 # vecteur porteur sur Z si mode type_axe = 5                       POUR DMU 50 eVo linear
                        sensbase = -1  # sens de base par defaut 1 = positif SEQ+ ou -1 pour SEQ- en cycle plane      POUR DMU 50 eVo linear
                        maxi_B = 0.5        # angle maxi le l'angle A ou B    POUR DMU 50 eVo linear                   POUR DMU 50 eVo linear
                        mini_B = -162.5    # angle mini de l'angle A ou B    POUR DMU 50 eVo linear                       POUR DMU 50 eVo linear
                        type_axe = 5        # type de cynematique de la machine a toujours renseigner quand on sort axe reel en 5 axes continue ( ecrivec = 1 )
                                            # 1 = axe sur la table A et C ( DMU 65, hermle U30 )
                                            # 2 = axe sur la table B et C ( DMU 50 nouvelle generation, mikron HSM )
                                            # 3 = axe C sur la table porte par Z, Axe B porte la Broche sur Y ( DMF 360 ) prend en compte une approche diferrente en positionner 5 axes
                                            # 4 = axe a 45 degre en vue de cote porte par Y ( DMU50 CLASSIC, huron, )
                                            # 5 = axe suivant axe machine porte dans l'angle machine ( DMU 50,40,60, etc evo ) renseignez le vecteur porteur
                        degagez = -1        # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey = -450      # Degagement en Y pour appel outil
                        degagex = -1          # Degagement en X pour appel outil et changement de position 4eme axe
                        degagez_fin = -1    # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey_fin = -1      # Degagement en Y pour appel outil
                        degagex_fin = -1      # Degagement en X pour appel outil et changement de position 4eme axe
                        sfmax = sfmaxi        # STRING de la vitesse rapide
                        ]
                    if machine = 2,   # POUR DMU 50 eVo linear 2
                        [
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN POUR ", smachineC, sfcom, e$ #         nom  MACHINE du traitement post-pro
                        Vect_porteur_x =   0.584821 # vecteur porteur sur X si mode type_axe = 5                      POUR DMU 50 eVo linear 2
                        Vect_porteur_y =  0.57358   # vecteur porteur sur Y si mode type_axe = 5                       POUR DMU 50 eVo linear 2
                        Vect_porteur_z =  -0.573576 # vecteur porteur sur Z si mode type_axe = 5                       POUR DMU 50 eVo linear 2
                        sensbase = -1  # sens de base par defaut 1 = positif SEQ+ ou -1 pour SEQ- en cycle plane      POUR DMU 50 eVo linear 2
                        maxi_B = 0.5        # angle maxi le l'angle A ou B    POUR DMU 50 eVo linear                   POUR DMU 50 eVo linear 2
                        mini_B = -162.5    # angle mini de l'angle A ou B    POUR DMU 50 eVo linear                       POUR DMU 50 eVo linear 2
                        type_axe = 5        # type de cynematique de la machine a toujours renseigner quand on sort axe reel en 5 axes continue ( ecrivec = 1 )
                                            # 1 = axe sur la table A et C ( DMU 65, hermle U30 )
                                            # 2 = axe sur la table B et C ( DMU 50 nouvelle generation, mikron HSM )
                                            # 3 = axe C sur la table porte par Z, Axe B porte la Broche sur Y ( DMF 360 ) prend en compte une approche diferrente en positionner 5 axes
                                            # 4 = axe a 45 degre en vue de cote porte par Y ( DMU50 CLASSIC, huron, )
                                            # 5 = axe suivant axe machine porte dans l'angle machine ( DMU 50,40,60, etc evo ) renseignez le vecteur porteur
                        degagez = -1        # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey = -450      # Degagement en Y pour appel outil
                        degagex = -1          # Degagement en X pour appel outil et changement de position 4eme axe
                        degagez_fin = -1    # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey_fin = -1      # Degagement en Y pour appel outil
                        degagex_fin = -1      # Degagement en X pour appel outil et changement de position 4eme axe
                        sfmax = sfmaxi        # STRING de la vitesse rapide
                        ]
                    if machine = 3,   # POUR DMU 60 eVo linear
                        [
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN POUR ", smachineD, sfcom, e$ #         nom  MACHINE du traitement post-pro
                        Vect_porteur_x =   -0.584825 # -0.597488      # vecteur porteur sur X si mode type_axe = 5    POUR DMU 60 eVo linear
                        Vect_porteur_y =  0.573576 #0.5860035      # vecteur porteur sur Y si mode type_axe = 5           POUR DMU 60 eVo linear
                        Vect_porteur_z =  -0.573576 #-0.5473644      # vecteur porteur sur Z si mode type_axe = 5       POUR DMU 60 eVo linear
                        sensbase = 1  # sens de base par defaut 1 = positif SEQ+ ou -1 pour SEQ- en cycle plane      POUR DMU 60 eVo linear
                        maxi_B = 180.5        # angle maxi le l'angle A ou B                                            POUR DMU 60 eVo linear
                        mini_B = -6.5        # angle mini de l'angle A ou B                                            POUR DMU 60 eVo linear
                        type_axe = 5        # type de cynematique de la machine a toujours renseigner quand on sort axe reel en 5 axes continue ( ecrivec = 1 )
                                            # 1 = axe sur la table A et C ( DMU 65, hermle U30 )
                                            # 2 = axe sur la table B et C ( DMU 50 nouvelle generation, mikron HSM )
                                            # 3 = axe C sur la table porte par Z, Axe B porte la Broche sur Y ( DMF 360 ) prend en compte une approche diferrente en positionner 5 axes
                                            # 4 = axe a 45 degre en vue de cote porte par Y ( DMU50 CLASSIC, huron, )
                                            # 5 = axe suivant axe machine porte dans l'angle machine ( DMU 50,40,60, etc evo ) renseignez le vecteur porteur
                        degagez = -1        # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey = -450      # Degagement en Y pour appel outil
                        degagex = -1          # Degagement en X pour appel outil et changement de position 4eme axe
                        degagez_fin = -1    # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey_fin = -1      # Degagement en Y pour appel outil
                        degagex_fin = -1      # Degagement en X pour appel outil et changement de position 4eme axe
                        sfmax = sfmaxi        # STRING de la vitesse rapide
                        ]

                    if machine = 4,   # POUR YCM
                        [
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN POUR ", smachineA, sfcom, e$ #         nom  MACHINE du traitement post-pro
                        sensbase = 1  # sens de base par defaut 1 = positif SEQ+ ou -1 pour SEQ- en cycle plane      POUR DMU 50 eVolution
                        maxi_B = 105.5        # angle maxi le l'angle A ou B    POUR DMU 50 eVo linear                   POUR DMU 50 eVolution
                        mini_B = -5.5    # angle mini de l'angle A ou B    POUR DMU 50 eVo linear                       POUR DMU 50 eVolution
                        type_axe = 2        # type de cynematique de la machine a toujours renseigner quand on sort axe reel en 5 axes continue ( ecrivec = 1 )
                                            # 1 = axe sur la table A et C ( DMU 65, hermle U30 )
                                            # 2 = axe sur la table B et C ( DMU 50 nouvelle generation, mikron HSM )
                                            # 3 = axe C sur la table porte par Z, Axe B porte la Broche sur Y ( DMF 360 ) prend en compte une approche diferrente en positionner 5 axes
                                            # 4 = axe a 45 degre en vue de cote porte par Y ( DMU50 CLASSIC, huron, )
                                            # 5 = axe suivant axe machine porte dans l'angle machine ( DMU 50,40,60, etc evo ) renseignez le vecteur porteur
                        degagez = -1        # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey = -450      # Degagement en Y pour appel outil
                        degagex = -600    # Degagement en X pour appel outil et changement de position 4eme axe
                        degagez_fin = -1    # Degagement en Z pour appel outil et changement de position 4eme axe
                        degagey_fin = -450      # Degagement en Y pour appel outil
                        degagex_fin = -800      # Degagement en X pour appel outil et changement de position 4eme axe
                        sfmax = sfmaxi         # STRING de la vitesse rapide
                        ]









#------------------------------------------------------------------------------------------------------------------
#   UTILISER LES CYCLES MACHINE ou DECOMPOSITION en G1 G0
usecandrill$ : yes$   # utiliser cycle percage lamage
usecanpeck$  : yes$   # utiliser cycle debourrage
usecanchip$  : yes$   # utiliser cycle brise copeaux
usecantap$   : yes$   # utiliser cycle taraudage
usecanbore1$ : yes$   # utiliser cycle alesage a l'alesoir
usecanbore2$ : yes$   # utiliser cycle alesage a la barre
usecanmisc1$ : no$    # utiliser cycle divers 1
usecanmisc2$ : no$    # utiliser cycle divers 2
# ---------------------------------------------------------------------------------------------------------
#            VALEURS MACHSIM
#
fmt "X" 2 xaff
fmt "Y" 2 yaff
fmt "Z" 2 zaff
fmt "B" 2 baff
fmt "C" 2 caff
fmt "R" 2 raff
fmt        4 n2
fmt        4 n$        # numerotetion des blocs a chaque ligne
n2 = n$

fmt  "C" 3 axeC5xsimu
fmt 8 m1simu
fmt 8 m2simu
fmt 8 m3simu
fmt 8 tox4simu
fmt 8 m4simu
fmt 8 m5simu
fmt 8 m6simu
fmt 8 toy4simu
fmt 8 m7simu
fmt 8 m8simu
fmt 8 m9simu
fmt 8 toz4simu
fmt 20 corgx$
fmt 20 corgy$
fmt 20 corgz$
fmt "Z" 2 drl_depth_z$
fmt "plinc" 2 plinc
fmt  "F" 4 avancepercsimu
fmt 4 contperc
contperc : 0
xaff=xabs
yaff=yabs
zaff=zabs
baff=axeB
caff=axeC
sxmag : "X-499."
sxmagaff : " X-499.000"
symag : "Y-1.000"
symagaff : " Y-1.000"
szmag : "Z-1.000"
szmagaff :  " Z-1.000"
szmach : "Z+0.000"
szmachaff : " Z0.000"
sbzero : "B+0.000"
sbzeroaff : " B0."
sczero : "C+0.000"
sczeroaff : " C0."
sfsimurapid : "F10000"
stype_arc : ""
sdegageZsimu : "Z-1.001"
sr : "MW_RELMOVE RAPID" # mouvement rapide par rapport a la piece
sl : "MW_RELMOVE FEED" # mouvement ligne travail par rapport a la piece
sc : "MW_RELARCMOVE FEED"  # mouvement par rapport a la piece
sm : "MW_MACHMOVE RAPID"    # MOUVEMENT par rapport au repere de la machine
sf : "MW_OP_END"      # fin d'une operation

space_aff : "" # "<EOC>"     # <EOC> pour un affichage avec tabulation, "" sans

paf_xyzbc    # ici on gere l'affichage en bout de ligne X Y Z B C
                n$,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*baff,space_aff,*caff

paf_xy    # ici on gere l'affichage en bout de ligne X Y
                n$,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff

paf_xyz    # ici on gere l'affichage en bout de ligne X Y Z
                n$,35,no_spc$,*n2,sgcode,sinc_abs,xaff,yaff,zaff

paf_xybc    # ici on gere l'affichage en bout de ligne X Y B C
                n$,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*baff,space_aff,*caff

paf_zbc    # ici on gere l'affichage en bout de ligne Z B C
                n$,35,no_spc$,*n2,*sgcode,space_aff,*zaff,space_aff,*baff,space_aff,*caff

paf_xyzr    # ici on gere l'affichage en bout de ligne X Y Z R
                n$,35,no_spc$,*n2,*sgcode,space_aff,*xaff,space_aff,*yaff,space_aff,*zaff,space_aff,*raff

paf_bc    # ici on gere l'affichage en bout de ligne B C
                n$,35, no_spc$,*n2,*sgcode,space_aff,*baff,space_aff,*caff

paf
                n$,35,no_spc$,*n2

pafcom
                35,no_spc$



fmt "CT" 3 cont_axeC
fmt "DAC" 3 dif_axeC
fmt "ABSD" 3 absdif
fmt "Sens par defaut" 4 sensbase
fmt "C" 1 axeCbase
fmt "Mini B=" 2 mini_B
fmt "Maxi B=" 2 maxi_B
fmt "Changement de polarite A ou B=" 4 changpolar_AB
fmt "Changement de polarite C=" 4 changpolar_C

fmt 1 ecrivec

ptextefin  # macro ecrite en fin de programme suivant client
            #n$, "CALL PGM TNC:\ANNUL", e$
            #n$, "CALL PGM TNC:\NET", e$
            #n$, "CALL PGM TNC:\FIN", e$
            #n$, "CALL PGM TNC:\ROBOT", e$

#--------------------------------------------------------------------------------------------------------
#   DEBUG POST PRO
bug1$     : 0       # 0 = pas voir le NC  1 = Visu du NC en lecture - 2 = visu du NC en edit
bug2$     : 70      # numero de colonne pour l'affichage du bloc en cour de traitement
#CNC<<ECHEC>>bug3$     : 0       # whatline 01234 etat de l'usinage0 debut prog 1 prapid 2 pzrapid 3 mouvement frplung 4 fin
#CNC<<MSG-ERREUR(412)>> La variable, bloc PP ou mot clef n'est plus support√©
bug4$     : 1       # numero de ligne du nci traite
whatno$   : yes$    # Ignore whatline branches to plin1 etc.?

#--------------------------------------------------------------------------------------------------------
#   TOLERANCES POST PRO
linktolvar$    : 1  #Associer les variables de tolerance X metrique au variable english
#linklvar$  :1  # ULISLIDE LES USECANDRIL POUR LES LCANDRILL
linkplnvar$    : 0  #Associer les variables specifiques plan Xy POUR TOUS LES PLAN YZ XZ
linklvar$      : 1  #Associer les variables specifiques X Tournage AU FRAISAGE ULISISE LES USECANDRIL POUR LES LCANDRILL
cant_tlchng$   : 1  #Ignorer entree de texte programme au changement avec tlchng_aft?
newglobal$     : 1  #Activer la verification d'erreur pour les variables globales?

#------------------------------------------------------------------------------------------------------------------
#   FORMATS DES VARIABLES
#
fs  1  1.9lt        # Format avec toute la precision pour les variable internes de mp
# voir en debut de pp pour le fs 2 et fs 3
fs  4  1 0      # 1 chiffre mini avant virgule  pas de virgule pas de chiffre apres
fs  5  1 0n     # idem mais non modale
fs  6  4 0ln        # 4 chiffres avant pas de virgule pas de chiffre apres non modal force 0 de tete
fs  7  1 3t     # 1 chiffre mini avant virgule  pas de virgule 3 apres force 0 de queue non modal.
fs  8  1.3ln        # 1 chiffre avant la vigule met . 3 chiffres apres virgule non modal force 0 de tete
fs  9  1 0n     # pour liste outil
fs  10 1.3n     # pour liste outil
fs  11 +1%3li       # force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental
fs  12 +1%3lni
fs  13 3 0ln
fs  14 1,4lt
fs  15 1^3n     # pour liste outil
fs  16 1^3l
fs  17 1.5ln
fs  18 +1^4ln
fs  19  1.3
fs  20  1.3ltn
#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES FLAG
#
fmt     4 numcoment # flag pour Numeroter les lignes de commentaire
fmt     4 numsprog  # flag pour Numeroter les lignes de sous programme
fmt     1 texte     # flag pour textes
fmt     1 nbr_car   # nombre de carracteres maxi dans les connemtaires
fmt     1 old_comm_cnt  # nombre d'enregistrement dans buffeur commentaires
fmt     1 info_corr # flag pour correction outil
fmt     1 info_outil    # flag pour info outil
fmt     1 info_surep    # flag pour surep
fmt     1 info_groupe   # flag pour le nom des groupes
fmt     1 old_spaces    # memo de spaces
fmt     1 old_omitseq   # memo de omiseq
fmt     1 old_linarc    # memo de la decomposition des arcs
fmt     4 entete    # Variable utilisee pour generer l'entete
fmt     4 numerote  # Variable numerote utilisee pour numeroter ou non les lignes
fmt     1 outil_apres   # flag pour la position d'appel de l'outil suivant
fmt     1 avance_arc    # flag pour gerer l'avance sur arc
fmt     4 force_ss
#________________________________________________________________________
#________________Valeur des avances par FQ____________________________
fmt   4 ftravail    # pour stoker l'avance travail de l'op
fmt   4 fplongee    # pour stoker l'avance plongee de l'op
fmt   4 fretract    # pour stoker l'avance retraction de l'op
fmt   4 fg1ugv         # pour stocker l'avance au dessus de la piece en UGV 3D
fmt  "F" 4 valparam  # pour affiche FQ1 en travail, FQ2 en plongee, fQ3 en retraction, fQ4 deplacement au dessus de la pcs en UGV
fmt   "F" 4 frap5x
fmt  "F" 4 old_prpos
#_____________________________________________________________________

#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES MP
fmt     5 gcode$        # Gcode pst
fmt     5 memo_gcode
fmt     1 x$        # XYZ pst
fmt     1 y$
fmt     1 z$
fmt     1 xr$       # XYZ rapide pst
fmt     1 yr$
fmt     1 zr$
fmt     1 i$        # IJK centre des arcs pst
fmt     1 j$
fmt     1 k$
fmt     1 arcrad$   # Valeur du rayon pst
fmt     1 linarc$   # couper les arcs
fmt     1 t$        # numero d'outil pst
fmt     1 next_tool$    # numero suivant pst
fmt     1 first_tool$   # numero du premier outil pst
fmt     1 tloffno$  # Correcteur de Diamentre pst
fmt     1 tlngno$   # Correcteur de Longueur pst
fmt     1 tldia$    # diametre outil pst
fmt     1 cc_computer$  # correction ordinateur
fmt     1 cc_pos$   # correction Armoire
fmt     1 fr$       # avance pst
fmt  "F" 16 fr_pos$  # AVANCE TRAVAIL au point pst
fmt     1 ss$       # vitesse de broche pst
fmt     5 progno$   # Numero de programe pst
fmt  "G" 4 cc$      # valeur de la correction dans NCI
fmt     1 coolant$  # Lubrification 0 1 2 3 arret axe buse les deux
fmt     1 mi1$      # mi1 utilise pour degagement en Z avant rotation plateau
fmt     1 mi2$      # mi2 utilise pour ne pa rebloquer le plateau
fmt     1 op_id$    # Numero de l'operation du gestionaire PST
#------------------- PERCAGES ------------------------------------------
fmt    1 depth$     # profondeur percage pst
fmt    1 refht$     # Garde pour percage pst
fmt    1 initht$    # Plan de secu percage pst
fmt    1 frplunge$  # Avance percage pst
fmt    1 dwell$     # Tempo pour percage pst
fmt  "D" 3 peckclr$     # garde d'approche rapide dans les debourrage pst
fmt  "Q" 3 peck1$       # Pas Z du premier debourrage pst
fmt     1 peck2$        # Pas Z des debourrages suivants
fmt  "Q" 3 shftdrl$     # valeur de retrait du grain de la barre d'allsage
fmt     1 retr$         # valeur de remonte relative en rapide dans les debourages en G1 G0
#_____________________alesage a la fraise_______________________________________
fmt     3 dianomi       # diametre nominale pour cycle def 208(alesage a la fraise)
fmt     3 diapreperc    # diametre de pre-percage pour cycle def 208
fmt     1 modefraisage  # mode fraisage 1 pour oui 0 pou non pour cycle def 208
#-------------------------filetage a la fraise--cycl def 262-------------
fmt     3 filparpas
fmt     3 fprepo
fmt     3 pasdvis
#------------------- SOUS PROG ------------------------------------------
fmt     1 sub_prg_no$       # Numero de sous-programe interne en Z
fmt     1 main_prg_no$      # Numero de sous prog interne en transformation
fmt  "X" 1 sub_trnsx$       # decalage en X pour G52 en usinage transformer translation
fmt  "Y" 1 sub_trnsy$       # decalage en Y pour G52 en usinage transformer translation
fmt  "Z" 1 sub_trnsz$       # decalage en Z pour G52 en usinage transformer translation
sub_trnsx$   :  -99999
sub_trnsy$   :  -99999
sub_trnsz$   :  -99999
#------------------- 4 AXES ------------------------------------------
fmt    1 rotdia$            # diam de sbstitution
fmt    1 rotaxis$       # type de substitution
fmt  "v" 1 v$
fmt  "w" 1 w$
m7$        : 999
m8$        : 999

fmt "" 1 question_axeC
fmt "AxeC=" 1 presence_axe_C
presence_axe_C : 1  # ATTENTION NE PAS CHANGER

#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES NC
#
#------------------- POSITIONS ------------------------------------------
fmt  "X" 2 xabs         # XYZ en Absolue pour NC
fmt  "Y" 2 yabs
fmt  "Z" 2 zabs

fmt  "X" 3 degagex         # XYZ en Absolue pour le degagement en M91
fmt  "Y" 3 degagey
fmt  "Z" 3 degagez


fmt  "X" 3 degagex_fin         # XYZ en Absolue pour le degagement en M91
fmt  "Y" 3 degagey_fin
fmt  "Z" 3 degagez_fin



fmt  "X" 2 xabs3d         # XYZ en plan spacial
fmt  "Y" 2 yabs3d
fmt  "Z" 2 zabs3d

fmt  "IX" 11 xinc           # XYZ en incremental pour NC
fmt  "IY" 11 yinc
fmt  "IZ" 11 zinc

fmt  "A" 2 axeA         # POSITION pour rotation plateau en ABS
fmt  "IA" 11 axeAi      # POSITION pour rotation plateau en INCREMENTAL
fmt "dessus" 4 dessus

xinc = xabs
yinc = yabs
zinc = zabs
axeAi = axeA            # A incremental

fmt "X" 2 old_x        # ancien XYZ du NC
fmt "Y" 2 old_y
fmt "Z" 2 old_z

fmt  "X" 2 iabs         # IJK centre des arcs pour NC en G90
fmt  "Y" 2 jabs
fmt  "Z" 2 kabs

fmt  "IX" 2 iinc        # ijk centre des arcs pour NC en G91
fmt  "IY" 2 jinc
fmt  "IZ" 2 kinc
fmt  "R" 3 rayon        # valeur de rayon de l'arc pour NC
fmt  "IPA" 3 sweep$
fmt      1 cor_arc      # compensation sur les arc autorisee
fmt "X" 3 xmin
fmt "Y" 3 ymin
fmt "Z" 3 zmin
fmt "X" 3 xmax
fmt "Y" 3 ymax
fmt "Z" 3 zmax

fmt "X" 2 old_u
fmt "Y" 2 old_v
fmt "Z" 2 old_w


#------------------- OUTILS ------------------------------------------
fmt      1 deg_debut
fmt      1 deg_outil
fmt      1 deg_4axe
fmt      1 deg_fin
#fmt      1 ftravail
fmt "" 4 stop_opt
fmt "" 4 dernieroutil
fmt "" 4 gestion_nom_outil

fmt  "TOOL CALL "  5 outil " Z"     # numero d'outil appele pour NC
fmt  "TOOL CALL "  5 oldoutil " Z"
fmt  "TOOL DEF "  5 outil_suivant   # numero de l'outil suivant pour NC
fmt     5 nbroutil          # nombre d'outil du changeur de la def machine

fmt  "D" 4 correcteur_D     # Correcteur de Diamentre pour NC
fmt  "H" 4 correcteur_H     # Correcteur de Longueur pour NC
fmt  "H" 4 old_correcteur_H

correcteur_D = tloffno$ #+ nbroutil
correcteur_H = tlngno$

fmt  "DIAM " 2 diam_outil   # diametre outil pour NC
fmt "DR" 2 DR           # decalage de rayon de fraise pour correction usure
fmt      2 old_DR
fmt  "F" 4 avance       # avance pour NC
fmt  "F" 4 avanceperc   # avance pour NC
fmt  "S" 4 ssa          # Vitesse de broche affiche

ssa = abs(ss$)          # vitesse de broche en valeur absolue

fmt  "S" 4 old_ss       # memo de la vitesse de broche precedente
fmt     4 lubrif        # gestion de la lubrification pour NC
fmt     4 oldlubrif
fmt     3 type_comp     # type de correction
fmt "SUREP R " 8 surep          # Surep au rayon
fmt "SUREP Z " 8 surepl         # Surep en Z
fmt "SUREP 3D " 8 surep3d       # Surep en usinage 3D
surep3d = surep
fmt "R" 1 result        # resultat de calcul
fmt "" 4 type_axe

fmt     5 prognosav     # Memo du Numero de programe
fmt     1 debut         # flag pour debut de programme
fmt "" 4 cycle32on

fmt    4 oldstation

#------------------- NUMEROTATION ------------------------------------------
fmt  "N" 4 num          # numero de bloc sur ligne appel outil si pas de numerotation des lignes
fmt    1 old_op_id      # Memo de l'operation
fmt    1 last_op_id     # Derniere operation
num : 0
num = num + 1
old_op_id : -99999
fmt  "OPERATION "  5 numop  # NUMERO D'OPERATION
#------------------- ORIGINES D'USINAGE ------------------------------------------
fmt  "G" 4 origine      # origine d'usinage G54 a G59 pour NC
fmt     4 orheid
fmt  "G54.1P"  4 originebis # origine d'usinage G60 a G9999 pour NC
fmt  "G" 4 old_origine      # Stocage de la valeur precedente de origine d'usinage
fmt     4 old_orheid

fmt "ORI" 1 oriusi  # flag pour savoir si on utilise une origine d'usinage
fmt "X" 2 tox$
fmt "Y" 2 toy$
fmt "Z" 2 toz$
fmt "X" 2 tox4$
fmt "Y" 2 toy4$
fmt "Z" 2 toz4$
fmt "X" 2 old_tox
fmt "Y" 2 old_toy
fmt "Z" 2 old_toz
old_tox : 0
old_toy : 0
old_toz : 0
#---------------------- SOUS PROG ------------------------------------
fmt "inc" 1 incremental     # mode incremental ou Absolue
fmt     1 memo_incremental  # memeo du mode incremental ou Absolue
fmt     1 inc_degage        # degagement machine en INCREMENTAL ou en ABSOLUE

fmt  "O" 6 debsousprog      # Numero du premier sous programe
fmt  "#100="  4 nprincipal  # memo du numero de ligne du prog principal
fmt  "X" 2 decX         # decalage d'origine en X pour G52
fmt  "Y" 2 decY         # decalage d'origine en Y pour G52
fmt  "Z" 2 decZ         # decalage d'origine en Z pour G52
fmt  "CALL LBL "  5 subprognum      # numero du sous-programe pour l'appel
fmt  "LBL " 5 numsubprog        # Numero entete de sous-programe
fmt     5 nomsubprog        # Numero n'entete de sous-programe

fmt  "N" 4 ndebutsz         # memo du 1er numero de ligne du sous prog en z
fmt  "N" 4 ndebutst         # memo du 1er numero de ligne du sous prog en transformation



fmt  "DEC" 2 decalage       # flag pour savoir si on a ecrit un G52
fmt      1 sous_prog_type   # type de merge des sous prog (0 apres prog principal 1 avant)
incremental : 1         # init en Absolue
decalage : 0

fmt  "transform" 2 transform


#------------------- PERCAGES ------------------------------------------
fmt     1 use_cyc200    # flag pour utiliser les cycle 200
fmt     2 profabs       # profondeur de percage en ABS
fmt     2 profi         # profondeur de percage en INC
fmt     2 gardeabs      # Garde pour percage en ABS
fmt     2 gardei        # Garde pour percage en INC
fmt  "F" 8 pas          # valeur calculee du pas pour taraudage rigide
fmt  "F" 5 pasavance
fmt     2 typcycle      # variable mise a 1 lors des percage pour afficher l'intitule du cycle
fmt    14 tempo
tempo = dwell$

fmt "Pe5x=" 4 percage5x


fmt     2 old_profabs   # memo de la prof
fmt     2 old_gardeabs  # memo de la garde
fmt     3 passe     # increment de percage
fmt     3 passe2
fmt     2 psecu     # plan de secu
fmt     2 dbrut     # dessus du brut
fmt     2 old_psecu
fmt     2 old_dbrut
fmt     3 degage
fmt     3 orientation


fmt  "    Q200=" 3 bq200    # Cycle 200
fmt  "    Q201=" 3 bq201    # Cycle 200
fmt  "    Q202=" 3 bq202    # Cycle 200
fmt  "    Q203=" 3 bq203    # Cycle 200
fmt  "    Q204=" 3 bq204    # Cycle 200
fmt  "    Q205=" 3 bq205    # Cycle 200
fmt  "    Q206=" 4 bq206    # Cycle 200
fmt  "    Q207=" 3 bq207    # Cycle 200
fmt  "    Q208=" 4 bq208    # Cycle 200
fmt  "    Q209=" 3 bq209    # Cycle 200
fmt  "    Q210=" 8 bq210    # Cycle 200 tempo en haut
fmt  "    Q211=" 8 bq211    # Cycle 200 tempo en bas
fmt  "    Q212=" 3 bq212    # Cycle 200
fmt  "    Q213=" 5 bq213    # Cycle 200
fmt  "    Q214=" 5 bq214    # Cycle 200
fmt  "    Q239=" 8 bq239    # Cycle 200 pas du taraud
fmt  "    Q256=" 3 bq256    # Cycle 200
fmt  "    Q257=" 3 bq257    # Cycle 200 debourrage du taraudage
fmt  "    Q258=" 3 bq258    # Cycle 200
fmt  "    Q259=" 3 bq259    # Cycle 200
fmt  "    Q336=" 3 bq336    # Cycle 200




fmt  "    Q321=" 3 bq321    # TCH PROBE 411 et 413
fmt  "    Q322=" 3 bq322    # TCH PROBE 411 et 413
fmt  "    Q323=" 3 bq323    # TCH PROBE 411
fmt  "    Q324=" 3 bq324    # TCH PROBE 411
fmt  "    Q261=" 3 bq261    # TCH PROBE 411 et 413
fmt  "    Q320=" 3 bq320    # TCH PROBE 411 et 413
fmt  "    Q260=" 3 bq260    # TCH PROBE 411 et 413
fmt  "    Q301=" 3 bq301    # TCH PROBE 411 et 413
fmt  "    Q305=" 3 bq305    # TCH PROBE 411 et 413
fmt  "    Q331=" 3 bq331    # TCH PROBE 411 et 413
fmt  "    Q332=" 3 bq332    # TCH PROBE 411 et 413
fmt  "    Q303=" 3 bq303    # TCH PROBE 411 et 413
fmt  "    Q381=" 3 bq381    # TCH PROBE 411 et 413
fmt  "    Q382=" 3 bq382    # TCH PROBE 411 et 413
fmt  "    Q383=" 3 bq383    # TCH PROBE 411 et 413
fmt  "    Q384=" 3 bq384    # TCH PROBE 411 et 413
fmt  "    Q333=" 3 bq333    # TCH PROBE 411 et 413



fmt  "    Q262=" 3 bq262    # TCH PROBE 413
fmt  "    Q325=" 3 bq325    # TCH PROBE 413
fmt  "    Q247=" 3 bq247    # TCH PROBE 413
fmt  "    Q423=" 3 bq423    # TCH PROBE 413
fmt  "    Q365=" 3 bq365    # TCH PROBE 413

#-------------------- 5 axes Axe  ------------------------------------------

fmt  3 useaxe           # flag pour utiliser le 4eme axe
fmt  "S" 2 sens         # pour inverser le sens de l'axe
fmt     1 bloque        # pour gestion M10 M11
fmt     1 use_bloque
fmt     1 old_rotaxis       # memo de rotaxis$
fmt "A" 2 old_axeA     # memo de l ancien A
fmt "Sens" 2 sensA      # sens de rotation de A
fmt  "A" 2 epsi         # Delta de rotation de l'axe A
fmt  "Ntour" 2 nbrtour      # nombre de tour realise
fmt     3 tolquestion       # flag utilise pour poser la question de tolerance de developpe q'une fois
fmt     4 mode_5axe
fmt     4 type_plane
fmt  3 axeB
fmt  3 axeC
fmt  "C" 3 axeC5x
fmt  "axeccalsimu" 3 axeccalsimu
fmt  "axeacalsimu" 3 axeacalsimu
fmt     3 tourne
fmt "ROT" 3 itourne
fmt     3 old_axeB
fmt     3 old_axeC
fmt     3 old_tourne
fmt "P base=" 1 produit_p_base
fmt "C base=" 1 C_angle_base
fmt "sin_C_base=" 1 C_angle_base_sin
fmt "cos_C_base=" 1 C_angle_base_cos

fmt "P souhaiter=" 1 produit_p_souhaiter
fmt "C souhaiter=" 1 C_angle_souhaiter
fmt "sin_C_souhaiter=" 1 C_angle_souhaiter_sin
fmt "cos_C_souhaiter=" 1 C_angle_souhaiter_cos
fmt "C=" 1 C_rotation
fmt "C reel=" 1 C_angle_reel
fmt "C reel droit=" 1 C_angle_reel_droite
fmt "C reel gauche=" 1 C_angle_reel_gauche


fmt "P pour B=" 1 produit_p_B
fmt "B =" 1 B_angle
fmt "sin_B_souhaiter=" 1 B_angle_sin
fmt "cos_B_souhaiter=" 1 B_angle_cos
fmt "B=" 1 B_rotation
fmt "Sens de B=" 4 sens_de_B
fmt "on est en 5axe continu=" 4 continu5x





fmt "P2X" 18 m1p
fmt "P2Y" 18 m2p
fmt "P2Z" 18 m3p
fmt "P3X" 18 m4p
fmt "P3Y" 18 m5p
fmt "P3Z" 18 m6p
fmt "" 18 m7p
fmt "" 18 m8p
fmt "" 18 m9p

fmt "old_P2X" 18 old_m1
fmt "old_P2Y" 18 old_m2
fmt "old_P2Z" 18 old_m3
fmt "old_P3X" 18 old_m4
fmt "old_P3Y" 18 old_m5
fmt "old_P3Z" 18 old_m6
fmt "old_" 18 old_m7
fmt "old_" 18 old_m8
fmt "old_" 18 old_m9


fmt "long_OA=" 1 long_OA
fmt "long_OB=" 1 long_OB
fmt "long_OC=" 1 long_OC
fmt "long_AB=" 1 long_AB
fmt "long_AC=" 1 long_AC
fmt "long_CB=" 1 long_CB

fmt "Angle A=" 1 angle_a
fmt "Angle B=" 1 angle_b
fmt "Angle C=" 1 angle_c

fmt "Cos Angle A=" 1 cosangle_a
fmt "Cos Angle B=" 1 cosangle_b
fmt "Cos Angle C=" 1 cosangle_c

fmt " produitAA =" 1 produitAA
fmt " produitBB =" 1 produitBB
fmt " produitCC =" 1 produitCC





fmt "Vecteur porteur X=" 1 Vect_porteur_x
fmt "Vecteur porteur Y=" 1 Vect_porteur_y
fmt "Vecteur porteur Z=" 1 Vect_porteur_z
fmt "angle entre repere et axe B=" 1 angle_axeB
fmt "angle entre repere et axe outil=" 1 angle_axe_outil
fmt "diff angle=" 1 dif_angle_B_outil
fmt "sens de rotation 1 pour inverser et  0 pour normal  =" 1 sens_axe_outil

fmt "TX" 1 tx
fmt "TY" 1 ty
fmt "TZ" 1 tz
fmt "TX" 1 old_tx
fmt "TY" 1 old_ty
fmt "TZ" 1 old_tz


fmt  "A" 1 axeA1
fmt  "A" 1 axeA2
fmt    3 axeAB
fmt    3 difaxeAB

fmt  "A" 1 delta_axeA1
fmt  "A" 1 axeA1_dep
fmt  "A" 1 old_axeA1
fmt    3 old_axeAB
fmt     1 debutpmx  # flag debut prog pmx
srot_label : ""
fmt    4 macro
axeA1_dep :  -999999
fmt "VX" 1 vx
fmt "VY" 1 vy
fmt "VZ" 1 vz
fmt "VX2" 1 vx2
fmt "VX2" 1 vx2_h
fmt "VY2" 1 vy2
fmt "VZ2" 1 vz2
fmt "VEC" 1 longvec

fmt "PROPR" 18 PROPR
fmt "PROMIN" 18 PROMIN

fmt   4 GESTc247
fmt "Polarite=" 4 polarite_axe
fmt "" 4 mode_turn


fmt "m1=" 1 m1$
fmt "m2=" 1 m2$
fmt "m3=" 1 m3$
fmt "m4=" 1 m4$
fmt "m5=" 1 m5$
fmt "m6=" 1 m6$
fmt "m7=" 1 m7$
fmt "m8=" 1 m8$
fmt "m9=" 1 m9$


axeA     : 999          # Inint de A
old_axeA : 0.9999999        # Inint de old_axeA
nbrtour : 0         # Inint du nombre de tour realise
tolquestion : 0         # Inint de tolquestion
polarite_axe : 1
#vtol$      : 0.01


#----------------------Parametres de DEF MACHINE-------------------------------

fmt    1 type_composant     # type de composant
fmt    1 compt_axes_rot     # compteur d'axes rotatif
fmt    3 erreur         # numero d'erreur
fmt    3 testerreur4            # flag pour erreur 4
fmt    1 diviseur       # Axe de l'axe rotatif
fmt    1 old_syncaxis       # memo du numero de combinaison d'axes
fmt    1 nbr_combi      # Nombre de combinaison d'axes
fmt    1 palette        # flag pour machine avec palette
fmt    1 fmaxi          # avance maxi de la machine
fmt    1 fmini          # avance mini de la machine


write_ops    : 0     #Write NC operation information (True/False)
erreur : 0
nbr_combi : 0
compt_axes_rot : 0
palette : 0
#-----------------------------Liste des OUTILS----------------------------------------

fmt "T" 5 paramT1       # Ne outil
fmt   5 paramT2         # Type d'outil
fmt   5 paramT3         # Matiere de l'outil 1=Rapide 2=carbure 3=carbure revetu 4=cermet 5=borzon
fmt   5 paramT4         # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt "DIAM=" 10 paramT5   # Diametre
fmt "R=" 10 paramT6     # Rayon de bout
fmt   10 paramT7        # Nombre de filet par mm
fmt "A=" 10 paramT8 # Angle de bout
fmt   5 paramT9         # Ne de correcteur de rayon
fmt   5 paramT10    # Ne de correcteur de longeur
fmt   9 paramT11    # Avance travail
fmt   9 paramT12    # Avance plongee
fmt   9 paramT13    # Avance retraction
fmt   5 paramT14    # Vitesse de broche
fmt   5 paramT15    # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt   5 paramT16    " DENTS" # Nombre de dents
fmt "F" 15 fauto     # AFFICHAGE AVANCE TRAVAIL DANS LIGNE "TOOL CALL"
#-------------------------------divers------------------------


#-----------------------------------------------------
#   ZONE de FORMULES  si : uniquement au dedut si = mise a jour systematique
#

#tlchng_aft$ : 1     # Delay the tool change call until the first motion is read on all the NCI Gcode 1000, 1001, 1002 tool changes.
get_1004$   : 1     # Find gcode 1004 with getnextop?
rpd_typ_v7$ : 0     # Use Version 7 style contour flags?
getnextop$  : 1     # autorise la commande nextop nextccomp etc
strtool_v7$ : 2     # autorise la lecture des commentaires de la bibiotheque outil
skp_lead_flgs$  : 0 # Do NOT use v9 style contour flags
ncldr$      : 20    # nbr de zero de queue utilises pour la fonction "fleader"
ldrcode$    : 65
nobrk$      : no$   # ne pas decomposer en xy pui z les mouvements en rapid
cc_1013$    : 1     # pour connaitre cc dans appel outil
opcode$     : 1
gcode$      : -1
progname$   : 1      # force le nom du nci en majuscule



#-----------------------------------------------------
#   DEFINITION DES STRING
#

#--------- DEFINITION DES STRING -----------------------
svide : ""           # STRING Vide utilisee pour faire des comparaisons
space : " "       # STRING pour forcer un espace
sdcom   : ";"        # STRING de debut de commentaire
sdcomf   : "* - "        # STRING de debut de commentaire pour affichage fenetre de gauche
sfcom : ""           # STRING de fin de commentaire
sdesioutil : ""      # STRING de designation outil
snomgroupe_op : ""       # STRING du nom du groupe d'operation
snomgroupe_op_old : ""   # STRING de l'ancien nom du groupe d'operation
smachine : ""        # STRING du nom de la machine
spalette : "PALETTE"  # STRING du nom palette
scomentsprog : ""        # STRING du commentaire pour le titre du sous prog
snom_nc : ""         # STRING de stockage du non du NC complet avec chemin et extesion style c:\cfao\prog-cn\TOTO.NC
snom_numero : ""     # STRING de stockage du non du NC sous forme O0123.nc avec chemin et extesion style c:\cfao\prog-cn\ous forme O0123.NC
spoint : "."      # STRING du POINT pour l'extesion (.NC)
stringo : ""         # STRING du O pour le non (O0123) en nom du Numero PRG
seditor : "notepad.exe"   # STRING du non de l'editeur pour les prog en nom du Numero PRG (avec chemenin complet si pas dans Windows)
sfileops : ""        # STRING du nom du fichier OPS
sops : ".ops"     # STRING de l'extention des fichier OPS
sfmaxi : "FMAX"
sf999maxi : "F99999"
sfmax : "" #"FMAX"        # STRING de la vitesse rapide
spt_ref : ""
sfauto : "F AUTO"
seq : ""
#--------- DEFINITION DES TABLEAUX DE STRING -----------------------
# erreur
serr0   : "err0"
serr1   : "ERREUR - LA FONCTION Ecriture de l'information CN d'operation DOIT ETRE VALIDE DANS LA DEFINITION D'ARMOIRE"
serr2   : "ERREUR - CE POST PRO NE SUPPORTE Q'UN SEUL AXE ROTATIF - VERIFIEZ LA DEF MACHINE ET LA COMBINAISON D'AXE"
serr3   : "ERREUR - CE POST PRO NE SUPPORTE Q'UNE SEULE COMBINAISON D'AXE PAR PROGRAMME - VERIFIEZ LA COMBINAISON D'AXE DES OPERATIONS"
serr4   : "CORRECTION SUR ARC DETECTEE - Verifiez les entrees/sorties de l'operation "
serreur : ""
fstrsel serr0 erreur serreur 5 -1

#   Mode Absolue ou incremental
sinc00 : ""          # Mode Absolue
sinc01 : ""          # Mode incremental
sinc02 : ""
sinc_abs : ""
fstrsel sinc00 incremental sinc_abs 3 -1

#   Affectation de cote de correction outil G41 G42
sc00    : "R0"
sc01    : "RL"
sc02    : "RR"
scord : ""
fstrsel  sc00 cc_pos$ scord 3 -1

#   Affectation de G0 e G3 dans sgcode en fonction du GCODE
sg00    : "L"        # Rapide
sg01    : "L"        # travail
sg02    : "DR-"       # arc horaire
sg03    : "DR+"       # arc trigo
sq04    : "G4"       # tempo
sg05    : "G80"          # annulation Cycle Fixes
sgcode : ""

fstrsel  sg00 gcode$ sgcode 6 -1

#   Affectation des plans d'usinage pour
spl00 : ""       # plan XY
spl01 : ""       # plan YZ
spl02 : ""       # plan XZ
spl03 : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1

#   Blocage deblocage 4ieme Axe
sblo0 : ""           # pour pas de blocage ni deblocage
sblo1   : "M10"   # blocage axe A
sblo2   : "M11"   # deblocage axe A
sblo3 : ""           # pour Frein axe A
sbloque : ""

fstrsel sblo0 bloque sbloque 4 -1

#      Rotation broche
sm00    : "M4"
sm01    : "M5"
sm02    : "M3"
sm03    : "M4"
sm04    : "M5"
sm05    : "M3"
sm06    : "M4" #"M24"
sm07    : "M7"
sm08    : "M3" #"M23"
sm09    : "M4"
sm10    : "M5"
sm11    : "M3"
spdlon : ""

#spdlsel = fsg3(ss$)
spdlsel = fsg3(ss$)+(coolant$*3)
#spdlsel = fsg3(ss)+(coolant*3)

fstrsel  sm00 spdlsel spdlon 12 -1


#   Types d'outils
stypT00 : "RIEN"
stypT01 : "FORET A CENTRER"
stypT02 : "FORET A NOYER"
stypT03 : "FORET"
stypT04 : "TARAUD A DROITE"
stypT05 : "TARAUD A GAUCHE"
stypT06 : "ALESOIR"
stypT07 : "BARRE D'ALESAGE"
stypT08 : "FRAISE A LAMER"
stypT09 : "FRAISE A EBAVURER"
stypT10 : "FRAISE 2 TAILLES"
stypT11 : "FRAISE BOULE"
stypT12 : "FRAISE A CHANFREINER"
stypT13 : "TOURTEAU"
stypT14 : "FRAISE 3 TAILLES"
stypT15 : "FRAISE A RAYON"
stypT16 : "FRAISE QUEUE D'ARONDE"
stypT17 : "FRAISE CONIQUE"
stypT18 : "FRAISE SPHERIQUE"
stypT19 : "FRAISE TORIQUE"
stypT20 : "SPECIAL"
stypT21 : "FRAISE A GRAVER"
stypT22 : "FORET BRAD"

stypeT : ""
fstrsel stypT00 paramT2 stypeT 23 -1

#   Matiere des outils
smatT0  : "ARS"
smatT1  : "ARS"
smatT2  : "CARBURE"
smatT3  : "CARBURE PLAQUETTES"
smatT4  : "CERAMIQUE"
smatT5  : "BORZON"
smatT6  : "BORZON"
smatT7  : "BORZON"
smatT8  : "BORZON"
smatT9  : "BORZON"
smatT10 : "INCONNU"
smatT : ""
fstrsel smatT0 paramT3 smatT 11 -1

# Table de l'affichage du type de corection

stc0   : "SANS CORRECTION"             #"CORRECTION AUCUNE"
stc1   : "AVEC CORRECTION ARMOIRE"             #"CORRECTION ARMOIRE DROITE"
stc2   : "AVEC CORRECTION ARMOIRE"             #"CORRECTION ARMOIRE GAUCHE"
stc3   : "SANS CORRECTION"             #"CORRECTION ORDINATEUR DROITE"
stc4   : "SANS CORRECTION"             #"CORRECTION ORDINATEUR GAUCHE"
stc5   : "AVEC CORRECTION USURE"             #"CORRECTION USURE DROITE"
stc6   : "AVEC CORRECTION USURE"             #"CORRECTION USURE GAUCHE"
stc7   : "AVEC CORRECTION USURE"             #"CORRECTION USURE INVERSE DROITE"
stc8   : "AVEC CORRECTION USURE"             #"CORRECTION USURE INVERSE GAUCHE"

stype_comp : ""

fstrsel  stc0 type_comp stype_comp 9 -1


#-----------------------------------------------------
#   Tables de parametres
#
fprmtbl 2    1          # lecture des parametres de surep pour surfacage
        12068  surepl       # surep en Z

fprmtbl 1    2          # lecture des parametres de surep pour contour et 3D
        10010    surep      # surep R
        10068    surepl     # surep Z

#fprmtbl 18000   4           # Lecture des Param de def armoire
 #       18171   write_ops   # Autoriser l'ecriture de l'information CN d'operation
 #      #18458   texte       # Nombre de caracteres pour les commentaires
  #     18705   cor_arc     # compesation sur les arcs autorisee
  #     18713   sous_prog_type  # type de merge des sous prog (0 apres prog principal 1 avant)

texte : 1

#------------- Bloc de definition des Questions du post pro -----------------
#   Question 1
#
fmt 2 robot
robot : 0
fq 1 robot "Utilisation du Robot 1 pour oui 0 pour non"


#   Question 2
#
sclient : ""
fq 2 sclient "CLIENT"

#   Question 3
#
srepere : ""
fq 3 srepere "DESIGNATION PIECE"

#   Question 4
#
sindice : ""
fq 4 sindice "REFERENCE PIECE"

#   Question 5
#
snumpiece : ""
fq 5 snumpiece "NUMERO DE PIECE SVP"

#   Question 6
#
fq 6 progno$ "Numero de Prog SVP ?"
#   Question 7
#   Question 8
#
fq 8 vtol$    "TOLERANCE CORDALE POUR DEVELOPPE"
#   Question 10
#
fq 10 progno$ "Numero de programme //progno$// existant, ENTREZ UN NOUVEAU NUMERO"
#   Question 11
#
fmt 2 remplace
remplace : 2

fq 11 remplace "Numero de programme //progno$// existant, LE REMPLACER ?      0 pour NON - 1 pour OUI"

fq 12 degagex "Point de degagement en X de securite dans le referentiel machine //smodedeg// ?"
fq 13 degagey "Point de degagement en Y de securite dans le referentiel machine //smodedeg// ?"
fq 14 degagez "Point de degagement en Z de securite dans le referentiel machine //smodedeg// ?"

sutilaxeC : "Utilisation du 5eme axe qui est sur la table.   OK = OUI      Annule = NON"

fq 15 machine "Votre programme n'indique pas la machine choisie, pour quel machine DM est ce programme: 0=DM0 (DMU50eVolution), 1=DM1 (DMU50 eVo linear), 2=DM2 (DMU50 eVo linear 2) ou 3=DM3 (DMU60 eVo linear)?"

fmt 2 palpage
palpage : 0
fq 16 palpage "Utilisation du palpeur 0 pour non 1 pour palpage rectangulaire et 2 pour palpage de cercle"

fmt 4 repetpiece
repetpiece : 1
fq 17 repetpiece "Nombre de r√©p√©tition"

fmt 4 origine247
origine247 : 1
fq 18 origine247 "Choix de l'origine programme"

fq 27 spt_ref "Numero point de ref"

pdebug      # pour activer les infos de debug pst

        err_file$ = 4
        fastmode$ = 0
        bug2$ = 60



serreurbase : ""
serreur1 : "Probleme 5 axes continue ou percage 5 axes, il faut etre en plan de dessus sur operation num:"
serreur2 : "L'angle demander sur B est impossible. Votre machine ne se placera pas comme souhaite sur operation num:"
serreur3 : "L'axe B est arriver en limite, il y aurra un changement de cote (B- <=> B+) sur operation num:"
serreur4 : "L'axe B est arriver en limite positive et negative sur operation num:"

fmt "" 4 erreurtype
#fmt  "OPERATION "  5 numop  # NUMERO D'OPERATION

perreur   # affichage des erreurs lors du traitement pp

            if erreurtype = 1,
            [
            serreurbase = serreur1 + no2str(numop)
            result = mprint(serreurbase)
            serreurbase, e$
            exitpost$ # abandon
            ]

            if erreurtype = 2,
            [
            serreurbase = serreur2 + no2str(numop)
            result = mprint(serreurbase,2)
            if result = 1,   sdcom, serreurbase, sfcom, e$
            if result = 2,   sdcom, serreurbase, sfcom, e$, exitpost$ # abandon
            ]

            if erreurtype = 3,
            [
            serreurbase = serreur3 + no2str(numop)
            result = mprint(serreurbase,2)
            if result = 1,   sdcom, serreurbase, sfcom, e$
            if result = 2,   sdcom, serreurbase, sfcom, e$, exitpost$ # abandon
            ]

            if erreurtype = 4,
            [
            serreurbase = serreur4 + no2str(numop)
            result = mprint(serreurbase)
            serreurbase, e$
            exitpost$ # abandon
            ]


pinfos      # affichage d'infos

        #*tlchng_aft$, "--------------", e$
        #*workofs$, e$
        #*sub_trnstyp$, e$
        #*sub_trnmthd$, e$
        #*usecandrill$, e$
        #*usecanpeck$, e$
        #*usecanchip$, e$
        #*usecantap$, e$
        #*usecanbore1$, e$
        #*usecanbore2$, e$
        #*usecanmisc1$, e$
        #*usecanmisc2$, e$
        #*sous_prog_type, "----", e$

#---------------- BLOCS DE PRE TRAITEMENT POST PRO ---------------------------------
#

sblk : "BLK"
pprep$      # affectation des variables avant debut traitememt post pro

    #pdebug     # pour activer les infos de debug pst
    if type_pp = 2, sextnc$ = sext
    if type_pp = 1, rotaxtyp$ = 3
    if type_pp = 2, rotaxtyp$ = 4
    #if type_pp = 1, use_cyc200 = 1
    #if type_pp = 2, use_cyc200 = 0
    use_cyc200 = 1     # 0 pour utiliser les anciens cycles DEF1  -  1 pour utiliser les cycles de percage 200 et 203 - 2 pour utiliser que le 203
    tlchng_aft$ = 1     # Delay the tool change call until the first motion is read on all the NCI Gcode 1000, 1001, 1002 tool changes.
    omitseq$ = 0    # forcer la numerotation de bloc de 1 en 1
    seqinc$ = 1
    seqno$ = 0
    arctype$ = 1    # forcer les arcs en ij absolue
    if type_pp = 2,
    [
    result = nwadrs(sblk, n$)    # affectation du nom de l'axe X
    #result = newfs (4, x$)  # affectation en format modal
    ]



    #rd_mch_ent_no$ = 0          # pour lire les infos de base de la machine
    #rd_cd$                  # lire le control definition
    #if write_ops = 0, erreur = 1        # Write NC Operation information MUST be enabled in CD
    #!erreur
    #!serreur

   # if erreur <> 0, [
      #  result = mprint(serreur, 2)
      #  exitpost$
      #      ]


#---------------- BLOCS DE DEF MACHINE ET DEF ARMOIRE ---------------------------------
#

pmachineinfo$    # lecture des parametre de def armoire et def machine

    #"-------------------pmachineinfo$", e$
    #~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire", sparameter$, e$
    #if prmcode$ = 19958, *prmcode$, "type de composant", "=", sparameter$, e$  # type de composant 5 = axe rotatif
    #if prmcode$ = 17399, *prmcode$, "AXE DE L'AXE ROTATIF", "=", sparameter$, e$   # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17402, *prmcode$, "sens de laxe", "=", sparameter$, e$       # sens de l'axe rotatif 0=trigo 1=horaire
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$
    #if prmcode$ = 17696, *prmcode$, "nom de la combinaison =", sparameter$, e$

    if prmcode$ = 17063, fmaxi = rpar(sparameter$, 1)           # avance maxi en G1
    if prmcode$ = 17062, fmini = rpar(sparameter$, 1)           # avance mini en G1



    if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000)   # Lecture de la table de parametre Control Definition

    if prmcode$ = 17012, smachine = sparameter$             # Nom de la machine

    if prmcode$ = 17201,        [               # nom du composant
            if ucase(sparameter$) = spalette, palette = 1       # si c'est une palette, activer la gestion de palette

                        ]

    if prmcode$ = 19958,        [               # type de composant
            type_composant = rpar(sparameter$, 1)
            if type_composant = 5,  [               # si c'est un axe rotatif
            useaxe = 1
            compt_axes_rot  = compt_axes_rot + 1            # compter le nombre d'axes rotatif
                        ]
                        ]

    if prmcode$ = 17399,    [                   #AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
            diviseur = rpar(sparameter$, 1)
            if diviseur > 3, diviseur = diviseur - 6        #ne garder que x y z
                    ]

    if prmcode$ = 17402,    [                   # sens de l'axe rotatif 0=trigo 1=horaire
            sens = rpar(sparameter$, 1)
        if sens = 0, sens = 1                   # variable sens pour le post pro
        else, sens = -1
                ]

      if prmcode$ = 17598,      [               # nombre d'outils du changeur de la def machine
        #nbroutil = rpar(sparameter$, 1)
                        ]

      if prmcode$ = 17397,      [               # Nom de l'axe rotatif (ABC)
    srot_label = sparameter$
            ]

plireaxes   # Lecture des parametres de la combinaison d'axes uniquement
        #"plireaxes", syncaxis$, e$

    if syncaxis$ <> old_syncaxis, [
    compt_axes_rot = 0
    erreur = 0
        ]


    rd_mch_ent_no$ = syncaxis$      # pour avoir les infos de la conbinaison d'axe utilisee
    #rd_mch_ent_no$ = -2            # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    #rd_cd$                 # lecture de la def armoire
    rd_md$                  # lecture de la def machine


        result = nwadrs(srot_label, axeA)   # affectation du nom de l'axe rotatif en ABS
        srot_label = "I" + srot_label       # affectation du nom de l'axe rotatif en INC
        result = nwadrs(srot_label, axeAi)  # affectation du nom de l'axe rotatif en INC

    ptestmachine
    old_syncaxis = syncaxis$

#---------------- BLOCS DE LECTURE DES PARAMETRES ---------------------------------
#

pparameter$  # lecture des parametres d'operation
    #"------------------------------------------------pparameter$", e$
    #~prmcode$, "=", sparameter$, e$                # pour afficher tous les parametres



    if opcode$ <> 19, result = fprm (1)                 # lecture des parametres de surep pour surfacage
    if opcode$ = 19, result = fprm (2)                  # lecture des parametres de surep pour contour et 3D

    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)        # lecture des parametres d'outil
    if prmcode$ = 20018, snomgroupe_op = ucase (sparameter$)    # Lecture du nom de groupe d'usinage

    if prmcode$ = 10030, ftravail = rpar(sparameter$, 1)
    if prmcode$ = 10031, fplongee = rpar(sparameter$, 1)
    if prmcode$ = 15140, fretract = rpar(sparameter$, 1)
    if prmcode$ = 12662, fg1ugv   = rpar(sparameter$, 1)

    #if prmcode$ = 15166, "--------------15166--------------", sparameter$, e$
    #if prmcode$ = 15181, "--------------15181--------------", sparameter$, e$
    #if prmcode$ = 15370, "--------------15370--------------", sparameter$, e$
    #if prmcode$ = 15239, sparameter$, e$


pwrttparam$  # lecture des parametres d'outils
    #~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)

    if syncaxis$ <> old_syncaxis, nbr_combi = nbr_combi + 1
    #*nbr_combi, "-------------pwrttparam--------", e$
    old_syncaxis = syncaxis$








#---------------- BLOCS DE TRAITEMENT DES SOUS PROG EN Z ---------------------------------

psub_call_s$       # appel sous prog en Z
        sub_seq_typ$ = transform
    #"--------appel sous prog en Z---------", *sub_sec_no$, e$
        !sub_prg_no$                # mise a jour du numero interne de sous prog en Z
        subprognum = debsousprog + sub_prg_no$  # affectation du numero de sous prog en Z
        nprincipal = n$  + seqinc$      # memo du numero de ligne pour le rappel dans le sous-programme

        if transform = 1, n$, *subprognum, e$           # appel du sous prog

        else, if sub_sec_no$ > 1 | sub_sec_no$ < 1, [    # call suivant

        #*nprincipal, e$            # affecation du parametre CN pour memo du numero de ligne
        n$, *subprognum, e$         # appel du sous prog

            ]


        nprincipal = n$             # memo du numero de ligne pour le prog principal



psub_st_s$    # ecriture de l'entete de sous prog en Z

        if sub_sec_no$ > 1 | sub_sec_no$ <1, ndebutsz = n$
    if transform = 1, n$  = 1

        !sub_prg_no$                # mise a jour du numero interne de sous prog en Z
        numsubprog = debsousprog + sub_prg_no$  # affectation du numero de sous prog en Z
        nomsubprog = numsubprog                 # affectation du nom de sous prog en Z
        memo_incremental = incremental          # memorisation du mode ABS INC Actuel
        incremental = sub_inc$          # Sous prog en incremental ou absolue


    #if incremental = 1, p_casse_modalite   # casser la modalite xyz pour les sous prog en relatif
    p_casse_modalite_avance         # casser la modalite le l'avance pour les sous prog

        if numsprog = 0, omitseq$ = 1       # pas du numero de ligne pour les sous prog

    #space, e$                  # sauter une ligne


        if texte <> 0, [            # entete avec commentaires

                if scomentsprog <> svide, n$, *numsubprog, sdcom, spaces$ = 0, scomentsprog, sfcom, e$
                 else, n$, *numsubprog, e$
                spaces$ = old_spaces
                                ]


        else, [             # entete sans commentaires
                n$, *numsubprog, e$
                    ]

        n$, *sinc_abs, e$                 # ecrire si sous prog en ABS ou INC
    gcode$ = 5      # pour forcer l'ecriture de code G du premier bloc du sous prog
        !gcode$

psub_end_s$    # fin sous prog en Z


        incremental = memo_incremental          # rappel du mode INC ABS precedent
        n$, *sinc_abs, e$

        n$, "LBL 0", e$                 # fermeture de sous prog
    #space, e$                  # sauter une ligne
    #if sub_sec_no$ > 1 | sub_sec_no$ <1, n$ = ndebutsz

        if transform = 0, [
        if sub_sec_no$ > 1 | sub_sec_no$ <1, n$ = ndebutsz
            subout$ = transform
                mergeaux$
                clearaux$
                ]
#-------------------------BLOCS DE TRAITEMENT DES SOUS PROG EN TRANSFORMER ---------------------------


pmirroir    # pour usinage transformer en mirroir

protation    # pour usinage transformer en rotation

pechelle    # pour usinage transformer en echelle

    # pour usinage transformer en translation

        #n$, "-------------------------------------", *sub_trnmthd$, e$



ptranslation

        prapid$

psub_call_mm$
    psub_call_m$



psub_call_m$   # appel sous prog en transformation pour outil unique
        transform = 1
        sub_seq_typ$ = 1

       # "appel sous prog en transformation pour outil unique", e$

        #main_prg_no$, sub_prg_no$, sub_ref_id$, sub_op_id$, sub_grp_id$, sub_trns_id$, sub_sec_no$, sub_totl_no$, sub_chn_no$, sub_inc$, e
        #*main_prg_no$, e


        !main_prg_no$               # mise a jour du numero interne de sous prog en transformation pour outils multiples
        subprognum = debsousprog + main_prg_no$ +300   # affectation du numero de sous prog


        if sub_trnstyp$ = 0, pmirroir       # si on fait du mirroir
        if sub_trnstyp$ = 1, protation      # si on fait de la rotation
        if sub_trnstyp$ = 2, pechelle       # si on fait de l'echelle
        if sub_trnstyp$ = 3, ptranslation   # si on fait de la translation aller avant dans bloc ecriture decalage orignie

        nprincipal = n$  + seqinc$      # memo du numero de ligne pour le rappel dans le sous-programme

        #*nprincipal, e$            # affecation du parametre CN pour memo du numero de ligne
        #if sub_sec_no$ <> 0, n$, *subprognum, e$       # appel du sous prog
        if type_pp = 1,n$, *subprognum, e$     # appel du sous prog
        if type_pp = 2,sm,paf, *subprognum, e$     # appel du sous prog
        nprincipal = n$             # memo du numero de ligne pour le prog principal


      # n, "(PASSE ", sub_sec_no, "SUR ", sub_totl_no, ")", e


          #  "Subprogram number ", sub_op_id, e
          #  "Actual operation ID", sub_grp_id, e
          #  "Transform/non-transform indicator", sub_ref_id, e
          #  "Iteration counter", sub_sec_no, e
          #  "Total number of instances", sub_totl_no, e


psub_end_m_r$    # bloc system non explique dans doc des PST (a voir)
        transform = 0
        #"-------------------------------------------", "psub_end_m_r$", e$


psub_st_m$    # entete sous prog en transformation

        ndebutst = n$
    n$  = 1
        !main_prg_no$                   # mise a jour du numero interne de sous prog en transformation pour outils multiples
        numsubprog = debsousprog + main_prg_no$ +300    # affectation du numero de sous prog
        nomsubprog = numsubprog                 # affectation du nom de sous prog en Z
        memo_incremental = incremental          # memorisation du mode ABS INC Actuel
        incremental = sub_inc$          # Sous prog en incremental ou absolue


    #if incremental = 1, p_casse_modalite   # casser la modalite pour les sous prog en relatif
    p_casse_modalite_avance         # casser la modalite le l'avance pour les sous prog

        if numsprog = 0, omitseq$ = 1       # pas du numero de ligne pour les sous prog
        if texte <> 0, [            # entete avec commentaires

                 if scomentsprog <> svide,
                                             [
                                            if type_pp = 1,n$, *numsubprog, sdcom, spaces$ = 0, scomentsprog, sfcom, e$
                                            if type_pp = 2,sm,paf, *numsubprog, sdcom, spaces$ = 0, scomentsprog, sfcom, e$
                                            ]

                 else,
                         [
                        if type_pp = 1,n$, *numsubprog, e$
                        if type_pp = 2,sm,paf,*numsubprog, e$
                        ]
                spaces$ = old_spaces
                ]


        else,         [             # entete sans commentaires
                    if type_pp = 1,*numsubprog, e$
                    if type_pp = 2,sm,paf,*numsubprog, e$
                    ]

        if type_pp = 1,n$, *sinc_abs, e$           # ecrire si sous prog en ABS ou INC
        if type_pp = 2,sm,paf, *sinc_abs, e$           # ecrire si sous prog en ABS ou INC
    gcode$ = 5              # pour forcer l'ecriture de code G du premier bloc du sous prog
        !gcode$

             #sub_op_id, sub_prg_no, e


psub_end_m$   # fin sous prog en transformation


        incremental = memo_incremental          # rappel du mode INC ABS precedent
        if type_pp = 1,
                        [
                        n$, *sinc_abs, e$
                        n$, "LBL 0", e$
                        ]
        if type_pp = 2,
                        [
                        sm,paf, *sinc_abs, e$
                        sm,paf, "LBL 0", e$
                        ]

    #space, e$                  # sauter une ligne
    #if sub_sec_no$ <> 0 & transform = 0, n$ = ndebutst

        omitseq$ = old_omitseq
        #n$ = ndebutst                  # recuperation du numero de ligne pour prog principal

       # subout$ = 0
       # mergesub$
       # clearsub$




#------------------- GESTION DES COMMENTAIRES ---------------------------------------
#
pcomment$   # Gestion des commentaires dans le prog

        if entete = 0,  pcomment2   # commentaires des usinages
        else,       pcomment3   # commentaires d'entete de prog

pcomment_end$   # post traitement des commentaires

         if entete = 1, comm_cnt$ = old_comm_cnt            # pour pouvoir relire les commentaires apres appel de comment dans pheader



pcomment2       #Affichage des commentaire des usinages

    scomm$ = ucase (scomm$)                             # focer en majuscules
    scomentsprog = svide                                # mise a zero du commentaire de sous prog

    if texte <> 0, [
        if type_pp = 1,
                        [
                        spaces$ = 0                             # suprimer les espaces
                        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc
                        if debut = 1,     [
                                        # if gcode$ = 1051, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, scomm$, sfcom, e$ # Nom Machine
                                        if gcode$ = 1053, spaces$ = old_spaces, n$, sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Nom du Groupe Machine
                                           if gcode$ = 1052, spaces$ = old_spaces, n$, sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Commentaire de groupe Machine
                                        #if gcode$ = 1054, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, scomm$, sfcom, e$  # Descripteur de fichier
                                        ]
                        if gcode$ = 1005, spaces$ = old_spaces, n$, sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Usinage commentaire - en commentaire
                        if gcode$ = 1007, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, scomm$, sfcom       # Entree Manuelle - en commentaire avec le mouvement sans e$
                        if gcode$ = 1008, spaces$ = old_spaces, n$, "* -     ", spaces$ = 0, scomm$, e$   # Commentaire d'operation
                        if gcode$ = 1008, scomentsprog = scomm$
                        spaces$ = old_spaces                            # rappel des espaces
                        omitseq$ = old_omitseq                          # rappel des numero de bloc
                        ]
        if type_pp = 2,
                        [
                        spaces$ = 0                             # suprimer les espaces
                        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc
                        if debut = 1,     [
                                        # if gcode$ = 1051, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, scomm$, sfcom, e$ # Nom Machine
                                        if gcode$ = 1053, spaces$ = old_spaces, sm, paf, sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Nom du Groupe Machine
                                           if gcode$ = 1052, spaces$ = old_spaces, sm, paf,sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Commentaire de groupe Machine
                                        #if gcode$ = 1054, spaces$ = old_spaces, sm, paf,sdcom, spaces$ = 0, scomm$, sfcom, e$  # Descripteur de fichier
                                        ]
                        if gcode$ = 1005, spaces$ = old_spaces, sm, paf, sdcomf, spaces$ = 0, scomm$, sfcom, e$   # Usinage commentaire - en commentaire
                        if gcode$ = 1007, spaces$ = old_spaces, sm, paf,sdcomf, spaces$ = 0, scomm$, sfcom       # Entree Manuelle - en commentaire avec le mouvement sans e$
                        if gcode$ = 1008, spaces$ = old_spaces, sm, paf,"* -     ", spaces$ = 0, scomm$, e$   # Commentaire d'operation
                        if gcode$ = 1008, scomentsprog = scomm$
                        spaces$ = old_spaces                            # rappel des espaces
                        omitseq$ = old_omitseq                          # rappel des numero de bloc
                        ]
                    ]

        if type_pp = 1,
                        [
                        if gcode$ = 1006, n$, scomm$, e$                        # Usinage commentaire - en code
                        if gcode$ = 1026, scomm$                            # Entree Manuelle - en code avec le mouvement sans e$
                        ]
        if type_pp = 2,
                        [
                        if gcode$ = 1006, sm, paf, scomm$, e$                        # Usinage commentaire - en code
                        if gcode$ = 1026, scomm$                            # Entree Manuelle - en code avec le mouvement sans e$
                        ]

pcomment3   # Affichage des commentaires d'entete de prog

        if gcode$ = 1054,
        [
        scomm$ = ucase (scomm$)
        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, scomm$, sfcom, e$     # Descripteur de fichier
        spaces$ = old_spaces
         ]
         old_comm_cnt = comm_cnt$



pnomgroupe  # Affichage du nom du groupe d'operation
    if info_groupe = 1, [
    if snomgroupe_op <> svide & texte <> 0 & snomgroupe_op <> snomgroupe_op_old, [
        spaces$ = 0                             # suprimer les espaces
        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "*", snomgroupe_op, "*", sfcom, e$                # nom du groupe d'operation
        #space, e$
        spaces$ = old_spaces                            # rappel des espaces
        omitseq$ = old_omitseq                          # rappel des numero de bloc
            snomgroupe_op_old = snomgroupe_op                   # memo du nom du groupe d'operation
                        ]
                    ]

pnumop      # numerotation des operations post-processees

        if op_id$ <> old_op_id, numop = numop + 1

#------------------- 5 Axes continue calcul ---------------------------------------


paxeA   # Affichage de l'axe A



        nbrtour = int (axeA / 360) * sens

    if incremental = 0, axeA, !axeAi
    if incremental = 1, !axeA, axeAi

        old_axeA = axeA




pcalculpmx  # Calcul de l'axe A x y z


    vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$

    if diviseur = 1, axeA1 = atan2(vy,vz) # on tourne autour de x
    if diviseur = 2, axeA1 = atan2(vx,vz) # on tourne autour de Y

    if axeA1 >  180, axeA2 = 360 - axeA1
    if axeA1 <= 180, axeA2 = axeA1 * -1

    delta_axeA1 = axeA1 - old_axeA1

    if delta_axeA1 >  180, delta_axeA1 = delta_axeA1 - 360
    if delta_axeA1 <  -180,delta_axeA1 = delta_axeA1 + 360

    axeA1_dep = axeA1_dep + delta_axeA1
    old_axeA1 = axeA1
    axeA = axeA1_dep * sens


    if diviseur = 1, [          # on tourne autour de x
    xabs = x$
    yabs = z$*sin(axeA2) + y$*cos(axeA2)
    zabs = z$*cos(axeA2) - y$*sin(axeA2)
            ]

    if diviseur = 2, [          # on tourne autour de Y
    xabs = z$*sin(axeA2) + x$*cos(axeA2)
    yabs = y$
    zabs = z$*cos(axeA2) - x$*sin(axeA2)
            ]




pmx0$       # pre output pmx
            if fr$ = -2, gcode$ = 0
            else, gcode$ = 1
            pcalculpmx



pmx$      # ecriture du 5 axes continue
            continu5x = 1   # flag pour savoir que l'on est en 5 axes continue
            #"voir ", *x$, *y$,*z$,*u$,*v$,*w$,*vx,*vy,*vz,*longvec,e$
            if mode_5axe = 0, pmx_4axes
            else, pmx_5axes



pchange_sens  # changement de polarite de l'axe B
                #"voir changpolar_AB au debut dans pchange sens" , *changpolar_AB,  e$
                if axeAB5x > maxi_B & (axeAB5x * -1 ) < mini_B | axeAB5x < mini_B & (axeAB5x * -1 ) > maxi_B, erreurtype = 4
                else, erreurtype = 3
                perreur  # on previent que l'on va changer de sens
                changpolar_AB = changpolar_AB * -1 # flag pour definir le changement de cote , on change
                polarite  # on reactualise la variable polarite_axe
                # on doit sortir de la piece doucement a la hauteur du vecteur ( par defaut 25 mm)
                if type_pp = 1, n$, "L" , *old_u, *old_v, *old_w, pfr,e$  # on remonte en travail le long de l'outil
                if type_pp = 2, sr, *old_u, *old_v, *old_w, sfsimurapid, paf, "L" , *old_u, *old_v, *old_w, pfr, e$
                if type_pp = 1, n$, "M129", e$   # arret rtcp
                if type_pp = 2,sm,paf, "M129", e$


                #pdegage  # degagement en butter Z
                 m7$ = (old_vx/longvec)
                    m8$ = (old_vy/longvec)
                    m9$ = (old_vz/longvec)
                 #"voir les vecteur avant plane marche", m7$, m9$, m8$ , e$
                 plane_marche    # ecriture des plane spacial
                old_axeC = axeC
                x1 =  old_u * cos(-(axeC)) - old_v * sin(-(axeC))
                y1 =  old_u * sin(-(axeC)) + old_v * cos(-(axeC))
                z1 =  old_w
                y2 =  y1 * cos(-axeAB) - z1 * sin(-axeAB)
                z2 =  y1 * sin(-axeAB) + z1 * cos(-axeAB)
                if type_pp = 1,
                                [
                                gcode$ = 0
                                n$, `sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, e$ #ssa, pgamme, *spdlon, e$
                                 #n$, `sgcode, *zabs,pcord, pfr, e$
                                n$, "PLANE RESET STAY", e$
                                ]
                if type_pp = 2,
                                [
                                sr, *xabs, *yabs, *zabs,axeC5xsimu, axeAB5xsimu, sfsimurapid, paf,`sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, sm, degagez,  e$ #ssa, pgamme, *spdlon, e$
                                 sr, *xabs, *yabs,*zabs, sfsimurapid, paf,`sgcode, *zabs,pcord, pfr, e$
                                sm, paf, "PLANE RESET STAY", e$
                                ]
                 tx = (old_vx/longvec)
                    ty = (old_vy/longvec)
                    tz = (old_vz/longvec)

                 if type_pp = 1, n$, "M128 M126",e$
                 if type_pp = 2,sm, paf, "M128 M126",e$
                 gcode$ = 1
                 cont_axeC = 0
                 pcal5xcontinue
                 #axeAB5x = axeAB5xsimu
                 #axeC5x = axeC5xsimu
                 p_casse_modalite_avance
                 if type_pp = 1,
                             [
                            n$, "L" , *old_u, *old_v, *old_w,*axeAB5x,*axeC5x, pfr, e$  # on replonge en travail le long de l'outil
                            n$, "L" , *old_x, *old_y, *old_z, *axeAB5x,*axeC5x,plubrifon, pfr,e$
                            ]
                if type_pp = 2,
                            [

                            sr, *old_u, *old_v, *old_w, *axeAB5xsimu, *axeC5xsimu, sfsimurapid, paf, "L" , *old_u, *old_v, *old_w, *axeAB5xsimu, *axeC5xsimu, pfr, e$
                            sr, *old_x, *old_y, *old_z, *axeAB5xsimu, axeC5xsimu, sfsimurapid, paf, "L" , *old_x, *old_y, *old_z, *axeAB5xsimu, *axeC5xsimu, pfr, e$
                            ]

                 pcalpmx
                 pcal5xcontinue
                # "voir changpolar_AB a la fin" , *changpolar_AB,  e$

pcont
        if dif_axeC > 0, cont_axeC = cont_axeC - 360
        if dif_axeC < 0, cont_axeC = cont_axeC + 360
        pcal5xcontinue
        axeC5x = cont_axeC + axeC5x

pcalpmx
              xabs = x$
           yabs = y$
           zabs = z$
           !xabs, !yabs, !zabs

           if opcode$ = 16, ex$  # on passe la dans le percage 5 axes
           vx = u$ - x$
           vy = v$ - y$
           vz = w$ - z$

           longvec=sqrt(vx * vx + vy * vy + vz * vz)
           #"voir ", *x$, *y$,*z$,*u$,*v$,*w$,*vx,*vy,*vz,*longvec,e$
           tx = (vx/longvec)
           ty = (vy/longvec)
           tz = (vz/longvec)
           #"voir les vecteurs avant  =", *tx, *ty, *tz,  e$
           if abs(tx) <= bruit, tx = 0  # filtrage en proche vertical pour pas fair "dancer" l'axe C
           if abs(ty) <= bruit, ty = 0
           #"voir les vecteurs avant mais apres =", *tx, *ty, *tz,  e$
           if tx = 0 & ty = 0, tz = 1

           #if gcode$ = 0, fr$ = frap5x
           if gcode$ = 0, fr$ = -2
           gcode$ = 1


pcal5xcontinue   # calcul des axes reel suivant cinematique machine
                    #"voir les vecteur", *tx, *ty, *tz, e$
                    polarite  # voir choix polariter B+ ou B-
                    if type_axe = 1, # mode classic A et C triede de base
                        [
                        if polarite_axe = 1,
                                        [
                                        axeC5x = (atan2(-ty,tx))
                                        axeAB5x = acos(tz)
                                        ]
                        else,
                                        [
                                        axeC5x = (atan2(ty,-tx))
                                        axeAB5x = acos(tz) * -1
                                        ]
                        ]
                    if type_axe = 2, # mode classic B et C triede de base
                        [
                        if polarite_axe = 1,
                                        [
                                        axeC5x = (atan2(-ty,tx))
                                        axeAB5x = acos(tz)
                                        ]
                        else,
                                        [
                                        axeC5x = (atan2(ty,-tx))
                                        axeAB5x = acos(tz) * -1
                                        ]
                        ]
                    if type_axe = 3, # mode  B sur la tete et C sur table
                        [
                        if polarite_axe = 1,
                                        [
                                        axeC5x = (atan2(-ty,tx))
                                        axeAB5x = acos(tz)
                                        ]
                        else,
                                        [
                                        axeC5x = (atan2(ty,-tx))
                                        axeAB5x = acos(tz) * -1
                                        ]
                        ]
                    if     type_axe = 4, # mode axe porte a 45 degre par un autre
                        [
                        if polarite_axe = 1, axeCbase = (atan2(-ty,tx))
                        else, axeCbase = (atan2(ty,-tx))
                        axeAB5x = acos((2*tz)-1)
                        if axeAB5x <> 180 & axeAB5x <> 0, axeC5x = atan((tan(axeAB5x/2))*(sqrt(2)/2))
                                        else,
                                            [
                                            if axeAB5x = 180, axeC5x = 90
                                            if axeAB5x = 0, axeC5x = 0
                                            ]
                                        axeC5x = axeC5x + axeCbase + 180
                                        if axeC5x >= 360, axeC5x = axeC5x - 360
                                        axeC5x = axeC5x * polarite_axe
                                        axeAB5x = axeAB5x * polarite_axe
                        ]
                    if     type_axe = 5, # mode axe porte a 45 degre en vue de dessus ( dans un angle)
                        [
                        pcalcul_type_axe_5
                        axeAB5x = axeAB5xsimu
                        axeC5x = axeC5xsimu
                        xabs = x$
                        yabs = y$
                        zabs = z$

                        ]




pmx_5axes   # Gestion en 5 axes continue
            #"on est dans pmx$", e$
            if type_pp = 2, ecrivec = 1
             pcalpmx

               if debutpmx = 1,   # 1 er mouvement 5 axe donc positionnement via un cycle plane
                        [
                        if ecrivec = 0,  # ecriture en mode vectoriel
                                [
                                   #pcal5xpos
                                   gcode$ = 0
                                    axeC = atan2(tx,-ty)
                                    axeAB = acos(tz)
                                    # Calcul du point 3d exprimer dans le repere Spacial pour pre-placement
                                    x1 =  x$ * cos(axeC*-1) - y$ * sin(axeC*-1)
                                    y1 =  x$ * sin(axeC*-1) + y$ * cos(axeC*-1)
                                       z1 =   z$ * cos(axeAB) - y1 * sin(axeAB)
                                    y2 =   z$ * sin(axeAB) + y1 * cos(axeAB)
                                    #" XYZ base=", x$, " y=", y$ , " z=", z$ , e$
                                    #" 1er dep = X1=",*x1," Y1=",*y1, " Z =", *z$, e$
                                       #" 2em dep = X2=", *x1," Y2=",*y2, " Z1=",*z1, e$

                                    xabs3d = x1
                                    yabs3d = y2
                                    zabs3d = z1

                                    n$, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ",sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                    if type_axe = 5, pcalcul_type_axe_5, n$, sdcom, "AXES REEL MACHINE", *axeC5xsimu,*axeAB5xsimu, sfcom, e$  # on est en mode axe machine non classic

                                    if type_axe  = 3,   # pre placement pour un axe B sur la tete
                                                            [
                                                            xabs = x$
                                                            yabs = y$
                                                             zabs = z$
                                                            n$, "PLANE RESET STAY", e$
                                                            n$, "M128 M126",e$
                                                            gcode$ = 0
                                                            n$, `sgcode, sinc_abs, *xabs, *yabs, pfr, *spdlon, e$
                                                            n$, `sgcode, sinc_abs, *zabs, pfr, e$
                                                            n$, "M129",e$
                                                            n$, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ", sfmax5x, p_casse_modalite_avance, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                                            ]

                                    n$, `sgcode, *xabs3d, *yabs3d, pfr, *spdlon, e$
                                    n$, `sgcode, *zabs3d, pfr, plubrifon, e$
                                    #n$, "L X+0 Y+0 R0 FMAX", e$
                                    n$, "PLANE RESET STAY", e$
                                    n$, "M128 M126",e$
                                    n$, "LN" , *xabs, *yabs, *zabs, *tx, *ty, *tz, pfr,e$
                                    debutpmx = 0
                                ]
                           if ecrivec = 1,  # ecriture en mode angle reel AC ou BC
                                [
                                pdril5x_cal
                                gcode$ = 0
                                comment$
                                if type_pp = 1,
                                                [
                                                n$, `sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, e$ #ssa, pgamme, *spdlon, e$
                                                 n$, `sgcode, *zabs,pcord, pfr, e$
                                                n$, "PLANE RESET STAY", e$
                                                ]
                                if type_pp = 2,
                                                [
                                                sr, *xabs, *yabs, *zabs,axeC5xsimu, axeAB5xsimu, sfsimurapid, paf,`sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, sm, degagez,  e$ #ssa, pgamme, *spdlon, e$
                                                 sr, *xabs, *yabs,*zabs, sfsimurapid, paf,`sgcode, *zabs,pcord, pfr, e$
                                                sm, paf, "PLANE RESET STAY", e$
                                                ]
                                if type_pp = 1,
                                                [
                                                n$, "M128 M126",e$
                                                n$, "CYCL DEF 32.0 TOLERANCE",e$
                                                n$, "CYCL DEF 32.1 T0.1", e$
                                                n$, "CYCL DEF 32.2 HSC-MODE:0 TA0.25",e$
                                                n$, "L", *spdlon, e$
                                                ]
                                if type_pp = 2,
                                                [
                                                sm, paf, "M128 M126",e$
                                                sm, paf, "CYCL DEF 32.0 TOLERANCE",e$
                                                sm, paf, "CYCL DEF 32.1 T0.1", e$
                                                sm, paf, "CYCL DEF 32.2 HSC-MODE:0 TA0.25",e$
                                                sm, paf, "L", *spdlon, e$
                                                #"MW_MACHINE_AXIS_INTERPOLATION_BY_THRESHOLD_ANGLE 90", e$
                                                ]
                                if fr$ = -2, gcode$ = 0
                                pcal5xcontinue
                                xabs = x$
                                yabs = y$
                                zabs = z$
                                if type_pp = 1, n$, "L" , *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, pfr, e$
                                if type_pp = 2,
                                                [
                                                if gcode$ = 0, sr, *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, sfsimurapid, paf, "L" , *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, pfr, e$
                                                if gcode$ = 1, sl, *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, pfr, paf, "L" , *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, avance, e$
                                                #"MW_MACHINE_AXIS_INTERPOLATION_BY_THRESHOLD_ANGLE 90", e$
                                                ]
                    debutpmx = 0
                                ]
                        ]
            else,             # # mouvement suivant 5 axe apres le 1er mouvement
                    [
                    if fr$ = -2, gcode$ = 0
                    pcal5xcontinue
                    #"voir old vecteur= ", *old_tx, *old_ty, *old_tz, e$
                    #"voir vecteur= ", *tx, *ty, *tz, e$
                    # algo pour autoriser le changement de polarite de B ( passage de B+ a B- )
                                if old_tx = 0 & old_ty = 0,"" # on fait rien si on est dessus
                                else,
                                   [
                                   #"voir old vecteur= ", *old_tx, *old_ty, *old_tz, e$
                                   #"voir  vecteur= ", *tx, *ty, *tz, e$
                                if  (old_tx <= 0 & tx >= 0 & old_ty <= 0 & ty >= 0) |
                                       (old_tx >= 0 & tx <= 0 & old_ty >= 0 & ty <= 0) |
                                       (old_tx <= 0 & tx >= 0 & old_ty >= 0 & ty <= 0) |
                                       (old_tx >= 0 & tx <= 0 & old_ty <= 0 & ty >= 0),
                                            [
                                            changpolar_AB = changpolar_AB * -1 # flag pour definir le changement de cote , on change
                                            " ; Changement de polarite", e$
                                            pcal5xcontinue
                                            ]
                                    ]

                    axeC5x = cont_axeC + axeC5x
                    if tx = 0 & ty = 0, axeC5x = old_axeC  # on maintien C quand on est en vertical
                    dif_axeC = axeC5x - old_axeC
                    absdif = abs(dif_axeC)
                    if absdif > 180, pcont # compte tour de l'axe C
                    if ecrivec = 0, n$, "LN" , *xabs, *yabs, *zabs, *tx,*ty,*tz, pfr,e$
                    if ecrivec = 1,
                                [
                                if axeAB5x > maxi_B | axeAB5x < mini_B, pchange_sens   # on se retrouve en butee d'axe B donc procedure de changement de cote





                                if type_pp = 1, n$, "L" , *xabs, *yabs, *zabs, *axeAB5x,*axeC5x,plubrifon, pfr,e$
                                if type_pp = 2,
                                            [
                                            if gcode$ = 0, sr, *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, sfsimurapid, paf, "L" , *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, pfr, e$
                                            if gcode$ = 1,
                                                        [
                                                        dif_c = abs(axeC5x - old_axeC)
                                                        if dif_c > delta,
                                                                         [
                                                                         v_delta_x = xabs - old_xabs_simu
                                                                         v_delta_y = yabs - old_yabs_simu
                                                                         v_delta_z = zabs - old_zabs_simu
                                                                         v_delta_xyz = sqrt(v_delta_x^2 + v_delta_y^2 + v_delta_z^2)
                                                                         v_sindir_x = v_delta_x/v_delta_xyz
                                                                         v_sindir_y = v_delta_y/v_delta_xyz
                                                                         v_sindir_z = v_delta_z/v_delta_xyz
                                                                         v_delta_div = v_delta_xyz / 10
                                                                        v_abs_plus_x = v_delta_div * v_sindir_x
                                                                         v_abs_plus_y = v_delta_div * v_sindir_y
                                                                         v_abs_plus_z = v_delta_div * v_sindir_z
                                                                         while conttour < 10,   # on coupe en 10 le mouvement pour une simulation plus reel
                                                                                             [
                                                                                             conttour = 1 + conttour
                                                                                             x_inter = old_xabs_simu + (v_abs_plus_x * conttour)
                                                                                             y_inter = old_yabs_simu + (v_abs_plus_y * conttour)
                                                                                             z_inter = old_zabs_simu + (v_abs_plus_z * conttour)
                                                                                             delta_c = (old_axeC - axeC5x) / 10
                                                                                            delta_b = (old_axeB - axeAB5x) / 10
                                                                                             c_inter = (old_axeC - delta_c * conttour)
                                                                                            b_inter = (old_axeB - delta_b * conttour)
                                                                                             sl, *x_inter, *y_inter, *z_inter, *b_inter, *c_inter, pfr, pafcom, "MOUVEMENT DE RATTRAPAGE", e$
                                                                                              ]
                                                                             ]
                                                        sl, *xabs, *yabs, *zabs, *axeAB5x, *axeC5x, pfr, paf, "L" , *xabs, *yabs, *zabs, *axeAB5x, *axeC5x,
                                                        if avance <> -1, avance, e$
                                                        else, e$
                                                        ]
                                        #"MW_MACHINE_AXIS_INTERPOLATION_BY_THRESHOLD_ANGLE 0.5", e$
                                        ]
                            ]
                ]
    old_axeC = axeC5x
    old_axeB = axeAB5x
    old_xabs_simu = xabs
    old_yabs_simu = yabs
    old_zabs_simu = zabs
    old_x = xabs
    old_y = yabs
    old_z = zabs
    old_vx = vx
    old_vy = vy
    old_vz = vz
    old_u = u$
    old_v = v$
    old_w = w$
    old_tx = tx
    old_ty = ty


    conttour = 0




fmt "dif_c" 1 dif_c
fmt "delta" 1 delta
fmt "old_xabs_simu" 1 old_xabs_simu
fmt "old_yabs_simu" 1 old_yabs_simu
fmt "old_zabs_simu" 1 old_zabs_simu
fmt "v_delta_x" 1 v_delta_x
fmt "v_delta_y" 1 v_delta_y
fmt "v_delta_z" 1 v_delta_z
fmt "v_delta_xyz" 1 v_delta_xyz
fmt "v_sindir_x" 1 v_sindir_x
fmt "v_sindir_y" 1 v_sindir_y
fmt "v_sindir_z" 1 v_sindir_z
fmt "v_delta_div" 1 v_delta_div
fmt "v_abs_plus_x" 1 v_abs_plus_x
fmt "v_abs_plus_y" 1 v_abs_plus_y
fmt "v_abs_plus_z" 1 v_abs_plus_z
fmt "conttour" 1 conttour
fmt "X" 3 x_inter
fmt "Y" 3 y_inter
fmt "Z" 3 z_inter
fmt "delta_c" 1 delta_c
fmt "delta_b" 1 delta_b
fmt "C" 3 c_inter
fmt "B" 3 b_inter
fmt "Old-vx" 1 old_vx
fmt "Old-vy" 1 old_vy
fmt "Old-vz" 1 old_vz

conttour : 0
delta : 90

pmx_end$  # Operation  premier mouvement
        if opcode$ = 16, ex$
        if debutpmx = 1, pmx$



pmx_4axes        # Gestion 4 axes continue avec fonction 5 axes
            if debutpmx = 1, pmx_4axes_2
            if debutpmx = 0,
                                [
                                if gcode$ = 1,     [
                                                @xabs, @yabs, @old_x, @old_y, @axeA, @old_axeA
                                                if xabs <> old_x | yabs <> old_y | axeA <> old_axeA,
                                                                                                    [
                                                                                                    if type_pp = 1,poriusinul, n$, sinc_abs, sgcode, pxyz, paxeA, pcord, pfr, e$
                                                                                                    if type_pp = 2, sm,paf,poriusinul,sl,pxyz, paxeA, pfr, paf,sinc_abs, sgcode, pxyz, paxeA, pcord, pfr, e$
                                                                                                    ]

                                                                                                else,
                                                                                                    [
                                                                                                    if type_pp = 1,poriusinul, n$, sinc_abs, sgcode, pxyz, paxeA, pfr, e$
                                                                                                    if type_pp = 2,sm,paf,poriusinul,sl, pxyz, paxeA, pfr, paf,sinc_abs, sgcode, pxyz, paxeA, pfr, e$
                                                                                                    ]
                                                   ]
                                if gcode$ = 0,     [
                                                if type_pp = 1, n$, sinc_abs, sgcode, pxyz, paxeA, pfr, e$
                                                if type_pp = 2, sr, pxyz, paxeA, sfsimurapid, paf,sinc_abs, sgcode, pxyz, paxeA, pfr, e$
                                                ]
                                ]
            old_x = xabs
            old_y = yabs
            old_z = zabs

pmx_4axes_2   # debut du 4 axes continue
            bloque = 2
            if use_bloque = 0, bloque = 0
            if type_pp = 1,n$, sbloque, e$
            if type_pp = 2,sm,paf, sbloque, e$
            gcode$ = 0
            poriusi
            if type_pp = 1,n$, sinc_abs, *sgcode, *xabs, *yabs, paxeA, pfr, *spdlon, e$
            if type_pp = 2,sr,*xabs, *yabs, paxeA, sfsimurapid, paf,sinc_abs, *sgcode, *xabs, *yabs, paxeA, pfr, *spdlon, e$
            paffiche_outil_suivant
            if type_pp = 1,n$, sinc_abs, sgcode, *zabs, pfr, e$
            if type_pp = 2,sr,*zabs,sfsimurapid,paf,sinc_abs, sgcode, *zabs, pfr, e$
            !x$, !y$, !z$, !xr$, !yr$, !zr$
            p_modal
            debutpmx = 0



pcalangleC  # sortie des solutions angle pour C avec matrix sur Z

            axeC = (atan2(m7$,m8$))
            "voir axeC solution 1 =", *axeC, e$
            axeC = (atan2(-m7$,m8$))
            "voir axeC solution 2 =", *axeC, e$
            axeC = (atan2(m7$,-m8$))
            "voir axeC solution 3 =", *axeC, e$
            axeC = (atan2(-m7$,-m8$))
            "voir axeC solution 4 =", *axeC, e$
            axeC = (atan2(m8$,m7$))
            "voir axeC solution 5 =", *axeC, e$
            axeC = (atan2(-m8$,m7$))
            "voir axeC solution 6 =", *axeC, e$
            axeC = (atan2(m8$,-m7$))
            "voir axeC solution 7 =", *axeC, e$
            axeC = (atan2(-m8$,-m7$))


fmt "Base_a=" 1 base_a
fmt "Base_b=" 1 base_b
fmt "Base_c=" 1 base_c
fmt "Base_d=" 1 base_d


psortical

            axeC = (atan2(base_a,base_b))
            "voir axeC solution 1 =", *axeC, e$
            axeC = (atan2(-base_a,base_b))
            "voir axeC solution 2 =", *axeC, e$
            axeC = (atan2(base_a,-base_b))
            "voir axeC solution 3 =", *axeC, e$
            axeC = (atan2(-base_a,-base_b))
            "voir axeC solution 4 =", *axeC, e$
            axeC = (atan2(base_b,base_a))
            "voir axeC solution 5 =", *axeC, e$
            axeC = (atan2(-base_b,base_a))
            "voir axeC solution 6 =", *axeC, e$
            axeC = (atan2(base_b,-base_a))
            "voir axeC solution 7 =", *axeC, e$
            axeC = (atan2(-base_b,-base_a))
            "voir axeC solution 8 =", *axeC, e$

            axeC = (atan2(base_a,base_c))
            "voir axeC solution 9 =", *axeC, e$
            axeC = (atan2(-base_a,base_c))
            "voir axeC solution 10 =", *axeC, e$
            axeC = (atan2(base_a,-base_c))
            "voir axeC solution 11 =", *axeC, e$
            axeC = (atan2(-base_a,-base_c))
            "voir axeC solution 12 =", *axeC, e$
            axeC = (atan2(base_c,base_a))
            "voir axeC solution 13 =", *axeC, e$
            axeC = (atan2(-base_c,base_a))
            "voir axeC solution 14 =", *axeC, e$
            axeC = (atan2(base_c,-base_a))
            "voir axeC solution 15 =", *axeC, e$
            axeC = (atan2(-base_c,-base_a))
            "voir axeC solution 16 =", *axeC, e$

            axeC = (atan2(base_a,base_d))
            "voir axeC solution 9 =", *axeC, e$
            axeC = (atan2(-base_a,base_d))
            "voir axeC solution 10 =", *axeC, e$
            axeC = (atan2(base_a,-base_d))
            "voir axeC solution 11 =", *axeC, e$
            axeC = (atan2(-base_a,-base_d))
            "voir axeC solution 12 =", *axeC, e$
            axeC = (atan2(base_d,base_a))
            "voir axeC solution 13 =", *axeC, e$
            axeC = (atan2(-base_d,base_a))
            "voir axeC solution 14 =", *axeC, e$
            axeC = (atan2(base_d,-base_a))
            "voir axeC solution 15 =", *axeC, e$
            axeC = (atan2(-base_d,-base_a))
            "voir axeC solution 16 =", *axeC, e$




pcalangle  # sortie des solutions angle toutes solution possible, principe de trouver l'angle voulu par eliteration soit 16 fois 24 possibilite
            " groupe solution 1", e$
            base_a = m1$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 2", e$
            base_a = m1$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical

            " groupe solution 3", e$
            base_a = m1$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

            " groupe solution 4", e$
            base_a = m2$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 5", e$
            base_a = m2$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$


            psortical
            " groupe solution 6", e$
            base_a = m2$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

            " groupe solution 7", e$
            base_a = m3$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 8", e$
            base_a = m3$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
            " groupe solution 8", e$
            base_a = m3$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

            " groupe solution 9", e$
            base_a = m4$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 10", e$
            base_a = m4$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
            " groupe solution 11", e$
            base_a = m4$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

             " groupe solution 12", e$
            base_a = m5$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 13", e$
            base_a = m5$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
              " groupe solution 14", e$
            base_a = m5$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$
            psortical

             " groupe solution 15", e$
            base_a = m6$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 16", e$
            base_a = m6$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
            " groupe solution 17", e$
            base_a = m6$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

            " groupe solution 18", e$
            base_a = m7$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 19", e$
            base_a = m7$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
             " groupe solution 20", e$
            base_a = m7$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

                " groupe solution 21", e$
            base_a = m8$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 22", e$
            base_a = m8$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
               " groupe solution 23", e$
            base_a = m8$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$

            psortical

             " groupe solution 24", e$
            base_a = m9$   # a remplacer pour touver angle voulu
            base_b = m1$
            base_c = m2$
            base_d = m3$

            psortical
            " groupe solution 25", e$
            base_a = m9$   # a remplacer pour touver angle voulu
            base_b = m4$
            base_c = m5$
            base_d = m6$

            psortical
            " groupe solution 26", e$
            base_a = m9$   # a remplacer pour touver angle voulu
            base_b = m7$
            base_c = m8$
            base_d = m9$


polarite     # determine la polarite des angles de base suivant sansbase ( voir au debut ) et de mi2$
             if presence_axe_C = 1,   # on as un axe C
                         [
                        if mi2$ = -1,  # on inverse le sens de polarite
                            [
                            if sensbase = -1, seq = seqplus, polarite_axe = 1
                            else, seq = seqmoins, polarite_axe = -1
                            ]
                        else,
                            [
                            if sensbase = -1, seq = seqmoins, polarite_axe = -1
                            else, seq = seqplus, polarite_axe = 1
                            ]
                        polarite_axe = polarite_axe * changpolar_AB # on change si on est arriver en bute B
                        ]
                else,   # pas d'axe C donc gestion gauche droite autour de la piece
                        [
                        if m7$ >=0, seq = seqplus, polarite_axe = 1
                        else, seq = seqmoins, polarite_axe = -1
                        ]

pcalcul_type_axe_5    # partie commune pour le calcul de vrais angle pour config machine axe B (A) non classic ( DMU 40 evo, etc.. )
                        # ATTENTION ICI COMMENCE LE CALCUL PAR MODE TRIGONOMETRIE SPHERIQUE;;; PREVOIR ASPIRINE

                                        #"voir les vecteurs =", *tx, *ty, *tz,  e$
                                        # ON DOIT POSER LES 3 VECTEURS, vecteur outil A, vecteur machine B, origine C
                                        #"voir chanpolar dans calcul 5 ax=" , *changpolar_AB, e$
                                        # calcul entre origine et vecteur machine CoA
                                        # on considere un triangle forme par CoA
                                        # on a donc un triangle avec 3 cotes de longeur OA, OC et CA
                                    long_OA = 1 # C4EST LE VECTEUR Z PUR DONC 1
                                    long_OC = 1 # C'est l'axe de
                                    long_OB = 1
                                    long_AC = sqrt((0 - tx)^2 + (0 - ty)^2 + (1 - tz)^2)
                                    long_CB = sqrt((0 - Vect_porteur_x)^2 + (0 - Vect_porteur_y)^2 + (1 - Vect_porteur_z)^2)
                                    long_AB = sqrt((tx - Vect_porteur_x)^2 + (ty - Vect_porteur_y)^2 + (tz - Vect_porteur_z)^2)
                                    #"voir les distances:" *long_OA,*long_OC, *long_AB, *long_AC, *long_CB, e$

                                   if abs(tz) <> 1,
                                   [

                                        # TROUVER LA POLARITE dans un premier temp SI ON EST A GAUCHE OU A DROITE DE L'axe B
                                        angle_axeB = atan2(Vect_porteur_y,Vect_porteur_x)
                                        angle_axe_outil = atan2(ty,tx)
                                        #*angle_axeB, e$
                                        #*angle_axe_outil, e$
                                        dif_angle_B_outil = angle_axe_outil - angle_axeB
                                        if dif_angle_B_outil < 0,  dif_angle_B_outil = dif_angle_B_outil + 360
                                        #*dif_angle_B_outil, e$
                                        if dif_angle_B_outil < 180, sens_axe_outil = -1 #* changpolar_AB
                                        else, sens_axe_outil = 1 #* changpolar_AB
                                        #sens_axe_outil = 1
                                        #"voir le sens outil", *sens_axe_outil, e$

                                        # suivant la loi des cosinus angle = acosinus de la sommes des carre des vecteur adjasent et opposer - hypotenus au carre le tout diviser par  2 fois adjacent fois opposer

                                        cosangle_b = (long_OC^2 + long_OA^2 - long_AC^2)/(2*long_OC*long_OA)
                                        cosangle_c = (long_OB^2 + long_OA^2 - long_AB^2)/(2*long_OB*long_OA)
                                        cosangle_a = (long_OC^2 + long_OB^2 - long_CB^2)/(2*long_OC*long_OB)

                                        if cosangle_a <= 1 & cosangle_a >= -1,angle_b = (acos(cosangle_b))
                                        if cosangle_b <= 1 & cosangle_b >= -1,angle_c = (acos(cosangle_c))
                                        if cosangle_c <= 1 & cosangle_c >= -1,angle_a = (acos(cosangle_a))

                                        #"voir ", *angle_a,*angle_b,*angle_c, e$

                                        produit_p_base = (angle_a + angle_b + angle_c)/2
                                        produitAA = ((sin(produit_p_base - angle_a))*(sin(produit_p_base - angle_b)))
                                        produitBB = ((sin(angle_a))*(sin(angle_b)))
                                        produitCC = ((sin(produit_p_base))*(sin(produit_p_base - angle_c)))

                                        #"voir les produits= ", *produitAA, *produitBB, *produitCC, e$
                                        # on calcul l'ouverture angulaire entre A et B outour de C en vue de dessus


                                        # il faut verifier les valeur pour pas de division par 0 ou SQRT de 0

                                        C_angle_base_sin = sqrt(produitAA/produitBB)
                                        #C_angle_base_sin = (  (sqrt (((sin(produit_p_base - angle_a))*(sin(produit_p_base - angle_b)))/(sin(angle_a)*(sin(angle_b))))))

                                        if Vect_porteur_x, C_angle_base_cos = sqrt(produitCC/produitBB), else,  C_angle_base_cos = 0
                                        #C_angle_base_cos = (  (sqrt (((sin(produit_p_base))*(sin(produit_p_base - angle_c)))/(sin(angle_a)*(sin(angle_b))))))
                                        C_angle_base = (atan2(C_angle_base_sin,C_angle_base_cos))*2

                                        #"voir primaire de ", *C_angle_base, e$
                                        # on calcul l'ouverture angulaire entre A et B outour de C en vue de dessus souhaiter, en fait angle c = angle a
                                        angle_c = angle_a
                                        produit_p_souhaiter = (angle_a + angle_b + angle_c)/2
                                        C_angle_souhaiter_sin = (  (sqrt (((sin(produit_p_souhaiter - angle_a))*(sin(produit_p_souhaiter - angle_b)))/(sin(angle_a)*(sin(angle_b))))))
                                        C_angle_souhaiter_cos = (  (sqrt (((sin(produit_p_souhaiter))*(sin(produit_p_souhaiter - angle_c)))/(sin(angle_a)*(sin(angle_b))))))
                                        C_angle_souhaiter = (atan2(C_angle_souhaiter_sin,C_angle_souhaiter_cos))*2
                                        #"voir", *C_angle_souhaiter, e$

                                        # Il reste a sortir la differance pour connaitre de combien ou tourne C
                                        C_rotation = C_angle_souhaiter - C_angle_base
                                        #"Voir ", *C_rotation, e$
                                         C_angle_reel_droite =  ( C_angle_base * 2 ) + C_rotation
                                         C_angle_reel_gauche = C_rotation
                                        if C_angle_reel_droite > 180, C_angle_reel_droite = C_angle_reel_droite -360
                                        if C_angle_reel_gauche > 180, C_angle_reel_gauche = C_angle_reel_gauche -360


                                        #"Voir creel= ", *C_angle_reel, e$


                                        # on calcul l'ouverture angulaire entre A et C outour de B dans l'axe B ( axe de rottation de travers de la machine pour rappel )
                                        produit_p_B = (angle_a + angle_b + angle_c)/2
                                        B_angle_sin = (  (sqrt (((sin(produit_p_B - angle_c))*(sin(produit_p_B - angle_a)))/(sin(angle_c)*(sin(angle_a))))))
                                        B_angle_cos = (  (sqrt (((sin(produit_p_B))*(sin(produit_p_B - angle_b)))/(sin(angle_c)*(sin(angle_a))))))
                                        B_rotation = (atan2(B_angle_sin,B_angle_cos))*2
                                        #"voir les angles -----------", *B_rotation, e$
                                        # sens des axes
                                         if polarite_axe = 1, # on est en Mode seq+
                                            [
                                            if sens_axe_outil = -1, # l'outil est du cote negatif
                                                [
                                                C_angle_reel = C_angle_reel_droite * changpolar_C * -1 * sens_de_C
                                                B_rotation = B_rotation  * -1 * sens_de_B
                                                ]
                                            else,
                                                [
                                                C_angle_reel = C_angle_reel_gauche * changpolar_C * -1 * sens_de_C
                                                B_rotation = B_rotation *  -1 * sens_de_B
                                                ]
                                            ]
                                        else,     # on est en Mode seq-
                                            [
                                            if sens_axe_outil = -1, # l'outil est du cote negatif
                                                [
                                                C_angle_reel = C_angle_reel_gauche * changpolar_C * sens_de_C
                                                B_rotation = B_rotation * sens_de_B
                                                ]
                                            else,
                                                [
                                                C_angle_reel = C_angle_reel_droite * changpolar_C * sens_de_C
                                                B_rotation = B_rotation * sens_de_B
                                                ]
                                            ]
                                        #"voir les angles reel ", *B_rotation, *C_angle_reel, e$
                                        axeAB5xsimu = B_rotation
                                        axeC5xsimu = C_angle_reel
                                        ]
                                    else, # on est en dessus
                                        [
                                        axeC5xsimu = 0
                                        axeAB5xsimu = 0


                                    ]

ppalpage


        #palpage = 0

        if palpage = 1, ppalpage1
        if palpage = 2, ppalpage2



ppalpage1

        n$, "TOOL CALL 30 Z", e$

        bq321 = (xmin+((xmax-xmin)/2))
        bq322 = (ymin+((ymax-ymin)/2))
        bq323 = (xmax-xmin)
        bq324 = (ymax-ymin)
        bq261 = (zmax-10)
        bq320 = 10
        bq260 = zmax + 50
        bq301 = 1
        bq305 = 1
        bq331 = ymin
        bq332 = xmin
        bq303 = 1
        bq381 = zmax
        bq382 = 0
        bq383 = 0
        bq384 = 0
        bq333 = zmax

        n$, "TCH PROBE 411 PT REF. EXT. RECTAN. ~", e$
            bq321, "   ;CENTRE 1ER AXE ~", e$
            bq322, "   ;CENTRE 2EME AXE ~", e$
            bq323, "   ;1ER COTE ~", e$
            bq324, "   ;2EME COTE ~", e$
            bq261, "    ;HAUTEUR DE MESURE ~", e$
            bq320, "    ;DISTANCE D'APPROCHE ~", e$
            bq260, "  ;HAUTEUR DE SECURITE ~", e$
            bq301, "    ;DEPLAC. HAUT. SECU. ~", e$
            bq305, "    ;NO. DANS TABLEAU ~", e$
            bq331, "    ;POINT DE REFERENCE ~", e$
            bq332, "    ;POINT DE REFERENCE ~", e$
            bq303, "    ;TRANSF. VAL. MESURE ~", e$
            bq381, "    ;PALP. DS AXE PALPEUR ~", e$
            bq382, "    ;1.COO.POUR AXE PALP. ~", e$
            bq383, "    ;2.COO.POUR AXE PALP. ~", e$
            bq384, "    ;3.COO.POUR AXE PALP. ~", e$
            bq333, "    ;POINT DE REFERENCE", e$

ppalpage2


        n$, "TOOL CALL 30 Z", e$

        bq321 = (xmin+((xmax-xmin)/2))
        bq322 = (ymin+((ymax-ymin)/2))
        bq262 = xmax - xmin
        bq325 = 0
        bq247 = 90
        bq261 = (zmax-10)
        bq320 = 10
        bq260 = zmax + 50
        bq301 = 1
        bq305 = 1
        bq331 = (ymin+((ymax-ymin)/2))
        bq332 = (xmin+((xmax-xmin)/2))
        bq303 = -1
        bq381 = zmax
        bq382 = 0
        bq383 = 0
        bq384 = 0
        bq333 = zmax
        bq423 = 4
        bq365 = 1

        n$, "TCH PROBE 413 PT REF. EXT. CERCLE ~", e$
            bq321, "   ;CENTRE 1ER AXE ~", e$
            bq322, "   ;CENTRE 2EME AXE ~", e$
            bq262, "    ;DIAMETRE NOMINAL ~", e$
            bq325, "    ;ANGLE INITIAL ~", e$
            bq247, "   ;INCREMENT ANGULAIRE ~", e$
            bq261, "    ;HAUTEUR DE MESURE ~", e$
            bq320, "    ;DISTANCE D'APPROCHE ~", e$
            bq260, "  ;HAUTEUR DE SECURITE ~", e$
            bq301, "    ;DEPLAC. HAUT. SECU. ~", e$
            bq305, "    ;NO. DANS TABLEAU ~", e$
            bq331, "    ;POINT DE REFERENCE ~", e$
            bq332, "    ;POINT DE REFERENCE ~", e$
            bq303, "    ;TRANSF. VAL. MESURE ~", e$
            bq381, "    ;PALP. DS AXE PALPEUR ~", e$
            bq382, "    ;1.COO.POUR AXE PALP. ~", e$
            bq383, "    ;2.COO.POUR AXE PALP. ~", e$
            bq384, "    ;3.COO.POUR AXE PALP. ~", e$
            bq333, "    ;POINT DE REFERENCE ~", e$
            bq423, "    ;NB POINTS DE MESURE ~", e$
            bq365, "    ;TYPE DEPLACEMENT", e$

pcal5xpos  # conversion de la matrice pour le calcul des angle en positionner 5 axes
                        #" on y est", e$
                        # Activer la partie matrice voulue
                        #pcalangleC    # a activer pour connaitre les solutions avec m7 m8 m9
                        #pcalangle   # a activer pour connaitre toute les solutions possible de la matrice
                        tx = m7$
                           ty = m8$
                           tz = m9$
                        #"voir polarite axe avant", *polarite_axe, e$
                        polarite
                        #"voir polarite axe apres", *polarite_axe, e$
                        if changpolar_AB = 1, axeC = atan2(m7$,-m8$)
                        if changpolar_AB = -1, axeC = atan2(-m7$,m8$)
                        axeAB = acos(m9$)
                                if type_axe = 1,
                                                [
                                                if polarite_axe = 1, axeC5xsimu = atan2(m7$,-m8$)
                                                else, axeC5xsimu = atan2(-m7$,m8$)
                                                if m9$ = 1,  axeC5xsimu = 0
                                                axeAB5xsimu = acos(m9$) * polarite_axe
                                                ]
                                if type_axe = 2,
                                                [
                                                if polarite_axe = 1, axeC5xsimu = atan2(-m8$,m7$)
                                                else, axeC5xsimu = atan2(m8$,-m7$)
                                                if m9$ = 1,  axeC5xsimu = 0
                                                axeAB5xsimu = acos(m9$) * polarite_axe
                                                ]
                                if type_axe = 3,
                                                [
                                                if polarite_axe = 1, axeC5xsimu = atan2(-m8$,m7$)
                                                else, axeC5xsimu = atan2(m8$,-m7$)
                                                if m9$ = 1,  axeC5xsimu = 0
                                                axeAB5xsimu = acos(m9$) * polarite_axe
                                                ]


                                if type_axe = 4,  # on est en mode axe porter a 45 degres
                                        [
                                        axeAB5xsimu = acos((2*m9$)-1)
                                        if axeAB5xsimu <> 180 & axeAB5xsimu <> 0, axeC5xsimu = atan((tan(axeAB5xsimu/2))*(sqrt(2)/2))
                                        else,
                                            [
                                            if axeAB5xsimu = 180, axeC5xsimu = 90
                                            if axeAB5xsimu = 0, axeC5xsimu = 0
                                            ]
                                        axeC5xsimu = axeC5xsimu + axeC + 270


                                        if axeC5xsimu >= 360, axeC5xsimu = axeC5xsimu - 360
                                        axeC5xsimu = axeC5xsimu * polarite_axe  # definition si solution gauche ou droite
                                        axeAB5xsimu = axeAB5xsimu * polarite_axe  # definition si solution gauche ou droite
                                        #"voir axeAB5xsimu=", *axeAB5xsimu, e$
                                        #"voir axeC5xsimu=", *axeC5xsimu, e$
                                        ]
                            if type_axe = 5, pcalcul_type_axe_5  # on est en mode axe machine non classic



                        if type_pp = 1, tourne = (atan2(m3$,m6$))
                        if percage5x <> 1,
                        [
                        m1p = m1$, m2p = m2$, m3p = m3$, m4p = m4$, m5p = m5$, m6p = m6$
                        !m1p, !m2p, !m3p, !m4p, !m5p, !m6p
                        if m1$ = 1 & m5$ = 1 & m9$ = 1, dessus = 1   # flag pour voir que l'on ne bouge pas
                        else, dessus = 0
                        if dessus = 1,
                                    [
                                    axeC = 0
                                    axeAB = 0
                                    tourne = 0
                                    if type_pp = 2, axeAB5xsimu = 0, axeC5xsimu = 0
                                    ]
                        if ecrit_plane_dessus = 1 , dessus = 0  # on ecrit le cycle plan meme en vue de dessus
                        ]
                        else,
                        [
                        tourne = 0
                        dessus = 0
                        ]
                        if tourne = 360, tourne = 0
                        if type_pp = 1 | type_pp = 5,
                                    [
                                    if axeAB5xsimu < mini_B | axeAB5xsimu > maxi_B, erreurtype = 2, perreur
                                    ]

fmt "X tourne=" 1 New_x_tourne
fmt "Y tourne=" 1 New_y_tourne




pcalxyz3d       #calcul de x y z dans un repere autre que dessus quand on est dans le repere origine piece 3 d
         #"voir les point de base X=",*x$, " Y=",*y$," Z=",*z$, e$
         #"Voir A C et Tourne, AxeA=", *axeAB, " AxeC=", *axeC, " Tourne=", *tourne, e$

         New_x_tourne = y$*sin(tourne*-1) + x$*cos(tourne*-1)
         New_y_tourne = y$*cos(tourne*-1) - x$*sin(tourne*-1)
         #" voir une fois passer dans tourne, ",  *New_x_tourne,  *New_y_tourne, e$


        @New_x_tourne,@New_y_tourne

        y1 =  New_y_tourne * cos(axeAB) - z$ * sin(axeAB)
        z1 =  New_y_tourne * sin(axeAB) + z$ * cos(axeAB)
        y2 =   y1 * cos(axeC * -1) - New_x_tourne * sin(axeC * -1)
        x1 =   y1 * sin(axeC * -1) + New_x_tourne * cos(axeC * -1)

        #" 1er dep = X=",*x$," Y1=",*y1, " Z1=", *z1, e$
        #" 2em dep = X1=", *x1," Y2=",*y2, " Z1=",*z1, e$

         xabs3d = x1
         yabs3d = y2
         zabs3d = z1



#----------- PREPARATION et calcul pour  DU PERCAGE 5 AXES ----------------


fmt "X1=" 1 x1
fmt "X2=" 1 x2
fmt "z2=" 3 z2
fmt "Y1=" 3 y1
fmt "Y2=" 3 y2
fmt "Z1=" 3 z1
fmt "U1=" 1 u1
fmt "W2=" 3 w2
fmt "V1=" 3 v1
fmt "V2=" 3 v2
fmt "W1=" 3 w1
fmt "chgtl" 4 chgtl
fmt "" 2 zgarde
fmt "" 2 zdebut_cycle

pcaldrilxyzsimu  # calcul des point dans le plan de l'axe outil
            #"voir xyz", *x$ ," ", *y$," ", *z$," ", *u$," ", *v$," ", *w$," ", *initht$, " ",*refht$," ", *depth$,   e$

            v_delta_x = x$ - u$
            v_delta_y = y$ - v$
            v_delta_z = z$ - w$
            v_delta_xyz = sqrt(v_delta_x^2 + v_delta_y^2 + v_delta_z^2)
            v_sindir_x = v_delta_x/v_delta_xyz
            v_sindir_y = v_delta_y/v_delta_xyz
            v_sindir_z = v_delta_z/v_delta_xyz

            #v_abs_plus_x = x$ + ((initht$ + depth$) * v_sindir_x)
            #v_abs_plus_y = y$ + ((initht$ + depth$) * v_sindir_y)
            #v_abs_plus_z = z$ + ((initht$ + depth$) * v_sindir_z)

            v_abs_plus_x = u$#x$ - (initht$ * v_sindir_x)
            v_abs_plus_y = v$#y$ - (initht$ * v_sindir_y)
            v_abs_plus_z = w$#z$ - (initht$ * v_sindir_z)
            #"voir v_abs_plus_x", " ",*v_abs_plus_x," ", *v_abs_plus_y," ", *v_abs_plus_z, e$



            #axeccalsimu = (atan2(m8$,m7$))
            axeccalsimu = axeC5xsimu
            #axeccalsimu = (atan2(m7$,-m8$))
            #axeacalsimu = (atan2(m8$,m9$))
            axeacalsimu = axeAB5xsimu
            #axeacalsimu = (atan2(m7$,m9$))
            #axeacalsimu = acos(m9$)
            x1 =  x$ * cos(axeccalsimu) - y$ * sin(axeccalsimu)
            y1 =  x$ * sin(axeccalsimu) + y$ * cos(axeccalsimu)
            z1 =  z$
            y2 =  y1 * cos(-axeacalsimu) - z1 * sin(-axeacalsimu)
            z2 =  y1 * sin(-axeacalsimu) + z1 * cos(-axeacalsimu)
            xabs = x$
            yabs = y$
            zabs = z$ # + ( depth$ * -1 + initht$ )
            #y1 =   z$ * cos(axeAB5xsimu) - y$ * sin(axeAB5xsimu)
            #z1 =   z$ * sin(axeAB5xsimu) + y$ * cos(axeAB5xsimu)
            #x1 =  y1 * cos(axeC5xsimu) - x$ * sin(axeC5xsimu)
            #y2 =  y1 * sin(axeC5xsimu) + x$ * cos(axeC5xsimu)
            #xabs = x1
            #yabs = y2
            #zabs = z1

pcaldrilxyz  # calcul des point dans le plan de l'axe outil
            x1 =  x$ * cos(-(axeC)) - y$ * sin(-(axeC))
            y1 =  x$ * sin(-(axeC)) + y$ * cos(-(axeC))
            z1 =  z$
            y2 =  y1 * cos(-axeAB) - z1 * sin(-axeAB)
            z2 =  y1 * sin(-axeAB) + z1 * cos(-axeAB)
            #"voir", *z1, *y1,*x1, *y2,*z2, e$

            u1 =   u$ * cos(-(axeC)) - v$ * sin(-(axeC))
            v1 =   u$ * sin(-(axeC)) + v$ * cos(-(axeC))
            w1 =   w$
            v2 =  v1 * cos(axeAB) - w1 * sin(axeAB)
            w2 =  v1 * sin(axeAB) + w1 * cos(axeAB)
            #  "voir", *u1, *v1,*v2,*w2, e$


pdril5x_cal    # placement pour percage 5 axes et debut de 5 axe continue definition des rotations et modification des coordonee pour pre placement avant 5 axes continue
                #"on calcul", e$
            vx = u$ - x$
            vy = v$ - y$
            vz = w$ - z$
            longvec=sqrt(vx * vx + vy * vy + vz * vz)
           #"voir ", *x$, *y$,*z$,*u$,*v$,*w$,*vx,*vy,*vz,*longvec,e$
           m7$ = (vx/longvec)
           m8$ = (vy/longvec)
           m9$ = (vz/longvec)
           m3$ = 0
           m6$ = 1
           #"voir les vecteur avant plane marche", m7$, m9$, m8$ , e$
           pcal5xpos
           @old_axeC, @axeC, @old_axeAB, @axeAB
           #"voir les angle ", *old_axeC, *axeC, *old_axeAB, *axeAB, e$
           if old_axeC <> axeC | old_axeAB <> axeAB, plane_marche    # ecriture des plane spacial
           old_axeC = axeC
           old_axeAB = axeAB
           !old_axeAB
           pcaldrilxyz
           #"voir initht=", *initht$, " refht=",*refht$, " depth=", *depth$, "zdrl=", *zdrl$, e$
            if type_pp = 1,    [
                            xabs = x1
                            yabs = y2
                            if opcode$ = 16, zabs = z2 + ( depth$ * -1 + initht$ )
                            else, zabs = z2
                            ]
            chgtl = 0
            old_x = xabs
            old_y = yabs
            old_z = zabs

pdril5x_cal2    # placement pour percage 5 axes entre continue  definition des rotations et modification des coordonee pour pre placement avant 5 axes continue
            vx = u$ - x$
            vy = v$ - y$
            vz = w$ - z$
            longvec=sqrt(vx * vx + vy * vy + vz * vz)
            #"voir ", *x$, *y$,*z$,*u$,*v$,*w$,*vx,*vy,*vz,*longvec,e$
            m7$ = (vx/longvec)
            m8$ = (vy/longvec)
            m9$ = (vz/longvec)
            old_axeC = axeC
            old_axeAB = axeAB
            !old_axeAB
            pcaldrilxyz
           #"voir initht=", *initht$, " refht=",*refht$, " depth=", *depth$, "zdrl=", *zdrl$, e$
            xabs = x1
            yabs = y2
            if opcode$ = 16, zabs = z2 + ( depth$ * -1 + initht$ )
            else, zabs = z2
            chgtl = 0
            old_x = xabs
            old_y = yabs
            old_z = zabs




#------------------- 4 Axes continue en substitution d'axe ---------------------------------------
#

plinarc  # Convertir les G2 G3 en G1

        linarc$ = 1
        if tolquestion <> 1, q8
        tolquestion = 1


p_Apos  # calcul de l'axe A en substitution

        @x$, @y$

        if diviseur = 1, axeA = (y$ * 360 / (pi$ * rotdia$)) * sens   # pour 4eme axe autour de X (substituer Y)
        if diviseur = 2, axeA = (x$ * 360 / (pi$ * rotdia$)) * sens   # pour 4eme axe autour de Y (substituer X)

    p_zdev          # calcul du Z en substitution

p_zdev  # calcul du Z en substitution

    @z$, @rotdia$
    zabs  = z$ +(rotdia$ /2)    # Z pour continue substitutuion en ABS


p_Apos_affiche  # affichage de l'angle au chg outil nul pour continue





           if useaxe <> 0, [

            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
                #"---------p_Apos_affiche-------", ee

           if epsi <> 0, [
            pdegage4_5axes, e$
         bloque = 2
         if use_bloque = 0, bloque = 0
            if type_pp = 1,n$, sbloque, e$
            if type_pp = 2,sm,paf,sbloque, e$
            if incremental = 0, [
                                if type_pp = 1,poriusi, n$, sgcode, sinc_abs, *axeA, !axeAi, pfr, sbloque, e$
                                if type_pp = 2,sm,paf,poriusi, sr, *axeA, !axeAi,sfsimurapid,paf, sgcode, sinc_abs, *axeA, !axeAi, pfr, sbloque, e$
                                ]
                        else,     [
                                if type_pp = 1,poriusi, n$, sgcode, sinc_abs, !axeA, *axeAi, pfr, sbloque, e$
                                if type_pp = 2,sm,paf,poriusi, sr,!axeA, *axeAi,sfsimurapid, paf, sgcode, sinc_abs, !axeA, *axeAi, pfr, sbloque, e$
                                ]
                        ]
            ]

        old_axeA = axeA



#------------------- 4 Axes positionne ---------------------------------------
#

probot

        if robot = 1, n$, "CALL PGM TNC:\lmo\robot", e$

prot0$  #   Tool plan view matrix du gcode 1014


prot$



prot1   # calcul de l'axe A en positionne

        @old_axeA, @nbrtour

        if diviseur = 1, axeA = atan2(m8$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de X
        if diviseur = 2, axeA = atan2(m7$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de Y
    axeA = axeA * sens                      # prise en compte du sens de rotation

    epsi = axeA - old_axeA                      # variation angulaire
    sensA = 0
    if epsi > 0, sensA = 1                      # sens de la variation
    if epsi < 0, sensA =  -1
    epsi = abs(epsi)
    @epsi, @sensA                           # mise a jour

            if epsi > 180,  [                   # optimisation de l'angle
        axeA = axeA - (360 * sensA)
                epsi = axeA - old_axeA
                sensA = 0
        if epsi > 0, sensA = 1
        if epsi < 0, sensA = -1
                        ]
        nbrtour = int (axeA / 360)                  # Calcul du nombre de tour

        # "----prot1-----valeur corigee------", *old_axeA, *axeA,*epsi,*sensA,*nbrtour, e


prot2   # affichage de l'angle au chg outil pour positionne


           if useaxe <> 0, [        # afficher les angle que si machine avec Axe A

            @old_axeA, @axeA        # mise a jour

            epsi = old_axeA - axeA  # regarder si on tourne
            epsi = abs(epsi)

            if epsi <> 0, [      # si ca tourne
            bloque = 2          # deblocage de l'axe A
            if use_bloque = 0, bloque = 0
            if type_pp = 1, n$, sbloque, e$
            if type_pp = 2, sm,paf, sbloque, e$
            if mi2$ = 0, bloque = 1         # preparer le blocage de l'axe A
            if use_bloque = 0, bloque = 0
            if type_pp = 1,    [
                            poriusi
                            if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, pfr, e$
                            else, n$, sgcode, sinc_abs, !axeA, *axeAi, pfr, e$
                            n$, sbloque, e$     # bloquer l'axe A
                            ]
            if type_pp = 2,    [
                            sm,paf,poriusi
                            if incremental = 0, sr, *axeA, !axeAi,sfsimurapid, paf,sgcode, sinc_abs, *axeA, !axeAi, pfr, e$
                            else, sr,!axeA, *axeAi,sfsimurapid,paf,sgcode, sinc_abs, !axeA, *axeAi, pfr, e$
                            sm,paf, sbloque, e$     # bloquer l'axe A
                            ]
                        ]

            ]

        old_axeA = axeA         # memo de la position de l'axe A affiche




prot3   # affichage de l'angle au chg outil nul pour positionne



           if useaxe <> 0, [        # afficher les angle que si machine avec Axe A

            @old_axeA, @axeA        # mise a jour

            epsi = old_axeA - axeA  # regarder si on tourne
            epsi = abs(epsi)

           if epsi <> 0, [      # si ca tourne

            #xabs = x$           # reprendre les positions xyz avant le degagement
            #yabs = y$
            #zabs = z$

            pdegage4_5axes        # Degagement machine avant la rotation de l'axe A

            bloque = 2          # deblocage de l'axe A
            if use_bloque = 0, bloque = 0
            if type_pp = 1,    n$, sbloque, e$
            if type_pp = 2,    sm,paf, sbloque, e$
            if mi2$ = 0, bloque = 1         # preparer le blocage de l'axe A
            if use_bloque = 0, bloque = 0

            if type_pp = 1,    [
                            if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, pfr, e$
                            else, n$, sgcode, sinc_abs, !axeA, *axeAi, pfr, e$
                            n$, sbloque, e$     # bloquer l'axe A
                            ]
            if type_pp = 2,    [
                            if incremental = 0, sr,*axeA, !axeAi,sfsimurapid, paf,sgcode, sinc_abs, *axeA, !axeAi, pfr, e$
                            else, sr, !axeA, *axeAi,sfsimurapid, paf,sgcode, sinc_abs, !axeA, *axeAi, pfr, e$
                            sm,paf, sbloque, e$     # bloquer l'axe A
                            ]
            if incremental = 0,
                                [           # Rappel des positions XYZ avant le degagement
                                if type_pp = 1,
                                                [
                                                n$, sgcode, sinc_abs, *xabs, *yabs, pfr, e$
                                                n$, sgcode, *zabs, pfr, e$
                                                p_modal
                                                ]
                                if type_pp = 2,
                                                [
                                                sr,*xabs, *yabs,sfsimurapid,paf,sgcode, sinc_abs, *xabs, *yabs, pfr, e$
                                                sr,*zabs,sfsimurapid,paf, sgcode, *zabs, pfr, e$
                                                p_modal
                                                ]
                                ]
                ]
            ]

        old_axeA = axeA         # memo de la position de l'axe A affiche


#sfauto : "F AUTO"
fmt  "F" 3 avance2
fmt  "F" 3 old_fr
#fmt  F  1 fr_pos$
pfrparam         # avance en parametre

        avance = fr$ #fr_pos$
        #avance2 = fr_pos$
        if gcode$ = 0, [
        fr_pos$ =  -9999
        !fr_pos$
        valparam = 0
        !valparam
                    ]

    if gcode$ <> 0,
     [
                @fr_pos$

        if fr_pos$ = fg1ugv, valparam = 4
        if fr_pos$ = fretract, valparam = 3
        if fr_pos$ = fplongee, valparam = 2
        if fr_pos$ = ftravail, valparam = 1
        #if fr_pos$ = ftravail  | fr_pos$ = fplongee | fr_pos$ = fretract | fr_pos$ = fg1ugv, valparam

         #if avance = ftravail, sfauto
         #else, fr_pos$ #avance2
         fr_pos$ #avance2
                !fr_pos$
                    ]

#   Gestion de la valeur de l'avance pour l'afficher
#
pfr     # avance travail

        @cc_computer$, @cc_pos$                 # mise e jour des variables

        if cc_pos$ = 0  & cc_computer$ = 0, type_comp = 0   #AUCUNE

        if cc_pos$ = 2  & cc_computer$ = 0, type_comp = 1   #ARMOIRE DROITE
        if cc_pos$ = 1  & cc_computer$ = 0, type_comp = 2   #ARMOIRE GAUCHE

        if cc_pos$ = 0  & cc_computer$ = 42, type_comp = 3  #ORDINATEUR DROITE
        if cc_pos$ = 0  & cc_computer$ = 41, type_comp = 4  #ORDINATEUR GAUCHE

    if cc_pos$ = 2  & cc_computer$ = 42, type_comp = 5  #USURE DROITE
    if cc_pos$ = 1  & cc_computer$ = 41, type_comp = 6  #USURE GAUCHE

    if cc_pos$ = 1  & cc_computer$ = 42, type_comp = 7  #USURE INVERSE DROITE
    if cc_pos$ = 2  & cc_computer$ = 41, type_comp = 8  #USURE INVERSE GAUCHE


    if gcode$ <> 0,
            [   # Avance travail
            @fr_pos$
            @fmini
            @fmaxi
            avance = fr_pos$    # affectation de l'avance

            if avance_arc <> 0,
                     [   # acivation de l'avance optimisee sur arc  (option PST)

                    # arc horaire correction a gauche
                    if gcode$ = 2 & (type_comp = 6 | type_comp = 4 | type_comp = 8), if (arcrad$ - tldia$/2) <> 0, avance =(arcrad$*fr_pos$)/abs(arcrad$ - tldia$/2)
                    # arc trigo correction a gauche
                    if gcode$ = 3 & (type_comp = 6 | type_comp = 4 | type_comp = 8), avance =(arcrad$*fr_pos$)/(tldia$/2 + arcrad$)

                    # arc horaire correction a droite
                    if gcode$ = 2 & (type_comp = 5 | type_comp = 3 | type_comp = 7), if (arcrad$ - tldia$/2) <> 0, avance =(arcrad$*fr_pos$)/abs(arcrad$ -tldia$/2)
                    # arc trigo correction a droite
                    if gcode$ = 3 & (type_comp = 5 | type_comp = 3 | type_comp = 7), avance =(arcrad$*fr_pos$)/(tldia$/2 +arcrad$)

                        # control en foction de l'operation (par mi10$)
                    # que ralentir (mi10$ = 1)
                    if avance > fr_pos$ & mi10$ = 1, avance = fr_pos$
                    # que accelerer (mi10$ = 2)
                    if avance < fr_pos$ & mi10$ = 2, avance = fr_pos$
                    # pas d'optimisation (mi10$ = 0)
                    if mi10$ = 0, avance = fr_pos$

                        # test des avances en fonction des limites de la def machine
                    if avance < fmini, avance = fmini
                        if avance > fmaxi, avance = fmaxi

                    ]

            avance
            result = newfs (4, avance)  # affectation en format modal
            ]
       #pfrparam

    if gcode$ = 0,
            [   # Avance rapide
            `sfmax
            avance = -9999
            !avance
            ]

pavanceperce    # Avance en percage

    p_casse_modalite_avance             # pour forcer l'affichage de l'avance
    pfr                     # Affichage de l'avance


#   Gestion de la correction outil et du numero de corecteur
#




pcord



    if opcode$ < 16 | opcode$ > 18, [   # pour 3 axes

    if cc$ = 140, cc$ = 40

         if cc$ <> 0, `scord
                    ]

        else, [                 # pour 4 axes pmx
        if cend$ = 1 & cc_pos$ <> 0, cc$ = 40

         if cc$ <> 0, scord

        cc$ = 0

        ]

    #if cc$ <> 0, if gcode$ = 2 | gcode$ =3, if cor_arc = 0, erreur = 4, perreur


pcancelcc$  # Annulation de correction de rayon



#   Gestion lubrif -0 arret -1 axe outil -2 buse -3 les deux separe du M3 M4
#
plubrifon

        #n$, "attention", *coolant$, e$

        #@coolant$
           lubrif = coolant$

           if lubrif = 1, "M8"      #air
           if lubrif = 2, "M8"     #buse
           if lubrif = 3, "M7"     #centre

           oldlubrif = lubrif


plubrifoff
           if lubrif = 1, n$, "M9"
           if lubrif = 2, n$, "M9"
           if lubrif = 3, n$, "M9"




#   Initialisation de la machine
#

pintcn  #   Initialisation de la machine
        if type_pp = 1, n$, sdcom, e$
        if type_pp = 2, sm, paf, sdcom, e$
        if GESTc247 = 1, [
        n$, "CYCL DEF 247 INIT. PT DE REF. ~", e$
        spaces$ = 0, n$, "  Q339=+", *origine247, "    ;NUMERO POINT DE REF.", e$    #spt_ref *orheid
        spaces$ = 1
        old_orheid = orheid
        ]
        if mode_5axe = 1,[
            if type_pp = 1,
                [
                n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$
                n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ #degageY,
                n$, "PLANE RESET TURN ", sfmax5x, p_casse_modalite_avance, e$
                ]
            if type_pp = 2,
                [
                sm, degagez, paf, sgcode, sinc_abs, degagez, pfr, smodedeg, e$
                sm, degagex, degagey,paf, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$
                sm, paf,"PLANE RESET TURN ", sfmax5x, p_casse_modalite_avance, e$
                ]
                        ]


pbrise_outilavant

                n$, outil, "S5000", e$

                n$, "TCH PROBE 584 MES. LONGUEUR,RAYON ~", e$
                "    Q350=-2    ;TYPE DE MESURE ~", e$
                "    Q351=+1    ;CHOIX DE MESURE ~", e$
                "    Q352=+0    ;OPTION DE CONTROLE ~", e$
                "    Q355=-1    ;POSITION DE MESURE ~", e$
                "    Q361=+3    ;NOMBRE DE MESURE ~", e$
                "    Q362=+0.01 ;TOLERANCE REPETAB. ~", e$
                "    Q359=+0    ;LONGUEUR ADDITIVE ~", e$
                "    Q360=+0    ;RAYON ADDITIF", e$

                n$, outil, *ssa, e$


pbrise_outilapres

        if oldstation  = 2 | oldstation = 3, [
                                                n$ , oldoutil, "S5000", e$

                                                n$, "TCH PROBE 584 MES. LONGUEUR,RAYON ~", e$
                                                "    Q350=-2    ;TYPE DE MESURE ~", e$
                                                "    Q351=+1    ;CHOIX DE MESURE ~", e$
                                                "    Q352=+0    ;OPTION DE CONTROLE ~", e$
                                                "    Q355=-1    ;POSITION DE MESURE ~", e$
                                                "    Q361=+3    ;NOMBRE DE MESURE ~", e$
                                                "    Q362=+0.01 ;TOLERANCE REPETAB. ~", e$
                                                "    Q359=+0    ;LONGUEUR ADDITIVE ~", e$
                                                "    Q360=+0    ;RAYON ADDITIF", e$

                                            ]


pbrise_outilapresfin

        if lstation$  = 2 | lstation$ = 3, [
                                                n$ , outil, "S5000", e$

                                                n$, "TCH PROBE 584 MES. LONGUEUR,RAYON ~", e$
                                                "    Q350=+2    ;TYPE DE MESURE ~", e$
                                                "    Q351=+1    ;CHOIX DE MESURE ~", e$
                                                "    Q352=+0    ;OPTION DE CONTROLE ~", e$
                                                "    Q355=-1    ;POSITION DE MESURE ~", e$
                                                "    Q361=+3    ;NOMBRE DE MESURE ~", e$
                                                "    Q362=+0.01 ;TOLERANCE REPETAB. ~", e$
                                                "    Q359=+0    ;LONGUEUR ADDITIVE ~", e$
                                                "    Q360=+0    ;RAYON ADDITIF", e$

                                            ]


pbrise_outil                    # controle bris outil
    #test_bris = mi3$
    if test_bris <> 0,
                    [
                    if type_pp = 1,
                                    [
                                    if test_bris = 1,
                                        [
                                        if degagez <> 0, n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$        # degager en Z
                                        n$, "TCH PROBE 481 LONGUEUR D'OUTIL ~", e$
                                        "    Q340=+1    ;CONTROLE ~", e$
                                        "    Q260=+100  ;HAUTEUR DE SECURITE ~", e$
                                        "    Q341=+0    ;ETALONNAGE DENTS", e$
                                        #n$, "FN 9: IF +Q199 EQU +2 GOTO LBL 249", e$
                                        #n$, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
                                        ]
                                    if test_bris = 2,
                                        [
                                        n$, ";TEST BRIS OUTIL", e$
                                        n$, sbris_outil, e$
                                        ]
                                    if test_bris = 3,
                                        [
                                        if degagez <> 0, n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$        # degager en Z
                                        n$, "TCH PROBE 586 CONTROLE DE BRIS ~", e$
                                        "    Q356=+1    ;DIRECTION DE MESURE ~", e$
                                        "    Q357=+0    ;DECALAGE RADIAL", e$

                                        n$, "FN 9: IF +Q199 EQU +2 GOTO LBL 69", e$
                                        #n$, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
                                        ]
                                    ]
                    if type_pp = 2,
                                    [
                                    if test_bris = 1,
                                        [
                                        if degagez <> 0, sm,degagez, paf,sgcode, sinc_abs, degagez, pfr, smodedeg, e$        # degager en Z
                                        sm,paf, "TCH PROBE 481 LONGUEUR D'OUTIL ~", e$
                                        sm,paf,"    Q340=+1    ;CONTROLE ~", e$
                                        sm,paf,"    Q260=+100  ;HAUTEUR DE SECURITE ~", e$
                                        sm,paf,"    Q341=+0    ;ETALONNAGE DENTS", e$
                                        #sm,paf, "FN 9: IF +Q199 EQU +2 GOTO LBL 249", e$
                                        #sm,paf, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
                                        ]
                                    if test_bris = 2,
                                        [
                                        sm,paf, ";TEST BRIS OUTIL", e$
                                        sm,paf, sbris_outil, e$
                                        ]
                                    if test_bris = 3,
                                        [
                                        if degagez <> 0, sm,degagez, paf,sgcode, sinc_abs, degagez, pfr, smodedeg, e$
                                        sm,paf, "TCH PROBE 586 CONTROLE DE BRIS ~", e$
                                        sm,paf,"    Q356=+1    ;DIRECTION DE MESURE ~", e$
                                        sm,paf,"    Q357=+0    ;DECALAGE RADIAL", e$

                                        #n$, "FN 9: IF +Q199 EQU +2 GOTO LBL 249", e$
                                        #n$, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
                                        ]
                                    ]
                    ]
#   Gestion du degagement de la machine au debut de prog
#
pdegage_debut       #   Gestion du degagement de la machine au debut de prog

    if deg_debut <> 0,
                        [
                        memo_gcode = gcode$         # memo du gcode precedent
                        gcode$ = 0              # Degagement en Rapide
                        @incremental
                        memo_incremental = incremental      # memo du mode actuel G90 G91
                        incremental = inc_degage        # passage en mode 90 ou 90 pour degagement
                        if type_pp = 1,
                                        [
                                        if deg_debut >= 1,                     [            # si degager en Z
                                                                            if degagez <> 0, n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                           if deg_debut = 2 | deg_outil = 4,     [             # si degager en Z et X
                                                                            if degagex <> 0, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                               ]
                                        if deg_debut = 3 | deg_outil = 4,     [             # si degager en Z et Y
                                                                            if degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                            ]
                                        if deg_debut = 5,                     [             # si degager en Z etXY
                                                                            if degagex <> 0 & degagey <> 0, n$, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X Y # degager en X
                                                                            ]
                                        ]
                        if type_pp = 2,
                                        [
                                        if deg_debut >= 1,                     [            # si degager en Z
                                                                            if degagez <> 0, sm,degagez,paf,sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                           if deg_debut = 2 | deg_outil = 4,     [             # si degager en Z et X
                                                                            if degagex <> 0, sm,degagex,paf,sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                               ]
                                        if deg_debut = 3 | deg_outil = 4,     [             # si degager en Z et Y
                                                                            if degagey <> 0, sm,degagey,paf,sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                            ]
                                        if deg_debut = 5,                     [             # si degager en Z etXY
                                                                            if degagex <> 0 & degagey <> 0, sm,degagex, degagey,paf, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X Y # degager en X
                                                                            ]
                                        ]
                        gcode$ = memo_gcode         # rappel du gcode precedent
                        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
                        #@incremental                                                                                   # mise a jour
                        #if degageZ <> 0 | degageX <> 0 | degageY <> 0, n$, sinc_abs, e$
                        #!incremental
                        ]


#   Gestion du degagement de la machine avant appel outil
#
pdegage     #   Gestion du degagement de la machine avant appel outil

    if deg_outil <> 0, [
                        memo_gcode = gcode$         # memo du gcode precedent
                        gcode$ = 0              # Degagement en Rapide
                        @incremental
                        memo_incremental = incremental      # memo du mode actuel G90 G91
                        incremental = inc_degage        # passage en mode 90 ou 90 pour degagement
                        if type_pp = 1,    [
                                        if deg_outil >= 1,     [            # si degager en Z
                                                            if degagez <> 0,
                                                                                [
                                                                                n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$ # degager en Z
                                                                                ]
                                                            ]
                                        if deg_outil = 2 | deg_outil = 4,         [             # si degager en Z et X
                                                                                if degagex <> 0, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                                ]
                                        if deg_outil = 3 | deg_outil = 4,    [             # si degager en Z et Y
                                                                            if degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                            ]
                                        if deg_outil = 5,     [             # si degager en Z etXY
                                                            if mi1$ = 1, if degagex <> 0 & degagey <> 0, n$, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X et Y
                                                            if mi1$ = 2, if degagex <> 0, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                            if mi1$ = 3, if degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en Y
                                                            if mi1$ = 4, if degagex <> 0 & degagey <> 0, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ #degager en  X puis Y
                                                            if mi1$ = 5, if degagex <> 0 & degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ #degager en  Y puis X
                                                            ]
                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
                                        @incremental                                                                                    # mise a jour
                                            if degagez <> 0 | degagex <> 0 | degagey <> 0, n$, sinc_abs, e$
                                        !incremental
                                        ]
                        if type_pp = 2,    [
                                        if deg_outil >= 1,     [            # si degager en Z
                                                            if degagez <> 0,
                                                                                [
                                                                                sm, degagez, paf, sgcode, sinc_abs, degagez, sfmax, smodedeg, e$
                                                                                ]
                                                            ]
                                        if deg_outil = 2 | deg_outil = 4,         [             # si degager en Z et X
                                                                                if degagex <> 0, sm, degagex,paf,sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                                ]
                                        if deg_outil = 3 | deg_outil = 4,    [             # si degager en Z et Y
                                                                            if degagey <> 0, sm, degagey,paf,sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en Y
                                                                            ]
                                        if deg_outil = 5,     [             # si degager en Z etXY
                                                            if mi1$ = 1, if degagex <> 0 & degagey <> 0, sm,degagex, degagey,paf,sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X et Y
                                                            if mi1$ = 2, if degagex <> 0, sm,degagex,paf,sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                            if mi1$ = 3, if degagey <> 0, sm,degagey,paf, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en Y
                                                            if mi1$ = 4, if degagex <> 0 & degagey <> 0, sm,degagex,paf,sgcode, sinc_abs, degagex, pfr, smodedeg, e$, sm,degagey,paf, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ #degager en  X puis Y
                                                            if mi1$ = 5, if degagex <> 0 & degagey <> 0, sm,degagey,paf,sgcode, sinc_abs, degagey, pfr, smodedeg, e$, sm,degagex,paf, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ #degager en  Y puis X
                                                            ]
                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                        incremental = memo_incremental                                                                  # Rappel du mode actuel G90 G91
                                        @incremental                                                                                    # mise a jour
                                            if degagez <> 0 | degagex <> 0 | degagey <> 0, sm,paf, sinc_abs, e$
                                        !incremental
                                        ]
                        ]
#   Gestion du degagement de la machine fin de prog
#
pdegage_fin #   Gestion du degagement de la machine fin de prog

   if deg_fin <> 0, [
                    memo_gcode = gcode$         # memo du gcode precedent
                    gcode$ = 0              # Degagement en Rapide
                    @incremental                # mise a jour
                    memo_incremental = incremental          # memo du mode actuel G90 G91
                    incremental = inc_degage        # passage en mode 90 ou 90 pour degagement


                    if deg_fin >= 1,     [          # si degager en Z
                                        if degagez_fin <> 0,
                                                                [
                                                                if type_pp = 1, n$, sgcode, sinc_abs, degagez_fin, pfr, smodedeg, e$                     # degager en Z
                                                                if type_pp = 2, sm, degagez_fin, paf, sgcode, sinc_abs, degagez_fin, pfr, smodedeg, e$
                                                                ]
                                        ]
                    if deg_fin = 2 | deg_outil = 4,     [               # si degager en Z et X
                                                        if degagex_fin <> 0,     [
                                                                                if type_pp = 1,n$, sgcode, sinc_abs, degagex_fin, pfr, smodedeg, e$ # degager en X
                                                                                if type_pp = 2,sm,degagex_fin,paf, sgcode, sinc_abs, degagex_fin, pfr, smodedeg, e$ # degager en X
                                                                                ]
                                                        ]
                    if deg_fin = 3 | deg_outil = 4,     [               # si degager en Z et Y
                                                        if degagey_fin <> 0,     [
                                                                                if type_pp = 1,n$, sgcode, sinc_abs, degagey_fin, pfr, smodedeg, e$ # degager en X
                                                                                if type_pp = 2,sm,degagey_fin, paf,sgcode, sinc_abs, degagey_fin, pfr, smodedeg, e$ # degager en X
                                                                                ]
                                                        ]
                    if deg_fin = 5,     [               # si degager en Z etXY
                                        if degagex_fin <> 0 & degagey_fin <> 0,     [
                                                                                    if type_pp = 1, n$, sgcode, sinc_abs, degagex_fin, degagey_fin, pfr, smodedeg, e$  # degager en  X Y
                                                                                    if type_pp = 2, sm, degagex_fin, degagey_fin,paf, sgcode, sinc_abs, degagex_fin, degagey_fin, pfr, smodedeg, e$
                                                                                    ]
                                        ]

                    gcode$ = memo_gcode         # rappel du gcode precedent
                    incremental = memo_incremental          # Rappel du mode actuel G90 G91
                    @incremental                # mise a jour
                    if degagez_fin <> 0 | degagex_fin <> 0 | degagey_fin <> 0,     [
                                                                                    if type_pp = 1,n$, sinc_abs, e$
                                                                                    if type_pp = 2,sm,paf, sinc_abs, e$
                                                                                    ]
                    !incremental
                    ]

#   Gestion du degagement de la machine avant rotation plateau
#
pdegage4_5axes        #   Gestion du degagement de la machine avant rotation plateau

   if deg_4axe <> 0,    [
                                        memo_gcode = gcode$         # memo du gcode precedent
                                        gcode$ = 0              # Degagement en Rapide
                                        @incremental
                                        memo_incremental = incremental          # memo du mode actuel G90 G91
                                        incremental = inc_degage            # passage en mode 90 ou 90 pour degagement
                                        p_casse_modalite            # casser la modalite pour rappel des XYZ
                                        if type_pp = 1,    [
                                                        if deg_4axe >= 1,     [         # si degager en Z
                                                                            if degagez <> 0, n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                                        if deg_4axe = 2 | deg_outil = 4,     [              # si degager en Z et X
                                                                                            if degagex <> 0, n$, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 3 | deg_outil = 4,     [              # si degager en Z et Y
                                                                                            if degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 5,                     [
                                                                                            if degagex <> 0 & degagey <> 0,
                                                                                                        [
                                                                                                        if type_pp = 1, n$, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X Y
                                                                                                        ]
                                                                                            ]

                                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                                        incremental = memo_incremental          # Rappel du mode actuel G90 G91
                                                        @incremental                # mise a jour
                                                        n$, sinc_abs, e$
                                                        ]
                                        if type_pp = 2,    [
                                                        if deg_4axe >= 1,     [         # si degager en Z
                                                                            if degagez <> 0, sm,degagez, paf, sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                                        if deg_4axe = 2 | deg_outil = 4,     [              # si degager en Z et X
                                                                                            if degagex <> 0,sm, degagex,paf, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 3 | deg_outil = 4,     [              # si degager en Z et Y
                                                                                            if degagey <> 0, sm, degagey,paf, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 5,     [              # si degager en Z etXY
                                                                            if type_pp = 2, sm, degagex, degagey,paf, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$
                                                                            ]
                                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                                        incremental = memo_incremental          # Rappel du mode actuel G90 G91
                                                        @incremental                # mise a jour
                                                        sm,paf, sinc_abs, e$
                                                        ]
                                        ]


pdegage4_5axesptlchg0        #   Gestion du degagement de la machine avant rotation plateau

   if deg_4axe <> 0,    [
                                        memo_gcode = gcode$         # memo du gcode precedent
                                        gcode$ = 0              # Degagement en Rapide
                                        @incremental
                                        memo_incremental = incremental          # memo du mode actuel G90 G91
                                        incremental = inc_degage            # passage en mode 90 ou 90 pour degagement
                                        p_casse_modalite            # casser la modalite pour rappel des XYZ
                                        if type_pp = 1,    [
                                                        if deg_4axe >= 1,     [         # si degager en Z
                                                                            if degagez <> 0, n$, sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                                        if deg_4axe = 2 | deg_outil = 4,     [              # si degager en Z et X
                                                                                            #if degageX <> 0, n$, sgcode, sinc_abs, degageX, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 3 | deg_outil = 4,     [              # si degager en Z et Y
                                                                                            if degagey <> 0, n$, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 5,                     [
                                                                                            if degagex <> 0 & degagey <> 0,
                                                                                                        [
                                                                                                        if type_pp = 1, n$, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$  # degager en  X Y
                                                                                                        ]
                                                                                            ]

                                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                                        incremental = memo_incremental          # Rappel du mode actuel G90 G91
                                                        @incremental                # mise a jour
                                                        n$, sinc_abs, e$
                                                        ]
                                        if type_pp = 2,    [
                                                        if deg_4axe >= 1,     [         # si degager en Z
                                                                            if degagez <> 0, sm,degagez, paf, sgcode, sinc_abs, degagez, pfr, smodedeg, e$                     # degager en Z
                                                                            ]
                                                        if deg_4axe = 2 | deg_outil = 4,     [              # si degager en Z et X
                                                                                            if degagex <> 0,sm, degagex,paf, sgcode, sinc_abs, degagex, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 3 | deg_outil = 4,     [              # si degager en Z et Y
                                                                                            if degagey <> 0, sm, degagey,paf, sgcode, sinc_abs, degagey, pfr, smodedeg, e$ # degager en X
                                                                                            ]
                                                        if deg_4axe = 5,     [              # si degager en Z etXY
                                                                            if type_pp = 2, sm, degagex, degagey,paf, sgcode, sinc_abs, degagex, degagey, pfr, smodedeg, e$
                                                                            ]
                                                        gcode$ = memo_gcode         # rappel du gcode precedent
                                                        incremental = memo_incremental          # Rappel du mode actuel G90 G91
                                                        @incremental                # mise a jour
                                                        sm,paf, sinc_abs, e$
                                                        ]
                                        ]

#   Gestion des Origine d'usinages G54 a G59
#
poriusi


    if workofs$ >=0, [                  # ne pas afficher de G54 si le decalage < 0
        pfairedef7
    #origine = 54 + workofs$                 # origine de  54 a 59
    origine = workofs$                 # origine de  54 a 59

        originebis = origine - 59               # origine > 59


      ]

       # if origine <> old_origine, [                # si changement d'origine

         #n$, "CYCL DEF 247 INIT. PT DE REF. ~", e$
        #spaces$ = 0, n$, "  Q339=+1    ;NUMERO POINT DE REF.", e$
        #spaces$ = 1
        #n$, " * - CHANGEMENT ORIGINE", e$

        #old_origine = origine               # memo de l'origine affichee

        #]


#   Gestion des G54 a 59 pour changement outil mul
#
poriusinul

        #"poriusinul", e$
    if workofs$ >=0, [                  # ne pas afficher de G54 si le decalage < 0
        pfairedef7
    #origine = 54 + workofs$                 # origine de  54 a 59
    origine = workofs$                 # origine de  54 a 59
    originebis = origine - 59               # origine > 59


        #if origine <> old_origine, [                # si changement d'origine



        #old_origine = origine               # memo de l'origine affichee

        #]
            ]


panuldef7

        if type_pp = 1,
                        [
                        n$, "CYCL DEF 7.0 POINT ZERO", e$
                        n$, "CYCL DEF 7.1 X0", e$
                        n$, "CYCL DEF 7.2 Y0", e$
                        n$, "CYCL DEF 7.3 Z0", e$
                        ]
         if type_pp = 2,
                        [
                        sm, paf, "CYCL DEF 7.0 POINT ZERO", e$
                        sm, paf, "CYCL DEF 7.1 X0", e$
                        sm, paf, "CYCL DEF 7.2 Y0", e$
                        sm, paf, "CYCL DEF 7.3 Z0", e$
                        ]
        oriusi = 0

pfairedef7

    !tox4$, !toy4$, !toz4$ #, *tox$, *toy$, *toz$, *tox4$, *toy4$, *toz4$,e$
     if tox4$ <> old_tox | toy4$ <> old_toy | toz4$ <> old_toz | ((tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0 ) & oriusi = 0 ), pcycledef7 # si origine dif ancienne l'ecrire

    #if old_tox <> tox$ | old_toy <> toy$ | old_toz <> toz$, pcycledef7 # si origine dif ancienne l'ecrire

pcycledef7  # ecrire le cycle def7
        #if oriusi = 1, [
        #        panuldef7   # annuler la precedente
        #        ]

        p_casse_modalite                # pour forcer le rappel des coordonees apres changement d'origine
        #n$, *tox$, e$
        #n$, *toy$, e$
        #n$, *toz$, e$
        #n$, *old_tox, e$
        #n$, *old_toy, e$
        #n$, *old_toz, e$
        if type_pp = 1,
        [
        n$, "CYCL DEF 7.0 POINT ZERO", e$
        n$, "CYCL DEF 7.1", *tox4$, e$
        n$, "CYCL DEF 7.2", *toy4$, e$
        n$, "CYCL DEF 7.3", *toz4$, e$
        ]
        if type_pp = 2,
        [
        sm, paf, "CYCL DEF 7.0 POINT ZERO", e$
        sm, paf, "CYCL DEF 7.1", *tox4$, e$
        sm, paf, "CYCL DEF 7.2", *toy4$, e$
        sm, paf, "CYCL DEF 7.3", *toz4$, e$
        ]

        old_tox = tox4$
        old_toy = toy4$
        old_toz = toz4$
        oriusi = 1




#   Gestion des gammes de vitesse de broche
#
pgamme

    @ssa
    #if ssa < 1500, "M38"
    #else, "M39"

p_block_form


          if stck_crnr$ = 0,
               [
               xmin = stck_x$ - (stck_ht$ / 2)
               ymin = stck_y$ - (stck_wdth$ / 2)
               xmax = stck_x$ + (stck_ht$ / 2)
               ymax = stck_y$ + (stck_wdth$ / 2)
               ]
          if stck_crnr$ = 1 | stck_crnr$ = 5,
               [
               xmin = stck_x$
               ymin = stck_y$ - stck_wdth$
               xmax = stck_x$ + stck_ht$
               ymax = stck_y$
               ]
          if stck_crnr$ = 2 | stck_crnr$ = 6,
               [
               xmin = stck_x$ - stck_ht$
               ymin = stck_y$ - stck_wdth$
               xmax = stck_x$
               ymax = stck_y$
               ]
          if stck_crnr$ = 3 | stck_crnr$ = 7,
               [
               xmin = stck_x$ - stck_ht$
               ymin = stck_y$
               xmax = stck_x$
               ymax = stck_y$ + stck_wdth$
               ]
          if stck_crnr$ = 4 | stck_crnr$ = 8,
               [
               xmin = stck_x$
               ymin = stck_y$
               xmax = stck_x$ + stck_ht$
               ymax = stck_y$ + stck_wdth$
               ]

          if stck_crnr$ < 5,
               [
               zmin = stck_z$ - stck_thck$
               zmax = stck_z$
               ]
          else,
               [
               zmin = stck_z$
               zmax = stck_z$ + stck_thck$
              ]



#----------------- BLOCS D'AFFICHAGES DES ENTETES ET APPEL OUTLIS -----------------


pentete     # QUESTION POUR L'ENTETE

           if entete = 1, q2, q3, q4
        entete = 1
        sclient = ucase (sclient)
        srepere = ucase (srepere)
        sindice = ucase (sindice)
        if type_pp = 1,    [
                        if sclient <> svide, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "CLIENT - ", sclient, sfcom, e$
                        if srepere <> svide, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "DESIGNATION - ", srepere, sfcom, e$
                        if sindice <> svide, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "REFERENCE PIECE - ", sindice, sfcom, e$
                        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "FICHIER MASTERCAM - ", smcname$, sfcom, e$
                        ]
        if type_pp = 2,    [
                        if sclient <> svide, spaces$ = old_spaces, sm,paf, n$, sdcom, spaces$ = 0, "CLIENT - ", sclient, sfcom, e$
                        if srepere <> svide, spaces$ = old_spaces, sm,paf, n$, sdcom, spaces$ = 0, "DESIGNATION - ", srepere, sfcom, e$
                        if sindice <> svide, spaces$ = old_spaces, sm,paf, n$, sdcom, spaces$ = 0,"REFERENCE PIECE - ", sindice, sfcom, e$
                        spaces$ = old_spaces,sm,paf, n$, sdcom, spaces$ = 0, "FICHIER MASTERCAM - ", smcname$, sfcom, e$
                        ]
        spaces$ = old_spaces
       # comment$        # pour sortie du descripteur de fichier
        entete = 0




pheader$     # ENTETE DE PROGRAMME

    if type_pp = 2,
                    [
                    "MW_CL_VERSION 1.2", e$
                    " ", e$
                    "MW_HEADERAXESNAME ", 34, "Num et Mouvements<EOC>X<EOC>Y<EOC>Z<EOC>B<EOC>C<EOC>",34,e$
                    #"MW_TOOLPATH_TRANSFORM (1,0,0,0.000,0,1,0,0.000,0,0,1,0.000,0,0,0,1)", e$
                    spaces$ = 0
                    "MW_TOOLPATH_TRANSFORM (1,0,0,", *corgx$, ",0,1,0,", *corgy$, ",0,0,1,", *corgz$, ",0,0,0,1)", e$
                    spaces$ = 1
                    usecandrill$ = yes$   # utiliser cycle percage lamage
                    usecanpeck$  = yes$   # utiliser cycle debourrage
                    usecanchip$  = yes$     # utiliser cycle brise copeaux
                    usecantap$   = yes$   # utiliser cycle taraudage
                    usecanbore1$ = yes$  # utiliser cycle alesage a l'alesoir
                    usecanbore2$ = yes$   # utiliser cycle alesage a la barre
                    usecanmisc1$ = yes$   # utiliser cycle divers 1
                    usecanmisc2$ = yes$   # utiliser cycle divers 2
                    ]

    rd_mch_ent_no$ = -1         # pour lire les info de toute la machine
    rd_md$                  # lire la definition machine
    rd_mch_ent_no$ = 0          # pour lire les info de base de la machine
    rd_md$                  # lire la definition machine
    compt_axes_rot = 0          # pour remetre a zero le nombre d'axe rotatif avant la lecture de la conbinasin d'axe
    useaxe = 0

    if omitseq$ = 1, numcoment = 0      # si pas de numero de bloc ne pas numeroter les commentaires
    debut = 1               # flag pour debut de prog
        old_omitseq = omitseq$          # memo du mode de numerotation de ligne
        old_spaces = spaces$            # memo du nombre d'espaces
    old_linarc = linarc$            # memo de la decomposition des arcs

        smcpath$ = ucase (smcpath$)     # convertir en MAJUSCULES les noms
        smcname$ = ucase (smcname$)
        smcext$ = ucase(smcext$)
        snamepst$ = ucase (snamepst$)
    snamenc$ = ucase (snamenc$)
    smachine = ucase (smachine)



        if use_progno = 1, [            # si on sauve sous la forme 00123.NC
        while progno$ = 0, q6               # verifier le numero de prog
        pnom_nc             # Generation des noms du fichier NC
        ptest_nom           # Tester si prog O0123.NC existe
                ]

         prognosav = progno$            # memo du numero de prog
         debsousprog = 0            # memo du num de premier sous prog
         #debsousprog = progno$ * 100       # memo du num de premier sous prog


    #---------------------- Debut de prog -----------------------


            if type_pp = 1,
                               [
                            if use_progno = 0,  n$, "BEGIN PGM", snamenc$, "MM", e$
                            else,           n$, "BEGIN PGM", progno$, "MM", e$

                            ]
            if type_pp = 2,
                               [
                            if use_progno = 0,  sm, sxmag, symag, szmag, sbzero, sczero, paf, "BEGIN PGM", snamenc$, "MM", e$
                            else,               sm, sxmag, symag, szmag, sbzero, sczero, paf, "BEGIN PGM", progno$, "MM", e$
                            ]
        pchoix_machine
        if texte <> 0,      [                           # Si la machine accepte les commentaires

        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc
            pentete                                 # faire l'entete de prog

        #spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "POST-PRO FICAM", sfcom, e$
        #spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "MACHINE - ", smachine, sfcom, e$         # nom de la machine
        #spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "DESSIN MASTERCAM - ", smcname$, sfcom, e$    # nom du fichier MCX
        spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "PROG-CN DU ", date$, " A ", time$, sfcom, e$ # date du traitement post-pro
        #space, e$                                          # Sauter une ligne
        spaces$ = old_spaces                                        # rappel des espaces
    omitseq$ = old_omitseq                                  # rappel des numero de bloc
                ]


        p_block_form

            if type_pp = 1,
                               [
                            n$, "BLK FORM 0.1 Z", *xmin, *ymin, *zmin, e$
                            zmax = (abs(zmax))
                            n$, "BLK FORM 0.2", *xmax, *ymax, *zmax, e$
                            ]

            if type_pp = 2,
                               [
                            sm, paf, "BLK FORM 0.1 Z", *xmin, *ymin, *zmin, e$
                            zmax = (abs(zmax))
                            sm, paf, "BLK FORM 0.2", *xmax, *ymax, *zmax, e$
                            ]


      #q2, q3, q4, q5 #q27
      #origineheid = workofs$
      sclient = ucase (sclient)
      sindice = ucase (sindice)
      srepere = ucase (srepere)
      spt_ref = ucase (spt_ref)
      orheid = workofs$
      if orheid = 0, orheid = 1
          #n$, "* -", e$
        #n$, "* -", "PROGRAMME NUM = ", progno$, e$
        #n$, "* -", "CLIENT =", sclient, e$
        #n$, "* -", "DESIGNATION =", srepere, e$
        #n$, "* -", "REFERENCE PIECE =", sindice, e$
        #n$, "* -", "NUMERO DE PIECE =", snumpiece, e$
        #n$, "* -", "POST-PRO FICAM", e$
        #n$, "* -", "MACHINE = DMU50", e$
        #n$, "* -", "DESSIN MASTERCAM =", smcname$, e$
        #n$, "* -", "PROG-CN DU ", date$, " A ", time$, e$

        if texte <> 0,      [                           # Si la machine accepte les commentaires
            spaces$ = 0                             # suprimer les espaces
        if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc

            if type_pp = 1,
                               [
                            if tooltable$ <> 0, spaces$ = old_spaces,n$, sdcom, e$, n$, sdcom,spaces$ = 0, "LISTE DES OUTILS UTILISES", sfcom, e$ # pour liste des outils
                            ]
            if type_pp = 2,
                               [
                            if tooltable$ <> 0, spaces$ = old_spaces, sm, paf, sdcom, e$, sm, paf, sdcom,spaces$ = 0, "LISTE DES OUTILS UTILISES", sfcom, e$ # pour liste des outils
                            ]

            spaces$ = old_spaces                            # rappel des espaces
        omitseq$ = old_omitseq                          # rappel des numero de bloc
                ]

psof0$       # DEBUT DE PROGRAMME pour T=0

       psof$

pappel_outil    # ecriture de l'appel outil pour psof et ptlchg

    pnomgroupe                                  # Nom du groupe d'operation


    if tool_typ$ = 5, ss$ = (abs(ss$))*-1       # si tataud e gauche inverser le sens de broche

        #--------------- infos outil -------------------------------------------
        #if texte <> 0 & info_outil = 1, [                   # si affichage des infos outil
        #        sdesioutil = ucase (strtool$)               # convertir en MAJUSCULES le nom outil
        #        spaces$ = 0                     # suprimer les espaces
        #    if numcoment = 0, omitseq$ = 1              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        #        paramT1 = t$
        #    if strtool$ <> 0,   spaces$ = old_spaces, n$, sdcom, spaces$ = 0, paramT1, space, sdesioutil, space, stypeT, space,paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
        #    else,           spaces$ = old_spaces, n$, sdcom, spaces$ = 0, paramT1, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
        #       spaces$ = old_spaces                    # rappel des espaces
        #   omitseq$ = old_omitseq                  # rappel des numero de bloc
        #           ]
        #--------------- surep et compenstion ----------------------------------                    _-_-_-_-_-_-_-_-_-_-_-___AFFICHAGE INFOS OUTIL DANS BLOC "poutil"_-_-_-_-_-_-_-_-______
        #paramcomp                               # afficher le type de compensation



     if stop_opt = 1, n$, "M1", e$
    paffiche_outil


        #space, e$                              # Sauter une ligne
        debut = 0
        gcode$ = 5
        !gcode$


sdefoutil : ""
fmt "Num=" 4 numpas
sblanc : " "
snomoutil : ""



poutil  # appel outil sans outil suivant
    if type_pp = 1, n$, sdcom, e$
    if type_pp = 2, sm, paf, sdcom, e$
    fauto = paramT11
    outil = t$
    if nom_tool = 1,     [      # appel outil par son nom
                        if strtool$ <> svide,     [
                                                snomoutil = ucase(strtool$)
                                                if gestion_nom_outil = 1,  # on enleve les blancs dans le nom d'outil
                                                    [
                                                    numpas = strstr(sblanc,strtool$)  # on vois a partir d'ou il y a un blanc
                                                    if numpas > 0, sdefoutil = brksps(numpas,snomoutil) # on coupe a partir du blanc
                                                    #"voir=", *numpas, " deb=", *st_str_ix$, snomoutil, e$
                                                    ]
                                                if type_pp = 1,    [


                                                                spaces$ = 0
                                                                if omitseq$ = 1, num, " TOOL CALL ", 34, snomoutil, 34, " Z ", *ssa
                                                                   if omitseq$ = 0, n$, " TOOL CALL ", 34, snomoutil, 34, " Z ", *ssa
                                                                spaces$ = old_spaces

                                                                ]
                                                if type_pp = 2,    [
                                                                spaces$ = 0
                                                                if omitseq$ = 1, sm,paf,num, " TOOL CALL ", 34, snomoutil, 34, " Z ", *ssa
                                                                   if omitseq$ = 0, sm,paf, " TOOL CALL ", 34, snomoutil, 34, " Z ", *ssa
                                                                spaces$ = old_spaces
                                                                ]
                                                ]
                        else,     [
                                if type_pp = 1,    [
                                        n$, "attention", oldlubrif, e$
                                        if oldlubrif = 3, num, "M75", e$
                                                if omitseq$ = 1, num, *outil, *ssa
                                                if omitseq$ = 0, n$, *outil, *ssa
                                                if oldlubrif = 3, num, "M76", e$
                                                ]
                                if type_pp = 2,    [
                                                if omitseq$ = 1, sm,paf,num, *outil, *ssa
                                                if omitseq$ = 0, sm,paf, *outil, *ssa
                                                ]
                                ]
                        ]
    else,                 [             # appel outil par son numero
                        if type_pp = 1,
                                        [
                                        if omitseq$ = 1, num, *outil, *ssa
                                        #if omitseq$ = 0, n$, *outil, *ssa, *fauto,
                                        if omitseq$ = 0, n$, *outil, *ssa,
                                        ]
                        if type_pp = 2,
                                        [
                                        if omitseq$ = 1, sm, paf, num, *outil, *ssa
                                        if omitseq$ = 0, sm, paf, *outil, *ssa,
                                        ]
                        ]
    if use_DR = 1, [
                    DR = 0
                    if type_comp >=5, DR = tldia$/-2
                    DR
                    old_DR = DR
                     ]
    e$
    p_casse_modalite_X
    p_casse_modalite_Y
    p_casse_modalite_Z

    #--------------- infos outil -------------------------------------------

        if texte <> 0 & info_outil = 1, [                   # si affichage des infos outil

                sdesioutil = ucase (strtool$)               # convertir en MAJUSCULES le nom outil
                spaces$ = 0                     # suprimer les espaces
            if numcoment = 0, omitseq$ = 1              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
                paramT1 = t$

            if type_pp = 1,
                            [
                            if strtool$ <> svide,  spaces$ = old_spaces, n$, sdcomf, spaces$ = 0, paramT1, space, sdesioutil, space, stypeT, space, paramT5, space, !paramT16, ptypeBoutT , pangleT , space, !smatT, e$
                            else, spaces$ = old_spaces, n$, sdcomf, spaces$ = 0, !paramT1, space, stypeT, space, paramT5, space, !paramT16, ptypeBoutT , pangleT , space, !smatT, e$
                            ]
            if type_pp = 2,
                            [
                            if strtool$ <> svide,  spaces$ = old_spaces, sm, paf, sdcomf, spaces$ = 0, paramT1, space, sdesioutil, space, stypeT, space, paramT5, space, !paramT16, ptypeBoutT , pangleT , space, !smatT, e$
                            else, spaces$ = old_spaces, sm, paf, sdcomf, spaces$ = 0, !paramT1, space, stypeT, space, paramT5, space, !paramT16, ptypeBoutT , pangleT , space, !smatT, e$
                            ]
                spaces$ = old_spaces                    # rappel des espaces
            omitseq$ = old_omitseq                  # rappel des numero de bloc
                    ]

      comment$                                    # commentaires d'operation
      paramcomp                               # afficher le type de compensation

      oldoutil = outil

poutil_suivant  # appel outil avec outil suivant

        if outil_apres = 0,  # flag pour la position d'appel de l'outil suivant
                [
                if nom_tool = 0,      # appel outil par son numero
                        [
                           outil = t$
                        if dernieroutil <> 0 & ttblend$ = 1, outil_suivant = dernieroutil
                        else, outil_suivant = next_tool$
                        if type_pp = 1, n$, *outil_suivant, e$
                        if type_pp = 2, sm, paf, *outil_suivant, e$
                        ]
                if nom_tool = 1,  # appel outil par son nom
                        [
                        #paffichedesoutil # lire quel est le nom de l'outil suivant qui a ete memoriser lors de la creation bibliotheque
                        if sdernieroutil <> svide & ttblend$ = 1,
                                [
                                if type_pp = 1, n$, "TOOL DEF", 34,no_spc$, sdernieroutil,no_spc$,34, e$
                                if type_pp = 2, sm, paf, "TOOL DEF", 34,no_spc$, sdernieroutil, no_spc$,34, e$
                                ]
                        else,
                                [
                                if type_pp = 1, n$, "TOOL DEF", 34, no_spc$, paffichedesoutil,no_spc$,34, e$
                                if type_pp = 2, sm, paf, "TOOL DEF", 34,no_spc$, paffichedesoutil,no_spc$, 34, e$
                                ]
                        ]
             ]

paffiche_outil_suivant  # affichage de l'outil suivant ou non


   if bldnxtool$ = 1 & outil_apres = 1,
                       [
                if nom_tool = 0,      # appel outil par son numero
                        [
                           outil = t$
                        if dernieroutil <> 0 & ttblend$ = 1, outil_suivant = dernieroutil
                        else, outil_suivant = next_tool$
                        if type_pp = 1, n$, *outil_suivant, e$
                        if type_pp = 2, sm, paf, *outil_suivant, e$
                        ]
                if nom_tool = 1,  # appel outil par son nom
                        [
                        if sdernieroutil <> svide & ttblend$ = 1,
                                [
                                if type_pp = 1, n$, "TOOL DEF", 34,no_spc$, sdernieroutil, no_spc$,34, e$
                                if type_pp = 2, sm, paf, "TOOL DEF",34,no_spc$, sdernieroutil, no_spc$,34,e$
                                ]
                        else,
                                [
                                if type_pp = 1, n$, "TOOL DEF", 34,no_spc$,paffichedesoutil, no_spc$,34,e$
                                if type_pp = 2, sm, paf, "TOOL DEF", 34,no_spc$,paffichedesoutil, no_spc$,34,e$
                                ]
                        ]
             ]
#     Debut de programme pour outil
#


paffiche_outil  # affichage du numero d'outil

#     Debut de programme pour outil
        if bldnxtool$ = 1, [
                poutil, poutil_suivant  # appel outil avec outil suivant juste apres
                #if op_id$ <> last_op_id & t$ <> next_tool$, poutil, poutil_suivant  # appel outil avec outil suivant juste apres
                #if op_id$ <> last_op_id & t$ = next_tool$, poutil           # appel outil sans outil suivant
                #if op_id$ = last_op_id & t$ <> first_tool$, poutil, poutil_suivant  # appel outil avec outil suivant juste apres
                #if op_id$ = last_op_id & t$ = first_tool$, poutil           # appel outil sans outil suivant
                            ]
        if bldnxtool$ = 0, poutil                       # appel outil sans outil suivant


#


psof$        # DEBUT DE PROGRAMME

            q1, q16, q18

             if robot = 1, q17
            # question de base
            continu5x = 0
            if question_axeC = 1,
            [
            result = mprint(sutilaxeC,2)
            if result = 1,   presence_axe_C = 1, n$, "; UTILISATION MODE 5 AXES", e$
            if result = 2,   presence_axe_C = 0, n$, "; UTILISATION MODE 4 AXES", e$
            ]
            else, presence_axe_C = 1

            if question_deg_X, q12
            if question_deg_Y, q13
            if question_deg_Z, q14



        pnumop
        debutpmx = 1
        if opcode$ = 16, percage5x = 1  # test si l'operation coureante est du 5 axes
        else, percage5x = 0
        if (nextop$ = 11 | opcode$ = 16) & ( m1$ <> 1 | m5$ <> 1 | m9$ <> 1), erreurtype = 1, perreur

    pinfos
    DR = -99999
    old_DR = -99999
    !DR, !old_DR

    plireaxes                   # Lecture des parametres de la combinaison d'axes uniquement


        if tooltable$ <> 0 & texte <> 0, [      # Si liste des outils et textes supportes

            if numcoment = 0, omitseq$ = 1  # Si pas de numero sur les commentaires
                spaces$ = 0
            #spaces$ = old_spaces, n$, sdcom, spaces$ = 0, "FIN DE LISTE DES OUTILS", sfcom, e$
            #space, e$                  # Sauter une ligne
                spaces$ = old_spaces
                omitseq$ = old_omitseq
                        ]

                        if robot = 1, n$, "LBL ", spaces$ = 0, 34, "LABEL10", 34, spaces$ = 1,e$
                        ppalpage

    pnumop                      # compteur d'operation
        gcode$ = 0
    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$

    old_origine = -9999             # pour forcer l'affichage du G54 au chg outil
        incremental = 0                 # Travail en Absolue


    pintcn                      # Initialisation de la machine


        incremental = 2                 # pour re forcer l'affichage du mode Absolue
        !incremental
        incremental = 0

    pdegage_debut                           # Degagement de la Machine au debut de prog
        pcomment2
    #space, e$                  # sauter une ligne

    if cycle32on = 1,
                        [
                                if type_pp = 1,
                                                [
                                                n$, "CYCL DEF 32.0 TOLERANCE",e$
                                                n$, "CYCL DEF 32.1 T0.1", e$
                                                n$, "CYCL DEF 32.2 HSC-MODE:0 TA0.1",e$
                                                ]
                                if type_pp = 2,
                                                [
                                                sm, paf, "CYCL DEF 32.0 TOLERANCE",e$
                                                sm, paf, "CYCL DEF 32.1 T0.1", e$
                                                sm, paf, "CYCL DEF 32.2 HSC-MODE:0 TA0.1",e$
                                                #"MW_MACHINE_AXIS_INTERPOLATION_BY_THRESHOLD_ANGLE 90", e$
                                                ]
                        ]
        pappel_outil                        # APPEL OUTIL
        if lstation$ = 1 | lstation$ = 3 , pbrise_outilavant
         if texte <> 0, paramsurep                       # afficher les surepaisseur
    #n$, "M51", e$
    #n$, "M37", e$

    pplacement_cn                   # AFFICHAGE DES MOUVEMENTS MACHINE
    #n$, "bris d'outil", *lstation$,  e$


        oldstation = lstation$

#   Mise en route cn apres appel outil
#
pplacement_cn   # AFFICHAGE DES MOUVEMENTS MACHINE

        @rotaxis$                   # mise a jour du type de substitution d'axe


        if nextop$ = 11,    [               # si  4  ou 5 axes
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        axeA = 0
        axeA1_dep = 0
        old_axeA1 = 0
        debutpmx = 1                # flag pour faire l'appel outil

        cc$ = cc_pos$ + 40
        if mode_5axe = 1, pdegage4_5axes, plane_arret_sansbouger, pmx$

                        ]


    if nextop$ <> 11 & percage5x <> 1 ,    [   # utilisation en positionne ou substitution

        gcode$ = 0                              # Force le gcode a 0 pour faire un G0 apres
        xabs = x$
        yabs = y$
        zabs = z$
        #"voir ", *x$, *y$, *z$, *nextx$, *nexty$, *nextz$, *xnci$, *ynci$, *znci$, e$

    if rotaxis$ = 0,    [     # 3 axes + diviser en positionne
        poriusi

        if mode_5axe <> 1,
                         [     # on est en mode 3 ou 4 axes
                        if mi3$ = 0, prot1                                   # calcul rotation plateau
                        old_axeA =  -99998                                 # pour forcer l'affichage
                        if mi3$ = 0, prot2                                   # affichage de l'angle au chg outil
                          ]
        else, plane_marche         # on est en mode 5 axes
        if type_pp = 1, n$, *sgcode, sinc_abs, *xabs, *yabs, pfr, *spdlon, e$   #ssa, pgamme, *spdlon, e$
        if type_pp = 2, sr, *xabs, *yabs, *zabs, sfsimurapid, paf, *sgcode, sinc_abs, *xabs, *yabs, pfr, *spdlon, plubrifon, sm, degagez, e$   #ssa, pgamme, *spdlon, e$
        paffiche_outil_suivant
        if type_pp = 1, n$, sgcode, *zabs, pfr, plubrifon, e$
        if type_pp = 2, sr, *xabs, *yabs, *zabs, sfsimurapid, paf, sgcode, *zabs, pfr, e$
        old_z = zabs
                        ]


   if rotaxis$ <> 0,    [           # utilisation en substitution
                        plinarc
                        p_Apos
                        bloque = 2
                        if use_bloque = 0, bloque = 0
                        if rotaxis$ = 1, xabs = 0                   # diviseur tourne autour de Y (X sbstitue)
                        if rotaxis$ = 2, yabs = 0                   # diviseur tourne autour de X (Y sbstitue)
                            if type_pp = 1,poriusi
                        if type_pp = 2,sm,paf,poriusi
                        if type_pp = 1,    [
                                        n$, *sgcode, sinc_abs, sbloque, *axeA, pfr, e$
                                        n$, sgcode, sinc_abs, *xabs, *yabs, pfr, *spdlon, plubrifon, e$ # ssa, pgamme, *spdlon, e$
                                        paffiche_outil_suivant
                                        n$, sgcode, *zabs, pfr, e$
                                        ]
                        if type_pp = 2,    [
                                        sr, *axeA,sfsimurapid,paf,  *sgcode, sinc_abs, sbloque, *axeA, pfr, e$
                                        sr, *xabs, *yabs,sfsimurapid,paf,sgcode, sinc_abs, *xabs, *yabs, pfr, *spdlon, plubrifon, e$ # ssa, pgamme, *spdlon, e$
                                        paffiche_outil_suivant
                                        sr,*zabs,sfsimurapid,paf, sgcode, *zabs, pfr, e$
                                        ]
                        ]

   p_modal                                 # affectation en format modal
   !x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axeA, !axeAi  # mise e jour des positions affichees
                                    ]


   old_ss = ss$             # memo de la vitesse de broche
   old_op_id = op_id$           # memo du numero d'operation
   old_rotaxis = rotaxis$       # memo du type de substitution
   old_x = xabs             # memo X Y Z
   old_y = yabs
   old_z = zabs


  c_mmlt$           # truc qui doit servire pour usinage transforme
  c_msng$

        #origineheid = workofs$
        #if origine <> old_origine, [
        #n$, "CYCL DEF 247 INIT. PT DE REF. ~", e$
        #spaces$ = 0, n$, "  Q339=+1    ;NUMERO POINT DE REF.", e$
        #spaces$ = 1
        #n$, "* - CHANGEMENT ORIGINE", e$
        #]

ptlchg0$     # CHANGEMENT D'OUTIL NUL
        if force_ss = 1 & op_id$ <> old_op_id,
            [
            old_ss = 999999   #pour forcer l'appel de vitesse de rotation a chaque operation
            if debutpmx = 0 & mode_5axe = 1,
                                        [
                                        if type_pp = 1, n$, "M129", e$
                                        if type_pp = 2, sm,paf, "M129", e$
                                        ]
            ]

        contperc = 0
        if op_id$ <> old_op_id, changpolar_AB = 1, continu5x = 0 # on remet le marqueur de polarite a 1 et flag 5 axe
        if type_pp = 2 & op_id$ <> old_op_id,
                        [
                        sf, e$
                        pmplane
                        spaces$ = 0
                        #"MW_TOOLPATH_TRANSFORM (1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)", e$
                        "MW_TOOLPATH_TRANSFORM (1,0,0,", *corgx$, ",0,1,0,", *corgy$, ",0,0,1,", *corgz$, ",0,0,0,1)", e$
                        #" (",*m1simu,svirg,*m2simu,svirg,*m3simu,svirg,*tox4simu,svirg,*m4simu,svirg,*m5simu,svirg,*m6simu,svirg,*toy4simu,svirg,*m7simu,svirg,*m8simu,svirg,*m9simu,svirg,*toz4simu,svirg,"0.,0.,0.,1.)", e$
                        spaces$ = 1
                        sr, pxyzf, axeAB5xsimu, axeC5xsimu, sfsimurapid, paf_xyz, pfr, e$
                        ]

        pnumop
       # n$, "-----CHANGEMENT D'OUTIL NUL--------", *workofs$, e$
           if (nextop$ = 11 | opcode$ = 16) & ( m1$ <> 1 | m5$ <> 1 | m9$ <> 1), erreurtype = 1, perreur
        if opcode$ = 16, percage5x = 1  # test si l'operation coureante est du 5 axes
        else, percage5x = 0
        gcode$ = 0
        pinfos



        pnumop                      # compteur d'operation

        if subout$ = 0, omitseq$ = old_omitseq
        memo_incremental = incremental              # memo du mode ABS INC actuel
        if subout$ = 0, incremental = 0         # pour forcer le mode Absolue
        @rotaxis$, @old_rotaxis             # mise a jour
        if op_id$ <> old_op_id, linarc$ = old_linarc                    # pour activer les G2 G3
        typcycle = 0                    # variable mise a 1 lors des percage pour afficher l'intitule du cycle
        pnomgroupe                  # Nom du groupe d'operation
        comment$                    # commentaires d'operation
        paramcomp                   # afficher le type de compensation
        if texte <> 0, paramsurep           # afficher les surepaisseur
        if tool_typ$ = 5, ss$ = (abs(ss$))*-1       # si tataud e gauche inverser le sens de broche
        if ss$ <> old_ss, [             # si changement de vitesse de broche l'afficher
            DR = -99999
            !DR
        poutil
            ]


        if use_DR = 1, [
        DR = 0
        if type_comp >=5, DR = tldia$/-2
        #*DR, *old_DR, "------------------------------", e$
        if DR <> old_DR, poutil

         ]

            if nextop$ = 11,
                            [       # si  4 axes avec fonction 5 axes
                            if op_id$ <> old_op_id,
                                                     [
                                                     old_axeA1 = 0
                                                     axeA1_dep = 0.
                                                    cc$ = cc_pos$ + 40
                                                    if mode_5axe = 1 & debutpmx = 1, pdegage4_5axes, plane_arret_sansbouger
                                                    if mode_5axe = 1 & debutpmx = 0,
                                                                                    [
                                                                                    if type_pp = 1,n$, "M129", e$
                                                                                    if type_pp = 2,sm,paf, "M129", e$
                                                                                    pdegage4_5axesptlchg0
                                                                                    plane_arret_sansbouger
                                                                                    debutpmx = 1
                                                                                    ]
                                                     poriusinul              # affichage de l'origine d'usinage
                                                    ]
                            ]



   if nextop$ <> 11, [                      # utilisation en positionne ou substitution

        x$ = nextx$                   # prise en compte de XYZ
        y$ = nexty$
        z$ = nextz$
        if debutpmx = 0 & mode_5axe = 1,     [
                                            if type_pp = 1,n$, "M129", e$
                                            if type_pp = 2,sm,paf, "M129", e$
                                            ]

        xabs = nextx$                   # prise en compte de XYZ
        yabs = nexty$
        zabs = nextz$
        #"voir ", *x$, *y$, *z$, *nextx$, *nexty$, *nextz$, *xnci$, *ynci$, *znci$, e$
        if rotaxis$ = 0, [              # 3 axes + diviser en positionne

        if mode_5axe <> 1,  [
        poriusinul                                  # affichage de l'origine d'usinage cycle def 7
        if mi3$ = 0, prot1                          # calcul rotation plateau
        if mi3$ = 0, prot3                          # affichage de l'angle
                            ]
         else, plane2plane                          # on est en mode 5 axes
                         ]
        if rotaxis$ <> 0, plinarc                   # Convertir les G2 G3 en G1
        if rotaxis$ <> 0 & old_rotaxis = 0, [       # si on passe de positionne a continue
        plinarc                                     # Convertir les G2 G3 en G1
        p_Apos                                      # calcul de l'axe A en substitution
        if rotaxis$ = 1, xabs = 0                   # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2, yabs = 0                   # diviseur tourne autour de X (Y sbstitue)
        poriusinul
        p_Apos_affiche                          # affichage de l'angle au chg outil nul pour continue
        if type_pp = 1,     [
                            n$, sgcode, sinc_abs, xabs, yabs, !xinc, !yinc, pfr, e$
                            n$, sgcode, sinc_abs, zabs, !zinc, pfr, e$
                            ]
        if type_pp = 2,     [
                            sr, xabs, yabs, !xinc, !yinc, sfsimurapid, paf, sgcode, sinc_abs, xabs, yabs, !xinc, !yinc, pfr, e$
                            sr,zabs, !zinc,sfsimurapid, paf, sgcode, sinc_abs, zabs, !zinc, pfr, e$
                            ]
        p_modal                                 # affectation en format modal
        !x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axeA, !axeAi  # mise e jour des positions affichees
                     ]
                    debutpmx = 1
                ]

       if GESTc247 > 1, pcycledef247
        if force_ss = 1 & old_op_id <> op_id$,
                [
                if type_pp = 1, n$, `sgcode, *spdlon, e$
                if type_pp = 2, sm, paf, n$, `sgcode, *spdlon, e$
                ]
   incremental = memo_incremental   # rappel du mode incremental ou absolue precedent
   old_ss = ss$             # memo de la vitesse de broche
   old_op_id = op_id$           # memo du numero d'operation
   old_rotaxis = rotaxis$       # memo du type de substitution
   old_x = xabs             # memo X Y Z
   old_y = yabs
   old_z = zabs

   c_mmlt$              # Appel sous prog multi outils
   c_msng$              # Appel sous prog mono outil

       # origineheid = workofs$
       #*workofs$, tox4$, toy4$, toz4$, e$
        #if workofs$ <> old_origine, [
        #n$, "CYCL DEF 247 INIT. PT DE REF. ~", e$
       # spaces$ = 0, n$, "  Q339=+1    ;NUMERO POINT DE REF.", e$
       # spaces$ = 1
       # n$, "* - CHANGEMENT ORIGINE", e$
       # ]

ptlchg0_end$

        #"--------------- fin ptlchg0_end$", e$


panulldecalageg52

        memo_incremental = incremental
        incremental = 0

        decX = 0
        decY = 0
        decZ =0

            if type_pp = 1, n$, sinc_abs, "G52", *decX, *decY, *decZ, e$
            if type_pp = 2, sm,paf, sinc_abs, "G52", *decX, *decY, *decZ, e$
        decalage = 0
        incremental = memo_incremental

ptlchg$      # CHANGEMENT D'OUTIL

        #if continu5x,
        #[
        #if type_pp = 1,n$, "M129", e$
        #if type_pp = 2,sm,paf, "M129", e$
        #]
        continu5x = 0
        contperc = 0
        changpolar_AB = 1 # on remet le marquer de polarite a 1
        pnumop
        if (nextop$ = 11 | opcode$ = 16) & ( m1$ <> 1 | m5$ <> 1 | m9$ <> 1), erreurtype = 1, perreur
        if opcode$ = 16, percage5x = 1  # test si l'operation courente est du percage 5 axes
        else, percage5x = 0

       if debutpmx = 0 & mode_5axe = 1,     [
                                        if type_pp = 1, n$, "M129", e$
                                        if type_pp = 2, sm,paf, "M129", e$
                                        ]
    DR = -99999
    old_DR = -99999
    !DR, !old_DR

    if type_pp = 1, plubrifoff, e$                  # arret lubriff
    if type_pp = 2, sm, paf, plubrifoff, e$
    if type_pp = 1, n$, "M5", e$                    # arret broche
    if type_pp = 2, sm, paf, "M5", e$                    # arret broche
    if decalage = 1, panulldecalageg52      # annuler les decalages d'origine
    pinfos
    if nbrtour <> 0,    [           # pour remise a zero du diviseur
        old_axeA = 0
        axeA = 0
        nbrtour = 0
                ]


       pnumop                      # compteur d'operation

    p_casse_modalite_avance             # pour rappel de l'avance sur le premier G1

    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$

    memo_incremental = incremental          # memo du mode incremental
        incremental = 2                 # pour re forcer l'affichage du mode Absolue
    !incremental
    incremental = 0                 # pour forcer le mode Absolue

    old_origine = -9999             # pour forcer l'affichage du G54 au chg outil
    linarc$ = old_linarc                    # pour activer les G2 G3
    typcycle = 0                    # variable mise a 1 lors des percage pour afficher l'intitule du cycle

        if mode_5axe = 1,
        [
        if mode_turn = 0, pdegage, plane_arret_sansbouger  # RAZ si 5 axes positionner
        else,
                [
                if deg_4axe = 0, pdegage   # ecrire un degagement avant de tourner
                pdegage4_5axes
                plane_arret_RAZ
                ]
        ]
        else, pdegage                             # Degagement de la Machine

       if GESTc247 > 1, pcycledef247                        # appel cycle 247
        pbrise_outil                    # controle bris outil
        if type_pp = 2, [
                        outil = t$
                        #, sr, "X-44.006 Y+7.944 Z+50.1 F10000", paf, e$
                        sm, szmag, paf, sgcode, sinc_abs, szmag, sfmax, smodedeg, e$
                        sm, sxmag, symag, paf,
                        if omitseq$ = 1, num, *outil, *ssa, e$
                        if omitseq$ = 0, *outil, *ssa, e$
                        sf, e$
                        pmplane
                        spaces$ = 0
                        #"MW_TOOLPATH_TRANSFORM (1,0,0,0.000,0,1,0,0.000,0,0,1,0.000,0,0,0,1)", e$
                        "MW_TOOLPATH_TRANSFORM (1,0,0,", *corgx$, ",0,1,0,", *corgy$, ",0,0,1,", *corgz$, ",0,0,0,1)", e$
                        #" (",*m1simu,svirg,*m2simu,svirg,*m3simu,svirg,*tox4simu,svirg,*m4simu,svirg,*m5simu,svirg,*m6simu,svirg,*toy4simu,svirg,*m7simu,svirg,*m8simu,svirg,*m9simu,svirg,*toz4simu,svirg,"0.,0.,0.,1.)", e$
                        spaces$ = 1
                        sm, sxmag, symag, szmag, paf,
                        if omitseq$ = 1, num, *outil, *ssa, e$
                        if omitseq$ = 0, *outil, *ssa, e$
                        ]
        pbrise_outilapres
        pappel_outil                        # APPEL OUTIL
        if lstation$ = 1 | lstation$ = 3 , pbrise_outilavant

        if texte <> 0, paramsurep                       # afficher les surepaisseur
        pplacement_cn                   # AFFICHAGE DES MOUVEMENTS MACHINE

        incremental = memo_incremental          # pour revenir au mode precedent
        #"voir opcode et percage", *opcode$ , *percage5x, e$
        #"voir avant  les old=", *old_axeAB,  *old_axeC, e$
        if percage5x = 1, old_axeC = 99999, old_axeAB = 99999, @old_axeAB,  @old_axeC
        #"voir apres  les old=", *old_axeAB,  *old_axeC, e$

        oldstation = lstation$

peof0$

           peof$

pcycledef247
      orheid = workofs$
      if orheid = 0, orheid = 1
      @orheid
      #n$, *workofs$, e$
      #n$, " voir orheid=", *orheid, e$
      #n$, " voir orheid=", *old_orheid, e$
      if old_orheid <> orheid,     [
                                  if type_pp = 1,    [
                                                n$, "CYCL DEF 247 INIT. PT DE REF. ~", e$
                                                spaces$ = 0, n$, "  Q339=+", *orheid, ";NUMERO POINT DE REF.", e$
                                                spaces$ = 1
                                                n$, sdcom, "CHANGEMENT ORIGINE", e$
                                                ]
                                  if type_pp = 2,    [
                                                sm,paf, "CYCL DEF 247 INIT. PT DE REF. ~", e$
                                                spaces$ = 0, sm,paf, "  Q339=+", *orheid, ";NUMERO POINT DE REF.", e$
                                                spaces$ = 1
                                                sm,paf, sdcom, "CHANGEMENT ORIGINE", e$
                                                ]
                                ]
         old_orheid = orheid

pdecharge_outil     # Dechargement de l'outil en broche

    outil = 0

    n$, *outil, e$

peof$
        #n$, "G0", sinc_abs, degageX, degageY, pfr, smodedeg, e$
    if debutpmx = 0 & mode_5axe = 1,     [
                                        if type_pp = 1, n$, "M129", e$
                                        if type_pp = 2, sm, paf, "M129", e$
                                        ]
    if type_pp = 1, plubrifoff, e$                  # Arret lubriff
    if type_pp = 2, sm, paf, plubrifoff, e$                  # Arret lubriff
        if type_pp = 1, n$, "M5", e$                    # Arret broche
    if type_pp = 2, sm, paf, "M5", e$                    # Arret broche
        if decalage = 1, panulldecalageg52      # Annuler les decalages d'origine
        if oriusi = 1, panuldef7
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        incremental = 2                 # pour re forcer l'affichage du mode Absolue
        !incremental
        incremental = 0                 # pour forcer le mode Absolue
    pdegage4_5axes
    if mode_5axe = 1, plane_arret_RAZfin  # RAZ si 5 axes positionner


     pbrise_outil                    # controle bris outil

    else, [
          if useaxe <> 0 & old_axeA <> 0, [       # Remise a 0 de l'axe A si pas a Zero
         axeA = 0                # A = 0
            prot2                   # affichage de l'angle
                ]
          ]
         if robot = 0, degagex_fin = -150, degagey_fin = -1
          pdegage_fin                 # Degagement de la machine fin de prog
    #pdecharge_outil                    # Dechargement de l'outil en broche
    plane$ = 3                  # pour focer le rappel G17 G18 G19
    !plane$
    plane$ = 0

    if type_pp = 1, n$, splcode, sinc_abs, e$           # Plan XY mode Absolue
    if type_pp = 2, sm,paf, splcode, sinc_abs, e$           # Plan XY mode Absolue
    comment$                    # commentaires d'operation
    if palette = 1,    [
                    if type_pp = 1,n$, "M98", "P9901", e$  #
                    if type_pp = 2,sm,paf "M98", "P9901", e$  #
                    ]
    # DEBUT de programme personalisable

    # FIN de programme personalisable


    #test_bris = mi3$
    #if test_bris = 1, n$, "LBL 249", e$
    ptextefin
    if macro <> 0 & mode_5axe = 1, pmacro
    #space, e$                  # Sauter une ligne

    subout$ = 0                 # Ecriture dan le NC
    #mergeext$                      # Merge les sous prog
    mergesub$                   # merge les sous prog en transform
    mergeaux$                   # merge les sous prog en Z


    #clearext$                  # Effacer les sous prog
    clearsub$
    clearaux$
    pbrise_outilapresfin
    n$, "M50", e$
    n$, "M38", e$
    probot


        if robot = 1, n$, "CALL LBL ", spaces$ = 0,34, "LABEL10", 34," REP",  *repetpiece, spaces$ = 1,e$

    if type_pp = 1, n$, "M30", e$                   # fin de prog et rembobine au debut
    if type_pp = 2, sm, paf, "M30", e$                   # fin de prog et rembobine au debut

    if use_progno = 0,
                    [
                    if type_pp = 1, n$, "END PGM", snamenc$, "MM", e$        # fin de fichier
                    if type_pp = 2, sm, degagex, degagey, degagez,  paf, "END PGM", snamenc$, "MM", e$        # fin de fichier
                    ]
    else,
                    [
                    if type_pp = 1, n$, "END PGM", progno$, "MM", e$
                    if type_pp = 2, sm, degagex, degagey, degagez,paf, "END PGM", progno$, "MM", e$
                    ]
    if type_pp = 2, sf, e$

#--------------- debut du traitemant 5 axes positionner --------------------------------


pmacro     # macro ecrite en fin de prog si macro <> 0
                if type_plane = 3,
                                 [
                                if type_pp = 1,
                                                [
                                                  n$, "LBL 99 ; ANNULATION", e$
                                                  panuldef7
                                                  n$, "CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                  n$, "CYCL DEF 19.1 A+0 B+0 C+0", e$
                                                  n$, "CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                  n$, "CYCL DEF 19.1", e$
                                                  n$, "CYCL DEF 10.0 ROTATION" ,e$
                                                  n$, "CYCL DEF 10.1 ROT+0", e$
                                                  n$, "LBL 0", e$
                                                 ]
                                if type_pp = 2,
                                                [
                                                  sm, paf, "LBL 99 ; ANNULATION", e$
                                                  panuldef7
                                                  sm, paf, "CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                  sm, paf,"CYCL DEF 19.1 A+0 B+0 C+0", e$
                                                  sm, paf,"CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                  sm, paf, "CYCL DEF 19.1", e$
                                                  sm, paf,"CYCL DEF 10.0 ROTATION" ,e$
                                                  sm, paf,"CYCL DEF 10.1 ROT+0", e$
                                                  sm, paf,"LBL 0", e$
                                                 ]
                                ]
                    else,
                    [
                    if type_pp = 1, n$, "LBL 99 ; ANNULATION", e$
                    if type_pp = 2, sm, paf, "LBL 99 ; ANNULATION", e$
                      panuldef7
                      if type_pp = 1, n$, "PLANE RESET STAY", e$, n$, "LBL 0", e$
                      if type_pp = 2, sm, paf, "PLANE RESET STAY", e$, sm, paf, "LBL 0", e$
                    ]





plane_arret_RAZ   # Remise a zero des axes et tourner les axes
                        if type_plane = 3,
                                         [
                            n$, "CALL LBL 99", e$
                            n$, "L B+0 C+0 R0 FMAX", e$
                                        ]
                        else,
                            [
                            if type_pp = 1, n$, "PLANE RESET STAY", p_casse_modalite_avance, e$ #TURN sfmax5x,
                            if type_pp = 2, sm, sbzero, sczero, paf, "PLANE RESET TURN ", sfmax5x, p_casse_modalite_avance, e$
                            ]


plane_arret_RAZfin    # Remise a zero des axes et tourner les axes
                        if type_plane = 3,
                                         [
                            n$, "CALL LBL 99", e$
                            n$, "L B+0 C+0 R0 FMAX", e$
                                        ]
                        else,
                            [
                            if type_pp = 1, n$, "PLANE RESET TURN ", sfmax5x, p_casse_modalite_avance, e$ #TURN
                            if type_pp = 2, sm, sbzero, sczero, paf, "PLANE RESET TURN ", sfmax5x, p_casse_modalite_avance, e$
                            ]

plane_arret_sansbouger  #   Remise a zero des axes et pas bouger
                            if macro = 0, n$, "PLANE RESET STAY", e$
                            else,[
                                 if type_pp = 1, n$, "CALL LBL 99", e$
                                 if type_pp = 2, sm, paf, "CALL LBL 99", e$
                                 oriusi = 0
                                 ]
                            old_axeAB = 0, old_axeC = 0, old_tourne = 0
                            !old_axeAB,  !old_axeC, !old_tourne



plane2plane   # transition entre deux plan incline
                #" on est dans plan2plane" ,e$
                pcal5xpos
                if type_plane = 1, [
                            !old_axeAB, !axeAB, !old_axeC, !axeC, !old_tourne, !tourne
                            #"voir les axes et les old", *old_axeAB, *axeAB, *old_axec, *axec, *old_tourne, *tourne, e$
                            difaxeAB = axeAB - old_axeAB
                            if axeC <> old_axeC | axeAB <> old_axeAB | tourne <> old_tourne | debutpmx = 0,
                             [
                             if difaxeAB <> 0, pdegage4_5axes             # on degage
                                        else, pdegage4_5axesptlchg0
                            if dessus = 0, plane_arret_sansbouger      # on raz les angles
                            else, plane_arret_RAZ

                            if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0 | oriusi = 1, poriusinul                                # affichage de l'origine d'usinage cycle def 7
                            plane_marche               # on ecrit les plan
                            gcode$ = 0

                            if type_pp = 1, n$, *sgcode, sinc_abs, *xabs, *yabs, pfr, e$   #ssa, pgamme, *spdlon, e$
                            #if type_pp = 2, sr, *xabs, *yabs, *zabs, *axec5xsimu, *axeAB5xsimu, sfsimurapid, paf, *sgcode, sinc_abs, *xabs, *yabs, pfr, sm, degageZ, e$   #ssa, pgamme, *spdlon, e$
                            plinc = 1
                            #"voir zabs", *zabs, e$
                             ]
                             ]
                if type_plane = 2, [
                            if m1p <> old_m1 | m2p <> old_m2 | m3p <> old_m3 | m4p <> old_m4 | m5p <> old_m5 | m6p <> old_m6 | debutpmx = 0,
                            [
                            pdegage4_5axes             # on degage
                            if dessus = 0, plane_arret_sansbouger      # on raz les angles
                            else, plane_arret_RAZ
                            if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0 | oriusi = 1, poriusinul                                # affichage de l'origine d'usinage cycle def 7                              # affichage de l'origine d'usinage cycle def 7
                            plane_marche
                            gcode$ = 0
                             if type_pp = 1, n$, *sgcode, sinc_abs, *xabs, *yabs, pfr, e$   #ssa, pgamme, *spdlon, e$
                             if type_pp = 2, sr, *xabs, *yabs, sfsimurapid, paf,*sgcode, sinc_abs, *xabs, *yabs, pfr, e$   #ssa, pgamme, *spdlon, e$
                             ]
                ]
                if type_plane = 3, [

                            !old_axeAB, !axeAB, !old_axeC, !axeC, !old_tourne, !tourne
                            #"voir les axes et les old", *old_axeAB, *axeAB, *old_axec, *axec, *old_tourne, *tourne, e$

                            if axeC <> old_axeC | axeAB <> old_axeAB | tourne <> old_tourne | debutpmx = 0,
                             [
                            pdegage4_5axes             # on degage
                            if dessus = 0, plane_arret_sansbouger      # on raz les angles
                            else, plane_arret_RAZ

                            if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0 | oriusi = 1, poriusinul                                # affichage de l'origine d'usinage cycle def 7
                            plane_marche               # on ecrit les plan
                            gcode$ = 0

                            if type_pp = 1,n$, *sgcode, sinc_abs, *xabs, *yabs, pfr, e$   #ssa, pgamme, *spdlon, e$
                            if type_pp = 2, sr, *xabs, *yabs, sfsimurapid, paf,*sgcode, sinc_abs, *xabs, *yabs, pfr, e$   #ssa, pgamme, *spdlon, e$
                             ]
                ]
svirg : ","
pmplane

                m1simu =     m1$
                m2simu =     m2$
                m3simu =     m3$
                tox4simu =     tox4$
                m4simu =     m4$
                m5simu =     m5$
                m6simu =     m6$
                toy4simu =     toy4$
                m7simu =     m7$
                m8simu =     m8$
                m9simu =     m9$
                toz4simu =     toz4$
                #"voir", *m1simu,*m2simu,*m3simu,*tox4simu,*m4simu,*m5simu,*m6simu,*toy4simu,*m7simu,*m8simu,*m9simu,*toz4simu, e$


pSEQplus_ou_moins   # choix polarite
                        if tz=1,  seqplus      # en vue de dessus on force SEQ+ car la HEID 530 se met en defaut
                        else, seq


plane_marche   # activation du mode 5 axes position

            if type_plane = 1,   # ecriture en mode spatial
                        [
                        pcal5xpos
                        old_axeAB = axeAB, old_axeC = axeC, old_tourne = tourne
                        !old_axeAB, !old_axeC, !old_tourne
                        if dessus <> 1, [
                                        if type_pp = 1,
                                                        [
                                                        if difaxeAB <>0, pdegage4_5axes
                                                                   else, pdegage4_5axesptlchg0
                                                        if continu5x = 1, n$ ,`sgcode, *axeC5xsimu, "FMAX", e$
                                                        n$, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                                        if type_axe  = 3,   # pre placement pour un axe B sur la tete
                                                            [
                                                            if nextop$ <> 11, pcalxyz3d
                                                            else,
                                                                [
                                                                xabs3d = x$
                                                                yabs3d = y$
                                                                zabs3d = z$
                                                                ]
                                                            n$, "PLANE RESET STAY", e$
                                                            n$, "M128 M126",e$
                                                            gcode$ = 0
                                                            n$, `sgcode, sinc_abs, xabs3d, yabs3d, pfr, *spdlon, e$
                                                            n$, `sgcode, sinc_abs, zabs3d, pfr, e$
                                                            n$, "M129",e$
                                                            n$, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                                            ]
                                                         if tourne <> 0, n$, "PLANE RELATIV SPC", tourne, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, "TABLE ROT", e$
                                                         n$, sdcom, "AXES REEL MACHINE", *axeC5xsimu,*axeAB5xsimu, sfcom, e$

                                                            ]
                                         if type_pp = 2,
                                                        [
                                                        #"voir rotaxtyp$", *rotaxtyp$, e$
                                                        pdegage4_5axes
                                                        if continu5x = 1,n$ ,sr, "C0.", paf, `sgcode, "C0. FMAX", e$
                                                        sm, *axeAB5xsimu, *axeC5xsimu, paf, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                                        pmplane
                                                        spaces$ = 0
                                                        #" (",*m1simu,svirg,*m2simu,svirg,*m3simu,svirg,*tox4simu,svirg,*m4simu,svirg,*m5simu,svirg,*m6simu,svirg,*toy4simu,svirg,*m7simu,svirg,*m8simu,svirg,*m9simu,svirg,*toz4simu,svirg,"0.,0.,0.,1.)", e$
                                                        spaces$ = 1
                                                        #sm, paf, "PLANE SPATIAL SPA", axeAB,  "SPB+0", "SPC", axeC, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, " TABLE ROT", e$
                                                        #" (",*m1simu,svirg,*m4simu,svirg,*m7simu,svirg,*tox4simu,svirg,*m2simu,svirg,*m5simu,svirg,*m8simu,svirg,*toy4simu,svirg,*m3simu,svirg,*m6simu,svirg,*m9simu,svirg,*toz4simu,svirg,"0.,0.,0.,0.)",e$
                                                        if tourne <> 0, sm, paf, "PLANE RELATIV SPC", tourne, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, "TABLE ROT", e$
                                                        #plinc = 1
                                                        ]
                                        ]
                        ]
            if type_plane = 2,   # ecriture en mode points
                        [
                         pcal5xpos
                         old_m1 = m1p, old_m2 = m2p, old_m3 = m3p, old_m4 = m4p, old_m5 = m5p,  old_m6 = m6p
                         !old_m1, !old_m2, !old_m3, !old_m4, !old_m5, !old_m6
                         !m1p, !m2p, !m3p, !m4p, !m5p, !m6p
                         if dessus <> 1, [
                         if type_pp = 1, n$, "PLANE POINTS P1X+0 P1Y+0 P1Z+0", m1p, m2p, m3p, m4p, m5p, m6p, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, "TABLE ROT", frap5x, e$
                         if type_pp = 1, sm,paf, "PLANE POINTS P1X+0 P1Y+0 P1Z+0", m1p, m2p, m3p, m4p, m5p, m6p, "TURN ", sfmax5x, p_casse_modalite_avance, pSEQplus_ou_moins, "TABLE ROT", frap5x, e$
                                         ]
                        ]
            if type_plane = 3,  # ecriture en mode cycle 19
                        [
                        pcal5xpos
                        old_axeAB = axeAB, old_axeC = axeC, old_tourne = tourne
                        !old_axeAB, !old_axeC, !old_tourne
                        if dessus <> 1, [
                                        if type_pp = 1,    [
                                                        spaces$ = 0
                                                        n$, " M126", e$
                                                        n$, " CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                        n$, " CYCL DEF 19.1 A", *axeAB,  " B+0 C", *axeC, e$  #CYCL DEF 19.1 B+90 C+0 A+0                        #a tester sur machine 05-04-11 syl
                                                        spaces$ = 1
                                                        if tourne <> 0,    [
                                                                        itourne = tourne
                                                                        n$, "CYCL DEF 10.0 ROTATION" ,e$
                                                                        n$, "CYCL DEF 10.1", *itourne, e$
                                                                        ]
                                                        n$, "L C+Q122 B+Q121 R0 F MAX", e$
                                                        ]
                                        if type_pp = 2,    [
                                                        spaces$ = 0
                                                        sm,paf, " M126", e$
                                                        sm,paf," CYCL DEF 19.0 PLAN D'USINAGE", e$
                                                        sm,paf, " CYCL DEF 19.1 A", *axeAB,  " B+0 C", *axeC, e$  #CYCL DEF 19.1 B+90 C+0 A+0                        #a tester sur machine 05-04-11 syl
                                                        spaces$ = 1
                                                        if tourne <> 0,    [
                                                                        itourne = tourne
                                                                        sm,paf, "CYCL DEF 10.0 ROTATION" ,e$
                                                                        sm,paf,"CYCL DEF 10.1", *itourne, e$
                                                                        ]
                                                        sm,paf, "L C+Q122 B+Q121 R0 F MAX", e$
                                                        ]
                                        ]
                        ]

#----------------CORPS DU CODE ISO G1 G2 G3 G0 -------------------------

plrapid     # Ligne en rapide
        #" voir", *x$, *y$, *z$, *xnci$, *ynci$, *znci$, e$
        xabs = x$
        yabs = y$
        zabs = z$

        if type_pp = 1, n$, `sgcode, `sinc_abs, pxyz, pfr, e$
        if type_pp = 2, [
                        @old_z, @zabs
                        if plinc = 1, sr, *xabs, *yabs, *zabs, axeC5xsimu, axeAB5xsimu,sfsimurapid, paf, *sgcode, sinc_abs, *xabs, *yabs, pfr, sm, degagez, plinc = 0, e$
                        if contperc <> 1,    [
                                            if zabs <> old_z | m6$ = 1,sr, pxyzf, sfsimurapid, paf_xyz, pfr, e$
                                            ]
                        contperc = 0
                        if m1$ = 1 & m5$ = 1 & m9$ = 1, sr, pxyzf, sfsimurapid, paf_xyz, pfr, e$
                        ]

pltravail   # ligne en travail
        xabs = x$
        yabs = y$
        zabs = z$

            if type_pp = 1, n$, `sgcode, sinc_abs, pxyz, pcord, pfr, e$
            if type_pp = 2, [
                            sl, pxyzf, pfr, paf_xyz, pcord,
                            if avance <> -1, avance, e$
                            else, e$
                            ]

prapid$      # Ligne en rapide

    if gcode$ = 0, plrapid
        else, pltravail


pzrapid$     # Ligne Z en rapide
        x$ = xnci$
        y$ = ynci$

        if gcode$ = 0, plrapid
        else, pltravail


plin$        # Ligne travail

    if gcode$ = 0, plrapid
        else, pltravail

pz$      # z en avance TRAVAIL
        #"------PZ----", e$
        xabs = x$
        yabs = y$
        zabs = z$


         if gcode$ = 1,    [
                         if type_pp = 1, n$, `sgcode, sinc_abs, pxyz, pfr, e$
                        if type_pp = 2, sl, pxyz, pfr, paf, `sgcode, sinc_abs, pxyz, avance, e$
                        ]
         else, plrapid


p_modal     # affectation en format modal X Y Z A garde profondeur ABS ET INC
        #"p_modal"

            result = newfs (2, xabs)
            result = newfs (11, xinc)
            result = newfs (2, yabs)
            result = newfs (11, yinc)
            result = newfs (2, zabs)
            result = newfs (11, zinc)

            result = newfs (2, axeA)
            result = newfs (11, axeAi)

            result = newfs (2, profabs)
            result = newfs (2, profi)
            result = newfs (2, gardeabs)
            result = newfs (2, gardei)


pcir$        # Circulaire


    p_modal     #affectation en format modal

        xabs = x$
        yabs = y$
        zabs = z$

        #"----------------", *arctype$,"---------------", e$


        if arctype$ >= 5, pcir_r, e$    # en R
        else,
            [
            if type_pp = 2, pcir_r
            pcir_ij, e$           # en IJ
            ]

p_casse_modalite_avance # casser la modalite de l'avance


            result = newfs (5, avance)

p_casse_modalite    # pour casser la modalite de Xabs et Xinc Yabs et Yinc Zabs et Zinc Aabs Ainc

            p_casse_modalite_X
            p_casse_modalite_Y
            p_casse_modalite_Z
            p_casse_modalite_A


p_casse_modalite_X  # pour casser la modalite de Xabs et Xinc

            result = newfs (3, xabs)
            result = newfs (12, xinc)

p_casse_modalite_Y  # pour casser la modalite de Yabs et Yinc

            result = newfs (3, yabs)
            result = newfs (12, yinc)


p_casse_modalite_Z  # pour casser la modalite de Zabs et Zinc

            result = newfs (3, zabs)
            result = newfs (12, zinc)

p_casse_modalite_A  # pour casser la modalite de Aabs et Ainc

            result = newfs (3, axeA)
            result = newfs (12, axeAi)


p_casse_modalite_perce  # pour casser la modalite de profabs et profi gardeabs gardei

            result = newfs (3, profabs)
            result = newfs (3, profi)

            result = newfs (3, gardeabs)
            result = newfs (3, gardei)


pcir_r      # Circulaire G2 G3 G17 G18 G19 en R
        if arctype$ = 5, rayon = arcrad$            # pour Rayon
        if arctype$ = 6 & abs(sweep$) < 180, rayon = arcrad$    # pour Rayon signe
        if arctype$ = 6 & abs(sweep$) >=180, rayon = -arcrad$   # pour Rayon signe



        if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
        if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
        if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z
        if type_pp = 1,
                        [
                        if plane$ = 0, n$, splcode, sinc_abs, *sgcode, pxyz, rayon, pfr   # plan XY
                        if plane$ = 2, n$, splcode, sinc_abs, *sgcode, pxyz, rayon, pfr   # plan XZ
                        if plane$ = 1, n$, splcode, sinc_abs, *sgcode, pxyz, rayon, pfr   # plan YZ
                        ]
        if type_pp = 2,
                        [
                        rayon = arcrad$
                        if gcode$ = 2, stype_arc = "CW"
                        if gcode$ = 3, stype_arc = "CCW"
                        if plane$ = 0, sc, pxyzf, rayon, stype_arc, pfr  # plan XY
                        if plane$ = 2, sc, pxyzf, rayon, stype_arc, pfr  # plan XZ
                        if plane$ = 1, sc, pxyzf, rayon, stype_arc, pfr  # plan YZ
                        ]
pcir_ij     # Circulaire G2 G3 G17 G18 G19 en IJ
        @plane$
        if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
        if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
        if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z

        if type_pp = 1, n$, "CC", pijk, e$
        if type_pp = 2, paf, "CC", pijk, e$

        if plane$ = 0, [
                !old_z
            if zabs <> old_z, [
                    n$, "CP", sweep$
                    if incremental = 0, *zabs, !zinc
                    else, !zabs, *zinc
                    sgcode, pcord, pfr, !z$
                    ]
            else,
                [
                if type_pp = 1, n$, "C", pxyz, sgcode, pcord, pfr
                if type_pp = 2, sm, paf, "C", pxyz, sgcode, pcord, pfr
                ]
                ]

        if plane$ = 2, [
            if yabs <> old_y, [
                    n$, "CP", sweep$
                    if incremental = 0, *yabs, !yinc
                    else, !yabs, *yinc
                    sgcode, pcord, pfr, !y$
                    old_y = yabs
                    ]
            else,
                [
                if type_pp = 1, n$, "C", pxyz, sgcode, pcord, pfr
                if type_pp = 2, sm, paf, "C", pxyz, sgcode, pcord, pfr
                ]
                ]

        if plane$ = 1, [
            if xabs <> old_x, [
                    n$, "CP", sweep$
                    if incremental = 0, *xabs, !xinc
                    else, !xabs, *xinc
                    sgcode, pcord, pfr, !x$
                    old_x = xabs
                    ]
            else,
                [
                if type_pp = 1, n$, "C", pxyz, sgcode, pcord, pfr
                if type_pp = 2, sm, paf, "C", pxyz, sgcode, pcord, pfr
                ]
                ]



pxyz        # ecriture des x, y, z en abs ou incremental pour corp ISO
	
    pxyz_new
    p_modal     # affectation en format modal

        !x$, !y$, !z$   # mise a jour xyz

        old_x = xabs    # memo des anciennes positions
        old_y = yabs
        old_z = zabs


pxyz_new    # ecriture des positions X Y Z et A pour substitution
#CNC<<MSG-ERREUR(5505)>> Il manque un crochet de fermeture

    if rotaxis$ = 0,
    [    # XYZ CLASIQUE 3 axes (+ positionne)
        if incremental = 0, xabs, yabs, zabs , !xinc, !yinc, !zinc
#CNC<<ORIGINAL>>        if incremental = 0, xabs, yabs, [if gcode$ <> 2 & gcode$ <> 3 zabs], !xinc, !yinc, !zinc
#CNC<<MSG-ERREUR(5511)>> √âchec du traitement de type de sortie d'instruction PP¬†!
        else,           !xabs, !yabs, !zabs, xinc, yinc, zinc

                ]

    if rotaxis$ <> 0, [    # SUBSTITUTION
            p_Apos                              # Calcul de l'axe A
        if rotaxis$ = 1, xabs = 0                   # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2, yabs = 0                   # diviseur tourne autour de X (Y sbstitue)

            if incremental = 0,     xabs, yabs, axeA, zabs, !xinc, !yinc, !axeAi, !zinc
            else,           !xabs, !yabs, !axeA, !zabs, xinc, yinc, axeAi, zinc

        old_axeA  = axeA                            # memo de l'axe A
        nbrtour = int (axeA / 360)                      # calcul du nombre de tours
            ]


pxyzf        # ecriture des x, y, z en abs ou incremental pour corp ISO

    pxyz_newf
    p_modal     # affectation en format modal

        !x$, !y$, !z$   # mise a jour xyz

        old_x = xabs    # memo des anciennes positions
        old_y = yabs
        old_z = zabs

pxyz_newf    # ecriture des positions X Y Z et A pour substitution

    if rotaxis$ = 0,    [    # XYZ CLASIQUE 3 axes (+ positionne)

        if incremental = 0, *xabs, *yabs, *zabs, !xinc, !yinc, !zinc
        else,           !xabs, !yabs, !zabs, xinc, yinc, zinc

                ]

    if rotaxis$ <> 0, [    # SUBSTITUTION
            p_Apos                              # Calcul de l'axe A
        if rotaxis$ = 1, xabs = 0                   # diviseur tourne autour de Y (X sbstitue)
        if rotaxis$ = 2, yabs = 0                   # diviseur tourne autour de X (Y sbstitue)

            if incremental = 0,     *xabs, *yabs, *axeA, *zabs, !xinc, !yinc, !axeAi, !zinc
            else,           !xabs, !yabs, !axeA, !zabs, xinc, yinc, axeAi, zinc

        old_axeA  = axeA                            # memo de l'axe A
        nbrtour = int (axeA / 360)                      # calcul du nombre de tours
            ]


pijk        # ecriture des IJK pour G90 G91
        !i$, !j$, !k$
        if arctype$ = 1, [   # pour centre en absolue en G90
    iabs = i$
    jabs = j$
    kabs = k$
    iinc = i$ - prv_x$
    jinc = j$ - prv_y$
    kinc = k$ - prv_z$
            ]

        else,       [     # pour centre en relatif en G90

    iabs = i$
    jabs = j$
    kabs = k$
    iinc = i$
    jinc = j$
    kinc = k$
            ]

        if incremental = 0 & plane$ = 0, *iabs, *jabs, !iinc, !jinc, !kinc
        if incremental = 0 & plane$ = 2, *iabs, *kabs, !iinc, !jinc, !kinc
        if incremental = 0 & plane$ = 1, *jabs, *kabs, !iinc, !jinc, !kinc

        if incremental = 1 & plane$ = 0, !iabs, !jabs, *iinc, *jinc, !kinc
        if incremental = 1 & plane$ = 2, !iabs, !kabs, *iinc, !jinc, *kinc
        if incremental = 1 & plane$ = 1, !jabs, !kabs, !iinc, *jinc, *kinc



#-------------------------------------------------------------------------



pdril5x     # ecriture du 1er passage
                pdril5x_cal # calcul et ecriture des plans 5 axes
                  if type_pp = 1,    [
                                n$, `sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, *spdlon, plubrifon, e$ #ssa, pgamme, *spdlon, e$
                                n$, `sgcode, *zabs,pcord, pfr, e$
                                ]
                if type_pp = 2,    [
                                avancepercsimu = frplunge$
                                pcaldrilxyzsimu
                                #sl, *xabs, *yabs, *zabs, *axeAB5xsimu, *axeC5xsimu, *avancepercsimu,paf, sgcode, *xabs, *yabs, *zabs,*avancepercsimu, e$
                                old_initht = initht$
                                old_refht = refht$
                                old_depth = depth$
                                xabs = v_abs_plus_x
                                yabs = v_abs_plus_y
                                zabs = v_abs_plus_z
                                sr, *xabs, *yabs, *zabs,*axeAB5xsimu, *axeC5xsimu,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, sm, degagez, e$
                                sr, *xabs, *yabs, *zabs,*axeAB5xsimu, *axeC5xsimu,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                #sr,*xabs, *yabs,sfsimurapid, paf,`sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, *spdlon, plubrifon, e$ #ssa, pgamme, *spdlon, e$
                                #sr,*zabs,sfsimurapid,paf,`sgcode, *zabs,pcord, pfr, e$
                                ]


pdril5x_2  # placement au dessus du point en percage 5 axes entre  plusieur percages dans la meme op


                pdril5x_cal
                if type_pp = 1,    [
                                  n$, `sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, e$ #ssa, pgamme, *spdlon, e$
                                 n$, `sgcode, *zabs,pcord, pfr, e$
                                ]
                if type_pp = 2,    [
                                  sr, *xabs, *yabs,sfsimurapid, paf,`sgcode, sinc_abs, *xabs, *yabs,pcord, pfr, e$ #ssa, pgamme, *spdlon, e$
                                 sr,*zabs,sfsimurapid,paf,`sgcode, *zabs,pcord, pfr, e$
                                ]

#---------------- les cycle de percage en mode heidenhain -----------



pcyleperce_1    # ecriture du cycle de percage DEF 1 (percage debourrage)
        if type_pp = 1,    [
                        n$, "CYCL DEF 1.0 PERCAGE PROFOND", e$
                        n$, "CYCL DEF 1.1 DIST. ", *gardeabs, e$
                        n$, "CYCL DEF 1.2 PROF. ", *profabs, e$
                        n$, "CYCL DEF 1.3 PASSE ", *passe, e$
                        n$, "CYCL DEF 1.4 TEMP. ", *tempo, e$
                        n$, "CYCL DEF 1.5", pavanceperce, e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 1.0 PERCAGE PROFOND", e$
                        sm,paf, "CYCL DEF 1.1 DIST. ", *gardeabs, e$
                        sm,paf, "CYCL DEF 1.2 PROF. ", *profabs, e$
                        sm,paf, "CYCL DEF 1.3 PASSE ", *passe, e$
                        sm,paf, "CYCL DEF 1.4 TEMP. ", *tempo, e$
                        sm,paf, "CYCL DEF 1.5", pavanceperce, e$
                        avanceperc = avance
                        ]
pcyleperce_2    # ecriture du cycle de percage DEF 2 (taraudage simple)
        if type_pp = 1,    [
                          n$, "CYCL DEF 2.0 TARAUDAGE", e$
                          n$, "CYCL DEF 2.1 DIST. ", *gardeabs, e$
                         n$, "CYCL DEF 2.2 PROF. ", *profabs, e$
                          n$, "CYCL DEF 2.3 TEMP. ", *tempo, e$
                          n$, "CYCL DEF 2.4", *pasavance, e$
                        ]
        if type_pp = 2,    [
                          sm,paf, "CYCL DEF 2.0 TARAUDAGE", e$
                          sm,paf, "CYCL DEF 2.1 DIST. ", *gardeabs, e$
                         sm,paf, "CYCL DEF 2.2 PROF. ", *profabs, e$
                          sm,paf, "CYCL DEF 2.3 TEMP. ", *tempo, e$
                          sm,paf, "CYCL DEF 2.4", *pasavance, e$
                        ]
pcyleperce_17   # ecriture du cycle de percage DEF 17 (taraudage rigide)
        if type_pp = 1,    [
                          n$, "CYCL DEF 17.0 TARAUDAGE", e$
                          n$, "CYCL DEF 17.1 DIST. ", *gardeabs, e$
                          n$, "CYCL DEF 17.2 PROF. ", *profabs, e$
                          n$, "CYCL DEF 17.3 PAS. ", *pas, e$
                        ]
        if type_pp = 2,    [
                          sm,paf, "CYCL DEF 17.0 TARAUDAGE", e$
                          sm,paf,"CYCL DEF 17.1 DIST. ", *gardeabs, e$
                          sm,paf,"CYCL DEF 17.2 PROF. ", *profabs, e$
                          sm,paf,"CYCL DEF 17.3 PAS. ", *pas, e$
                        ]
pcyleperce_200  # ecriture du cycle de percage DEF 200 (percage debourrage)
        if type_pp = 1,    [
                        n$, "CYCL DEF 200 PERCAGE ~", e$
                        *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq206, "; AVANCE PLONGEE PROF.~", e$
                        *bq202, "; PROFONDEUR DE PASSE~", e$
                        *bq210, "; TEMPO. EN HAUT~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE~", e$
                        *bq211, "; TEMPO. AU FOND", e$
                        ]
        if type_pp = 2,    [
                        sm,paf,"CYCL DEF 200 PERCAGE ~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq206, "; AVANCE PLONGEE PROF.~", e$
                        sm,paf,*bq202, "; PROFONDEUR DE PASSE~", e$
                        sm,paf,*bq210, "; TEMPO. EN HAUT~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE~", e$
                        sm,paf,*bq211, "; TEMPO. AU FOND", e$
                        ]
pcyleperce_201  # ecriture du cycle d'alesage DEF 201 (alesage alesoir)
        if type_pp = 1,    [
                        n$, "CYCL DEF 201 ALESAGE AVEC ALESOIR~", e$
                        *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq206, "; AVANCE PLONGEE PROF.~", e$
                        *bq211, "; TEMPO. AU FOND~", e$
                        *bq208, "; AVANCE RETRAIT~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 201 ALESAGE AVEC ALESOIR~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq206, "; AVANCE PLONGEE PROF.~", e$
                        sm,paf,*bq211, "; TEMPO. AU FOND~", e$
                        sm,paf,*bq208, "; AVANCE RETRAIT~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE", e$
                        ]
pcyleperce_202  # ecriture du cycle d'alesage DEF 202 (alesage bare)
        if type_pp = 1,    [
                        n$, "CYCL DEF 202 ALESAGE A L'OUTIL~", e$
                        *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq206, "; AVANCE PLONGEE PROF.~", e$
                        *bq211, "; TEMPO. AU FOND~", e$
                        *bq208, "; AVANCE RETRAIT~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE~", e$
                        *bq214, "; SENS DEGAGEMENT~", e$
                        *bq336, "; ANGLE BROCHE", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 202 ALESAGE A L'OUTIL~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq206, "; AVANCE PLONGEE PROF.~", e$
                        sm,paf,*bq211, "; TEMPO. AU FOND~", e$
                        sm,paf,*bq208, "; AVANCE RETRAIT~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE~", e$
                        sm,paf,*bq214, "; SENS DEGAGEMENT~", e$
                        sm,paf,*bq336, "; ANGLE BROCHE", e$
                        ]
pcyleperce_203  # ecriture du cycle de percage DEF 203 (percage debourrage brise copeaux)
        if type_pp = 1,    [
                        n$, "CYCL DEF 203 PERCAGE UNIVERSEL~", e$
                        *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq206, "; AVANCE PLONGEE PROF.~", e$
                        *bq202, "; PROFONDEUR DE PASSE~", e$
                        *bq210, "; TEMPO. EN HAUT~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE~", e$
                        *bq212, "; VALEUR DE REDUCTION~", e$
                        *bq213, "; NB BRISE-COPEAUX~", e$
                        *bq205, "; PROF. PASSE MINI~", e$
                        *bq211, "; TEMPO. AU FOND~", e$
                        *bq208, "; AVANCE RETRAIT~", e$
                        *bq256, "; RETR. BRISE COPEAUX", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 203 PERCAGE UNIVERSEL~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq206, "; AVANCE PLONGEE PROF.~", e$
                        sm,paf,*bq202, "; PROFONDEUR DE PASSE~", e$
                        sm,paf,*bq210, "; TEMPO. EN HAUT~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE~", e$
                        sm,paf,*bq212, "; VALEUR DE REDUCTION~", e$
                        sm,paf,*bq213, "; NB BRISE-COPEAUX~", e$
                        sm,paf,*bq205, "; PROF. PASSE MINI~", e$
                        sm,paf,*bq211, "; TEMPO. AU FOND~", e$
                        sm,paf,*bq208, "; AVANCE RETRAIT~", e$
                        sm,paf,*bq256, "; RETR. BRISE COPEAUX", e$
                        ]
pcyleperce_205  # ecriture du cycle de percage DEF 203 (percage debourrage brise copeaux)
        if type_pp = 1,    [
                        n$, "CYCL DEF 205 PERC. PROF. UNIVERS. ~", e$
                        *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq206, "; AVANCE PLONGEE PROF.~", e$
                        *bq202, "; PROFONDEUR DE PASSE~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE~", e$
                        *bq212, "; VALEUR DE REDUCTION~", e$
                        *bq205, "; PROF. PASSE MINI~", e$
                        *bq258, "; DIST. SECUR. EN HAUT~", e$
                        *bq259, "; DIST. SECUR. EN BAS~", e$
                        *bq257, "; PROF. PERC. BRISE-COP.~", e$
                        *bq256, "; RETR. BRISE COPEAUX~", e$
                        *bq211, "; TEMPO. AU FOND", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 205 PERC. PROF. UNIVERS. ~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq206, "; AVANCE PLONGEE PROF.~", e$
                        sm,paf,*bq202, "; PROFONDEUR DE PASSE~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE~", e$
                        sm,paf,*bq212, "; VALEUR DE REDUCTION~", e$
                        sm,paf,*bq205, "; PROF. PASSE MINI~", e$
                        sm,paf,*bq258, "; DIST. SECUR. EN HAUT~", e$
                        sm,paf,*bq259, "; DIST. SECUR. EN BAS~", e$
                        sm,paf,*bq257, "; PROF. PERC. BRISE-COP.~", e$
                        sm,paf,*bq256, "; RETR. BRISE COPEAUX~", e$
                        sm,paf,*bq211, "; TEMPO. AU FOND", e$
                        ]
pcyleperce_207  # ecriture du cycle de percage DEF 207 (taraudage rigide)
        if type_pp = 1,    [
                        n$, "CYCL DEF 207 NOUV. TARAUDAGE RIG. ~", e$
                            *bq200, "; DISTANCE D'APPROCHE~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq239, "; PAS DE VIS~", e$
                        *bq203, "; COORD. SURFACE PIECE~", e$
                        *bq204, "; SAUT DE BRIDE", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 207 NOUV. TARAUDAGE RIG. ~", e$
                            sm,paf,*bq200, "; DISTANCE D'APPROCHE~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq239, "; PAS DE VIS~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE", e$
                        ]
pcyleperce_209  # ecriture du cycle de percage DEF 207 (taraudage rigide)
        if type_pp = 1,    [
                        n$, "CYCL DEF 209 TARAUD. BRISE-COP. ~", e$
                        *bq200, "; DISTANCE D'APPROCHE ~", e$
                        *bq201, "; PROFONDEUR~", e$
                        *bq239, "; PAS DE VIS~", e$
                        *bq203, "; COORD. SURFACE PIECE ~", e$
                        *bq204, "; SAUT DE BRIDE ~", e$
                        *bq257, "; PROF. PERC. BRISE-COP.~", e$
                        *bq256, "; RETR. BRISE-COPEAUX~", e$
                        *bq336, "; ANGLE BROCHE", e$
                        ]
        if type_pp = 2,    [
                        sm,paf, "CYCL DEF 209 TARAUD. BRISE-COP. ~", e$
                        sm,paf,*bq200, "; DISTANCE D'APPROCHE ~", e$
                        sm,paf,*bq201, "; PROFONDEUR~", e$
                        sm,paf,*bq239, "; PAS DE VIS~", e$
                        sm,paf,*bq203, "; COORD. SURFACE PIECE ~", e$
                        sm,paf,*bq204, "; SAUT DE BRIDE ~", e$
                        sm,paf,*bq257, "; PROF. PERC. BRISE-COP.~", e$
                        sm,paf,*bq256, "; RETR. BRISE-COPEAUX~", e$
                        sm,paf,*bq336, "; ANGLE BROCHE", e$
                        ]
pcyleperce  # choix du type de cycle

  if use_cyc200 <> 0,[      # si l'armoire utilise les cycle 200

    @drillcyc$

    bq200 = gardeabs                # distance de garde
    bq201 = profabs                 # distance de percage

    if drillcyc$ <> 2, bq202 = abs(passe)       # prise de passe pour debourrage et percages
    if drillcyc$ = 2, bq202 = abs(passe)        # prise de passe pour brises copeaux
    if drillcyc$ = 4, bq202 = abs(profabs)      # prise de passe pour alesage alesoir
    if drillcyc$ = 6, bq257 = abs(passe)
    if drillcyc$ = 2, bq257 = abs(passe2)

    bq203 = dbrut                   # Z de debut du percage
    if percage5x = 0, bq204 = initht$ - dbrut             # distance de securite
    else, bq204 = initht$ - dbrut

    if drillcyc$ = 1 , bq205 =  abs(shftdrl$)                   # prise de passe mini

    bq206 = frplunge$                 # avavce de travail

    bq208 = 9999                    # avance de retrait
    if drillcyc$ = 4, bq208 = bq206

    bq210 = 0                   # tempo en haut
    bq211 = dwell$                  # tempo au fond

    if drillcyc$ = 1, bq212 = abs(retr$)                  # valeur de reduction
        #else, bq212 = 0
    if drillcyc$ = 2, bq213 = abs(bq201 / passe)    # nombre de brise copeaux
    else, bq213 = 0

    bq214 = degage                   # sens de degagement pour alesage indexe
    if drillcyc$ = 5, bq336 = orientation                   # angle d'orientation de la broche pour alesage indexe
         else, bq336 = 0

    if tool_typ$ = 5, bq239 = pas *(-1)
    if tool_typ$ = 4, bq239 = pas

    if drillcyc$ = 6 , bq256 = abs(retr$)        # remonte brise copeaux
    else, bq256 = 0.2


    if drillcyc$ = 2, bq258 = 0.2
    if drillcyc$ = 2, bq259 = 0.2


    if use_cyc200 = 1, [
                        if drillcyc$ = 0,   pcyleperce_200
                        if drillcyc$ = 1,   pcyleperce_203
                           #if drillcyc$ < 2,  pcyleperce_200  # ecriture du cycle de percage 200 pour percage et debourrage
                        if drillcyc$ = 2,   pcyleperce_205  # ecriture du cycle de percage 205 pour percage et debourrage
                           if drillcyc$ = 3,   pcyleperce_207  # ecriture du cycle de taraudage rigide 207
                        if drillcyc$ = 4,   pcyleperce_201  # ecriture du cycle alesage alesoir
                        if drillcyc$ = 5,   pcyleperce_202  # ecriture du cycle alesage barre
                        if drillcyc$ = 6,   pcyleperce_209  # ecriture du cycle de taraudage avec brise copeaux
                        ]

    if use_cyc200 = 2, [
                        if drillcyc$ <= 2,  pcyleperce_203  # ecriture du cycle de percage 203 pour brise copeaux
                        if drillcyc$ = 3,   pcyleperce_207  # ecriture du cycle de taraudage rigide 207
                        if drillcyc$ = 4,   pcyleperce_203  # ecriture du cycle alesage alesoir
                        if drillcyc$ = 5,   pcyleperce_202  # ecriture du cycle alesage barre
                        if drillcyc$ = 6,   pcyleperce_209  # ecriture du cycle de taraudage avec brise copeaux
                        ]

              ]
  if use_cyc200 = 0, [              # si l'armoire n'utilise pas les cycle 200

    @drillcyc$
    if drillcyc$ <= 2,  pcyleperce_1        # ecriture cycle 1 (pas de brise copeaux)
    if drillcyc$ = 3,   pcyleperce_2        # ecriture du cycle de taraudage simple
    #if drillcyc$ = 3,  pcyleperce_17       # ecriture du cycle de taraudage rigide 17

  ]
fmt 2 old_initht
fmt 2 old_refht
fmt 2 old_depth
ppercage    # ecricure des cycle de percage, debourrage brise copeaux etc...

    pcyleperce                  # choix du type de cycle a ecrire
    if use_cyc200 = 0,    [             # si l'armoire n' utilise pas les cycle 200
                        if type_pp = 1, [
                                        gcode$ = 0
                                        n$, `sgcode, ppercexy, pfr, e$      # Position xy
                                        z$ = refht$
                                        p_casse_modalite_Z
                                        n$, sgcode, ppercez, pfr, "M99", e$ # Position Z et executer le cycle
                                        ]
                        if type_pp = 2, [
                                        gcode$ = 0
                                        sr, ppercexy, paf, `sgcode, ppercexy, pfr, e$      # Position xy
                                        z$ = refht$
                                        p_casse_modalite_Z
                                        sl, ppercez, pfr, paf, sgcode, ppercez, pfr, "M99", e$ # Position Z et executer le cycle
                                        ]
                        ]
    if use_cyc200 <> 0,
                        [                # si l'armoire utilise les cycle 200
                        gcode$ = 0
                        p_casse_modalite_X
                        p_casse_modalite_Y
                        p_casse_modalite_A
                        if type_pp = 1, n$, sgcode, ppercexy, pfr, "M99", e$    # Position xy et executer le cycle
                        if type_pp = 2,    [
                                        contperc = 1
                                        avancepercsimu = frplunge$
                                        pcaldrilxyzsimu
                                        sl, *xabs, *yabs, *zabs, *avancepercsimu,paf, sgcode, *xabs, *yabs, *zabs,*avancepercsimu, e$
                                        xabs = v_abs_plus_x
                                        yabs = v_abs_plus_y
                                        zabs = v_abs_plus_z
                                        sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                        old_initht = initht$
                                        old_refht = refht$
                                        old_depth = depth$
                                        #sr, ppercexy, paf, sgcode, ppercexy, pfr, "M99", e$
                                        ]
                        ]
    old_gardeabs = gardeabs         # memo des prof et garde
    old_profabs = profabs


pdrill$      # Cycle de percage G81 G82

        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes

        if texte <> 0,     [
                        if numcoment = 0, omitseq$ = 1
                        if type_pp = 1, [
                                        if typcycle = 0 & dwell$ = 0, n$, sdcom, "POINTAGE-PERCAGE", sfcom, e$
                                        if typcycle = 0 & dwell$ <> 0, n$, sdcom, "POINTAGE-PERCAGE-TEMPO", sfcom, e$
                                        ]
                        if type_pp = 2, [
                                        if typcycle = 0 & dwell$ = 0, sm, paf, sdcom, "POINTAGE-PERCAGE", sfcom, e$
                                        if typcycle = 0 & dwell$ <> 0, sm, paf, sdcom, "POINTAGE-PERCAGE-TEMPO", sfcom, e$
                                        ]
                        omitseq$ = old_omitseq
                        ]
    typcycle = 1
    pprof_garde         # calcul des profondreur et des gardes
    if percage5x <> 1, passe = depth$ - tosz$      # increment de percage
    ppercage            # ecriture des cycles de percage

ppeck$      # Cycle de debourrage G83

        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1, n$, sdcom, "DEBOURRAGE", sfcom, e$
                            if type_pp = 2, sm,paf, sdcom, "DEBOURRAGE", sfcom, e$
                            ]
        omitseq$ = old_omitseq
            ]

    typcycle = 1

    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    ppercage            # ecriture des cycles de percage




pchpbrk$    # Cycle de brise copeaux G73
        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1, n$, sdcom, "BRISE COPEAUX", sfcom, e$
                            if type_pp = 2, sm,paf, sdcom, "BRISE COPEAUX", sfcom, e$
                            ]
        omitseq$ = old_omitseq
            ]

    typcycle = 1

    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    passe2 = abs(peck2$)
    ppercage            # ecriture des cycles de percage





ptap$       # Cycle de taraudage G84
        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1,n$, sdcom, "TARAUDAGE", sfcom, e$
                            if type_pp = 2,sm,paf, sdcom, "TARAUDAGE", sfcom, e$
                            ]
        omitseq$ = old_omitseq
            ]

    typcycle = 1



           if tldia$ = 3, pas = 0.5
           if tldia$ = 4, pas = 0.7
           if tldia$ = 5, pas = 0.8
           if tldia$ = 6, pas = 1
           if tldia$ = 8, pas = 1.25
           if tldia$ = 10, pas = 1.5
           if tldia$ = 12, pas = 1.75
           if tldia$ = 14, pas = 2
           if tldia$ = 16, pas = 2

             if n_tap_thds$ <> 0, pas = n_tap_thds$

             if tool_typ$ = 5, ss$ = (abs(ss$))*-1

             pasavance = pas * abs(ss$)

    pprof_garde         # calcul des profondreur et des gardes
    if percage5x <> 1, passe = depth$ - tosz$      # increment de percage
    ppercage            # ecriture des cycles de percage



pbore1$     # Cycle d'alesage G85
        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1,n$, sdcom, "ALESAGE", sfcom, e$
                            if type_pp = 2,sm,paf, sdcom, "ALESAGE", sfcom, e$
                            ]
        omitseq$ = old_omitseq
                ]

    typcycle = 1

    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    ppercage            # ecriture des cycles de percage




pbore2$     # Cycle d'alesage indexe G75
        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1,n$, sdcom, "ALESAGE INDEXE", sfcom, e$
                            if type_pp = 2,sm,paf, sdcom, "ALESAGE INDEXE", sfcom, e$
                            ]
        omitseq$ = old_omitseq
                ]

    typcycle = 1

    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    degage = abs(shftdrl$)
    orientation = abs(peckclr$)
    ppercage            # ecriture des cycles de percage


pmisc1$     # Cycle de taraudage avec brise copeaux
        if percage5x = 1, pdril5x   # preparation angle + deplacement pour le mode percage 5 axes
        if texte <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0,     [
                            if type_pp = 1,n$, sdcom, "TARAUDAGE", sfcom, e$
                            if type_pp = 2,sm,paf, sdcom, "TARAUDAGE", sfcom, e$
                            ]
        omitseq$ = old_omitseq
            ]

    typcycle = 1



           if tldia$ = 3, pas = 0.5
           if tldia$ = 4, pas = 0.7
           if tldia$ = 5, pas = 0.8
           if tldia$ = 6, pas = 1
           if tldia$ = 8, pas = 1.25
           if tldia$ = 10, pas = 1.5
           if tldia$ = 12, pas = 1.75
           if tldia$ = 14, pas = 2
           if tldia$ = 16, pas = 2

             if n_tap_thds$ <> 0, pas = n_tap_thds$

             if tool_typ$ = 5, ss$ = (abs(ss$))*-1

             pasavance = pas * abs(ss$)

    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    ppercage            # ecriture des cycles de percage

pmisc2$     # Cycle


pdrill_2$   # Cycle de percage points suivants
    if percage5x = 1, pdrill$, ex$   # preparation angle + deplacement pour le mode percage 5 axes entre point

    pprof_garde         # calcul des profondreur et des gardes
    if percage5x <> 1, passe = depth$ - tosz$      # increment de percage
    phole                   # trous suivants


ppeck_2$    # Canned Peck Drill Cycle
    if percage5x = 1, ppeck$, ex$   # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    phole                   # trous suivants

pchpbrk_2$  # Canned Chip Break Cycle
    if percage5x = 1, pchpbrk$, ex$   # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    passe2 = abs(peck2$)
    phole                   # trous suivants

ptap_2$     # Canned Tap Cycle
    if percage5x = 1, ptap$, ex$  # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    if percage5x <> 1, passe = depth$ - tosz$      # increment de percage
    phole                   # trous suivants

pbore1_2$   # Canned Bore #1 Cycle
    if percage5x = 1, pbore1$, ex$  # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    phole                   # trous suivants

pbore2_2$   # Canned Bore #2 Cycle
    if percage5x = 1, pbore2$ , ex$   # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    phole                   # trous suivants

pmisc1_2$   # Canned Misc #1 Cycle
    if percage5x = 1, pmisc1$ , ex$   # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    phole                   # trous suivants

pmisc2_2$   # Canned Misc #2 Cycle
    if percage5x = 1, pmisc2$, ex$  # preparation angle + deplacement pour le mode percage 5 axes entre point
    pprof_garde         # calcul des profondreur et des gardes
    passe = abs(peck1$)     # increment de percage
    phole                   # trous suivants


ppercexy     # ecriture des x, y en abs ou incremental pour percage
                 #"voir pperce", e$
        xabs = x$
        yabs = y$
        if rotaxis$ = 0,
            [   # XY CLASIQUE
            if percage5x = 1, pdril5x_cal2
             if incremental = 0, xabs, yabs, !xinc, !yinc
            else, !xabs, !yabs, xinc, yinc
            ]
         if rotaxis$ <> 0,
             [    # SUBSTITUTION Y par A (diviseur tourne autour de X)
              p_Apos
              if incremental = 0, xabs, yabs, axeA, !xinc, !yinc, !axeAi
              else, !xabs, !yabs, !axeA, xinc, yinc, axeAi
              old_axeA  = axeA
               nbrtour = int (axeA / 360)
            ]
        p_modal     # afficher en format modal
        !x$, !y$    # mise a jour XY
        old_x = xabs
        old_y = yabs

ppercez     # ecriture de z en abs ou incremental pour percage

          if rotaxis$ = 0, [   # XY CLASIQUE

                zabs = z$

                    if incremental = 0, zabs, !zinc
                    else, !zabs, zinc

                        ]

          if rotaxis$ <> 0, [   # Z EN SUBSTITUTION

            @rotdia$
            zabs  = z$ +(rotdia$ /2)    # Z pour continue substitutuion en ABS

                ]

    p_modal     # afficher en format modal
        !z$         # mise a jour Z

        old_z = zabs

pprof_garde # calcul des profondeurs et des gardes
            #"voir initht=", *initht$, " refht=",*refht$, " depth=", *depth$, "zdrl=", *zdrl$, " drl_sel_tos = ", *drl_sel_tos$, e$

     if rotaxis$ = 0 & percage5x <> 1 ,
             [   # XY CLASIQUE
            @depth$
            @refht$
            @tosz$
            @initht$
            profabs = depth$ - tosz$
            profi = profabs
            gardeabs = refht$ - tosz$
            gardei = gardeabs
            psecu = initht$
            dbrut = tosz$
            !depth$
            !refht$
            !tosz$
             ]

           if rotaxis$ <> 0 & percage5x <> 1 ,
           [    # SUBSTITUTION par A (diviseur tourne autour de X ou Y)
            @depth$
            @refht$
            @tosz$
            @initht$
            profabs = (depth$ - tosz$)
            profi = profabs
            gardeabs = (refht$ - tosz$)
            gardei = gardeabs
            psecu = initht$ + (rotdia$/2)
            dbrut = tosz$ + (rotdia$/2)
            !depth$
            !refht$
            !tosz$
           ]

           if percage5x = 1, # on est en mode 5 axes pos
           [
               #"on y est", e$
               zgarde = z2 + ( depth$ * -1 + initht$ )
            gardeabs =  refht$ - drl_sel_tos$
            profabs = depth$ - drl_sel_tos$
            dbrut =  ((depth$ * -1) + drl_sel_tos$ ) + z2
            psecu = initht$
            passe = abs(profabs)      # increment de percage
           ]
            #"voir= zgarde=",*zgarde," gardeabs=",*gardeabs," profabs=", *profabs," dbrut=", *dbrut," psecu=", *psecu, e$

phole       # trous suivants
    gcode$ = 0
    if initht$ <> refht$,    [     # SI PLAN DE SECU ET GARDE DIFFERENT
                            if use_cyc200 = 0,  [       # si l'armoire n'utilise pas les cycles 200
                                                    z$ = initht$            # remonter plan secu avant
                                                if type_pp = 1, n$, sgcode, ppercez, pfr, e$
                                                if type_pp = 2, sr, ppercez, sfsimurapid, paf, sgcode, ppercez, pfr, e$
                                                ]
                            if (profabs <> old_profabs) | (gardeabs <> old_gardeabs),    [
                                                                                        if type_pp = 1, ppercage   # si la prof ou la garde sont <> ecrire le cycle
                                                                                        if type_pp = 2,    [
                                                                                                        #sr, ppercexy,sfsimurapid, paf, sgcode, ppercexy, pfr, "M99", e$
                                                                                                        avancepercsimu = frplunge$
                                                                                                        initht$ = old_initht
                                                                                                        refht$ = old_refht
                                                                                                        depth$ = old_depth
                                                                                                        pcaldrilxyzsimu
                                                                                                        xabs = v_abs_plus_x
                                                                                                        yabs = v_abs_plus_y
                                                                                                        zabs = v_abs_plus_z
                                                                                                        sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                                                                                        xabs = x$
                                                                                                        yabs = y$
                                                                                                        zabs = z$
                                                                                                        sl, *xabs, *yabs, *zabs, *avancepercsimu,paf, sgcode, *xabs, *yabs, *zabs,*avancepercsimu, e$
                                                                                                        xabs = v_abs_plus_x
                                                                                                        yabs = v_abs_plus_y
                                                                                                        zabs = v_abs_plus_z
                                                                                                        sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                                                                                        ]
                                                                                        ]
                              else,     [
                                     if use_cyc200 = 0,      [           # si l'armoire n'utilise pas les cycles 200
                                                            if type_pp = 1, n$, sgcode, ppercexy, pfr, e$       # Position xy
                                                            if type_pp = 2, sr, ppercexy,sfsimurapid, paf, sgcode, ppercexy, pfr, e$       # Position xy
                                                            z$ = refht$
                                                            if type_pp = 1, n$, sgcode, ppercez, pfr, "M99", e$ # Position Z et executer le cycle
                                                            if type_pp = 2, sr,ppercez, sfsimurapid, paf,sgcode, ppercez, pfr, "M99", e$, sl, *drl_depth_z$, paf, *drl_depth_z$,  e$ # Position Z et executer le cycle
                                                               ]
                                    if use_cyc200 <> 0,        [           # si l'armoire utilise les cycles 200
                                                            if type_pp = 1, n$, sgcode, ppercexy, pfr, "M99", e$    # Position XY et executer le cycle
                                                            if type_pp = 2,    [
                                                                            #sr, ppercexy,sfsimurapid, paf, sgcode, ppercexy, pfr, "M99", e$                    # Position xy  # se placer et percer
                                                                            avancepercsimu = frplunge$
                                                                            initht$ = old_initht
                                                                            refht$ = old_refht
                                                                            depth$ = old_depth
                                                                            pcaldrilxyzsimu
                                                                            xabs = v_abs_plus_x
                                                                            yabs = v_abs_plus_y
                                                                            zabs = v_abs_plus_z
                                                                            sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                                                            xabs = x$
                                                                            yabs = y$
                                                                            zabs = z$
                                                                            sl, *xabs, *yabs, *zabs, *avancepercsimu,paf, sgcode, *xabs, *yabs, *zabs,*avancepercsimu, e$
                                                                            xabs = v_abs_plus_x
                                                                            yabs = v_abs_plus_y
                                                                            zabs = v_abs_plus_z
                                                                            sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                                                            ]
                                                            ]
                                    ]
                            ]
    if initht$ = refht$,     [      # SI PLAN DE SECU ET GARDE IDENTIQUE
                            if type_pp = 1,    [
                                            if (profabs <> old_profabs) | (gardeabs <> old_gardeabs), pcyleperce     # si la prof ou la garde sont <> ecriture du cycle de percage
                                            ]
                            if type_pp = 1,n$, sgcode, ppercexy, pfr, "M99", e$                    # Position xy  # se placer et percer
                            if type_pp = 2,    [
                                            #sr, ppercexy,sfsimurapid, paf, sgcode, ppercexy, pfr, "M99", e$                    # Position xy  # se placer et percer
                                            avancepercsimu = frplunge$
                                            initht$ = old_initht
                                            refht$ = old_refht
                                            depth$ = old_depth
                                            pcaldrilxyzsimu
                                            xabs = v_abs_plus_x
                                            yabs = v_abs_plus_y
                                            zabs = v_abs_plus_z
                                            sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                            xabs = x$
                                            yabs = y$
                                            zabs = z$
                                            sl, *xabs, *yabs, *zabs, *avancepercsimu,paf, sgcode, *xabs, *yabs, *zabs,*avancepercsimu, e$
                                            xabs = v_abs_plus_x
                                            yabs = v_abs_plus_y
                                            zabs = v_abs_plus_z
                                            sr, *xabs, *yabs, *zabs,sfsimurapid, paf,sgcode, *xabs, *yabs, *zabs, pfr, e$
                                            ]
                            ]
    z$ = depth$
    if type_pp = 1,zabs = z$
    !z$
    !zabs
    !zinc
    old_gardeabs = gardeabs     # memo des prof et garde
    old_profabs = profabs

pcanceldc$  # Anuulation de cyle fixe


    z$ = initht$      # z au plan de secu
    profabs=  -99999    # raz des prof garde tempo
    gardeabs=  -99999
    tempo = 0
    !profabs
    !gardeabs
    !tempo


           if rotaxis$ = 0, [   # XYZ CLASIQUE

        if type_pp = 1, zabs = z$

                                ]
        else, [

        if type_pp = 1, zabs = z$ + (rotdia$/2)
            ]

        gcode$ = 0    # choix du gcode pour ecrire G0 G80

             if incremental = 0, [
                                  if type_pp = 1, n$, sinc_abs, `sgcode, zabs, !zinc, pfr, e$
                                 if type_pp = 2, #sr, zabs, !zinc, sfsimurapid, paf, sinc_abs, `sgcode, zabs, !zinc, pfr, e$
                                 ]

             if incremental = 1, [
                                  if type_pp = 1, n$, sinc_abs, `sgcode, !zabs, zinc, pfr, e$
                                 if type_pp = 2, #sr, !zabs, zinc, sfsimurapid, paf, sinc_abs, `sgcode, !zabs, zinc, pfr, e$
                                 ]




        !z$      # Raz de Z
        old_z = zabs





#------------------Liste des OUTILS---------------------------------------------------

ptypeBoutT # afficher on non le rayon de bout
           if paramT4 <> 0, space, paramT6

pangleT    # afficher on non l'angle de l'outil
           #if paramT2 = 3 | paramT2 = 12 | paramT2 = 2 | paramT2 = 17 | paramT2 = 9 | paramT2 = 4 | paramT2 = 5, space, paramT8




pwrtt$      # Lite des outil


            sdesioutil = ucase(strtool$)

           if texte <> 0 & t$ > 0,
               [


            if numcoment = 0, omitseq$ = 1

            paramT1 = t$
            spaces$ = 0
            if type_pp = 1,
                               [
                            if strtool$ <> svide, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, paramT1, space, sdesioutil, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
                            else, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, paramT1, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
                            ]
            if type_pp = 2,
                               [
                            if strtool$ <> svide, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, paramT1, space, sdesioutil, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
                            else, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, paramT1, space, stypeT, space, paramT5, space, paramT16, ptypeBoutT, pangleT, space, smatT, sfcom, e$
                            ]
            spaces$ = old_spaces
            omitseq$ = old_omitseq

            plistdesoutil

                ]

               last_op_id = op_id$



plistdesoutil   # memorisation des outil a venir pour tool def "non_prochain_outil"
                    if gestion_nom_outil = 1,
                    [
                    # on enleve les blancs dans le nom d'outil
                    numpas = strstr(sblanc,sdesioutil)  # on vois a partir d'ou il y a un blanc
                    if numpas > 0, sdefoutil = brksps(numpas,sdesioutil) # on coupe a partir du blanc
                    ]

                    if t$ = 1, sdesioutil_1 = sdesioutil
                    if t$ = 2, sdesioutil_2 = sdesioutil
                    if t$ = 3, sdesioutil_3 = sdesioutil
                    if t$ = 4, sdesioutil_4 = sdesioutil
                    if t$ = 5, sdesioutil_5 = sdesioutil
                    if t$ = 6, sdesioutil_6 = sdesioutil
                    if t$ = 7, sdesioutil_7 = sdesioutil
                    if t$ = 8, sdesioutil_8 = sdesioutil
                    if t$ = 9, sdesioutil_9 = sdesioutil
                    if t$ = 10, sdesioutil_10 = sdesioutil
                    if t$ = 11, sdesioutil_11 = sdesioutil
                    if t$ = 12, sdesioutil_12 = sdesioutil
                    if t$ = 13, sdesioutil_13 = sdesioutil
                    if t$ = 14, sdesioutil_14 = sdesioutil
                    if t$ = 15, sdesioutil_15 = sdesioutil
                    if t$ = 16, sdesioutil_16 = sdesioutil
                    if t$ = 17, sdesioutil_17 = sdesioutil
                    if t$ = 18, sdesioutil_18 = sdesioutil
                    if t$ = 19, sdesioutil_19 = sdesioutil
                    if t$ = 20, sdesioutil_20 = sdesioutil
                    if t$ = 21, sdesioutil_21 = sdesioutil
                    if t$ = 22, sdesioutil_22 = sdesioutil
                    if t$ = 23, sdesioutil_23 = sdesioutil
                    if t$ = 24, sdesioutil_24 = sdesioutil
                    if t$ = 25, sdesioutil_25 = sdesioutil
                    if t$ = 26, sdesioutil_26 = sdesioutil
                    if t$ = 27, sdesioutil_27 = sdesioutil
                    if t$ = 28, sdesioutil_28 = sdesioutil
                    if t$ = 29, sdesioutil_29 = sdesioutil
                    if t$ = 30, sdesioutil_30 = sdesioutil
                    if t$ = 31, sdesioutil_31 = sdesioutil
                    if t$ = 32, sdesioutil_32 = sdesioutil
                    if t$ = 33, sdesioutil_33 = sdesioutil
                    if t$ = 34, sdesioutil_34 = sdesioutil
                    if t$ = 35, sdesioutil_35 = sdesioutil
                    if t$ = 36, sdesioutil_36 = sdesioutil
                    if t$ = 37, sdesioutil_37 = sdesioutil
                    if t$ = 38, sdesioutil_38 = sdesioutil
                    if t$ = 39, sdesioutil_39 = sdesioutil
                    if t$ = 40, sdesioutil_40 = sdesioutil
                    if t$ = 41, sdesioutil_41 = sdesioutil
                    if t$ = 42, sdesioutil_42 = sdesioutil
                    if t$ = 43, sdesioutil_43 = sdesioutil
                    if t$ = 44, sdesioutil_44 = sdesioutil
                    if t$ = 45, sdesioutil_45 = sdesioutil
                    if t$ = 46, sdesioutil_46 = sdesioutil
                    if t$ = 47, sdesioutil_47 = sdesioutil
                    if t$ = 48, sdesioutil_48 = sdesioutil
                    if t$ = 49, sdesioutil_49 = sdesioutil
                    if t$ = 50, sdesioutil_50 = sdesioutil
                    if t$ = 51, sdesioutil_51 = sdesioutil
                    if t$ = 52, sdesioutil_52 = sdesioutil
                    if t$ = 53, sdesioutil_53 = sdesioutil
                    if t$ = 54, sdesioutil_54 = sdesioutil
                    if t$ = 55, sdesioutil_55 = sdesioutil
                    if t$ = 56, sdesioutil_56 = sdesioutil
                    if t$ = 57, sdesioutil_57 = sdesioutil
                    if t$ = 58, sdesioutil_58 = sdesioutil
                    if t$ = 59, sdesioutil_59 = sdesioutil
                    if t$ = 60, sdesioutil_60 = sdesioutil
                    if t$ = 61, sdesioutil_61 = sdesioutil
                    if t$ = 62, sdesioutil_62 = sdesioutil
                    if t$ = 63, sdesioutil_63 = sdesioutil
                    if t$ = 64, sdesioutil_64 = sdesioutil
                    if t$ = 65, sdesioutil_65 = sdesioutil
                    if t$ = 66, sdesioutil_66 = sdesioutil
                    if t$ = 67, sdesioutil_67 = sdesioutil
                    if t$ = 68, sdesioutil_68 = sdesioutil
                    if t$ = 69, sdesioutil_69 = sdesioutil
                    if t$ = 70, sdesioutil_70 = sdesioutil
                    if t$ = 71, sdesioutil_71 = sdesioutil
                    if t$ = 72, sdesioutil_72 = sdesioutil
                    if t$ = 73, sdesioutil_73 = sdesioutil
                    if t$ = 74, sdesioutil_74 = sdesioutil
                    if t$ = 75, sdesioutil_75 = sdesioutil
                    if t$ = 76, sdesioutil_76 = sdesioutil
                    if t$ = 77, sdesioutil_77 = sdesioutil
                    if t$ = 78, sdesioutil_78 = sdesioutil
                    if t$ = 79, sdesioutil_79 = sdesioutil
                    if t$ = 80, sdesioutil_80 = sdesioutil
                    if t$ = 81, sdesioutil_81 = sdesioutil
                    if t$ = 82, sdesioutil_82 = sdesioutil
                    if t$ = 83, sdesioutil_83 = sdesioutil
                    if t$ = 84, sdesioutil_84 = sdesioutil
                    if t$ = 85, sdesioutil_85 = sdesioutil
                    if t$ = 86, sdesioutil_86 = sdesioutil
                    if t$ = 87, sdesioutil_87 = sdesioutil
                    if t$ = 88, sdesioutil_88 = sdesioutil
                    if t$ = 89, sdesioutil_89 = sdesioutil
                    if t$ = 90, sdesioutil_90 = sdesioutil
                    if t$ = 91, sdesioutil_91 = sdesioutil
                    if t$ = 92, sdesioutil_92 = sdesioutil
                    if t$ = 93, sdesioutil_93 = sdesioutil
                    if t$ = 94, sdesioutil_94 = sdesioutil
                    if t$ = 95, sdesioutil_95 = sdesioutil
                    if t$ = 96, sdesioutil_96 = sdesioutil
                    if t$ = 97, sdesioutil_97 = sdesioutil
                    if t$ = 98, sdesioutil_98 = sdesioutil
                    if t$ = 99, sdesioutil_99 = sdesioutil
                    if t$ = 100, sdesioutil_100 = sdesioutil

paffichedesoutil   # memorisation des outil a venir pour tool def "non_prochain_outil"
                    if next_tool$ = 1, sdesioutil_1
                    if next_tool$ = 2, sdesioutil_2
                    if next_tool$ = 3, sdesioutil_3
                    if next_tool$ = 4, sdesioutil_4
                    if next_tool$ = 5, sdesioutil_5
                    if next_tool$ = 6, sdesioutil_6
                    if next_tool$ = 7, sdesioutil_7
                    if next_tool$ = 8, sdesioutil_8
                    if next_tool$ = 9, sdesioutil_9
                    if next_tool$ = 10, sdesioutil_10
                    if next_tool$ = 11, sdesioutil_11
                    if next_tool$ = 12, sdesioutil_12
                    if next_tool$ = 13, sdesioutil_13
                    if next_tool$ = 14, sdesioutil_14
                    if next_tool$ = 15, sdesioutil_15
                    if next_tool$ = 16, sdesioutil_16
                    if next_tool$ = 17, sdesioutil_17
                    if next_tool$ = 18, sdesioutil_18
                    if next_tool$ = 19, sdesioutil_19
                    if next_tool$ = 20, sdesioutil_20
                    if next_tool$ = 21, sdesioutil_21
                    if next_tool$ = 22, sdesioutil_22
                    if next_tool$ = 23, sdesioutil_23
                    if next_tool$ = 24, sdesioutil_24
                    if next_tool$ = 25, sdesioutil_25
                    if next_tool$ = 26, sdesioutil_26
                    if next_tool$ = 27, sdesioutil_27
                    if next_tool$ = 28, sdesioutil_28
                    if next_tool$ = 29, sdesioutil_29
                    if next_tool$ = 30, sdesioutil_30
                    if next_tool$ = 31, sdesioutil_31
                    if next_tool$ = 32, sdesioutil_32
                    if next_tool$ = 33, sdesioutil_33
                    if next_tool$ = 34, sdesioutil_34
                    if next_tool$ = 35, sdesioutil_35
                    if next_tool$ = 36, sdesioutil_36
                    if next_tool$ = 37, sdesioutil_37
                    if next_tool$ = 38, sdesioutil_38
                    if next_tool$ = 39, sdesioutil_39
                    if next_tool$ = 40, sdesioutil_40
                    if next_tool$ = 41, sdesioutil_41
                    if next_tool$ = 42, sdesioutil_42
                    if next_tool$ = 43, sdesioutil_43
                    if next_tool$ = 44, sdesioutil_44
                    if next_tool$ = 45, sdesioutil_45
                    if next_tool$ = 46, sdesioutil_46
                    if next_tool$ = 47, sdesioutil_47
                    if next_tool$ = 48, sdesioutil_48
                    if next_tool$ = 49, sdesioutil_49
                    if next_tool$ = 50, sdesioutil_50
                    if next_tool$ = 51, sdesioutil_51
                    if next_tool$ = 52, sdesioutil_52
                    if next_tool$ = 53, sdesioutil_53
                    if next_tool$ = 54, sdesioutil_54
                    if next_tool$ = 55, sdesioutil_55
                    if next_tool$ = 56, sdesioutil_56
                    if next_tool$ = 57, sdesioutil_57
                    if next_tool$ = 58, sdesioutil_58
                    if next_tool$ = 59, sdesioutil_59
                    if next_tool$ = 60, sdesioutil_60
                    if next_tool$ = 61, sdesioutil_61
                    if next_tool$ = 62, sdesioutil_62
                    if next_tool$ = 63, sdesioutil_63
                    if next_tool$ = 64, sdesioutil_64
                    if next_tool$ = 65, sdesioutil_65
                    if next_tool$ = 66, sdesioutil_66
                    if next_tool$ = 67, sdesioutil_67
                    if next_tool$ = 68, sdesioutil_68
                    if next_tool$ = 69, sdesioutil_69
                    if next_tool$ = 70, sdesioutil_70
                    if next_tool$ = 71, sdesioutil_71
                    if next_tool$ = 72, sdesioutil_72
                    if next_tool$ = 73, sdesioutil_73
                    if next_tool$ = 74, sdesioutil_74
                    if next_tool$ = 75, sdesioutil_75
                    if next_tool$ = 76, sdesioutil_76
                    if next_tool$ = 77, sdesioutil_77
                    if next_tool$ = 78, sdesioutil_78
                    if next_tool$ = 79, sdesioutil_79
                    if next_tool$ = 80, sdesioutil_80
                    if next_tool$ = 81, sdesioutil_81
                    if next_tool$ = 82, sdesioutil_82
                    if next_tool$ = 83, sdesioutil_83
                    if next_tool$ = 84, sdesioutil_84
                    if next_tool$ = 85, sdesioutil_85
                    if next_tool$ = 86, sdesioutil_86
                    if next_tool$ = 87, sdesioutil_87
                    if next_tool$ = 88, sdesioutil_88
                    if next_tool$ = 89, sdesioutil_89
                    if next_tool$ = 90, sdesioutil_90
                    if next_tool$ = 91, sdesioutil_91
                    if next_tool$ = 92, sdesioutil_92
                    if next_tool$ = 93, sdesioutil_93
                    if next_tool$ = 94, sdesioutil_94
                    if next_tool$ = 95, sdesioutil_95
                    if next_tool$ = 96, sdesioutil_96
                    if next_tool$ = 97, sdesioutil_97
                    if next_tool$ = 98, sdesioutil_98
                    if next_tool$ = 99, sdesioutil_99
                    if next_tool$ = 100, sdesioutil_100

# variable outil
sdesioutil_1 : ""
sdesioutil_2  : ""
sdesioutil_3 : ""
sdesioutil_4 : ""
sdesioutil_5 : ""
sdesioutil_6 : ""
sdesioutil_7 : ""
sdesioutil_8 : ""
sdesioutil_9 : ""
sdesioutil_10 : ""
sdesioutil_11 : ""
sdesioutil_12 : ""
sdesioutil_13 : ""
sdesioutil_14 : ""
sdesioutil_15 : ""
sdesioutil_16 : ""
sdesioutil_17 : ""
sdesioutil_18 : ""
sdesioutil_19 : ""
sdesioutil_20 : ""
sdesioutil_21 : ""
sdesioutil_22 : ""
sdesioutil_23 : ""
sdesioutil_24 : ""
sdesioutil_25 : ""
sdesioutil_26 : ""
sdesioutil_27 : ""
sdesioutil_28 : ""
sdesioutil_29 : ""
sdesioutil_30 : ""
sdesioutil_31 : ""
sdesioutil_32 : ""
sdesioutil_33 : ""
sdesioutil_34 : ""
sdesioutil_35 : ""
sdesioutil_36 : ""
sdesioutil_37 : ""
sdesioutil_38 : ""
sdesioutil_39 : ""
sdesioutil_40 : ""
sdesioutil_41 : ""
sdesioutil_42 : ""
sdesioutil_43 : ""
sdesioutil_44 : ""
sdesioutil_45 : ""
sdesioutil_46 : ""
sdesioutil_47 : ""
sdesioutil_48 : ""
sdesioutil_49 : ""
sdesioutil_50 : ""
sdesioutil_51 : ""
sdesioutil_52 : ""
sdesioutil_53 : ""
sdesioutil_54 : ""
sdesioutil_55 : ""
sdesioutil_56 : ""
sdesioutil_57 : ""
sdesioutil_58 : ""
sdesioutil_59 : ""
sdesioutil_60 : ""
sdesioutil_61 : ""
sdesioutil_62 : ""
sdesioutil_63 : ""
sdesioutil_64 : ""
sdesioutil_65 : ""
sdesioutil_66 : ""
sdesioutil_67 : ""
sdesioutil_68 : ""
sdesioutil_69 : ""
sdesioutil_70 : ""
sdesioutil_71 : ""
sdesioutil_72 : ""
sdesioutil_73 : ""
sdesioutil_74 : ""
sdesioutil_75 : ""
sdesioutil_76 : ""
sdesioutil_77 : ""
sdesioutil_78 : ""
sdesioutil_79 : ""
sdesioutil_80 : ""
sdesioutil_81 : ""
sdesioutil_82 : ""
sdesioutil_83 : ""
sdesioutil_84 : ""
sdesioutil_85 : ""
sdesioutil_86 : ""
sdesioutil_87 : ""
sdesioutil_88 : ""
sdesioutil_89 : ""
sdesioutil_90 : ""
sdesioutil_91 : ""
sdesioutil_92 : ""
sdesioutil_93 : ""
sdesioutil_94 : ""
sdesioutil_95 : ""
sdesioutil_96 : ""
sdesioutil_97 : ""
sdesioutil_98 : ""
sdesioutil_99 : ""
sdesioutil_100 : ""









# -------------------------LECTURE DES PARAMETRES DE SUREP ET DE TYPE DE CORRECTION--------------------------------------------

paramcomp   # Type de correction d'outil au changement d'operation


        @cc_computer$, @cc_pos$                 # mise e jour des variables
        #cc_comp 41 42 0
        #cc_pos   1  2 0
        if cc_pos$ = 0  & cc_computer$ = 0, type_comp = 0   #AUCUNE

        if cc_pos$ = 2  & cc_computer$ = 0, type_comp = 1   #ARMOIRE DROITE
        if cc_pos$ = 1  & cc_computer$ = 0, type_comp = 2   #ARMOIRE GAUCHE

        if cc_pos$ = 0  & cc_computer$ = 42, type_comp = 3  #ORDINATEUR DROITE
        if cc_pos$ = 0  & cc_computer$ = 41, type_comp = 4  #ORDINATEUR GAUCHE

    if cc_pos$ = 2  & cc_computer$ = 42, type_comp = 5  #USURE DROITE
    if cc_pos$ = 1  & cc_computer$ = 41, type_comp = 6  #USURE GAUCHE

    if cc_pos$ = 1  & cc_computer$ = 42, type_comp = 7  #USURE INVERSE DROITE
    if cc_pos$ = 2  & cc_computer$ = 41, type_comp = 8  #USURE INVERSE GAUCHE


        if opcode$ = 19, type_comp = 0              # mis sur aucune a la place d'ordinateur pour surfacage (bug)



    if info_corr = 1 & op_id$ <> old_op_id  & texte <> 0, [ # si afficher les infos de compesation et changement d'operation et texte supporte

    spaces$ = 0                                     # suprimer les espaces
    if numcoment = 0, omitseq$ = 1                              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
    if type_pp = 1,
                    [
                    if opcode$ <> 3, spaces$ = old_spaces, n$, sdcom,spaces$ = 0, stype_comp, sfcom, e$ # pour ne pas afficher les infos si percage
                    ]
    if type_pp = 2,
                    [
                    if opcode$ <> 3, spaces$ = old_spaces, sm, paf, sdcom,spaces$ = 0, stype_comp, sfcom, e$ # pour ne pas afficher les infos si percage
                    ]
        spaces$ = old_spaces                                    # rappel des espaces
    omitseq$ = old_omitseq                                  # rappel des numero de bloc
                                    ]


paramsurep  # Affichage des surep au changement d'operation

        if info_surep = 1 & op_id$ <> old_op_id  & texte <> 0, [    # si afficher les infos de compesation et changement d'operation et texte supporte

    spaces$ = 0                         # suprimer les espaces
    if numcoment = 0, omitseq$ = 1                  # si pas de numero de bloc pour commentaires enlever les numeros de bloc
    # surep pour surfacage
    if type_pp = 1,
                    [
                    if opcode$ = 19, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, *surepl, sfcom, e$
                    # surep 2d
                    if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, *surep, space, *surepl, sfcom, e$
                    # surep 3d
                    if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, spaces$ = old_spaces, n$, sdcom, spaces$ = 0, *surep3d, sfcom, e$
                    ]
    if type_pp = 2,
                    [
                    if opcode$ = 19, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, *surepl, sfcom, e$
                    # surep 2d
                    if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, *surep, space, *surepl, sfcom, e$
                    # surep 3d
                    if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, spaces$ = old_spaces, sm, paf, sdcom, spaces$ = 0, *surep3d, sfcom, e$
                    ]
        spaces$ = old_spaces                        # rappel des espaces
    omitseq$ = old_omitseq                      # rappel des numero de bloc
                                ]
ptestmachine    # verif de la def machine

        #*nbr_combi, "---------", e$
    if nbr_combi > 1, erreur = 3        # le pst ne supporte q'une combinaison d'axe par programme
    if compt_axes_rot > 1, erreur = 2       # le pst ne supporte q'un axe rotaif
    #if write_ops = 0, erreur = 1       # Write NC Operation information MUST be enabled in CD
    perreur









#-------------------------- RENOMMER LE FICHIER NC EN FONCTION DU NUMERO DE PROGRAMME -------------------------



pnom_nc     # Generation des noms du fichier NC

        snom_nc = spathnc$+snamenc$+sextnc$             # Fichier NC en cours de creation sous forme toto.nc
        snom_numero = no2str (progno$)
        snom_numero = spathnc$+snom_numero+sextnc$     # nouveau non de fichier NC sous forme O0015.nc


ptest_nom   # test du non du fichier NC si O0123.NC

        if fexist (snom_numero), q11

        if remplace = 0, pchange_nom
        if remplace = 1, result = remove (snom_numero)

pchange_nom     # changer le numero de prog si fichier exite deja


        while fexist (snom_numero), [
            q10
            snom_numero = no2str (progno$)
            snom_numero = spathnc$+snom_numero+sextnc$
                        ]



ppost$       # traitement apres post pro pour effacer le fichier OPS et renommer le fichier NC

        sfileops= spathnci$ + snamenci$ + sops      # non du fichier ops
        result = remove (sfileops)          # effacer le fichier ops


        if use_progno = 1, result = remove (snom_numero)            #efface fichier en nom numero
        if use_progno = 1, result = rename (snom_nc, snom_numero)   #renomer fichier NC en nom numero
        if use_progno = 1, result = launch (seditor, snom_numero)   #lancer le blocnote

#endbin$


[CTRL_TEXT_XML_BEGIN]  # Post text edits MUST be made with Control Definition Manager.
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
	<control>
		<control_label>CTRL_ROUTER|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>-1 =Inversion du sens: SEQ- devient SEQ+ </text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>Ajuster les avances sur arc 0=NON 1=Ralentir 2=Accelerer 3=les Deux</text>
			</misc_10>
		</misc_integers>
		<simple_drill>
			<description>
				<text>CYCLE200 PERCAGE</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>CYCLE203 DEBOURAGE</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Increment</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>Remontee</text>
			</retract_amount>
			<shift>
				<text>Prof de passe mini</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>CYCLE205 BRISE COPEAUX</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Increment</text>
			</first_peck>
			<subsequent_peck>
				<text>Prof brise copeau</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>CYCLE207 TARAUDAGE</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>CYCLE201 ALESAGE</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>CYCLE202 ALESAGE INDEX</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Orientation</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>Degagement</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>CYCLE209 TARAUDAGE BRISE-COP</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan de securite</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Increment</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>Remontee</text>
			</retract_amount>
		</misc1>
		<misc2>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_15>
		<drill_cycle_16>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_16>
		<drill_cycle_17>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_17>
		<drill_cycle_18>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Parametres de cycle special 1</text>
			</description>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Parametres de cycle special 2</text>
			</description>
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Parametres de cycle special 3</text>
			</description>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Parametres de cycle special 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Parametres de cycle special 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Parametres de cycle special 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Parametres de cycle special 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Parametres de cycle special 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Parametres de cycle special 9</text>
			</description>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Parametres de cycle special 10</text>
			</description>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Parametres de cycle special 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Parametres de cycle special 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Parametres de cycle special 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Parametres de cycle special 14</text>
			</description>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Parametres de cycle special 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Parametres de cycle special 16</text>
			</description>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Parametres de cycle special 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Parametres de cycle special 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Parametres de cycle special 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Parametres de cycle special 20</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Pereage</text>
			</simple_drill>
			<peck_drill>
				<text>Debourrage</text>
			</peck_drill>
			<chip_break>
				<text>Brise copeaux</text>
			</chip_break>
			<tapping>
				<text>Taraudage</text>
			</tapping>
			<boring_1>
				<text>Alesage alesoir</text>
			</boring_1>
			<boring_2>
				<text>Alesage bare</text>
			</boring_2>
			<misc_drill_1>
				<text>Taraudage brise-cop</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>""</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>""</text>
			</custom_drill_9>
			<custom_drill_10>
				<text>""</text>
			</custom_drill_10>
			<custom_drill_11>
				<text>""</text>
			</custom_drill_11>
			<custom_drill_12>
				<text>""</text>
			</custom_drill_12>
			<custom_drill_13>
				<text>""</text>
			</custom_drill_13>
			<custom_drill_14>
				<text>""</text>
			</custom_drill_14>
			<custom_drill_15>
				<text>""</text>
			</custom_drill_15>
			<custom_drill_16>
				<text>""</text>
			</custom_drill_16>
			<custom_drill_17>
				<text>""</text>
			</custom_drill_17>
			<custom_drill_18>
				<text>""</text>
			</custom_drill_18>
			<custom_drill_19>
				<text>""</text>
			</custom_drill_19>
			<custom_drill_20>
				<text>""</text>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>""</text>
			</canned_text_1>
			<canned_text_2>
				<text>""</text>
			</canned_text_2>
			<canned_text_3>
				<text>""</text>
			</canned_text_3>
			<canned_text_4>
				<text>""</text>
			</canned_text_4>
			<canned_text_5>
				<text>""</text>
			</canned_text_5>
			<canned_text_6>
				<text>""</text>
			</canned_text_6>
			<canned_text_7>
				<text>""</text>
			</canned_text_7>
			<canned_text_8>
				<text>""</text>
			</canned_text_8>
			<canned_text_9>
				<text>""</text>
			</canned_text_9>
			<canned_text_10>
				<text>""</text>
			</canned_text_10>
		</canned_text>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
